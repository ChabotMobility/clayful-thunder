(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

require('core-js/modules/es6.typed.array-buffer');

require('core-js/modules/es6.typed.int8-array');

require('core-js/modules/es6.typed.uint8-array');

require('core-js/modules/es6.typed.uint8-clamped-array');

require('core-js/modules/es6.typed.int16-array');

require('core-js/modules/es6.typed.uint16-array');

require('core-js/modules/es6.typed.int32-array');

require('core-js/modules/es6.typed.uint32-array');

require('core-js/modules/es6.typed.float32-array');

require('core-js/modules/es6.typed.float64-array');

require('core-js/modules/es6.map');

require('core-js/modules/es6.set');

require('core-js/modules/es6.weak-map');

require('core-js/modules/es6.weak-set');

require('core-js/modules/es6.reflect.apply');

require('core-js/modules/es6.reflect.construct');

require('core-js/modules/es6.reflect.define-property');

require('core-js/modules/es6.reflect.delete-property');

require('core-js/modules/es6.reflect.get');

require('core-js/modules/es6.reflect.get-own-property-descriptor');

require('core-js/modules/es6.reflect.get-prototype-of');

require('core-js/modules/es6.reflect.has');

require('core-js/modules/es6.reflect.is-extensible');

require('core-js/modules/es6.reflect.own-keys');

require('core-js/modules/es6.reflect.prevent-extensions');

require('core-js/modules/es6.reflect.set');

require('core-js/modules/es6.reflect.set-prototype-of');

require('core-js/modules/es6.promise');

require('core-js/modules/es6.symbol');

require('core-js/modules/es6.object.freeze');

require('core-js/modules/es6.object.seal');

require('core-js/modules/es6.object.prevent-extensions');

require('core-js/modules/es6.object.is-frozen');

require('core-js/modules/es6.object.is-sealed');

require('core-js/modules/es6.object.is-extensible');

require('core-js/modules/es6.object.get-own-property-descriptor');

require('core-js/modules/es6.object.get-prototype-of');

require('core-js/modules/es6.object.keys');

require('core-js/modules/es6.object.get-own-property-names');

require('core-js/modules/es6.object.assign');

require('core-js/modules/es6.object.is');

require('core-js/modules/es6.object.set-prototype-of');

require('core-js/modules/es6.function.name');

require('core-js/modules/es6.string.raw');

require('core-js/modules/es6.string.from-code-point');

require('core-js/modules/es6.string.code-point-at');

require('core-js/modules/es6.string.repeat');

require('core-js/modules/es6.string.starts-with');

require('core-js/modules/es6.string.ends-with');

require('core-js/modules/es6.string.includes');

require('core-js/modules/es6.regexp.flags');

require('core-js/modules/es6.regexp.match');

require('core-js/modules/es6.regexp.replace');

require('core-js/modules/es6.regexp.split');

require('core-js/modules/es6.regexp.search');

require('core-js/modules/es6.array.from');

require('core-js/modules/es6.array.of');

require('core-js/modules/es6.array.copy-within');

require('core-js/modules/es6.array.find');

require('core-js/modules/es6.array.find-index');

require('core-js/modules/es6.array.fill');

require('core-js/modules/es6.array.iterator');

require('core-js/modules/es6.number.is-finite');

require('core-js/modules/es6.number.is-integer');

require('core-js/modules/es6.number.is-safe-integer');

require('core-js/modules/es6.number.is-nan');

require('core-js/modules/es6.number.epsilon');

require('core-js/modules/es6.number.min-safe-integer');

require('core-js/modules/es6.number.max-safe-integer');

require('core-js/modules/es6.math.acosh');

require('core-js/modules/es6.math.asinh');

require('core-js/modules/es6.math.atanh');

require('core-js/modules/es6.math.cbrt');

require('core-js/modules/es6.math.clz32');

require('core-js/modules/es6.math.cosh');

require('core-js/modules/es6.math.expm1');

require('core-js/modules/es6.math.fround');

require('core-js/modules/es6.math.hypot');

require('core-js/modules/es6.math.imul');

require('core-js/modules/es6.math.log1p');

require('core-js/modules/es6.math.log10');

require('core-js/modules/es6.math.log2');

require('core-js/modules/es6.math.sign');

require('core-js/modules/es6.math.sinh');

require('core-js/modules/es6.math.tanh');

require('core-js/modules/es6.math.trunc');

require('core-js/modules/es7.array.includes');

require('core-js/modules/es7.object.values');

require('core-js/modules/es7.object.entries');

require('core-js/modules/es7.object.get-own-property-descriptors');

require('core-js/modules/es7.string.pad-start');

require('core-js/modules/es7.string.pad-end');

require('core-js/modules/web.timers');

require('core-js/modules/web.immediate');

require('core-js/modules/web.dom.iterable');

require('regenerator-runtime/runtime');

require('imagesloaded');
require('jquery-form')(window, $);
require('jquery-match-height');
require('lightslider/dist/js/lightslider.min.js');

var Polyglot = require('node-polyglot');
var jstz = require('jstimezonedetect');
var mergeWith = require('lodash.mergeWith');

var Thunder = function Thunder(options) {

	var language = window.navigator.userLanguage || window.navigator.language || null;

	var timezone = jstz.determine().name();

	var overrideArray = function overrideArray(ov, sv) {

		if (Array.isArray(ov) && Array.isArray(sv)) {
			return sv;
		}
	};

	options = mergeWith({
		client: null,
		language: language,
		currency: null,
		timezone: timezone,
		debugLanguage: language === 'ko' ? 'ko' : 'en',
		root: location.protocol + '//' + location.host,
		baseURL: null,
		authStorage: {
			customer: '__tct__',
			order: '__tot__'
		},
		dateInputFormat: 'YYYY-MM-DD',
		legal: {
			registrationTerms: { link: null, text: null },
			registrationPrivacy: { link: null, text: null },
			orderTerms: { link: null, text: null },
			orderPrivacy: { link: null, text: null }
		},
		confirmation: {
			customerDelete: true,
			couponDelete: false,
			reviewDelete: false,
			reviewCommentDelete: false
		},
		productActions: ['add-to-cart', 'buy-now'],
		productLabels: [
			// 'unavailable',
			// 'sold-out',
			// 'discounted'
		],
		productOptionSelector: 'combined',
		productReview: true,
		productReviewRating: true,
		productReviewComment: true,
		paymentMethods: {
			order: [],
			subscription: []
		},
		refundReasonCategories: [],
		subscriptionPlans: [],
		customerAvatar: true,
		customerDashboardLogout: false,
		customerIdentity: ['name.full', 'alias', 'userId'],
		customerRegistrationFields: ['userId:required', 'email:required', 'password:required',
		// 'alias',
		// 'name.first',
		// 'name.last',
		'name.full:required', 'mobile:required', 'phone'],
		customerUpdateFields: ['userId', 'email',
		// 'alias',
		// 'name.first',
		// 'name.last',
		'name.full:required', 'mobile:required', 'phone'],
		customerOrderFields: [
		// 'name.first',
		// 'name.last',
		'name.full:required', 'email:required', 'mobile:required', 'phone'],
		recipientFields: [
		// 'name.first',
		// 'name.last',
		'name.full:required', 'mobile:required', 'phone'],
		addressDisabled: ['country', 'state', 'city', 'address1', 'postcode'],
		orderAuthFields: [
			// 'userId',
			// 'alias',
			// 'email',
			// 'mobile',
			// 'phone',
			// 'name.first',
			// 'name.last',
			// 'name.full',
		],
		socialApps: [
			// 'facebook',
			// 'google',
			// 'instagram',
			// 'naver',
			// 'kakao',
		],
		header: false,
		recaptcha: {
			sitekey: null,
			onload: 'thunderRecaptcha',
			modules: ['customer-register', 'customer-login', 'customer-reset-password', 'customer-verification',
			// 'customer-update',
			// 'customer-update-credential',
			// 'customer-update-address',
			'product-review-writer', 'product-review-comments', 'checkout', 'order-request-refund', 'search-purchase'],
			queue: []
		},
		plugins: {},
		listeners: {},
		messages: {}
	}, options, overrideArray);

	if (options.plugins) {
		$.extend(Thunder.plugins, options.plugins);
	}

	if (options.listeners) {
		Object.keys(options.listeners).forEach(function (eventName) {
			Thunder.listeners[eventName] = Thunder.listeners[eventName].concat(options.listeners[eventName]);
		});
	}

	if (options.paymentMethods) {

		Object.keys(options.paymentMethods).forEach(function (type) {

			var paymentMethods = options.paymentMethods[type];

			if (paymentMethods.length > 0) return;

			delete options.paymentMethods[type];
		});
	}

	if (options.header) {

		var defaultHeaderOptions = {
			items: ['customer', // Register, Login | My Profile
			'search-purchase', // Search Order
			'cart'],
			actions: {
				'customer-dashboard': function customerDashboard() {
					return Thunder.open('customer-dashboard');
				},
				'customer-register': function customerRegister() {
					return Thunder.open('customer-register');
				},
				'customer-login': function customerLogin() {
					return Thunder.open('customer-login');
				},
				'order-list': function orderList() {
					return Thunder.open('order-list');
				},
				'search-purchase': function searchPurchase() {
					return Thunder.open('search-purchase');
				},
				cart: function cart() {
					return Thunder.open('cart');
				}
			}
		};

		if (options.header === true) {
			options.header = defaultHeaderOptions;
		} else {
			options.header = mergeWith(defaultHeaderOptions, options.header, overrideArray);
		}
	}

	if (options.messages) {
		Thunder.setMessages(options.messages);
	}

	if (options.recaptcha.sitekey) {
		window[options.recaptcha.onload] = Thunder.util.bindRecaptcha;
	}

	Thunder.options = {
		root: options.root, // Root page URL
		baseURL: options.baseURL || 'https://api.clayful.io', // API base URL
		language: options.language, // Content language
		currency: options.currency, // Content currency
		timezone: options.timezone, // Content time zone
		authStorage: options.authStorage, // Auth token storage
		dateInputFormat: options.dateInputFormat, // Date input format
		legal: options.legal, // Legal information
		confirmation: options.confirmation, // Confirmation settings
		productActions: options.productActions, // Supported product options
		productLabels: options.productLabels, // Product labels to display
		productReview: options.productReview,
		productReviewRating: options.productReviewRating,
		productReviewComment: options.productReviewComment,
		productOptionSelector: options.productOptionSelector,
		paymentMethods: options.paymentMethods, // Supported payment methods
		refundReasonCategories: options.refundReasonCategories, // Refund reason categories
		subscriptionPlans: options.subscriptionPlans, // Supported subscription plan ids
		customerAvatar: options.customerAvatar, // Use customer avatar for `customer-update`, `product-reviews`?
		customerDashboardLogout: options.customerDashboardLogout, // Show Logout button in `customer-dashboard`?
		customerIdentity: options.customerIdentity, // Customer identity fields
		customerRegistrationFields: options.customerRegistrationFields, // Customer registration fields
		customerUpdateFields: options.customerUpdateFields, // Customer update fields
		customerOrderFields: options.customerOrderFields, // Customer fields for orders and subscriptions
		recipientFields: options.recipientFields, // Allowed recipient fields for addresses
		addressDisabled: options.addressDisabled, // Disabled address fields (when search plugin exists)
		orderAuthFields: options.orderAuthFields, // Fields to authenticate for orders & subscriptions
		socialApps: options.socialApps, // Supported social apps for customer accounts
		header: options.header, // Header navigation menu items
		recaptcha: options.recaptcha // Google reCAPTCHA options
	};

	// Expose Thunder.Cart after configurations
	Thunder.Cart = require('./lib/cart')(Thunder);

	Thunder.credential(options.client);
	Thunder.preference(options);
	Thunder.initialize();

	Thunder.trigger('init');

	return Thunder;
};

// Translation dependency
Thunder.polyglot = new Polyglot();

// TODO: Event listeners
Thunder.listeners = {
	init: [],
	componentRender: [],
	componentInit: []
};

// Custom methods
Thunder.methods = {};

// Specs for components
Thunder.components = {
	cart: component(require('./modules/cart')(Thunder)),
	'catalog-slider': component(require('./modules/catalog-slider')(Thunder)),
	checkout: component(require('./modules/checkout')(Thunder)),
	'checkout-success': component(require('./modules/checkout-success')(Thunder)),
	'product-list': component(require('./modules/product-list')(Thunder)),
	'product-detail': component(require('./modules/product-detail')(Thunder)),
	'product-review': component(require('./modules/product-review')(Thunder)),
	'product-reviews': component(require('./modules/product-reviews')(Thunder)),
	'product-review-writer': component(require('./modules/product-review-writer')(Thunder)),
	'product-review-comments': component(require('./modules/product-review-comments')(Thunder)),
	'customer-register': component(require('./modules/customer-register')(Thunder)),
	'customer-login': component(require('./modules/customer-login')(Thunder)),
	'customer-reset-password': component(require('./modules/customer-reset-password')(Thunder)),
	'customer-verification': component(require('./modules/customer-verification')(Thunder)),
	'customer-dashboard': component(require('./modules/customer-dashboard')(Thunder)),
	'customer-update': component(require('./modules/customer-update')(Thunder)),
	'customer-update-credential': component(require('./modules/customer-update-credential')(Thunder)),
	'customer-update-address': component(require('./modules/customer-update-address')(Thunder)),
	'customer-reviews': component(require('./modules/customer-reviews')(Thunder)),
	'customer-review': component(require('./modules/customer-review')(Thunder)),
	'customer-review-comments': component(require('./modules/customer-review-comments')(Thunder)),
	'customer-review-comment': component(require('./modules/customer-review-comment')(Thunder)),
	'customer-delete-account': component(require('./modules/customer-delete-account')(Thunder)),
	'customer-coupons': component(require('./modules/customer-coupons')(Thunder)),
	'search-purchase': component(require('./modules/search-purchase')(Thunder)),
	'order-list': component(require('./modules/order-list')(Thunder)),
	'order-detail': component(require('./modules/order-detail')(Thunder)),
	'order-request-refund': component(require('./modules/order-request-refund')(Thunder)),
	'subscription-list': component(require('./modules/subscription-list')(Thunder)),
	'subscription-detail': component(require('./modules/subscription-detail')(Thunder)),
	'payment-form': component(require('./modules/payment-form')(Thunder))
};

Thunder.uis = {
	'component-spinner': require('./ui/component-spinner').bind(Thunder),
	'section-spinner': require('./ui/section-spinner').bind(Thunder),
	'button-spinner': require('./ui/button-spinner').bind(Thunder),
	'overlay-navigation': require('./ui/overlay-navigation').bind(Thunder),
	'header-navigation': require('./ui/header-navigation').bind(Thunder),
	'social-login': require('./ui/social-login').bind(Thunder),
	'avatar-placeholder': require('./ui/avatar-placeholder').bind(Thunder),
	'filled-star': require('./ui/filled-star').bind(Thunder),
	'half-filled-star': require('./ui/half-filled-star').bind(Thunder),
	'empty-star': require('./ui/empty-star').bind(Thunder),
	'hallow-star': require('./ui/hallow-star').bind(Thunder),
	'review-stars': require('./ui/review-stars').bind(Thunder),
	'review-star-rating': require('./ui/review-star-rating').bind(Thunder),
	'text-box-overlay': require('./ui/text-box-overlay').bind(Thunder),
	'left-arrow': require('./ui/left-arrow').bind(Thunder),
	'right-arrow': require('./ui/right-arrow').bind(Thunder)
};

// Plugins (address search, payment, ...)
Thunder.plugins = {
	searchAddress: null,
	makePayment: null,
	redirect: require('./plugins/redirect'),
	notification: require('./plugins/notification'),
	confirmation: require('./plugins/confirmation'),
	pagination: require('./plugins/pagination'),
	cartStorage: require('./plugins/cartStorage'),
	credentialStorage: require('./plugins/credentialStorage')
};

// Utility methods
Thunder.util = {
	log: require('./util/log').bind(Thunder),
	debounce: require('./util/debounce').bind(Thunder),
	ui: require('./util/ui').bind(Thunder),
	stripHTML: require('./util/stripHTML').bind(Thunder),
	excerpt: require('./util/excerpt').bind(Thunder),
	imageURL: require('./util/imageURL').bind(Thunder),
	toPrecision: require('./util/toPrecision').bind(Thunder),
	formatNumber: require('./util/formatNumber').bind(Thunder),
	formatPrice: require('./util/formatPrice').bind(Thunder),
	getCurrency: require('./util/getCurrency').bind(Thunder),
	isExpired: require('./util/isExpired').bind(Thunder),
	addTime: require('./util/addTime').bind(Thunder),
	countryName: require('./util/countryName').bind(Thunder),
	customerIdentity: require('./util/customerIdentity').bind(Thunder),
	productName: require('./util/productName').bind(Thunder),
	variantName: require('./util/variantName').bind(Thunder),
	orderShippingStatus: require('./util/orderShippingStatus').bind(Thunder),
	formToJSON: require('./util/formToJSON').bind(Thunder),
	parseQueryString: require('./util/parseQueryString').bind(Thunder),
	parseArrayString: require('./util/parseArrayString').bind(Thunder),
	urlQuery: require('./util/urlQuery').bind(Thunder),
	requestErrorHandler: require('./util/requestErrorHandler').bind(Thunder),
	userIdOrEmail: require('./util/userIdOrEmail').bind(Thunder),
	makeAsyncButton: require('./util/makeAsyncButton').bind(Thunder),
	bindAgreements: require('./util/bindAgreements').bind(Thunder),
	makeRecaptcha: require('./util/makeRecaptcha').bind(Thunder),
	unsetRecaptcha: require('./util/unsetRecaptcha').bind(Thunder),
	bindSocialApps: require('./util/bindSocialApps').bind(Thunder),
	handleSocialLogin: require('./util/handleSocialLogin').bind(Thunder),
	bindRecaptcha: require('./util/bindRecaptcha').bind(Thunder),
	useRecaptcha: require('./util/useRecaptcha').bind(Thunder),
	imageUploader: require('./util/imageUploader').bind(Thunder),
	copyToClipboard: require('./util/copyToClipboard').bind(Thunder),
	bindBackButton: require('./util/bindBackButton').bind(Thunder),
	followingNavigation: require('./util/followingNavigation').bind(Thunder),
	quantityInput: require('./util/quantityInput').bind(Thunder),
	checkItemRefunded: require('./util/checkItemRefunded').bind(Thunder)
};

// Global template methods
Thunder.templateMethods = {
	get: require('lodash.get'),
	kebabCase: require('lodash.kebabcase'),
	camelCase: require('lodash.camelcase'),
	stripHTML: Thunder.util.stripHTML,
	excerpt: Thunder.util.excerpt,
	imageURL: Thunder.util.imageURL,
	isExpired: Thunder.util.isExpired,
	countryName: Thunder.util.countryName,
	customerIdentity: Thunder.util.customerIdentity,
	productName: Thunder.util.productName,
	variantName: Thunder.util.variantName
};

Thunder.overlay = {
	background: '<div id="thunder--overlay-background" data-thunder-close></div>',
	container: '<div id="thunder--overlay"><div id="thunder--overlay-header"></div><div id="thunder--overlay-body"></div></div>',
	body: null
};

$.extend(Thunder, {
	initialize: require('./lib/initialize').bind(Thunder), // Initialize an app
	credential: require('./lib/credential').bind(Thunder), // Client setter
	preference: require('./lib/preference').bind(Thunder), // Preference setter
	setMessages: require('./lib/setMessages').bind(Thunder), // Sets translation messages
	on: require('./lib/on').bind(Thunder), // Registers event listeners
	off: require('./lib/off').bind(Thunder), // Unregisters event listeners
	trigger: require('./lib/trigger').bind(Thunder), // Trigger registered event listeners
	method: getterSetter('methods'), // Method getter/setter
	component: getterSetter('components'), // Component getter/setter
	template: getterSetter('components', 'template'), // Custom template getter/setter
	plugin: getterSetter('plugins'), // Plugin getter/setter
	ui: getterSetter('uis'), // Custom UI getter/setter
	render: require('./lib/render').bind(Thunder), // Renders a component
	open: require('./lib/open').bind(Thunder), // Opens an overlay and renders a component
	close: require('./lib/close').bind(Thunder), // Closes an overlay
	request: require('./lib/request')(Thunder), // Make an API request
	execute: require('./lib/execute').bind(Thunder), // Execute a custom method
	notify: require('./lib/notify').bind(Thunder), // Shortcut for Thunder.plugins.notification
	logout: require('./lib/logout').bind(Thunder),
	header: require('./lib/header').bind(Thunder),
	authenticated: require('./lib/authenticated').bind(Thunder)
});

function component(definition) {

	return $.extend({
		options: function options() {
			return {};
		},
		default: {},
		pre: function pre(context, callback) {
			return callback(null, context);
		},
		init: function init() {},
		template: function template(context) {
			return '';
		}
	}, definition);
}

function getterSetter(field, child) {

	return child ? function (name, value) {

		if (!value) return Thunder[field][name][child];

		Thunder[field][name][child] = value;

		return Thunder;
	} : function (name, value) {

		if (!value) return Thunder[field][name];

		Thunder[field][name] = value;

		return Thunder;
	};
}

Thunder.version = require('./version.json');

window.Thunder = Thunder;

},{"./lib/authenticated":2,"./lib/cart":3,"./lib/close":4,"./lib/credential":5,"./lib/execute":6,"./lib/header":7,"./lib/initialize":8,"./lib/logout":9,"./lib/notify":10,"./lib/off":11,"./lib/on":12,"./lib/open":13,"./lib/preference":14,"./lib/render":15,"./lib/request":16,"./lib/setMessages":17,"./lib/trigger":18,"./modules/cart":19,"./modules/catalog-slider":20,"./modules/checkout":22,"./modules/checkout-success":21,"./modules/customer-coupons":28,"./modules/customer-dashboard":29,"./modules/customer-delete-account":30,"./modules/customer-login":31,"./modules/customer-register":32,"./modules/customer-reset-password":33,"./modules/customer-review":36,"./modules/customer-review-comment":34,"./modules/customer-review-comments":35,"./modules/customer-reviews":37,"./modules/customer-update":40,"./modules/customer-update-address":38,"./modules/customer-update-credential":39,"./modules/customer-verification":41,"./modules/order-detail":42,"./modules/order-list":43,"./modules/order-request-refund":44,"./modules/payment-form":45,"./modules/product-detail":46,"./modules/product-list":48,"./modules/product-review":51,"./modules/product-review-comments":49,"./modules/product-review-writer":50,"./modules/product-reviews":52,"./modules/search-purchase":53,"./modules/subscription-detail":54,"./modules/subscription-list":55,"./plugins/cartStorage":56,"./plugins/confirmation":57,"./plugins/credentialStorage":58,"./plugins/notification":59,"./plugins/pagination":60,"./plugins/redirect":61,"./ui/avatar-placeholder":62,"./ui/button-spinner":63,"./ui/component-spinner":64,"./ui/empty-star":65,"./ui/filled-star":66,"./ui/half-filled-star":67,"./ui/hallow-star":68,"./ui/header-navigation":69,"./ui/left-arrow":70,"./ui/overlay-navigation":71,"./ui/review-star-rating":72,"./ui/review-stars":73,"./ui/right-arrow":74,"./ui/section-spinner":75,"./ui/social-login":76,"./ui/text-box-overlay":77,"./util/addTime":78,"./util/bindAgreements":79,"./util/bindBackButton":80,"./util/bindRecaptcha":81,"./util/bindSocialApps":82,"./util/checkItemRefunded":83,"./util/copyToClipboard":84,"./util/countryName":85,"./util/customerIdentity":86,"./util/debounce":87,"./util/excerpt":88,"./util/followingNavigation":89,"./util/formToJSON":90,"./util/formatNumber":91,"./util/formatPrice":92,"./util/getCurrency":93,"./util/handleSocialLogin":94,"./util/imageURL":95,"./util/imageUploader":96,"./util/isExpired":97,"./util/log":98,"./util/makeAsyncButton":99,"./util/makeRecaptcha":100,"./util/orderShippingStatus":101,"./util/parseArrayString":102,"./util/parseQueryString":103,"./util/productName":104,"./util/quantityInput":105,"./util/requestErrorHandler":106,"./util/stripHTML":107,"./util/toPrecision":108,"./util/ui":109,"./util/unsetRecaptcha":110,"./util/urlQuery":111,"./util/useRecaptcha":112,"./util/userIdOrEmail":113,"./util/variantName":114,"./version.json":115,"core-js/modules/es6.array.copy-within":222,"core-js/modules/es6.array.fill":223,"core-js/modules/es6.array.find":225,"core-js/modules/es6.array.find-index":224,"core-js/modules/es6.array.from":226,"core-js/modules/es6.array.iterator":227,"core-js/modules/es6.array.of":228,"core-js/modules/es6.function.name":229,"core-js/modules/es6.map":230,"core-js/modules/es6.math.acosh":231,"core-js/modules/es6.math.asinh":232,"core-js/modules/es6.math.atanh":233,"core-js/modules/es6.math.cbrt":234,"core-js/modules/es6.math.clz32":235,"core-js/modules/es6.math.cosh":236,"core-js/modules/es6.math.expm1":237,"core-js/modules/es6.math.fround":238,"core-js/modules/es6.math.hypot":239,"core-js/modules/es6.math.imul":240,"core-js/modules/es6.math.log10":241,"core-js/modules/es6.math.log1p":242,"core-js/modules/es6.math.log2":243,"core-js/modules/es6.math.sign":244,"core-js/modules/es6.math.sinh":245,"core-js/modules/es6.math.tanh":246,"core-js/modules/es6.math.trunc":247,"core-js/modules/es6.number.epsilon":248,"core-js/modules/es6.number.is-finite":249,"core-js/modules/es6.number.is-integer":250,"core-js/modules/es6.number.is-nan":251,"core-js/modules/es6.number.is-safe-integer":252,"core-js/modules/es6.number.max-safe-integer":253,"core-js/modules/es6.number.min-safe-integer":254,"core-js/modules/es6.object.assign":255,"core-js/modules/es6.object.freeze":256,"core-js/modules/es6.object.get-own-property-descriptor":257,"core-js/modules/es6.object.get-own-property-names":258,"core-js/modules/es6.object.get-prototype-of":259,"core-js/modules/es6.object.is":263,"core-js/modules/es6.object.is-extensible":260,"core-js/modules/es6.object.is-frozen":261,"core-js/modules/es6.object.is-sealed":262,"core-js/modules/es6.object.keys":264,"core-js/modules/es6.object.prevent-extensions":265,"core-js/modules/es6.object.seal":266,"core-js/modules/es6.object.set-prototype-of":267,"core-js/modules/es6.promise":268,"core-js/modules/es6.reflect.apply":269,"core-js/modules/es6.reflect.construct":270,"core-js/modules/es6.reflect.define-property":271,"core-js/modules/es6.reflect.delete-property":272,"core-js/modules/es6.reflect.get":275,"core-js/modules/es6.reflect.get-own-property-descriptor":273,"core-js/modules/es6.reflect.get-prototype-of":274,"core-js/modules/es6.reflect.has":276,"core-js/modules/es6.reflect.is-extensible":277,"core-js/modules/es6.reflect.own-keys":278,"core-js/modules/es6.reflect.prevent-extensions":279,"core-js/modules/es6.reflect.set":281,"core-js/modules/es6.reflect.set-prototype-of":280,"core-js/modules/es6.regexp.flags":282,"core-js/modules/es6.regexp.match":283,"core-js/modules/es6.regexp.replace":284,"core-js/modules/es6.regexp.search":285,"core-js/modules/es6.regexp.split":286,"core-js/modules/es6.set":287,"core-js/modules/es6.string.code-point-at":288,"core-js/modules/es6.string.ends-with":289,"core-js/modules/es6.string.from-code-point":290,"core-js/modules/es6.string.includes":291,"core-js/modules/es6.string.raw":292,"core-js/modules/es6.string.repeat":293,"core-js/modules/es6.string.starts-with":294,"core-js/modules/es6.symbol":295,"core-js/modules/es6.typed.array-buffer":296,"core-js/modules/es6.typed.float32-array":297,"core-js/modules/es6.typed.float64-array":298,"core-js/modules/es6.typed.int16-array":299,"core-js/modules/es6.typed.int32-array":300,"core-js/modules/es6.typed.int8-array":301,"core-js/modules/es6.typed.uint16-array":302,"core-js/modules/es6.typed.uint32-array":303,"core-js/modules/es6.typed.uint8-array":304,"core-js/modules/es6.typed.uint8-clamped-array":305,"core-js/modules/es6.weak-map":306,"core-js/modules/es6.weak-set":307,"core-js/modules/es7.array.includes":308,"core-js/modules/es7.object.entries":309,"core-js/modules/es7.object.get-own-property-descriptors":310,"core-js/modules/es7.object.values":311,"core-js/modules/es7.string.pad-end":312,"core-js/modules/es7.string.pad-start":313,"core-js/modules/web.dom.iterable":314,"core-js/modules/web.immediate":315,"core-js/modules/web.timers":316,"imagesloaded":334,"jquery-form":336,"jquery-match-height":337,"jstimezonedetect":338,"lightslider/dist/js/lightslider.min.js":339,"lodash.camelcase":340,"lodash.get":341,"lodash.kebabcase":342,"lodash.mergeWith":343,"node-polyglot":347,"regenerator-runtime/runtime":350}],2:[function(require,module,exports){
'use strict';

module.exports = function () {
	var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'customer';


	var storage = this.plugins.credentialStorage;

	// Customer case
	if (scope === 'customer') {

		var storageKey = this.options.authStorage.customer;
		var token = storage.getItem(storageKey);

		if (!token) {
			return false;
		}

		if (isTokenExpired(token)) {
			// If the token expired, log out the customer.
			this.logout();
			return false;
		}

		return parseToken(token);
	}

	// Order or Subscription case
	if (scope === 'order') {

		var _storageKey = this.options.authStorage.order;
		var _token = storage.getItem(_storageKey);

		if (!_token) {
			return false;
		}

		if (isTokenExpired(_token)) {
			// If the token expired, unset the token from the storage.
			storage.removeItem(this.options.authStorage.order);
			return false;
		}

		return parseToken(_token);
	}
};

function parseToken(token) {

	var parts = token.split('.');
	var data = JSON.parse(atob(parts[1]));

	return data;
}

function isTokenExpired(token) {

	var expiresAt = parseToken(token).exp * 1000;

	return expiresAt - Date.now() <= 0;
}

},{}],3:[function(require,module,exports){
'use strict';

module.exports = function (Thunder) {

		var Cart = {
				storage: '__items__',
				items: []
		};

		Cart.load = function () {

				var storage = Thunder.plugins.cartStorage;

				Cart.items = JSON.parse(storage.getItem(Cart.storage) || '[]');
		};

		Cart.persist = function () {

				var storage = Thunder.plugins.cartStorage;

				storage.setItem(Cart.storage, JSON.stringify(Cart.items));
		};

		Cart.totalItems = function (items) {

				return (Cart.items || items).reduce(function (sum, item) {
						return sum + 1 + (item.bundleItems ? item.bundleItems.length : 0);
				}, 0);
		};

		Cart.addItem = function (item, callback) {

				var items = $.extend(true, [], Cart.items);

				item._id = (Math.random() + '').slice(2, 17);

				if (item.bundleItems) {
						item.bundleItems.forEach(function (item) {
								item._id = (Math.random() + '').slice(2, 17);
						});
				}

				items.push(item);

				if (Cart.totalItems(items) >= 50) {
						return callback(CartError('items-exceeded'));
				}

				Cart.items = items;

				Cart.persist();

				return callback(null, item);
		};

		Cart.updateItem = function (itemId, update, callback) {

				itemId = itemId + '';

				var items = $.extend(true, [], Cart.items);
				var found = items.find(function (item) {
						return item._id === itemId;
				});

				if (!found) {
						return callback(CartError('no-item'));
				}

				var bundleItems = update.bundleItems;

				delete update.bundleItems;

				$.extend(found, update);

				if (bundleItems) {

						found.bundleItems = found.bundleItems || [];

						var _loop = function _loop(bundleId) {

								var item = found.bundleItems.find(function (item) {
										return item._id === bundleId;
								});
								var update = bundleItems[bundleId];

								if (!item && update) {
										found.bundleItems.push(update);
								}

								if (update) {
										$.extend(item, update);
								}

								if (update === null) {
										var index = found.bundleItems.indexOf(item);

										found.bundleItems.splice(index, 1);
								}
						};

						for (var bundleId in bundleItems) {
								_loop(bundleId);
						}
				}

				if (Cart.totalItems(items) >= 50) {
						return callback(CartError('items-exceeded'));
				}

				Cart.items = items;

				Cart.persist();

				return callback(null, found);
		};

		Cart.deleteItem = function (itemId, callback) {

				itemId = itemId + '';

				var items = $.extend(true, [], Cart.items);
				var index = null;

				for (var i = 0; i < items.length; i++) {

						var _item = items[i];

						if (_item._id === itemId) {
								index = i;
								break;
						}
				}

				if (index === null) {
						return callback(CartError('no-item'));
				}

				items.splice(index, 1);

				Cart.items = items;

				Cart.persist();

				return callback();
		};

		Cart.empty = function (callback) {

				Cart.items = [];

				Cart.persist();

				return callback();
		};

		return Cart;

		function CartError(code) {
				var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : code;


				var err = new Error(message);

				err.code = code;

				return err;
		}
};

},{}],4:[function(require,module,exports){
'use strict';

module.exports = function () {

	// Empty the contents and add a 'hidden' class
	this.overlay.container.addClass('hidden');
	this.overlay.background.addClass('hidden');

	this.overlay.body.html('');

	// show body scroll
	$('html, body').removeClass('thunder--overflow-fix');

	return this;
};

},{}],5:[function(require,module,exports){
'use strict';

module.exports = function (client) {

	this.request.setDefaultHeader('Authorization', 'Bearer ' + client);

	return this;
};

},{}],6:[function(require,module,exports){
'use strict';

module.exports = function (fn) {

	fn = typeof fn === 'string' ? this.methods[fn] : fn;

	if (!fn) return;

	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		args[_key - 1] = arguments[_key];
	}

	return fn.apply(undefined, args);
};

},{}],7:[function(require,module,exports){
'use strict';

module.exports = function () {

	if (!this.options.header) {
		return null;
	}

	var $headerNav = $('#thunder--header-navigation');

	if (!$headerNav.length) {

		var actions = this.options.header.actions;

		$('body').prepend(this.uis['header-navigation']());
		$('body').on('click', '#thunder--header-navigation [data-component]', function (e) {
			e.preventDefault();
			actions[$(this).data('component')]();
		});
	} else {

		$headerNav.replaceWith(this.uis['header-navigation']());
	}
};

},{}],8:[function(require,module,exports){
'use strict';

module.exports = function () {
	var _this = this;

	var Thunder = this;

	var body = $('body');

	this.Cart.load();

	// Cache overlay DOMs
	this.overlay.background = $(this.overlay.background).addClass('hidden');
	this.overlay.container = $(this.overlay.container).addClass('hidden');
	this.overlay.body = this.overlay.container.find('#thunder--overlay-body');

	// Append close button to the overlay's header
	this.overlay.container.find('#thunder--overlay-header').append(this.uis['overlay-navigation']());

	body.append(this.overlay.background);
	body.append(this.overlay.container);

	// Bind click events for DOMs with data-thunder-* attributes.
	body.on('click', '[data-thunder-open]', openOverlay);
	body.on('click', '[data-thunder-close]', function () {
		return _this.close();
	});
	body.on('click', '[data-thunder-logout]', function () {
		return _this.logout();
	});
	body.on('click', '[data-thunder-render][data-thunder-render-target]', renderComponentInTarget);

	// Render components for DOMs with 'data-thunder-render',
	// and without 'data-thunder-render-target'.
	body.find('[data-thunder-render]:not([data-thunder-render-target])').each(renderComponent);

	this.header();

	// Check whether authentication tokens are expired.
	// If it is expired -> Log out and unset from the storage...
	this.authenticated('customer');
	this.authenticated('order');

	function openOverlay($event) {

		$event.preventDefault();

		var data = $(this).data();
		var componentName = data.thunderOpen;

		// Pass the data from the caller DOM
		Thunder.open(componentName, data);
	}

	function renderComponent() {

		Thunder.render($(this), $(this).data('thunderRender'), {});
	}

	function renderComponentInTarget($event) {

		$event.preventDefault();

		var data = $(this).data();
		var thunderRender = data.thunderRender,
		    thunderRenderTarget = data.thunderRenderTarget;


		Thunder.render($(thunderRenderTarget), thunderRender, data);
	}
};

},{}],9:[function(require,module,exports){
"use strict";

module.exports = function () {

	var storage = this.plugins.credentialStorage;

	storage.removeItem(this.options.authStorage.customer);

	this.header();
};

},{}],10:[function(require,module,exports){
"use strict";

module.exports = function () {
	var _plugins;

	return (_plugins = this.plugins).notification.apply(_plugins, arguments);
};

},{}],11:[function(require,module,exports){
"use strict";

module.exports = function (scope, listener) {

	var index = this.listeners[scope].indexOf(listener);

	if (index === -1) {

		return this;
	}

	this.listeners[scope].splice(index, 1);

	return this;
};

},{}],12:[function(require,module,exports){
"use strict";

module.exports = function (scope, listener) {

	this.listeners[scope].push(listener);

	return this;
};

},{}],13:[function(require,module,exports){
'use strict';

module.exports = function (componentName, options) {
	var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};


	options = options || {};

	callback = typeof options === 'function' ? options : callback;

	if (this.overlay.background.hasClass('hidden')) {
		// Removes a 'hidden' class first
		this.overlay.background.removeClass('hidden');
		this.overlay.container.removeClass('hidden');
	}
	// hide body scroll
	$('html, body').addClass('thunder--overflow-fix');

	// Mark current view
	$.extend(true, options, {
		view: {
			component: componentName,
			cursor: this.cursor
		}
	});

	this.render(this.overlay.body, componentName, options, function (err, context) {

		if (err) {
			return callback.call($(this), err);
		}

		return callback.call($(this), err, context);
	});

	return this;
};

},{}],14:[function(require,module,exports){
'use strict';

module.exports = function (options) {

	var language = options.language;
	var currency = options.currency;
	var timezone = options.timezone;
	var debugLanguage = options.debugLanguage;

	this.options.language = language;
	this.options.currency = currency;
	this.options.timezone = timezone;

	this.polyglot.locale(this.options.language);

	if (language) this.request.setDefaultHeader('Accept-Language', language);
	if (currency) this.request.setDefaultHeader('Accept-Currency', currency);
	if (timezone) this.request.setDefaultHeader('Accept-Time-Zone', timezone);
	if (debugLanguage) this.request.setDefaultHeader('Accept-Debug-Language', debugLanguage);

	return this;
};

},{}],15:[function(require,module,exports){
'use strict';

var mergeWith = require('lodash.mergeWith');
var omit = require('lodash.omit');
var Pikaday = require('pikaday');

// Track component IDs
var componentIds = {};

module.exports = function (selector, componentName, options, callback) {

	var Thunder = this;

	options = options || {};
	callback = typeof options === 'function' ? options : callback;

	// Increment component counter
	componentIds[componentName] = componentIds[componentName] || 0;

	var id = componentIds[componentName]++;

	var container = selector instanceof $ ? selector : $(selector);
	var component = this.components[componentName];

	// Template context
	var context = {
		id: componentName + '-' + id
	};

	// Add 'thunder--contents' class for global css styles
	container.addClass('thunder--contents');

	// Unbind all event handlers
	container.off();
	container.find('*').off();
	container.find('[data-mh]').matchHeight({ remove: true });
	container.find('[data-pickaday]').each(function () {

		var picker = $(this).data('pickaday');

		return picker ? picker.destroy() : null;
	});

	// Start loading spinner
	container.html(this.uis['component-spinner']());

	// Copy and extend default options with runtime options
	mergeWith(context, { // Global context
		isAuthenticated: !!Thunder.authenticated() // Customer is authenticated?
	}, this.templateMethods, // Template methods
	{ // Translation method
		m: function m(key, context) {
			return Thunder.polyglot.t(componentName + '.' + key, context);
		},
		ui: Thunder.uis
	}, { options: component.options() }, { options: component.default }, { options: omit(container.data(), ['component', 'context']) }, // Declarative options
	{ options: options }, // Explicit options
	function (ov, sv) {
		if (Array.isArray(ov) && Array.isArray(sv)) {
			return sv;
		}
	});

	if (component.validate) {

		var err = component.validate(context.options);

		if (err) {
			return this.util.log(['error'], component.name + ' - ' + err);
		}
	}

	component.pre.call(container, context, function (err, context) {

		if (err) {
			return;
		}

		// Cache component
		container.data('component', Thunder.components[componentName]);

		// Cache context data
		container.data('context', context);

		container.html(component.template(context));

		Thunder.trigger('componentRender', container, componentName, container, context);

		Thunder.util.quantityInput(container);

		// Bind before automatic binding
		if (component.bind) {
			component.bind.call(container, context);
		}

		container.imagesLoaded(function () {
			return container.find('[data-mh]').matchHeight();
		});

		var t = function t(key) {
			return Thunder.polyglot.t('general.' + key);
		};

		container.find('[data-pickaday]').each(function () {

			$(this).data('pickaday', new Pikaday($.extend($(this).data(), {
				field: $(this)[0],
				format: Thunder.options.dateInputFormat,
				i18n: {
					previousMonth: t('previousMonth'),
					nextMonth: t('nextMonth'),
					months: [t('january'), t('february'), t('march'), t('april'), t('may'), t('june'), t('july'), t('august'), t('september'), t('october'), t('november'), t('december')],
					weekdays: [t('sunday'), t('monday'), t('tuesday'), t('wednesday'), t('thursday'), t('friday'), t('saturday')],
					weekdaysShort: [t('sundayShort'), t('mondayShort'), t('tuesdayShort'), t('wednesdayShort'), t('thursdayShort'), t('fridayShort'), t('saturdayShort')]
				}
			})));
		});

		var interfaces = component.init.call(container, context) || {};

		Thunder.trigger('componentInit', container, componentName, container, context);

		return callback && callback.call($(this), err, { interfaces: interfaces, context: context });
	}.bind(container));

	return this;
};

},{"lodash.mergeWith":343,"lodash.omit":344,"pikaday":348}],16:[function(require,module,exports){
'use strict';

module.exports = function (Thunder) {

	var request = function request(requestOptions) {

		var query = $.param(requestOptions.query || {});

		query = query ? '?' + query : query;

		requestOptions.url = Thunder.options.baseURL + requestOptions.url + query;

		var recaptcha = requestOptions.recaptcha;

		delete requestOptions.query;
		delete requestOptions.recaptcha;

		var req = $.extend(true, {
			crossDomain: true,
			headers: $.extend(request.getRequestHeaders(Thunder), recaptcha ? { 'Recaptcha-Response': recaptcha } : {}),
			xhrFields: {
				withCredentials: true
			},
			converters: {
				'text json': function textJson(data) {
					return $.parseJSON(data || 'null');
				}
			}
		}, requestOptions);

		if (req.data) {

			var _recaptcha = Thunder.util.unsetRecaptcha(req.data);

			if (_recaptcha) {
				req.headers['reCAPTCHA-Response'] = _recaptcha;
			}

			req.data = JSON.stringify(req.data);
			req.dataType = 'json';
			req.contentType = 'application/json; charset=utf-8';
		}

		return $.ajax(req);
	};

	request.defaultHeaders = {
		'Clayful-SDK': 'clayful-thunder'
	};

	request.setDefaultHeader = function (key, value) {
		request.defaultHeaders[key] = value;
	};

	request.getRequestHeaders = function () {

		var storage = Thunder.plugins.credentialStorage;

		// 1. If a customer is logged-in, send a customer token.
		// 2. If an order token or a subscription token exists, send the token.
		// 3. Or else, simply do not set `Authorization-Customer` header
		var customerToken = storage.getItem(Thunder.options.authStorage.customer) || storage.getItem(Thunder.options.authStorage.order);

		return $.extend({}, request.defaultHeaders, customerToken ? {
			'Authorization-Customer': customerToken
		} : {});
	};

	return request;
};

},{}],17:[function(require,module,exports){
"use strict";

module.exports = function () {
	var messages = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


	this.polyglot.extend(messages);

	return this;
};

},{}],18:[function(require,module,exports){
"use strict";

module.exports = function (scope, binder) {
	for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
		args[_key - 2] = arguments[_key];
	}

	this.listeners[scope].forEach(function (callback) {
		return binder ? callback.call.apply(callback, [binder].concat(args)) : callback.apply(undefined, args);
	});

	return this;
};

},{}],19:[function(require,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var set = require('lodash.set');

module.exports = function (Thunder) {

	var implementation = {
		name: 'cart'
	};

	implementation.options = function () {
		return {
			orderActions: Object.keys(Thunder.options.paymentMethods), // 'order', 'subscription'
			items: null, // Item filter - e.g., ['item1', 'item2', ...]

			onCheckout: function onCheckout($container, context, type) {

				Thunder.render($container, 'checkout', {
					type: type,
					items: context.options.items,
					back: {
						$container: $container,
						component: implementation.name,
						options: context.options
					}
				});
			}
		};
	};

	implementation.pre = function (context, callback) {

		context.options.orderActions = Thunder.util.parseArrayString(context.options.orderActions);

		var errors = {
			default: context.m('cartReadFailed')
		};

		return getCart(context.options.items).then(function (cart) {
			return callback(null, set(context, 'cart', cart.cart));
		}, function (err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
		});
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $cartItems = $(this).find('.thunder--cart-items');

		$container.on('click', '.thunder--delete-cart-item', deleteItem);
		$container.on('click', '.thunder--apply-changes', applyChanges);
		$container.on('click', '.thunder--checkout button', checkout);

		function recalculate() {

			var errors = {
				default: context.m('cartReadFailed')
			};

			return getCart(context.options.items).then(function (cart) {

				context.cart = cart.cart;

				var template = Thunder.component(implementation.name).template(context);
				var cartItemsTemplate = $(template).find('.thunder--cart-items').html();

				$cartItems.find('*').off();
				$cartItems.html(cartItemsTemplate);
				Thunder.util.quantityInput($cartItems);
			}, function (err) {
				return Thunder.util.requestErrorHandler(err.responseJSON, errors);
			});
		}

		function deleteItem() {

			var spinner = Thunder.util.makeAsyncButton($(this), { bind: false });

			spinner.run();

			var itemId = $(this).data('item');
			var bundleItemId = $(this).data('bundleItem');

			var errors = {
				default: context.m('deleteItemFailed')
			};

			if (Thunder.authenticated()) {

				if (bundleItemId) {

					return Thunder.request({
						method: 'PUT',
						url: '/v1/me/cart/items/' + itemId,
						data: { bundleItems: _defineProperty({}, bundleItemId, null) }
					}).then(function () {
						spinner.done();
						recalculate();
					}, function (err) {
						return Thunder.util.requestErrorHandler(err.responseJSON, errors, function (err) {
							return spinner.done();
						});
					});
				} else {

					return Thunder.request({
						method: 'DELETE',
						url: '/v1/me/cart/items/' + itemId
					}).then(function () {
						spinner.done();
						recalculate();
					}, function (err) {
						return Thunder.util.requestErrorHandler(err.responseJSON, errors, function (err) {
							return spinner.done();
						});
					});
				}
			} else {

				if (bundleItemId) {

					var update = {
						bundleItems: _defineProperty({}, bundleItemId, null)
					};

					Thunder.Cart.updateItem(itemId, update, function (err) {

						if (err) {
							spinner.done();
							return Thunder.notify('error', errors[err.code || 'default'] || errors.default);
						}

						spinner.done();
						recalculate();
					});
				} else {

					return Thunder.Cart.deleteItem(itemId, function (err) {

						if (err) {
							spinner.done();
							return Thunder.notify('error', errors[err.code || 'default'] || errors.default);
						}

						spinner.done();
						recalculate();
					});
				}
			}
		}

		function applyChanges() {

			var spinner = Thunder.util.makeAsyncButton($(this), { bind: false });

			spinner.run();

			var quantityChanged = [];
			var $quantityInputs = $container.find('.thunder--cart-item-quantity input');

			$quantityInputs.each(function () {

				var itemId = $(this).data('item');
				var bundleId = $(this).data('bundleItem');
				var originalQuantity = $(this).data('originalQuantity');
				var newQuantity = parseInt($(this).val());

				if (newQuantity === originalQuantity) return;

				quantityChanged.push({
					item: itemId,
					bundle: bundleId || null,
					quantity: newQuantity
				});
			});

			var updates = quantityChanged.reduce(function (o, change) {
				var item = change.item,
				    bundle = change.bundle,
				    quantity = change.quantity;


				o[item] = o[item] || {};

				var toUpdate = o[item];

				if (bundle) {
					toUpdate.bundleItems = toUpdate.bundleItems || {};
					toUpdate.bundleItems[bundle] = { quantity: quantity };
				} else {
					toUpdate.quantity = quantity;
				}

				return o;
			}, {});

			var errors = {
				default: context.m('itemUpdateFailed')
			};

			if (Thunder.authenticated()) {
				var _$;

				var itemIdsToUpdate = Object.keys(updates);

				if (itemIdsToUpdate.length === 0) {
					// There are no items to update
					return spinner.done();
				}

				return (_$ = $).when.apply(_$, _toConsumableArray(itemIdsToUpdate.map(function (itemId) {

					return Thunder.request({
						method: 'PUT',
						url: '/v1/me/cart/items/' + itemId,
						data: updates[itemId]
					}).then(function () {

						spinner.done();
						return recalculate();
					}, function (err) {
						return Thunder.util.requestErrorHandler(err.responseJSON, errors, function (err) {
							return spinner.done();
						});
					});
				})));
			} else {

				Object.keys(updates).forEach(function (itemId) {
					return Thunder.Cart.updateItem(itemId, updates[itemId], $.noop);
				});

				spinner.done();
				return recalculate();
			}
		}

		function checkout() {

			var cart = context.cart;
			var hasError = function hasError(code) {
				return cart.errors.some(function (err) {
					return err.code === code;
				});
			};

			if (hasError('empty-cart')) {
				return Thunder.notify('error', context.m('isEmptyCart'));
			}

			if (hasError('item-error')) {
				return Thunder.notify('error', context.m('hasErredItem'));
			}

			return Thunder.execute(context.options.onCheckout, $container, context, $(this).data('checkoutType'));
		}
	};

	function getCart(items) {

		var query = items ? { items: items.toString() } : {};

		var request = Thunder.authenticated() ? {
			method: 'POST',
			url: '/v1/me/cart',
			query: query
		} : {
			method: 'POST',
			url: '/v1/me/non-registered/cart',
			query: query,
			data: { items: Thunder.Cart.items }
		};

		return Thunder.request(request);
	}

	return implementation;
};

},{"lodash.set":345}],20:[function(require,module,exports){
'use strict';

var set = require('lodash.set');

module.exports = function (Thunder) {

	// Implementation
	var implementation = {
		name: 'catalog-slider'
	};

	implementation.options = function () {
		return {
			catalog: '', // Catalog ID to render
			useNav: true,
			usePager: true,
			showCaption: true,
			autoLoop: 3000
		};
	};

	implementation.pre = function (context, callback) {

		var errors = {};
		var catalogId = context.options.catalog;

		context.targetCheck = function (url) {

			var urlTarget = document.createElement('a');

			urlTarget.href = url;

			return urlTarget.host === window.location.host ? '_self' : '_blank';
		};

		return Thunder.request({
			method: 'GET',
			url: '/v1/catalogs/' + catalogId,
			query: {
				fields: ['slug', 'items.image', 'items.link', 'items.title'].join(',')
			}
		}).then(function (data) {

			return callback(null, set(context, 'catalogSlider', data));
		}, function (err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
		});
	};

	implementation.init = function (context) {

		var options = {
			item: 1,
			speed: 800,
			slideMargin: 0,
			gallery: false,
			pauseOnHover: true,
			loop: true,
			adaptiveHeight: true,
			pager: context.options.usePager,
			controls: context.options.useNav,
			auto: !!context.options.autoLoop,
			pause: context.options.autoLoop || 3000,
			prevHtml: '<img src="' + Thunder.uis['left-arrow']() + '">',
			nextHtml: '<img src="' + Thunder.uis['right-arrow']() + '">'
		};

		var slider = $(this).find('.thunder--catlaog-slider').lightSlider(options);

		return {
			// Expose slider methods
			goToSlide: slider.goToSlide,
			goToPrevSlide: slider.goToPrevSlide,
			goToNextSlide: slider.goToNextSlide,
			play: slider.play,
			pause: slider.pause,
			// Expose custom destory method
			destroy: function destroy() {
				slider.pause(); // To clear interval
				slider.destroy(); // Destroy the slider
				slider.remove(); // Remove the DOM
			}
		};
	};

	return implementation;
};

},{"lodash.set":345}],21:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var set = require('lodash.set');
var camelCase = require('lodash.camelcase');

module.exports = function (Thunder) {

	var implementation = {
		name: 'checkout-success'
	};

	implementation.options = function () {
		return {
			type: 'order', // 'order' || 'subscription'
			subject: null, // Order/Subscription ID
			onViewDetails: function onViewDetails($container, context) {
				var _context$options = context.options,
				    type = _context$options.type,
				    subject = _context$options.subject;


				return Thunder.render($container, type + '-detail', _defineProperty({}, type, subject));
			}
		};
	};

	implementation.pre = function (context, callback) {

		var type = context.options.type;
		var subject = context.options.subject;

		var errors = {
			default: context.m(camelCase([type, 'readFailed']))
		};

		// Get an order or a subscription
		return type === 'order' ? Thunder.request({
			method: 'PUT',
			url: '/v1/me/' + type + 's/' + subject + '/transactions'
		}).then(function () {
			return getSubject();
		}) : getSubject();

		function getSubject() {
			return Thunder.request({
				method: 'GET',
				url: '/v1/me/' + type + 's/' + subject
			}).then(function (subject) {
				return callback(null, set(context, 'subject', subject));
			}, function (err) {
				return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
			});
		}
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $viewMoreDetails = $(this).find('.thunder--view-more-details');
		var $copyToId = $(this).find('.thunder--copy-to-id');
		var $copyToIdButton = $(this).find('.thunder--copy-to-id-button');

		$viewMoreDetails.on('click', function () {
			return Thunder.execute(context.options.onViewDetails, $container, context);
		});

		$copyToIdButton.on('click', function () {
			Thunder.util.copyToClipboard($copyToId);
		});
	};

	return implementation;
};

},{"lodash.camelcase":340,"lodash.set":345}],22:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var get = require('lodash.get');
var set = require('lodash.set');
var camelCase = require('lodash.camelcase');
var CouponHandler = require('./lib/couponHandler.js');
var CustomerHandler = require('./lib/customerHandler.js');
var AddressHandler = require('./lib/addressHandler.js');
var SubscriptionHandler = require('./lib/subscriptionHandler.js');
var RecaptchaHandler = require('./lib/recaptchaHandler.js');

module.exports = function (Thunder) {

	var translationKeys = {
		'name.first': 'firstName',
		'name.last': 'lastName',
		'name.full': 'fullName'
	};

	var implementation = {
		name: 'checkout'
	};

	implementation.options = function () {
		return {
			type: 'order', // 'order' or 'subscription'
			items: null, // Item filter - e.g., ['item1', 'item2', ...]
			customerFields: Thunder.options.customerOrderFields,
			recipientFields: Thunder.options.recipientFields,
			addressDisabled: Thunder.options.addressDisabled,
			subscriptionPlans: Thunder.options.subscriptionPlans,
			termsLink: Thunder.options.legal.orderTerms.link,
			termsText: Thunder.options.legal.orderTerms.text,
			privacyLink: Thunder.options.legal.orderPrivacy.link,
			privacyText: Thunder.options.legal.orderPrivacy.text,
			onCheckoutSuccess: function onCheckoutSuccess($container, context, checkoutDetail) {
				var order = checkoutDetail.order,
				    subscription = checkoutDetail.subscription;


				return Thunder.render($container, 'checkout-success', {
					type: subscription ? 'subscription' : 'order',
					subject: (subscription || order)._id
				});
			},
			onPaymentFailure: function onPaymentFailure($container, context, checkoutDetail) {
				var order = checkoutDetail.order,
				    subscription = checkoutDetail.subscription;

				var type = subscription ? 'subscription' : 'order';

				Thunder.notify('error', context.m('paymentFailed'));

				return Thunder.render($container, type + '-detail', _defineProperty({}, type, (subscription || order)._id));
			}
		};
	};

	implementation.pre = function (context, callback) {
		var _context$options = context.options,
		    type = _context$options.type,
		    items = _context$options.items,
		    customerFields = _context$options.customerFields,
		    recipientFields = _context$options.recipientFields,
		    subscriptionPlans = _context$options.subscriptionPlans,
		    termsLink = _context$options.termsLink,
		    termsText = _context$options.termsText,
		    privacyLink = _context$options.privacyLink,
		    privacyText = _context$options.privacyText;


		context.agreements = [termsLink || termsText ? 'terms' : null, privacyLink || privacyText ? 'privacy' : null].filter(function (v) {
			return v;
		});

		var $container = $(this);

		var defaultCartQuery = items ? { items: items.toString() } : {};
		var defaultCartData = {};

		var disabledAddressFields = Thunder.util.parseArrayString(context.options.addressDisabled).reduce(function (o, field) {
			return set(o, field, true);
		}, {});

		context.isSubscription = context.options.type === 'subscription';

		context.useSearchAddress = !!Thunder.plugins.searchAddress;

		context.disabled = function (field) {
			return disabledAddressFields[field] && context.useSearchAddress ? 'readonly' : '';
		};

		var toFieldDetail = function toFieldDetail() {
			var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
			return function (field) {
				var _field$split = field.split(':'),
				    _field$split2 = _slicedToArray(_field$split, 2),
				    key = _field$split2[0],
				    required = _field$split2[1];

				return {
					required: required === 'required',
					key: key,
					translationKey: camelCase([prefix, translationKeys[key] || key])
				};
			};
		};

		context.customerFields = Thunder.util.parseArrayString(customerFields).map(toFieldDetail('customer'));

		context.recipientFields = Thunder.util.parseArrayString(recipientFields).map(toFieldDetail('address'));

		var requestFailed = function requestFailed(err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, {
				default: context.m('checkoutPreparationFailed')
			}, callback);
		};

		return $.when(Thunder.authenticated() ? Thunder.request({
			method: 'GET',
			url: '/v1/me',
			query: {
				raw: true,
				fields: ['name', 'email', 'mobile', 'phone', 'gender', 'birthdate', 'country', 'language', 'currency', 'timezone', 'address.primary'].join(',')
			}
		}) : null).then(function (customer) {

			var primaryAddress = get(customer, 'address.primary', null);

			if (primaryAddress) {

				defaultCartData.address = {
					shipping: primaryAddress,
					billing: primaryAddress
				};
			}

			context.customer = customer || null;
			context.address = primaryAddress || AddressHandler.defaultAddress();

			return $.when(Thunder.request({
				method: 'GET',
				url: '/v1/countries',
				query: { fields: 'code', limit: 120, page: 1 }
			}), Thunder.request({
				method: 'GET',
				url: '/v1/countries',
				query: { fields: 'code', limit: 120, page: 2 }
			}), Thunder.request({
				method: 'GET',
				url: '/v1/countries',
				query: { fields: 'code', limit: 120, page: 3 }
			}), getCart({
				query: defaultCartQuery,
				data: defaultCartData
			}), Thunder.authenticated() ? Thunder.request({
				method: 'GET',
				url: '/v1/me/coupons',
				query: {
					limit: 120,
					fields: ['name', 'active', 'only', 'type', 'discount', 'category', 'price', 'subscription', 'expiresAt'].join(',')
				}
			}) : null, context.isSubscription ? Thunder.request({
				method: 'GET',
				url: '/v1/subscriptions/plans',
				query: {
					ids: subscriptionPlans.map(function (_ref) {
						var id = _ref.id;
						return id;
					}).join(','),
					fields: ['name', 'immediate', 'interval'].join(','),
					sort: 'ids'
				}
			}) : null);
		}, requestFailed).then(function (countries1, countries2, countries3, cart, coupons, plans) {

			var hasCartError = cart[0].cart.errors.some(function (err) {
				return err.code !== 'shipping-address-required';
			});

			if (hasCartError) {
				return Thunder.render($container, 'cart', {
					orderActions: Object.keys(Thunder.options.paymentMethods),
					items: context.options.items
				});
			}

			context.countries = [].concat(countries1[0], countries2[0], countries3[0]);

			context.cart = cart[0].cart;
			context.subscription = cart[0].subscription || null;
			context.subscriptionPlans = (plans ? plans[0] : []).map(function (plan) {
				return $.extend(plan, subscriptionPlans.find(function (s) {
					return s.id === plan._id;
				}));
			});
			context.coupons = coupons ? coupons[0] : [];

			CouponHandler.setApplicableCoupons(context.options.type, context.cart, context.coupons);

			return callback(null, context);
		}, requestFailed);
	};

	implementation.init = function (context) {
		var _this = this;

		var $paymentFormContainer = $(this).find('.thunder--payment-form-container');

		Thunder.render($paymentFormContainer, 'payment-form', {
			type: context.options.type
		}, function (err, _ref2) {
			var paymentHandler = _ref2.interfaces;


			var $container = $(_this);
			var $backToCart = $(_this).find('.thunder--back-to-cart');
			var $cartItems = $(_this).find('.thunder--cart-items table');
			var $goToUpdateCustomer = $(_this).find('.thunder--go-to-update-customer');
			var $sameForRecipient = $(_this).find('[name="sameForRecipient"]');
			var $saveAsPrimaryAddress = $(_this).find('#thunder--save-primary-address-agreement');
			var $searchAddress = $(_this).find('.thunder--search-address');
			var $disabledAddressInputs = $(_this).find('.thunder--address-location div [readonly]').parent();
			var $applyAddress = $(_this).find('.thunder--apply-address');
			var $orderRequest = $(_this).find('[name="request"]');
			var $totalDetails = $(_this).find('.thunder--total-details');
			var $proceedCheckout = $(_this).find('.thunder--proceed-checkout');
			var processCheckoutSpinner = Thunder.util.makeAsyncButton($proceedCheckout, { bind: false });

			var areTermsAgreed = Thunder.util.bindAgreements({
				$terms: $(_this).find('[data-agreement-scope]'),
				agreements: {
					terms: {
						text: context.options.termsText,
						link: context.options.termsLink,
						error: context.m('termsAgreementRequired')
					},
					privacy: {
						text: context.options.privacyText,
						link: context.options.privacyLink,
						error: context.m('privacyAgreementRequired')
					}
				}
			});

			var couponHandler = CouponHandler({
				form: $(_this).find('.thunder--cart-items'),
				labels: {
					applyCoupons: context.m('applyCoupons'),
					finishApplyingCoupons: context.m('finishApplyingCoupons')
				},
				coupons: context.coupons,
				cart: function cart() {
					return context.cart;
				},
				onCouponApply: function onCouponApply(type) {
					return applyCoupons(type);
				},
				onCouponSelectError: function onCouponSelectError(code) {
					return Thunder.notify('error', context.m(code));
				}
			});

			var customerHandler = CustomerHandler({
				customerFields: context.customerFields.map(function (_ref3) {
					var key = _ref3.key,
					    required = _ref3.required;
					return {
						field: key,
						required: required
					};
				}).map(function (detail) {
					return $.extend(detail, {
						$input: $(_this).find('.thunder--customer [name="customer.' + detail.field + '"]')
					});
				}),
				translationKeys: translationKeys
			});

			var addressHandler = AddressHandler({
				addressFields: [].concat(_toConsumableArray(context.recipientFields.map(function (_ref4) {
					var key = _ref4.key,
					    required = _ref4.required;
					return {
						field: key,
						recipient: true,
						required: required
					};
				})), [{ field: 'country', required: true }, { field: 'state', required: false }, { field: 'city', required: true }, { field: 'address1', required: true }, { field: 'address2', required: false }, { field: 'postcode', required: true }]).map(function (detail) {
					return $.extend(detail, {
						$input: $(_this).find(['.thunder--recipient-info', '.thunder--address'].join(',')).find('[name="address.' + detail.field + '"]')
					});
				}),
				translationKeys: translationKeys,
				searchAddressPlugin: Thunder.plugins.searchAddress
			});

			var debouncedApplySubscriptionDetail = Thunder.util.debounce(applySubscriptionDetail, 100, true);

			var subscriptionHandler = SubscriptionHandler({
				form: $(_this).find('.thunder--subscription-details'),
				labels: {
					firstOrderStartsAt: context.m('firstOrderStartsAt'),
					secondOrderStartsAt: context.m('secondOrderStartsAt')
				},
				subscriptionPlans: context.subscriptionPlans,
				timezone: function timezone() {
					return Thunder.options.timezone;
				},
				onPlanChange: function onPlanChange() {
					return debouncedApplySubscriptionDetail();
				},
				onStartsAtChange: function onStartsAtChange() {
					return debouncedApplySubscriptionDetail();
				}
			});

			Thunder.util.bindBackButton($backToCart, context);

			customerHandler.setCustomer(context.customer);
			addressHandler.setAddress(context.address);

			$sameForRecipient.on('change', copyToRecipient);
			$applyAddress.on('click', applyChanges);
			$searchAddress.on('click', searchAddress);
			$disabledAddressInputs.on('click', searchAddress);

			$goToUpdateCustomer.on('click', function () {
				return Thunder.render($container, 'customer-update', {
					back: {
						$container: $container,
						component: implementation.name,
						options: context.options
					}
				});
			});

			// It's a bit hacky way to handle reCAPTCHA,
			// but if a store uses reCATPCHA for checkout and order/subscription auth,
			// bind reCATPCHA twice for the same button to get two reCAPTCHA responses.
			var recaptchaComponents = [implementation.name, 'search-purchase'];

			var recaptchaHandler = RecaptchaHandler(recaptchaComponents.filter(Thunder.util.useRecaptcha).reduce(function (o, c) {
				return set(o, c, true);
			}, {}));

			recaptchaComponents.forEach(function (componentName) {
				return Thunder.util.makeRecaptcha({
					componentName: componentName,
					button: $proceedCheckout,
					validate: validateCheckoutData,
					callback: proceedCheckout
				});
			});

			function copyToRecipient() {
				return $(this).is(':checked') ? addressHandler.setAddress(customerHandler.getCustomer()) : addressHandler.reset('recipient');
			}

			function applyChanges() {

				var options = buildCartOptions();
				var address = options.data.address.shipping;
				var discount = options.data.discount;

				var addressError = addressHandler.validateAddress(address, false);

				// Validate shipping address
				if (addressError) {
					return Thunder.notify('error', context.m(addressError));
				}

				var oldCartItems = $cartItems.html();
				var oldTotalDetails = $totalDetails.html();
				var sectionSpinner = Thunder.ui('section-spinner')();

				$cartItems.html('<tr><td>' + sectionSpinner + '</td></tr>');
				$totalDetails.html(sectionSpinner);

				var errors = {
					'invalid-postcode': context.m('invalidPostcode'),
					'starts-too-early': context.m('startsTooEarly'),
					'cart-coupon-category': context.m('cartCouponCategory'),
					'cart-coupon-price': context.m('cartCouponPrice'),
					default: context.m('cartUpdateFailed')
				};

				return getCart(options).then(function (_ref5) {
					var cart = _ref5.cart,
					    subscription = _ref5.subscription;


					var cartHasItemError = cart.errors.some(function (error) {
						return error.code === 'item-error';
					});

					if (cartHasItemError) {
						Thunder.notify('error', context.m('invalidCartItemIncluded'));
						return Thunder.render($container, 'cart', {
							orderActions: Object.keys(Thunder.options.paymentMethods),
							items: context.options.items
						});
					}

					context.cart = cart;
					context.subscription = subscription || null;

					CouponHandler.setApplicableCoupons(context.options.type, context.cart, context.coupons);

					if (discount) {

						if (discount.items) {
							discount.items.forEach(function (_ref6) {
								var item = _ref6.item,
								    coupon = _ref6.coupon;
								return set(context.cart.items.find(function (_ref7) {
									var _id = _ref7._id;
									return _id === item;
								}), 'appliedCoupon', couponHandler.getCoupon(coupon));
							});
						}

						if (discount.cart) {
							context.cart.appliedCoupon = couponHandler.getCoupon(discount.cart.coupon);
						}
					}

					var $template = $(Thunder.component(implementation.name).template(context));

					$cartItems.html($template.find('.thunder--cart-items table').html());
					$totalDetails.html($template.find('.thunder--total-details').html());

					couponHandler.bindCouponValidator();
				}, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors, function (err) {
						$cartItems.html(oldCartItems);
						$totalDetails.html(oldTotalDetails);
					});
				});
			}

			function validateCheckoutData() {

				var agreed = areTermsAgreed();

				if (!agreed) {
					return false;
				}

				var options = buildCartOptions('checkout');

				var _options$data = options.data,
				    address = _options$data.address,
				    subscription = _options$data.subscription;

				// Validate customer

				var customer = customerHandler.getCustomer();
				var customerError = customerHandler.validateCustomer(customer);

				if (customerError) {
					Thunder.notify('error', context.m(customerError));
					return false;
				}

				// Validate addresses
				var addressErrors = [address.shipping, address.billing].map(addressHandler.validateAddress).filter(function (v) {
					return v;
				});

				if (addressErrors[0]) {
					Thunder.notify('error', context.m(addressErrors[0]));
					return false;
				}

				var paymentError = paymentHandler.validate();

				if (paymentError) {
					Thunder.notify('error', paymentError.message);
					return false;
				}

				if (context.isSubscription) {
					// Validate only if checkout process is for a subscription
					var subscriptionError = subscriptionHandler.validateSubscriptionDetail(subscription);

					if (subscriptionError) {
						Thunder.notify('error', context.m(subscriptionError));
						return false;
					}
				}

				return true;
			}

			function proceedCheckout(token, resetRecaptcha) {

				var shouldExecute = recaptchaHandler.execute(token);

				if (!shouldExecute) return;

				var checkoutRes = shouldExecute.checkout,
				    searchPurchaseRes = shouldExecute['search-purchase'];


				processCheckoutSpinner.run();

				var options = buildCartOptions('checkout');
				var customer = customerHandler.getCustomer();
				var card = paymentHandler.getCard();

				var _options$data$payment = options.data.paymentMethod.split('.'),
				    _options$data$payment2 = _slicedToArray(_options$data$payment, 1),
				    paymentMethodId = _options$data$payment2[0];

				if (checkoutRes) {
					// Set reCAPTCHA response
					options.recaptcha = checkoutRes;
				}

				options.data.paymentMethod = paymentMethodId;

				if (!Thunder.authenticated()) {
					// Set customer details only for non-registered customers
					options.data.customer = customer;
				}

				var checkoutFinished = function checkoutFinished(successDetail) {

					processCheckoutSpinner.done();

					if (resetRecaptcha) {
						resetRecaptcha();
					}

					if (!successDetail) return;

					if (!Thunder.authenticated()) {
						// Delete ordered items from the local cart
						context.cart.items.forEach(function (item) {
							return Thunder.Cart.deleteItem(item._id, $.noop);
						});
					}

					return Thunder.execute(context.options.onCheckoutSuccess, $container, context, successDetail);
				};

				var order = void 0;
				var subscription = void 0;

				var authByOrderOrSubscription = {
					run: function run(_ref8) {
						var o = _ref8.order,
						    s = _ref8.subscription;


						if ($saveAsPrimaryAddress.is(':checked')) {
							// Update the primary address (Fire & Forget)
							var _options = buildCartOptions('checkout');

							Thunder.request({
								method: 'PUT',
								url: '/v1/me',
								data: {
									address: {
										primary: _options.data.address.shipping
									}
								}
							});
						}

						order = o;
						subscription = s || null;

						var type = context.options.type;
						var subject = context.isSubscription ? s : o;

						var options = {
							data: Thunder.options.orderAuthFields.reduce(function (o, field) {
								return set(o, field, get(subject.customer, field, null));
							}, {})
						};

						if (searchPurchaseRes) {
							options.recaptcha = searchPurchaseRes;
						}

						// Authenticate by an order or a subscription
						return auth(type, subject._id, options);
					},
					fail: function fail(err) {
						return Thunder.util.requestErrorHandler(err.responseJSON, {
							default: context.m('checkoutProcessFailed')
						}, function (err) {
							return checkoutFinished();
						});
					}
				};

				var persistTokenAndMakePayment = {
					run: function run(authResult) {

						if (authResult) {

							var _token = authResult.token;
							var storage = Thunder.plugins.credentialStorage;

							// Set auth token in the storage,
							// preferably in sessionStorage to take care of redirections from payment services.
							storage.setItem(Thunder.options.authStorage.order, _token);
						}

						return paymentHandler.makePayment({
							cart: context.cart,
							order: order,
							subscription: subscription,
							customer: customer
						}, function (err) {

							if (err) {

								checkoutFinished();

								return Thunder.execute(context.options.onPaymentFailure, $container, context, { order: order, subscription: subscription });
							}

							if (!subscription) {
								// Regular order case
								return checkoutFinished({ order: order, subscription: subscription });
							}

							var options = {
								data: card ? { card: card } : {}
							};

							// Subscription case, post schedules and finish.
							return scheduleSubscription(subscription._id, options).then(function () {

								return checkoutFinished({ order: order, subscription: subscription });
							}, function (err) {
								return Thunder.util.requestErrorHandler(err.responseJSON, {
									default: context.m('scheduleFailed')
								}, function (err) {
									return checkoutFinished();
								});
							});
						});
					}
				};

				var checkoutErrorHandler = function checkoutErrorHandler(err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, {
						default: context.m('checkoutFailed')
					}, function (err) {
						return checkoutFinished();
					});
				};

				// Checkout
				checkout(options).then(authByOrderOrSubscription.run, checkoutErrorHandler).then(persistTokenAndMakePayment.run, authByOrderOrSubscription.fail);
			}

			function buildCartOptions() {
				var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'calculate';


				var address = addressHandler.getAddress();
				var discount = couponHandler.getDiscountDetails();

				var options = {
					query: {},
					data: {}
				};

				// Filter items
				if (context.options.items) {
					options.query = { items: context.options.items.toString() };
				}

				// Set address
				if (address) {
					options.data.address = { shipping: address, billing: address };
				}

				// Set subscription details
				if (context.isSubscription) {

					var subscription = subscriptionHandler.getSubscriptionDetail();

					if (subscription && subscription.plan) {
						options.data.subscription = subscription;
					}
				}

				// Apply discount (coupons)
				if (Object.keys(discount).length) {
					options.data.discount = discount;
				}

				// Request options for checkout
				if (type === 'checkout') {
					options.data.currency = context.cart.currency.payment.code;
					options.data.paymentMethod = paymentHandler.getPaymentMethodId();
					options.data.request = $orderRequest.val() || null;
				}

				return options;
			}

			function searchAddress() {

				if (couponHandler.isApplying()) {
					return Thunder.notify('error', context.m('applyCouponsFirst'));
				}

				addressHandler.searchAddress(function (err) {

					return err ? Thunder.notify('error', err.message) : applyChanges();
				});
			}

			function applyCoupons(type) {

				if (context.isSubscription) {

					var detail = subscriptionHandler.getSubscriptionDetail();

					if (!detail || !detail.plan) {
						Thunder.notify('error', context.m('selectSubscriptionPlanFirst'));
						return false; // Block further executions
					}
				}

				if (type === 'end') {
					applyChanges();
				}

				return true;
			}

			function applySubscriptionDetail() {

				var detail = subscriptionHandler.getSubscriptionDetail();
				var error = subscriptionHandler.validateSubscriptionDetail(detail);

				if (error === 'subscriptionPlanRequired') {
					return Thunder.notify('error', context.m(error));
				}

				if (error === 'subscriptionStartsAtRequired') {
					return;
				}

				return applyChanges();
			}
		});
	};

	function getCart() {
		var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


		if (!Thunder.authenticated()) {
			set(options, 'data.items', Thunder.Cart.items);
		}

		return Thunder.request($.extend({
			method: 'POST',
			url: Thunder.authenticated() ? '/v1/me/cart' : '/v1/me/non-registered/cart'
		}, options));
	}

	function checkout() {
		var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


		var type = options.data.subscription ? 'subscription' : 'order';

		if (!Thunder.authenticated()) {
			set(options, 'data.items', Thunder.Cart.items);
		}

		return Thunder.request($.extend({
			method: 'POST',
			url: Thunder.authenticated() ? '/v1/me/cart/checkout/' + type : '/v1/me/non-registered/cart/checkout/' + type
		}, options));
	}

	function auth(type, id) {
		var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


		if (Thunder.authenticated()) {
			return null;
		}

		return Thunder.request($.extend({
			method: 'POST',
			url: type === 'order' ? '/v1/orders/' + id + '/auth' : '/v1/subscriptions/' + id + '/auth'
		}, options));
	}

	function scheduleSubscription(subscriptionId, options) {

		return Thunder.request($.extend({
			method: 'POST',
			url: '/v1/me/subscriptions/' + subscriptionId + '/scheduled'
		}, options));
	}

	return implementation;
};

},{"./lib/addressHandler.js":23,"./lib/couponHandler.js":24,"./lib/customerHandler.js":25,"./lib/recaptchaHandler.js":26,"./lib/subscriptionHandler.js":27,"lodash.camelcase":340,"lodash.get":341,"lodash.set":345}],23:[function(require,module,exports){
'use strict';

var get = require('lodash.get');
var set = require('lodash.set');
var camelCase = require('lodash.camelcase');

var AddressHandler = function AddressHandler(_ref) {
	var addressFields = _ref.addressFields,
	    translationKeys = _ref.translationKeys,
	    searchAddressPlugin = _ref.searchAddressPlugin;


	function reset() {
		var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';


		var fieldsToClear = type === 'recipient' ? addressFields.filter(function (_ref2) {
			var recipient = _ref2.recipient;
			return recipient;
		}) : addressFields;

		fieldsToClear.forEach(function (_ref3) {
			var $input = _ref3.$input;
			return $input.val(null);
		});
	}

	function getAddress() {

		return addressFields.reduce(function (o, _ref4) {
			var field = _ref4.field,
			    $input = _ref4.$input;


			return set(o, field, $input.val() || null);
		}, {});
	}

	function setAddress(address) {

		addressFields.forEach(function (_ref5) {
			var field = _ref5.field,
			    $input = _ref5.$input;


			var value = get(address, field);

			return value === undefined ? null : $input.val(value);
		});
	}

	function validateAddress(address) {
		var validateRecipient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


		var requireds = addressFields.filter(function (_ref6) {
			var required = _ref6.required;
			return required;
		}).filter(function (_ref7) {
			var recipient = _ref7.recipient;
			return validateRecipient ? true : !recipient;
		});

		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = requireds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var _ref8 = _step.value;
				var field = _ref8.field;


				if (get(address, field)) continue;

				var code = camelCase(['address', translationKeys[field] || field, 'required']);

				return code;
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		return null;
	}

	function searchAddress(callback) {

		searchAddressPlugin(function (err, address) {

			if (err) {
				return callback(err);
			}

			setAddress(address);

			return callback(null, address);
		});
	}

	return {
		reset: reset,
		getAddress: getAddress,
		setAddress: setAddress,
		validateAddress: validateAddress,
		searchAddress: searchAddress
	};
};

AddressHandler.defaultAddress = function () {
	return {
		name: {
			first: null,
			last: null,
			full: null
		},
		company: null,
		postcode: null,
		country: null,
		state: null,
		city: null,
		address1: null,
		address2: null,
		mobile: null,
		phone: null
	};
};

module.exports = AddressHandler;

},{"lodash.camelcase":340,"lodash.get":341,"lodash.set":345}],24:[function(require,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var get = require('lodash.get');
var set = require('lodash.set');

var CouponHandler = function CouponHandler(_ref) {
	var form = _ref.form,
	    _ref$labels = _ref.labels,
	    labels = _ref$labels === undefined ? {
		applyCoupons: '',
		finishApplyingCoupons: ''
	} : _ref$labels,
	    coupons = _ref.coupons,
	    _ref$cart = _ref.cart,
	    cart = _ref$cart === undefined ? function () {} : _ref$cart,
	    _ref$onCouponApply = _ref.onCouponApply,
	    onCouponApply = _ref$onCouponApply === undefined ? function (type) {
		return true;
	} : _ref$onCouponApply,
	    _ref$onCouponSelectEr = _ref.onCouponSelectError,
	    onCouponSelectError = _ref$onCouponSelectEr === undefined ? function (code) {} : _ref$onCouponSelectEr;


	var applying = false;

	var couponMap = coupons.reduce(function (o, c) {
		return set(o, c._id, c);
	}, {});

	var $applyCoupons = form.find('.thunder--apply-coupons');

	$applyCoupons.on('click', applyCoupons);

	bindCouponValidator();

	function isApplying() {
		return applying;
	}

	function getCoupon(couponId) {
		return couponMap[couponId];
	}

	function getCouponSelectors() {

		return form.find(['.thunder--cart-item-coupon', '.thunder--cart-coupon'].join(','));
	}

	function bindCouponValidator() {

		getCouponSelectors().on('change', validateCoupons);
	}

	function applyCoupons() {

		if (applying) {
			// Stop coupon selections
			if (!onCouponApply('end')) return;
			applying = false;
			$applyCoupons.text(labels.applyCoupons);
			getCouponSelectors().hide();
		} else {
			// Initialize coupon selections
			if (!onCouponApply('start')) return;
			applying = true;
			$applyCoupons.text(labels.finishApplyingCoupons);
			getCouponSelectors().show();
		}
	}

	function getDiscountDetails() {

		return getCouponSelectors().map(function () {

			var item = $(this).data('item') || null;
			var coupon = $(this).val();

			return { item: item, coupon: coupon };
		}).get().reduce(function (o, _ref2) {
			var item = _ref2.item,
			    coupon = _ref2.coupon;


			if (!coupon) return o;

			return item ? set(o, 'items', get(o, 'items', []).concat({ item: item, coupon: coupon })) : set(o, 'cart.coupon', coupon);
		}, {});
	}

	function validateCoupons() {

		var $selector = $(this);
		var itemId = $(this).data('item');
		var coupon = couponMap[$(this).val()];
		var item = cart().items.find(function (item) {
			return item._id === itemId;
		});

		if (!coupon || !item) return null;

		var code = null;

		// Duplicated discount applications
		if (coupon.only && item.discounts.length > 0) {
			code = 'alreadyDiscounted';
		}

		// Item's quantity must be 1 to apply a coupon
		if (item.quantity.raw !== 1) {
			code = 'mustBeOneQuantity';
		}

		// Duplicated coupon usage
		var selected = getCouponSelectors().map(function () {
			return $(this).is($selector) ? null : $(this).val();
		}).get().filter(function (v) {
			return v;
		});

		if (selected.indexOf(coupon._id) >= 0) {
			code = 'duplicatedCoupon';
		}

		if (code) {
			$selector.val('');
			return onCouponSelectError(code);
		}
	}

	return {
		isApplying: isApplying,
		getCoupon: getCoupon,
		bindCouponValidator: bindCouponValidator,
		getDiscountDetails: getDiscountDetails
	};
};

CouponHandler.setApplicableCoupons = function (orderType, cart, coupons) {

	// Filter only applicable coupons
	var applicableCoupons = coupons.filter(function (c) {
		var active = c.active,
		    expiresAt = c.expiresAt,
		    subscription = c.subscription;

		// Filter coupons where:
		// - A coupon is active
		// - A coupon is for a subscription and the view is for subscriptions
		// - A coupon is for an order and the view is for orders
		// - A coupon has no expiration dates
		// - A coupon has an expiration date and it is not passed yet

		return active && (orderType === 'subscription' && subscription.type || orderType === 'order' && !subscription.type) && (!expiresAt || new Date(expiresAt.raw).valueOf() > new Date().valueOf());
	});

	var productCoupons = applicableCoupons.filter(function (c) {
		return c.type === 'product';
	});
	var cartCoupons = applicableCoupons.filter(function (c) {
		return c.type === 'cart';
	});

	cart.items = cart.items.map(function (item) {

		item.applicableCoupons = productCoupons.filter(function (coupon) {

			return applicableByCategory(item, coupon.category) && applicableByPrice(item, coupon.price);
		});

		return item;
	});

	cart.applicableCoupons = cartCoupons;

	function applicableByCategory(item, category) {
		var _ref3;

		var brand = item.brand,
		    collections = item.collections,
		    product = item.product;


		if (category.type === 'any') {
			return true;
		}

		var subjectsToTest = {
			brands: [].concat(brand ? brand._id : []),
			collections: (_ref3 = []).concat.apply(_ref3, _toConsumableArray(collections.map(function (_ref4) {
				var path = _ref4.path;
				return path;
			}))).map(function (_ref5) {
				var _id = _ref5._id;
				return _id;
			}),
			products: [].concat(product ? product._id : [])
		};

		var categoryToTest = ['brands', 'collections', 'products'].find(function (c) {
			return category[c];
		});

		var toTest = subjectsToTest[categoryToTest];
		var pool = category[categoryToTest].map(function (_ref6) {
			var _id = _ref6._id;
			return _id;
		});

		if (category.type === 'include') {
			return pool.some(function (v) {
				return toTest.indexOf(v) >= 0;
			});
		}

		if (category.type === 'exclude') {
			return pool.every(function (v) {
				return toTest.indexOf(v) === -1;
			});
		}
	}

	function applicableByPrice(item, _ref7) {
		var min = _ref7.min,
		    max = _ref7.max;


		var price = item.variant.price.sale.raw;

		return (min === null || min.raw < price) && (max === null || max.raw > price);
	}
};

module.exports = CouponHandler;

},{"lodash.get":341,"lodash.set":345}],25:[function(require,module,exports){
'use strict';

var get = require('lodash.get');
var set = require('lodash.set');
var camelCase = require('lodash.camelcase');

module.exports = function (_ref) {
	var customerFields = _ref.customerFields,
	    translationKeys = _ref.translationKeys;


	function setCustomer(customer) {

		if (!customer) return;

		customerFields.forEach(function (_ref2) {
			var field = _ref2.field,
			    $input = _ref2.$input;


			$input.val(get(customer, field) || null);
		});
	}

	function getCustomer() {

		return customerFields.reduce(function (o, _ref3) {
			var field = _ref3.field,
			    $input = _ref3.$input;

			return set(o, field, $input.val() || null);
		}, {});
	}

	function validateCustomer(customer) {
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {

			for (var _iterator = customerFields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var _ref4 = _step.value;
				var field = _ref4.field;
				var required = _ref4.required;


				if (!required) continue;

				var value = get(customer, field);

				if (!value) {
					return camelCase(['customer', translationKeys[field] || field, 'required']);
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		return null;
	}

	return {
		setCustomer: setCustomer,
		getCustomer: getCustomer,
		validateCustomer: validateCustomer
	};
};

},{"lodash.camelcase":340,"lodash.get":341,"lodash.set":345}],26:[function(require,module,exports){
'use strict';

var set = require('lodash.set');

module.exports = function (requiredResponse) {

	var handler = {
		counter: 0,
		token: [],
		requiredResponse: requiredResponse
	};

	handler.execute = function (token) {

		var requiredComponents = Object.keys(handler.requiredResponse);
		var requiredLength = requiredComponents.length;

		if (requiredLength === 0) {
			// If a number of required responses is 0,
			// simply return an empty object.
			return {};
		}

		handler.token = handler.token.concat(token).filter(function (token) {
			return token;
		});

		if (++handler.counter === 2 && requiredLength === handler.token.length) {

			var result = requiredComponents.reduce(function (o, c, i) {
				return set(o, c, handler.token[i]);
			}, {});

			handler.reset();

			return result;
		} else {

			return null;
		}
	};

	handler.reset = function () {
		handler.counter = 0;
		handler.token = [];
	};

	return handler;
};

},{"lodash.set":345}],27:[function(require,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var set = require('lodash.set');

module.exports = function (_ref) {
	var form = _ref.form,
	    labels = _ref.labels,
	    subscriptionPlans = _ref.subscriptionPlans,
	    _ref$timezone = _ref.timezone,
	    timezone = _ref$timezone === undefined ? function () {
		return 'UTC';
	} : _ref$timezone,
	    _ref$onPlanChange = _ref.onPlanChange,
	    onPlanChange = _ref$onPlanChange === undefined ? function () {} : _ref$onPlanChange,
	    _ref$onStartsAtChange = _ref.onStartsAtChange,
	    onStartsAtChange = _ref$onStartsAtChange === undefined ? function () {} : _ref$onStartsAtChange;


	var $plan = form.find('[name="subscriptionPlan"]');
	var $startsAtSection = form.find('.thunder--subscription-starts-at');
	var $startsAtLabel = $startsAtSection.find('label');
	var $startsAt = $startsAtSection.find('[name="subscriptionStartsAt"]');
	var $immediateTip = $('.first-order-is-immediate');

	var datepicker = $startsAt.data('pickaday');

	var subscriptionPlanMap = subscriptionPlans.reduce(function (o, plan) {
		return set(o, plan._id, plan);
	}, {});

	subscriptionPlanChanged();

	if (datepicker) {
		// Set datepicker's min date as tomorrow (24 hours later)
		datepicker.setMinDate(new Date(new Date().valueOf() + 1000 * 3600 * 24));
	}

	$plan.on('change', function () {
		subscriptionPlanChanged();
		return onPlanChange();
	});

	$startsAt.on('change', function () {
		return onStartsAtChange();
	});

	function getSubscriptionPlan(subscriptionPlanId) {
		return subscriptionPlanMap[subscriptionPlanId];
	}

	function validateSubscriptionDetail(subscription) {

		if (!subscription || !subscription.plan) {
			return 'subscriptionPlanRequired';
		}

		var plan = subscriptionPlanMap[subscription.plan];

		if (plan.startsAt && !subscription.startsAt) {
			return 'subscriptionStartsAtRequired';
		}
	}

	function getSubscriptionDetail() {

		var plan = subscriptionPlanMap[$plan.val()];

		if (!plan) return null;

		var detail = {
			plan: plan._id,
			timezone: timezone()
		};

		var startsAt =
		// If `plan.startsAt` is a function, simply invoke and get the time value.
		typeof plan.startsAt === 'function' && plan.startsAt(plan) ||
		// If `plan.startsAt` is a 'datepicker', get the time value from datepicker.
		plan.startsAt === 'datepicker' && $startsAt.data('pickaday').getDate() || null;

		if (startsAt) {

			// Set order schedules' times (default = 09:00)
			startsAt.setHours.apply(startsAt, _toConsumableArray((plan.time || '09:00').split(':').map(function (v) {
				return parseInt(v);
			}).concat(0, 0, 0)));

			detail.startsAt = startsAt;
		}

		return detail;
	}

	function subscriptionPlanChanged() {

		var plan = subscriptionPlanMap[$plan.val()];

		if (!plan) return;

		if (plan.startsAt === 'datepicker') {
			$startsAtSection.show();
		} else {
			$startsAtSection.hide();
		}

		if (plan.immediate) {
			$immediateTip.show();
			$startsAtLabel.text(labels.secondOrderStartsAt);
		} else {
			$immediateTip.hide();
			$startsAtLabel.text(labels.firstOrderStartsAt);
		}

		$startsAt.val('');
		datepicker.setDate(null);
	}

	return {
		getSubscriptionPlan: getSubscriptionPlan,
		validateSubscriptionDetail: validateSubscriptionDetail,
		getSubscriptionDetail: getSubscriptionDetail,
		subscriptionPlanChanged: subscriptionPlanChanged
	};
};

},{"lodash.set":345}],28:[function(require,module,exports){
'use strict';

module.exports = function (Thunder) {

	var implementation = {
		name: 'customer-coupons'
	};

	implementation.options = function () {
		return {
			page: 1,
			limit: 24,
			usePagination: true,
			confirmOnDelete: Thunder.options.confirmation.couponDelete, // Whether to confirm before deleting a coupon

			onDelete: function onDelete($container, context) {

				return Thunder.notify('success', context.m('deleteSuccess'));
			}
		};
	};

	implementation.pre = function (context, callback) {

		context.couponListId = (Math.random() + '').slice(2);

		context.categories = function (coupon) {
			return (coupon.category.products || coupon.category.brands || coupon.category.collections).map(function (m) {
				return m.name;
			}).join(', ');
		};

		var errors = {
			default: context.m('couponListFailed')
		};

		$.when(Thunder.request({
			method: 'GET',
			url: '/v1/me/coupons',
			query: {
				page: context.options.page,
				limit: context.options.limit
			}
		}), context.options.usePagination ? Thunder.request({
			method: 'GET',
			url: '/v1/me/coupons/count',
			query: { raw: true }
		}) : null).then(function (coupons, count) {

			context.coupons = coupons[0];
			context.count = count ? count[0].count : null;

			return callback(null, context);
		}, function (err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
		});
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $pagination = $(this).find('.thunder--customer-coupon-list-pagination');
		var $deleteCoupon = $(this).find('.thunder--delete-coupon');

		$deleteCoupon.on('click', deleteCoupon);

		if (context.options.usePagination) {

			Thunder.plugins.pagination({
				container: $pagination,
				currentPage: context.options.page,
				totalResult: context.count,
				resultPerPage: context.options.limit,
				onPageChange: function onPageChange(_ref) {
					var page = _ref.page;
					return Thunder.render($container, 'customer-coupons', $.extend(context.options, { page: page }));
				}
			});
		}

		function deleteCoupon() {
			var _this = this;

			var removeCoupon = function removeCoupon() {

				var spinner = Thunder.util.makeAsyncButton($(_this), { bind: false });

				spinner.run();

				var couponId = $(_this).data('coupon');
				var $coupon = $container.find('[data-coupon="' + couponId + '"]');

				var errors = {
					default: context.m('couponDeleteFailed')
				};

				Thunder.request({
					method: 'DELETE',
					url: '/v1/me/coupons/' + couponId
				}).then(function () {

					spinner.done();
					$coupon.remove();
					$container.find('[data-mh]').matchHeight();

					return Thunder.execute(context.options.onDelete, $container, context);
				}, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors, function (err) {
						return spinner.done();
					});
				});
			};

			if (!context.options.confirmOnDelete) {
				return removeCoupon();
			}

			return Thunder.plugins.confirmation(context.m('deleteConfirm'), function () {
				return removeCoupon();
			});
		}
	};

	return implementation;
};

},{}],29:[function(require,module,exports){
'use strict';

var set = require('lodash.set');
var camelCase = require('lodash.camelcase');

module.exports = function (Thunder) {

	var supportedComponents = function supportedComponents() {
		return ['customer-update', 'customer-update-address', 'order-list', Thunder.options.paymentMethods.subscription ? 'subscription-list' : null, 'customer-coupons', Thunder.options.productReview ? 'customer-reviews' : null, Thunder.options.productReview && Thunder.options.productReviewComment ? 'customer-review-comments' : null, 'customer-delete-account'].filter(function (v) {
			return v;
		});
	};

	// Implementation
	var implementation = {
		name: 'customer-dashboard'
	};

	implementation.options = function () {
		return $.extend({
			nav: supportedComponents(), // Navigation components
			focus: supportedComponents()[0], // Initial component to be focused
			logout: Thunder.options.customerDashboardLogout

		}, supportedComponents().reduce(function (o, component) {

			return set(o, camelCase(['onView', component]), function ($container, context, $viewContainer) {
				return Thunder.render($viewContainer, component);
			});
		}, {}));
	};

	implementation.pre = function (context, callback) {

		var translationKeys = {
			'customer-update': 'customerInfo',
			'customer-update-address': 'customerAddress',
			'order-list': 'orderList',
			'subscription-list': 'subscriptionList',
			'customer-coupons': 'customerCoupons',
			'customer-reviews': 'customerReviews',
			'customer-review-comments': 'customerReviewComments',
			'customer-delete-account': 'customerDeleteAccount'
		};

		context.nav = Thunder.util.parseArrayString(context.options.nav).map(function (component) {
			return {
				key: component,
				translationKey: translationKeys[component]
			};
		});

		return callback(null, context);
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $menu = $(this).find('[data-component]');
		var $viewContainer = $(this).find('.thunder--customer-dashboard-view');
		var $logoutWrap = $(this).find('.thunder--logout-wrap');
		var $logout = $(this).find('.thunder--logout');

		viewComponent(context.options.focus);

		$menu.on('click', function () {
			return viewComponent($(this).data('component'));
		});

		function viewComponent(component) {

			$logoutWrap[component === 'customer-update' ? 'removeClass' : 'addClass']('hidden');

			$menu.removeClass('active');
			$container.find('[data-component="' + component + '"]').addClass('active');

			return Thunder.execute(context.options[camelCase(['onView', component])], $container, context, $viewContainer);
		}

		$logout.on('click', function () {
			Thunder.logout();
			Thunder.close();
		});
	};

	return implementation;
};

},{"lodash.camelcase":340,"lodash.set":345}],30:[function(require,module,exports){
'use strict';

module.exports = function (Thunder) {

	var implementation = {
		name: 'customer-delete-account'
	};

	implementation.options = function () {
		return {

			confirmOnDelete: Thunder.options.confirmation.customerDelete, // Whether to confirm before deleting

			onDelete: function onDelete($container, context) {

				Thunder.notify('success', context.m('deleteSuccess'));

				Thunder.plugins.redirect(Thunder.options.root);
			}

		};
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $form = $(this).find('.thunder--customer-delete-account-form');
		var $button = $form.find('.thunder--delete-account');
		var buttonSpinner = Thunder.util.makeAsyncButton($button);

		$button.on('click', function (event) {

			event.preventDefault();

			if (!context.options.confirmOnDelete) {
				return deleteCustomer();
			}

			return Thunder.plugins.confirmation(context.m('deleteConfirm'), function () {
				return deleteCustomer();
			}, function () {
				return buttonSpinner.done();
			});
		});

		function deleteCustomer() {

			var errors = {
				default: context.m('deleteFailed')
			};

			Thunder.request({
				method: 'DELETE',
				url: '/v1/me'
			}).then(function () {

				buttonSpinner.done();

				Thunder.logout();

				Thunder.execute(context.options.onDelete, $container, context);
			}, function (err) {
				return Thunder.util.requestErrorHandler(err.responseJSON, errors, function (err) {
					return buttonSpinner.done();
				});
			});
		}
	};

	return implementation;
};

},{}],31:[function(require,module,exports){
'use strict';

module.exports = function (Thunder) {

	var implementation = {
		name: 'customer-login'
	};

	implementation.options = function () {
		return {

			socialApps: Thunder.options.socialApps,

			onLogin: function onLogin($container, context) {

				Thunder.notify('success', context.m('loginSuccess'));

				Thunder.plugins.redirect(Thunder.options.root);
			},

			onSocialLogin: function onSocialLogin($container, context, data) {

				Thunder.notify('success', context.m('loginSuccess'));

				Thunder.plugins.redirect(Thunder.options.root);
			}

		};
	};

	implementation.pre = function (context, callback) {

		context.social = function () {
			return Thunder.uis['social-login']({
				type: 'login',
				vendors: context.options.socialApps
			});
		};

		return callback(null, context);
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $form = $(this).find('.thunder--login-form');
		var $button = $form.find('.thunder--login-customer');
		var $goToResetPassword = $(this).find('.thunder--go-to-reset-password');
		var buttonSpinner = Thunder.util.makeAsyncButton($button);

		Thunder.util.bindSocialApps($container);

		var socialData = Thunder.util.handleSocialLogin();

		if (socialData) {

			Thunder.execute(context.options.onSocialLogin, $container, context, socialData);
		}

		$goToResetPassword.on('click', function () {
			return Thunder.render($container, 'customer-reset-password', {
				back: {
					$container: $container,
					component: implementation.name,
					options: context.options
				}
			});
		});

		Thunder.util.makeRecaptcha(implementation.name, $button, function (token, resetRecaptcha) {

			var data = Thunder.util.userIdOrEmail(Thunder.util.formToJSON($form.serializeArray()));

			var resetState = function resetState() {
				buttonSpinner.done();
				return resetRecaptcha && resetRecaptcha();
			};

			var errors = {
				'not-existing-customer': context.m('notExistingCustomer'),
				'invalid-password': context.m('invalidPassword'),
				default: context.m('loginFailed')
			};

			Thunder.request({
				method: 'POST',
				url: '/v1/customers/auth',
				data: data
			}).then(function (data) {

				var storage = Thunder.plugins.credentialStorage;

				storage.setItem(Thunder.options.authStorage.customer, data.token);

				Thunder.header();

				Thunder.execute(context.options.onLogin, $container, context);

				return resetState();
			}, function (err) {
				return Thunder.util.requestErrorHandler(err.responseJSON, errors, function () {
					return resetState();
				});
			});
		});
	};

	return implementation;
};

},{}],32:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

var get = require('lodash.get');
var camelCase = require('lodash.camelcase');

module.exports = function (Thunder) {

	var translationKey = {
		'name.first': 'firstName',
		'name.last': 'lastName',
		'name.full': 'fullName'
	};

	// Implementation
	var implementation = {
		name: 'customer-register'
	};

	implementation.options = function () {
		return {

			fields: Thunder.options.customerRegistrationFields,
			birthdateFormat: Thunder.options.dateInputFormat,
			socialApps: Thunder.options.socialApps,
			termsLink: Thunder.options.legal.registrationTerms.link,
			termsText: Thunder.options.legal.registrationTerms.text,
			privacyLink: Thunder.options.legal.registrationPrivacy.link,
			privacyText: Thunder.options.legal.registrationPrivacy.text,

			onRegister: function onRegister($container, context, customer) {

				Thunder.notify('success', context.m('registerSuccess'));

				Thunder.render($container, 'customer-login');
			},
			onSocialRegister: function onSocialRegister($container, context, data) {

				if (data.error) {
					if (data.error === 'duplicated-email') {
						return Thunder.notify('error', context.m('duplicatedEmail'));
					}
				}

				Thunder.notify('success', context.m('registerSuccess'));

				Thunder.plugins.redirect(Thunder.options.root);
			}

		};
	};

	implementation.pre = function (context, callback) {
		var _context$options = context.options,
		    termsLink = _context$options.termsLink,
		    termsText = _context$options.termsText,
		    privacyLink = _context$options.privacyLink,
		    privacyText = _context$options.privacyText;


		context.agreements = [termsLink || termsText ? 'terms' : null, privacyLink || privacyText ? 'privacy' : null].filter(function (v) {
			return v;
		});

		var birthOptions = {
			YYYY: { key: 'birthYear', translationKey: 'year', tester: /^\d{4}$/ },
			MM: { key: 'birthMonth', translationKey: 'month', tester: /^\d{1,2}$/ },
			DD: { key: 'birthDate', translationKey: 'date', tester: /^\d{1,2}$/ }
		};

		var birthdateFormats = context.options.birthdateFormat.split('-');

		context.fields = Thunder.util.parseArrayString(context.options.fields).map(function (field) {
			var _field$split = field.split(':'),
			    _field$split2 = _slicedToArray(_field$split, 2),
			    key = _field$split2[0],
			    required = _field$split2[1];

			return {
				required: required === 'required',
				key: key,
				translationKey: translationKey[key] || key
			};
		});

		context.birthdateFields = birthdateFormats.map(function (format, i) {

			return $.extend({
				last: i === birthdateFormats.length - 1
			}, birthOptions[format]);
		});

		context.social = function () {
			return Thunder.uis['social-login']({
				type: 'register',
				vendors: context.options.socialApps
			});
		};

		return callback(null, context);
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $form = $(this).find('.thunder--register-form');
		var $button = $form.find('.thunder--register-customer');
		var buttonSpinner = Thunder.util.makeAsyncButton($button, { bind: false });

		var areTermsAgreed = Thunder.util.bindAgreements({
			$terms: $(this).find('[data-agreement-scope]'),
			agreements: {
				terms: {
					text: context.options.termsText,
					link: context.options.termsLink,
					error: context.m('termsAgreementRequired')
				},
				privacy: {
					text: context.options.privacyText,
					link: context.options.privacyLink,
					error: context.m('privacyAgreementRequired')
				}
			}
		});

		Thunder.util.bindSocialApps($container, areTermsAgreed);

		var socialData = Thunder.util.handleSocialLogin();

		if (socialData) {

			Thunder.execute(context.options.onSocialRegister, $container, context, socialData);
		}

		Thunder.util.makeRecaptcha({
			componentName: implementation.name,
			button: $button,
			validate: validateData,
			callback: function callback(token, resetRecaptcha) {

				buttonSpinner.run();

				var resetState = function resetState() {
					buttonSpinner.done();
					return resetRecaptcha && resetRecaptcha();
				};

				var success = function success(customer) {

					Thunder.execute(context.options.onRegister, $container, context, customer);

					return resetState();
				};

				var fail = function fail(err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, {
						'duplicated-email': context.m('duplicatedEmail'),
						'duplicated-user-id': context.m('duplicatedUserId'),
						default: context.m('registerFailed'),
						validation: function validation(err) {
							var _err$validation$sourc = err.validation.source.split('.'),
							    _err$validation$sourc2 = _toArray(_err$validation$sourc),
							    path = _err$validation$sourc2.slice(1);

							var field = path.join('.');

							return context.m(camelCase(['invalid', translationKey[field] || field]));
						}
					}, function (err) {
						return resetState();
					});
				};

				return Thunder.request({
					method: 'POST',
					url: '/v1/me',
					data: getCustomer()
				}).then(success, fail);
			}

		});

		function getCustomer() {

			var birthFields = ['birthYear', 'birthMonth', 'birthDate'];

			var data = Thunder.util.formToJSON($form.serializeArray());

			if (birthFields.every(function (field) {
				return data[field];
			})) {

				data.birthdate = new Date(data.birthYear, data.birthMonth - 1, data.birthDate);
			}

			birthFields.forEach(function (field) {
				return delete data[field];
			});

			return data;
		}

		function validateData() {

			var customer = getCustomer();

			var requiredFields = context.fields.filter(function (_ref) {
				var required = _ref.required;
				return required;
			});

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = requiredFields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var _ref2 = _step.value;
					var key = _ref2.key;
					var _translationKey = _ref2.translationKey;


					if (!get(customer, key, null)) {
						Thunder.notify('error', context.m(_translationKey + 'Required'));
						return false;
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return areTermsAgreed();
		}
	};

	return implementation;
};

},{"lodash.camelcase":340,"lodash.get":341}],33:[function(require,module,exports){
'use strict';

module.exports = function (Thunder) {

	var implementation = {
		name: 'customer-reset-password'
	};

	implementation.options = function () {
		return {
			customer: 'customer',
			secret: 'secret',
			input: 'query', // 'query' or 'attribute'
			expiresIn: 60 * 60 * 24, // 24 hours
			onEmailRequest: function onEmailRequest($container, context) {

				Thunder.notify('success', context.m('requestEmailSuccess'));
			},
			onPasswordReset: function onPasswordReset($container, context) {

				Thunder.notify('success', context.m('setPasswordSuccess'));

				Thunder.render($container, 'customer-login');
			}
		};
	};

	implementation.pre = function (context, callback) {

		if (context.options.input === 'query') {

			var query = Thunder.util.urlQuery();
			var customerField = context.options.customer;
			var secretField = context.options.secret;

			if (query[customerField] && query[secretField]) {

				context.customer = query[customerField];
				context.secret = query[secretField];
			}
		}

		if (context.options.input === 'attribute') {

			context.customer = context.options.customer;
			context.secret = context.options.secret;
		}

		context.type = context.customer && context.secret ? 'reset-password' : 'request-email';

		return callback(null, context);
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $form = $(this).find('.thunder--reset-password-form');

		if (context.type === 'request-email') {

			var $requestEmail = $form.find('.thunder--request-email');
			var $goToCustomerLogin = $(this).find('.thunder--go-to-customer-login');
			var requestEmailSpinner = Thunder.util.makeAsyncButton($requestEmail);

			Thunder.util.bindBackButton($goToCustomerLogin, context);

			Thunder.util.makeRecaptcha(implementation.name, $requestEmail, function (token, resetRecaptcha) {

				var data = $.extend(Thunder.util.userIdOrEmail(Thunder.util.formToJSON($form.serializeArray())), {
					expiresIn: context.options.expiresIn,
					scope: 'reset-password'
				});

				var resetState = function resetState() {
					requestEmailSpinner.done();
					return resetRecaptcha && resetRecaptcha();
				};

				var errors = {
					'not-existing-customer': context.m('notExistingCustomer'),
					'email-required': context.m('customerWithoutEmail'),
					default: context.m('requestEmailFailed')
				};

				Thunder.request({
					method: 'POST',
					url: '/v1/customers/verifications/emails',
					data: data
				}).then(function () {

					Thunder.execute(context.options.onEmailRequest, $container, context);

					return resetState();
				}, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors, function (err) {
						return resetState();
					});
				});
			});
		}

		if (context.type === 'reset-password') {

			var $resetPassword = $form.find('.thunder--reset-password');
			var resetPasswordSpinner = Thunder.util.makeAsyncButton($resetPassword);

			Thunder.util.makeRecaptcha(implementation.name, $resetPassword, function (token, resetRecaptcha) {

				var data = $.extend(Thunder.util.formToJSON($form.serializeArray()), {
					secret: context.secret
				});

				var resetState = function resetState() {
					resetPasswordSpinner.done();
					return resetRecaptcha && resetRecaptcha();
				};

				var errors = {
					default: context.m('setPasswordFailed')
				};

				Thunder.request({
					method: 'PUT',
					url: '/v1/customers/' + context.customer + '/password',
					data: data,
					recaptcha: token
				}).then(function () {

					Thunder.execute(context.options.onPasswordReset, $container, context);

					return resetState();
				}, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors, function (err) {
						return resetState();
					});
				});
			});
		}
	};

	return implementation;
};

},{}],34:[function(require,module,exports){
'use strict';

var productReview = require('../product-review');

module.exports = function (Thunder) {

	var productReviewInstance = productReview(Thunder);

	var implementation = {
		name: 'customer-review-comment'
	};

	// Other options will be exactly same as `product-review` component
	implementation.options = function () {
		return $.extend(productReviewInstance.options(), {
			comment: null, // Comment ID
			showProduct: true,
			showComments: {
				filter: null,
				useBodyExcerpt: false,
				useFlag: false,
				usePagination: false
			}
		});
	};

	implementation.pre = function (context, callback) {

		return callback(null, context);
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $backToComments = $(this).find('.thunder--back-to-comments');
		var $reviewContainer = $(this).find('.thunder--customer-review-comment-container');

		Thunder.util.bindBackButton($backToComments, context);

		if (context.options.showComments) {
			context.options.showComments.filter = { ids: context.options.comment };
		}

		Thunder.render($reviewContainer, 'product-review', context.options);
	};

	return implementation;
};

},{"../product-review":51}],35:[function(require,module,exports){
'use strict';

var set = require('lodash.set');

module.exports = function (Thunder) {

	var implementation = {
		name: 'customer-review-comments'
	};

	implementation.options = function () {
		return {
			page: 1, // Which page of comments?
			limit: 10, // How many comments at once?
			sort: '-createdAt', // Default sort value
			usePagination: true, // Use Pagination?

			onViewComment: function onViewComment($container, context, reviewId, commentId) {

				return Thunder.render($container, 'customer-review-comment', {
					review: reviewId,
					comment: commentId,
					back: {
						$container: $container,
						component: implementation.name,
						options: context.options
					}
				});
			}
		};
	};

	implementation.pre = function (context, callback) {

		var customer = Thunder.authenticated('customer').sub;

		var errors = {
			default: context.m('commentListFailed')
		};

		return $.when(fetchComments(), countComments()).then(function (comments, count) {
			return callback(null, $.extend(context, {
				comments: comments[0] || [],
				count: count ? count[0].count : null
			}));
		}, function (err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
		});

		function fetchComments() {

			return Thunder.request({
				method: 'GET',
				url: '/v1/products/reviews/comments',
				query: {
					customer: customer,
					page: context.options.page,
					limit: context.options.limit,
					sort: context.options.sort,
					fields: ['review', 'customer', 'body', 'createdAt'].join(',')
				}
			});
		}

		function countComments() {

			return Thunder.request({
				method: 'GET',
				url: '/v1/products/reviews/comments/count',
				query: {
					customer: customer
				}
			});
		}
	};

	implementation.init = function (context) {

		var commentMap = context.comments.reduce(function (o, comment) {
			return set(o, comment._id, comment);
		}, {});

		var $container = $(this);
		var $viewComment = $(this).find(['.thunder--customer-review-comment-body', '.thunder--view-comment'].join(','));
		var $pagination = $(this).find('.thunder--customer-review-comment-list-pagination');

		$viewComment.on('click', function (event) {

			event.preventDefault();

			var commentId = $(this).parents('[data-comment]').data('comment');
			var comment = commentMap[commentId];

			return Thunder.execute(context.options.onViewComment, $container, context, comment.review._id, comment._id);
		});

		if (context.options.usePagination) {

			Thunder.plugins.pagination({
				container: $pagination,
				currentPage: context.options.page,
				totalResult: context.count.raw,
				resultPerPage: context.options.limit,
				onPageChange: function onPageChange(_ref) {
					var page = _ref.page;
					return Thunder.render($container, implementation.name, $.extend(context.options, { page: page }));
				}
			});
		}
	};

	return implementation;
};

},{"lodash.set":345}],36:[function(require,module,exports){
'use strict';

var productReview = require('../product-review');

module.exports = function (Thunder) {

	var implementation = {
		name: 'customer-review'
	};

	// All options are exactly same as `product-review` component
	implementation.options = function () {
		return $.extend(productReview(Thunder).options(), {
			useBodyExcerpt: false,
			useFlag: false,
			showProduct: true,
			showComments: true
		});
	};

	implementation.pre = function (context, callback) {

		return callback(null, context);
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $backToReviews = $(this).find('.thunder--back-to-reviews');
		var $reviewContainer = $(this).find('.thunder--customer-review-container');

		Thunder.util.bindBackButton($backToReviews, context);

		Thunder.render($reviewContainer, 'product-review', context.options);
	};

	return implementation;
};

},{"../product-review":51}],37:[function(require,module,exports){
'use strict';

module.exports = function (Thunder) {

	var implementation = {
		name: 'customer-reviews'
	};

	implementation.options = function () {
		return {
			page: 1, // Which page of reviews?
			limit: 12, // How many reviews at once?
			sort: '-createdAt', // Default sort value
			useRating: Thunder.options.productReviewRating, // Use rating?
			useComments: Thunder.options.productReviewComment, // Use review comments?
			useHelpVote: true, // Use helpful votes?
			usePagination: true, // Use Pagination?

			onViewReview: function onViewReview($container, context, reviewId) {

				return Thunder.render($container, 'customer-review', {
					review: reviewId,
					useRating: context.options.useRating,
					useHelpVote: context.options.useHelpVote,
					useComments: context.options.useComments,
					back: {
						$container: $container,
						component: implementation.name,
						options: context.options
					}
				});
			}
		};
	};

	implementation.pre = function (context, callback) {

		var customer = Thunder.authenticated('customer').sub;

		var errors = {
			default: context.m('reviewListFailed')
		};

		return $.when(fetchReviews(), countReviews()).then(function (reviews, count) {
			return callback(null, $.extend(context, {
				reviews: reviews[0] || [],
				count: count ? count[0].count : null
			}));
		}, function (err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
		});

		function fetchReviews() {

			return Thunder.request({
				method: 'GET',
				url: '/v1/products/reviews/published',
				query: {
					customer: customer,
					page: context.options.page,
					limit: context.options.limit,
					sort: context.options.sort,
					fields: ['product', 'title', 'images', 'rating', 'helped', 'totalComment', 'createdAt'].join(','),
					embed: '+product.thumbnail'
				}
			});
		}

		function countReviews() {

			return Thunder.request({
				method: 'GET',
				url: '/v1/products/reviews/published/count',
				query: {
					customer: customer
				}
			});
		}
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $viewReview = $(this).find('.thunder--view-review');
		var $pagination = $(this).find('.thunder--customer-review-list-pagination');

		$viewReview.on('click', function (event) {

			event.preventDefault();

			var reviewId = $(this).parents('[data-review]').data('review');

			return Thunder.execute(context.options.onViewReview, $container, context, reviewId);
		});

		if (context.options.usePagination) {

			Thunder.plugins.pagination({
				container: $pagination,
				currentPage: context.options.page,
				totalResult: context.count.raw,
				resultPerPage: context.options.limit,
				onPageChange: function onPageChange(_ref) {
					var page = _ref.page;
					return Thunder.render($container, implementation.name, $.extend(context.options, { page: page }));
				}
			});
		}
	};

	return implementation;
};

},{}],38:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var get = require('lodash.get');
var set = require('lodash.set');
var camelCase = require('lodash.camelcase');

module.exports = function (Thunder) {

	var translationKey = {
		'name.first': 'firstName',
		'name.last': 'lastName',
		'name.full': 'fullName'
	};

	// Implementation
	var implementation = {
		name: 'customer-update-address'
	};

	implementation.options = function () {
		return {

			recipientFields: Thunder.options.recipientFields,
			addressDisabled: Thunder.options.addressDisabled,

			onUpdate: function onUpdate($container, context) {

				Thunder.notify('success', context.m('updateSuccess'));
			}

		};
	};

	implementation.pre = function (context, callback) {

		var disabledAddressFields = Thunder.util.parseArrayString(context.options.addressDisabled).reduce(function (o, field) {
			return set(o, field, true);
		}, {});

		context.useSearchAddress = !!Thunder.plugins.searchAddress;

		context.disabled = function (field) {
			return disabledAddressFields[field] && context.useSearchAddress ? 'readonly' : '';
		};

		context.recipientFields = Thunder.util.parseArrayString(context.options.recipientFields).map(function (field) {
			var _field$split = field.split(':'),
			    _field$split2 = _slicedToArray(_field$split, 2),
			    key = _field$split2[0],
			    required = _field$split2[1];

			return {
				required: required === 'required',
				key: key,
				translationKey: translationKey[key] || key
			};
		});

		context.addressFields = [{ required: true, key: 'country', translationKey: 'country' }, { required: false, key: 'state', translationKey: 'state' }, { required: true, key: 'city', translationKey: 'city' }, { required: true, key: 'address1', translationKey: 'address1' }, { required: false, key: 'address2', translationKey: 'address2' }, { required: true, key: 'postcode', translationKey: 'postcode' }];

		var errors = {
			default: context.m('customerReadFailed')
		};

		$.when(Thunder.request({
			method: 'GET',
			url: '/v1/countries',
			query: { fields: 'code', limit: 120, page: 1 }
		}), Thunder.request({
			method: 'GET',
			url: '/v1/countries',
			query: { fields: 'code', limit: 120, page: 2 }
		}), Thunder.request({
			method: 'GET',
			url: '/v1/countries',
			query: { fields: 'code', limit: 120, page: 3 }
		}), Thunder.request({
			method: 'GET',
			url: '/v1/me',
			query: { fields: 'address' }
		})).then(function (countries1, countries2, countries3, customer) {

			context.countries = [].concat(countries1[0], countries2[0], countries3[0]);

			context.address = customer[0].address.primary || { name: {} };

			return callback(null, context);
		}, function (err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
		});
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $form = $(this).find('.thunder--customer-address-update-form');
		var $button = $form.find('.thunder--update-address');
		var $searchAddress = $(this).find('.thunder--search-address');
		var $disabledAddressInputs = $(this).find('.thunder--address-location div [readonly]').parent();

		var buttonSpinner = Thunder.util.makeAsyncButton($button, { bind: false });

		var recipientFields = context.recipientFields.map(function (f) {
			return f.key;
		});
		var addressFields = context.addressFields.map(function (f) {
			return f.key;
		});
		var allFieldsMap = [].concat(_toConsumableArray(recipientFields), _toConsumableArray(addressFields)).reduce(function (o, field) {
			return set(o, [field], true);
		}, {});

		var $fields = [].concat(recipientFields, addressFields).reduce(function (o, key) {
			return set(o, [key], $form.find('[name="' + key + '"]'));
		}, {});

		addressToForm(context.address);

		$searchAddress.on('click', searchAddress);
		$disabledAddressInputs.on('click', searchAddress);

		Thunder.util.makeRecaptcha({
			componentName: implementation.name,
			button: $button,
			validate: validateAddress,
			callback: function callback(token, resetRecaptcha) {

				buttonSpinner.run();

				var primaryAddress = Thunder.util.formToJSON($form.serializeArray());
				var recaptcha = Thunder.util.unsetRecaptcha(primaryAddress);

				var data = { address: { primary: primaryAddress } };

				var resetState = function resetState() {
					buttonSpinner.done();
					return resetRecaptcha && resetRecaptcha();
				};

				var errors = {
					'invalid-postcode': context.m('invalidPostcode'),
					'postcode-required': context.m('postcodeRequired'),
					default: context.m('updateFailed'),
					validation: function validation(err) {
						var _err$validation$sourc = err.validation.source.split('address.primary.'),
						    _err$validation$sourc2 = _slicedToArray(_err$validation$sourc, 2),
						    field = _err$validation$sourc2[1];

						if (!field || !allFieldsMap[field]) return;

						return context.m(camelCase(['invalid', translationKey[field] || field]));
					}
				};

				return Thunder.request({
					method: 'PUT',
					url: '/v1/me',
					data: data,
					recaptcha: recaptcha
				}).then(function (data) {

					var address = get(data, 'address.primary');

					addressToForm(address);

					Thunder.execute(context.options.onUpdate, $container, context, address);

					return resetState();
				}, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors, function (err) {
						return resetState();
					});
				});
			}
		});

		function validateAddress() {

			var address = Thunder.util.formToJSON($form.serializeArray());

			var requiredFields = [].concat(context.recipientFields, context.addressFields).filter(function (f) {
				return f.required;
			}).map(function (f) {
				return f.key;
			});

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = requiredFields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var field = _step.value;


					if (!get(address, field, null)) {
						Thunder.notify('error', context.m((translationKey[field] || field) + 'Required'));
						return false;
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return true;
		}

		function addressToForm(address) {
			var onlyAddressFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


			if (!address) return;

			var fields = onlyAddressFields ? addressFields : [].concat(recipientFields, addressFields);

			fields.forEach(function (field) {

				var value = field === 'country' ? get(address, field + '.code', get(address, field, null)) : get(address, field, null);

				$fields[field].val(value);
			});
		}

		function searchAddress(event) {

			event.preventDefault();

			Thunder.plugins.searchAddress(function (err, address) {

				if (err) {
					return Thunder.notify('error', err.message);
				}

				addressToForm(address, true);
			});
		}
	};

	return implementation;
};

},{"lodash.camelcase":340,"lodash.get":341,"lodash.set":345}],39:[function(require,module,exports){
'use strict';

var camelCase = require('lodash.camelcase');

module.exports = function (Thunder) {

	var implementation = {
		name: 'customer-update-credential'
	};

	implementation.options = function () {
		return {

			field: null, // 'userId', 'email', 'password'

			onUpdate: function onUpdate($container, context) {

				Thunder.notify('success', context.m('updateSuccess'));
			},
			onUpdateCustomer: function onUpdateCustomer($container, context, field) {

				Thunder.render($container, 'customer-update');
			}

		};
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $updateCustomer = $(this).find('.thunder--update-customer');
		var $form = $(this).find('.thunder--credential-form');
		var $button = $form.find('.thunder--update-credential');
		var buttonSpinner = Thunder.util.makeAsyncButton($button);

		$updateCustomer.on('click', function () {
			return Thunder.execute(context.options.onUpdateCustomer, $container, context);
		});

		Thunder.util.makeRecaptcha(implementation.name, $button, function (token, resetRecaptcha) {

			var data = Thunder.util.formToJSON($form.serializeArray());

			// For customers with social registrations
			data.password = data.password || '';

			var resetState = function resetState() {
				buttonSpinner.done();
				return resetRecaptcha && resetRecaptcha();
			};

			var errors = {
				'invalid-password': context.m('invalidPassword'),
				'duplicated-user-id': context.m('duplicatedUserId'),
				'duplicated-email': context.m('duplicatedEmail'),
				default: context.m('updateFailed'),
				validation: function validation(err) {
					var path = err.validation.source.split('.');
					var field = path[path.length - 1];

					return context.m(camelCase(['invalidNew', field]));
				}
			};

			return Thunder.request({
				method: 'PUT',
				url: '/v1/me/credentials',
				data: data
			}).then(function () {

				Thunder.execute(context.options.onUpdate, $container, context);

				return resetState();
			}, function (err) {
				return Thunder.util.requestErrorHandler(err.responseJSON, errors, function (err) {
					return resetState();
				});
			});
		});
	};

	return implementation;
};

},{"lodash.camelcase":340}],40:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var get = require('lodash.get');
var set = require('lodash.set');
var camelCase = require('lodash.camelcase');

module.exports = function (Thunder) {

	var translationKey = {
		'name.first': 'firstName',
		'name.last': 'lastName',
		'name.full': 'fullName'
	};

	// Implementation
	var implementation = {
		name: 'customer-update'
	};

	implementation.options = function () {
		return {

			fields: Thunder.options.customerUpdateFields,
			birthdateFormat: Thunder.options.dateInputFormat,

			onUpdate: function onUpdate($container, context, customer) {

				return Thunder.notify('success', context.m('updateSuccess'));
			},
			onChangeCredential: function onChangeCredential($container, context, field) {

				return Thunder.render($container, 'customer-update-credential', { field: field });
			}

		};
	};

	implementation.pre = function (context, callback) {

		var birthOptions = {
			YYYY: { key: 'birthYear', translationKey: 'year', tester: /^\d{4}$/ },
			MM: { key: 'birthMonth', translationKey: 'month', tester: /^\d{1,2}$/ },
			DD: { key: 'birthDate', translationKey: 'date', tester: /^\d{1,2}$/ }
		};

		var hasBirthDate = context.options.fields.indexOf('birthdate') >= 0;
		var birthdateFormats = context.options.birthdateFormat.split('-');

		context.fields = Thunder.util.parseArrayString(context.options.fields).map(function (field) {
			var _field$split = field.split(':'),
			    _field$split2 = _slicedToArray(_field$split, 2),
			    key = _field$split2[0],
			    required = _field$split2[1];

			return {
				required: required === 'required',
				key: key,
				translationKey: translationKey[key] || key
			};
		});

		context.birthdateFields = hasBirthDate ? birthdateFormats.map(function (format, i) {
			return $.extend({
				last: i === birthdateFormats.length - 1
			}, birthOptions[format]);
		}) : [];

		var errors = {
			default: context.m('customerReadFailed')
		};

		return Thunder.request({
			method: 'GET',
			url: '/v1/me',
			query: {
				fields: ['avatar', 'userId', 'email', 'alias', 'name.first', 'name.last', 'name.full', 'mobile', 'phone', 'gender', 'birthdate', 'country'].join(',')
			}
		}).then(function (data) {
			return callback(null, set(context, 'customer', data));
		}, function (err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
		});
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $backToCheckout = $(this).find('.thunder--back-to-checkout');
		var $changeCredential = $(this).find('[data-change-credential]');
		var $avatarForm = $(this).find('.thunder--customer-avatar-form');
		var $avatar = $avatarForm.find('.thunder--customer-avatar');
		var $updateForm = $(this).find('.thunder--customer-update-form');
		var $button = $updateForm.find('.thunder--update-customer');
		var buttonSpinner = Thunder.util.makeAsyncButton($button, { bind: false });

		var fields = [].concat(_toConsumableArray(context.fields), _toConsumableArray(context.birthdateFields)).filter(function (_ref) {
			var key = _ref.key;
			return key !== 'birthdate';
		}).map(function (_ref2) {
			var key = _ref2.key;
			return {
				key: key,
				$input: $updateForm.find('[name="' + key + '"]')
			};
		});

		customerToForm(context.customer);

		Thunder.util.imageUploader($avatarForm, function (image) {
			return Thunder.request({
				method: 'PUT',
				url: '/v1/me',
				data: { avatar: image._id }
			}).then(function () {
				$avatar.attr('src', Thunder.util.imageURL(image, 120, 120));
				return Thunder.notify('success', context.m('avatarUploadSuccess'));
			}, function (err) {
				return Thunder.notify('error', context.m('avatarUploadFailed'));
			});
		}, function () {
			return Thunder.notify('error', context.m('avatarUploadFailed'));
		});

		Thunder.util.bindBackButton($backToCheckout, context);

		$changeCredential.on('click', function () {

			Thunder.execute(context.options.onChangeCredential, $container, context, $(this).data('changeCredential'));
		});

		Thunder.util.makeRecaptcha({
			componentName: implementation.name,
			button: $button,
			validate: validateCustomer,
			callback: function callback(token, resetRecaptcha) {

				buttonSpinner.run();

				var resetState = function resetState() {
					buttonSpinner.done();
					return resetRecaptcha && resetRecaptcha();
				};

				var errors = {
					default: context.m('updateFailed'),

					validation: function validation(err) {
						var _err$validation$sourc = err.validation.source.split('.'),
						    _err$validation$sourc2 = _toArray(_err$validation$sourc),
						    path = _err$validation$sourc2.slice(1);

						var field = path.join('.');

						return context.m(camelCase(['invalid', translationKey[field] || field]));
					}
				};

				return Thunder.request({
					method: 'PUT',
					url: '/v1/me',
					data: formToCustomer()
				}).then(function (customer) {

					customerToForm(customer);

					Thunder.execute(context.options.onUpdate, $container, context, customer);

					return resetState();
				}, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors, function (err) {
						return resetState();
					});
				});
			}
		});

		function normalizeBirthdate(data) {

			var birthFields = ['birthYear', 'birthMonth', 'birthDate'];

			if (birthFields.every(function (field) {
				return data[field];
			})) {

				data.birthdate = new Date(data.birthYear, data.birthMonth - 1, data.birthDate);
			} else {
				data.birthdate = null;
			}

			birthFields.forEach(function (field) {
				return delete data[field];
			});

			return data;
		}

		function formToCustomer() {

			return normalizeBirthdate(Thunder.util.formToJSON($updateForm.serializeArray()));
		}

		function customerToForm(customer) {

			var birthdate = customer.birthdate ? new Date(customer.birthdate.raw || customer.birthdate) : null;

			delete customer.birthdate;

			if (birthdate) {
				$.extend(customer, {
					birthYear: birthdate.getFullYear(),
					birthMonth: birthdate.getMonth() + 1,
					birthDate: birthdate.getDate()
				});
			}

			fields.forEach(function (_ref3) {
				var key = _ref3.key,
				    $input = _ref3.$input;


				$input.val(get(customer, key) || null);
			});
		}

		function validateCustomer() {

			var customer = formToCustomer();

			var requiredFields = context.fields.filter(function (field) {
				return field.required;
			});

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = requiredFields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var _ref4 = _step.value;
					var key = _ref4.key;
					var _translationKey = _ref4.translationKey;


					if (!get(customer, key, null)) {
						Thunder.notify('error', context.m(_translationKey + 'Required'));
						return false;
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return true;
		}
	};

	return implementation;
};

},{"lodash.camelcase":340,"lodash.get":341,"lodash.set":345}],41:[function(require,module,exports){
'use strict';

module.exports = function (Thunder) {

	var implementation = {
		name: 'customer-verification'
	};

	implementation.options = function () {
		return {
			customer: 'customer',
			secret: 'secret',
			input: 'query', // 'query' or 'attribute'
			expiresIn: 60 * 60 * 24, // 24 hours

			onEmailRequest: function onEmailRequest($container, context) {

				Thunder.notify('success', context.m('requestEmailSuccess'));
			},
			onVerification: function onVerification($container, context) {

				Thunder.notify('success', context.m('verificationSuccess'));
			}
		};
	};

	implementation.pre = function (context, callback) {

		if (context.options.input === 'query') {

			var query = Thunder.util.urlQuery();
			var customerField = context.options.customer;
			var secretField = context.options.secret;

			if (query[customerField] && query[secretField]) {

				context.customer = query[customerField];
				context.secret = query[secretField];
			}
		}

		if (context.options.input === 'attribute') {

			context.customer = context.options.customer;
			context.secret = context.options.secret;
		}

		context.type = context.customer && context.secret ? 'verification' : 'request-email';

		return callback(null, context);
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $form = $(this).find('.thunder--reset-password-form');

		if (context.type === 'request-email') {

			var $requestEmail = $form.find('.thunder--request-email');
			var requestEmailSpinner = Thunder.util.makeAsyncButton($requestEmail);

			Thunder.util.makeRecaptcha(implementation.name, $requestEmail, function (token, resetRecaptcha) {

				var data = $.extend(Thunder.util.userIdOrEmail(Thunder.util.formToJSON($form.serializeArray())), {
					expiresIn: context.options.expiresIn,
					scope: 'verification'
				});

				var resetState = function resetState() {
					requestEmailSpinner.done();
					return resetRecaptcha && resetRecaptcha();
				};

				var errors = {
					'not-existing-customer': context.m('notExistingCustomer'),
					'email-required': context.m('customerWithoutEmail'),
					default: context.m('requestEmailFailed')
				};

				Thunder.request({
					method: 'POST',
					url: '/v1/customers/verifications/emails',
					data: data
				}).then(function () {

					Thunder.execute(context.options.onEmailRequest, $container, context);

					return resetState();
				}, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors, function (err) {
						return resetState();
					});
				});
			});
		}

		if (context.type === 'verification') {

			var $finishVerification = $form.find('.thunder--finish-verification');
			var finishVerificationSpinner = Thunder.util.makeAsyncButton($finishVerification);

			Thunder.util.makeRecaptcha(implementation.name, $finishVerification, function (token, resetRecaptcha) {

				var data = {
					secret: context.secret
				};

				var resetState = function resetState() {
					finishVerificationSpinner.done();
					return resetRecaptcha && resetRecaptcha();
				};

				var errors = {
					default: context.m('verificationFailed')
				};

				Thunder.request({
					method: 'POST',
					url: '/v1/customers/' + context.customer + '/verified',
					data: data,
					recaptcha: token
				}).then(function () {

					Thunder.execute(context.options.onVerification, $container, context);

					return resetState();
				}, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors, function (err) {
						return resetState();
					});
				});
			});
		}
	};

	return implementation;
};

},{}],42:[function(require,module,exports){
'use strict';

var _set = require('lodash.set');
var _get = require('lodash.get');
var camelCase = require('lodash.camelcase');

module.exports = function (Thunder) {

	var implementation = {
		name: 'order-detail'
	};

	implementation.options = function () {
		return {
			order: '', // Order ID to render
			updateTransactions: true, // Update transactions before getting an order
			customerFields: Thunder.options.customerOrderFields.map(function (field) {
				return field.split(':')[0];
			}),
			recipientFields: Thunder.options.recipientFields.map(function (field) {
				return field.split(':')[0];
			}),

			onRequestRefund: function onRequestRefund($container, context, order) {
				return Thunder.render($container, 'order-request-refund', {
					order: order._id,
					back: {
						$container: $container,
						component: implementation.name,
						options: context.options
					}
				});
			}
		};
	};

	implementation.pre = function (context, callback) {
		var order = context.options.order;


		context.couponDetail = function (coupon) {
			return coupon ? context.m('discountedBy', { value: coupon.discount.value.converted }) : '';
		};

		context.fulfillmentTracker = function (_ref) {
			var tracking = _ref.tracking;


			var message = [tracking.company, tracking.uid ? '(' + tracking.uid + ')' : null].filter(function (v) {
				return v;
			}).join(' ');

			return tracking.url ? '<a href="' + tracking.url + '">' + (message || context.m('viewTracker')) + '</a>' : '<span>' + message + '</span>';
		};

		context.refundTotalDetail = function (total) {
			return [typeof total.items.price.withTax.raw === 'number' ? context.m('refundItemTotal', { total: total.items.price.withTax.converted }) : null, typeof total.shipping.fee.withTax.raw === 'number' ? context.m('refundShippingTotal', { total: total.shipping.fee.withTax.converted }) : null].filter(function (v) {
				return v;
			}).join(' + ');
		};

		context.calculateExpiresAt = function (order, item) {
			var _item$download$policy = item.download.policy.expires,
			    type = _item$download$policy.type,
			    value = _item$download$policy.value;


			if (!type) return null;

			return type === 'at' ? new Date(value.raw) : Thunder.util.addTime(order.createdAt.raw, type, value.raw);
		};

		context.toDateValues = function (date) {
			return {
				year: date.getFullYear().toString(),
				month: (date.getMonth() + 1).toString(),
				date: date.getDate().toString(),
				hours: date.getHours().toString()
			};
		};

		var translationKeys = {
			'name.first': 'firstName',
			'name.last': 'lastName',
			'name.full': 'fullName'
		};

		context.customerFields = Thunder.util.parseArrayString(context.options.customerFields).map(function (key) {
			return {
				key: key,
				translationKey: camelCase(['customer', translationKeys[key] || key])
			};
		});

		context.recipientFields = Thunder.util.parseArrayString(context.options.recipientFields).map(function (key) {
			return {
				key: key,
				translationKey: camelCase(['address', translationKeys[key] || key])
			};
		});

		context.undownloadableStatuses = {
			placed: true,
			cancelled: true,
			'under-paid': true
		};

		return context.options.updateTransactions ?
		// Since we are trying to make the order up-to-date with the best effort,
		// proceed following processes even if `updateTransactions` execution fails.
		updateTransactions().then(function () {
			return fetchOrder().then(function (order) {
				return success(order);
			});
		}, function () {
			return fetchOrder().then(function (order) {
				return success(order);
			});
		}) : fetchOrder().then(function (order) {
			return success(order);
		});

		function success(order) {

			// Make `updateTransactions` option as `true`,
			// event if it was passed as `false`.
			context.options.updateTransactions = true;

			var findDiscount = function findDiscount(type) {
				return function (discount) {
					return discount.coupon && discount.coupon.type === type;
				};
			};
			var findCartDiscount = findDiscount('cart');
			var findProductDiscount = findDiscount('product');

			var allItems = order.items.reduce(function (items, item) {
				return items.concat(item, item.bundleItems || []);
			}, []);
			var itemsAndShipments = [].concat(allItems, order.shipments);

			allItems.forEach(function (item) {
				// 환불 여부 플래그
				item.refunded = Thunder.util.checkItemRefunded(order, item._id);

				// 다운로드 가능 여부 플래그
				item.downloadable = item.type === 'downloadable' && // 다운로드 상품이면서
				!item.refunded && ( // 환불되지 않았고

				// 다운로드 가능 횟수 제한이 없거나, 제한량을 넘기지 않았고
				!item.download.policy.count || item.download.downloaded.raw < item.download.policy.count.raw) && (
				// 만료 날짜 제한이 없거나, 만료일이 지나지 않은 상품
				!item.download.policy.expires.type || context.calculateExpiresAt(order, item).valueOf() > Date.now());
			});

			itemsAndShipments.forEach(function (item) {

				item.appliedCoupon = (item.discounts.find(findProductDiscount) || { coupon: null }).coupon;
			});

			order.shippingStatus = Thunder.util.orderShippingStatus(order);

			order.appliedCoupon = ((itemsAndShipments.find(function (item) {
				return item.discounts.find(findCartDiscount);
			}) || { discounts: [] }).discounts.find(findCartDiscount) || { coupon: null }).coupon;

			order.hasTangibleItem = allItems.some(function (item) {
				return item.type === 'tangible';
			});

			context.order = order;

			context.vbanks = order.transactions.reduce(function (vbanks, transaction) {
				return vbanks.concat(transaction.vbanks || []);
			}, []).filter(function (vbank) {

				var expiresAt = _get(vbank, 'expiresAt.raw');

				// 만료 기간이 없으면 만료 되지 않은 것으로 간주
				if (!expiresAt) return true;

				// Filter out expired virtual bank details
				return !Thunder.util.isExpired(expiresAt);
			});

			// Set payment details.
			var thunderPaymentMethodMap = (Thunder.options.paymentMethods.order || []).reduce(function (o, p) {
				return _set(o, p.id, p);
			}, {});

			// Filter viable payment methods where..
			var paymentMethods = order.transactions.map(function (_ref2) {
				var paymentMethod = _ref2.paymentMethod,
				    vbanks = _ref2.vbanks;


				var thunderPaymentMethod = thunderPaymentMethodMap[paymentMethod._id] || thunderPaymentMethodMap[paymentMethod.slug];

				var shouldDisplay =
				// the payment method is configured for Thunder and..
				thunderPaymentMethod &&
				// the payment (by the method) is not for later
				!thunderPaymentMethod.payLater && (!vbanks.length || // the payment method is not for virtual banks
				vbanks.some(function (vbank) {
					// or one or more virtual banks are expired

					var expiresAt = _get(vbank, 'expiresAt.raw');

					// 만료 기간이 없으면 만료 되지 않은 것으로 간주
					if (!expiresAt) return false;

					return Thunder.util.isExpired(expiresAt);
				}));

				return shouldDisplay ? thunderPaymentMethod : null;
			}).filter(function (v) {
				return v;
			});

			// Should display a payment form when,
			// - The order's status is 'placed'
			// - One or more viable payment methods exist
			var shouldPay = order.status === 'placed' && paymentMethods.length;

			context.paymentMethods = paymentMethods;
			context.shouldPay = shouldPay;

			return callback(null, context);
		}

		function updateTransactions() {

			return Thunder.request({
				method: 'PUT',
				url: '/v1/me/orders/' + order + '/transactions'
			});
		}

		function fetchOrder() {

			var errors = {
				default: context.m('orderReadFailed')
			};

			return Thunder.request({
				method: 'GET',
				url: '/v1/me/orders/' + order
			}).then(null, function (err) {
				return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
			});
		}
	};

	implementation.init = function (context) {
		var order = context.order,
		    paymentMethods = context.paymentMethods,
		    shouldPay = context.shouldPay;


		var $container = $(this);
		var $backToOrders = $(this).find('.thunder--back-to-orders');
		var $subscriptionid = $(this).find('.thunder--subscription-id a');
		var $markAsReceived = $(this).find('.thunder--mark-order-as-received');
		var $markAsNotReceived = $(this).find('.thunder--mark-order-as-not-received');
		var $cancelOrder = $(this).find('.thunder--cancel-order');
		var $cancellationForm = $(this).find('.thunder--order-cancellation-form');
		var $cancellationReason = $cancellationForm.find('textarea');
		var $cancelButton = $cancellationForm.find('button');
		var $requestRefund = $(this).find('.thunder--request-refund');
		var $downloadButton = $(this).find('.thunder--download-button');

		var cancelButtonSpinner = Thunder.util.makeAsyncButton($cancelButton);

		$downloadButton.on('click', getDownloadLink);
		$subscriptionid.on('click', viewSubscription);
		$markAsReceived.on('click', markAsReceived);
		$markAsNotReceived.on('click', markAsNotReceived);
		$cancelOrder.on('click', startCancellation);
		$cancelButton.on('click', cancelOrder);
		$requestRefund.on('click', requestRefund);
		$(this).on('click', '.thunder--cancel-refund', startRefundCancellation);
		$(this).on('click', '.thunder--refund-cancellation-form button', cancelRefund);

		Thunder.util.bindBackButton($backToOrders, context);

		// Render a payment form if it's needed.
		if (shouldPay) {

			var $paymentFormContainer = $(this).find('.thunder--payment-form-container');
			var $makePayment = $(this).find('.thunder--make-payment');
			var makePaymentSpinner = Thunder.util.makeAsyncButton($makePayment, { bind: false });

			Thunder.render($paymentFormContainer, 'payment-form', {
				type: 'order',
				paymentMethods: paymentMethods.map(function (p) {
					return p.id;
				})
			}, function (err, _ref3) {
				var paymentHandler = _ref3.interfaces;
				return $makePayment.on('click', function () {

					var validationError = paymentHandler.validate();

					if (validationError) {
						return Thunder.notify('error', validationError.message);
					}

					makePaymentSpinner.run();

					return paymentHandler.makePayment({
						cart: order,
						order: order,
						customer: order.customer
					}, function (err) {

						if (err) {
							Thunder.notify('error', context.m('paymentFailed'));
							return makePaymentSpinner.done();
						}

						Thunder.notify('success', context.m('paymentSuccess'));
						makePaymentSpinner.done();
						return Thunder.render($container, implementation.name, $.extend(context.options, {
							updateTransactions: true
						}));
					});
				});
			});
		}

		function getDownloadLink() {

			var $item = $(this).parents('[data-item]').eq(0);
			var itemId = $item.data('bundleItem') || $item.data('item');
			var orderId = context.order._id;

			return Thunder.request({
				method: 'POST',
				url: '/v1/me/orders/' + orderId + '/items/' + itemId + '/download/url'
			}).then(function (res) {
				if (!res.url) return;

				var $countView = $item.find('.thunder--download-count-view').eq(0);

				if ($countView.length) {
					$countView.data('current', $countView.data('current') + 1);
					$countView.text(context.m('nTimesDownloaded', $countView.data()));
				}

				window.open(res.url);
			}, function (err) {
				if (err.responseJSON.errorCode === 'fully-used-item') {
					return Thunder.notify('error', context.m('fullyUsedDownloadable'));
				}
				if (err.responseJSON.errorCode === 'expired-item') {
					return Thunder.notify('error', context.m('expiredDownloadable'));
				}
				if (err.responseJSON.errorCode === 'refunded-item') {
					return Thunder.notify('error', context.m('refundedItem'));
				}
			});
		}

		function viewSubscription() {

			return Thunder.render($container, 'subscription-detail', {
				subscription: order.subscription._id,
				back: {
					$container: $container,
					component: implementation.name,
					options: context.options
				}
			});
		}

		function markAsReceived() {

			var errors = {
				'invalid-order-status': context.m('invalidOrderStatus'),
				default: context.m('markAsReceivedFailed')
			};

			return Thunder.request({
				method: 'POST',
				url: '/v1/me/orders/' + order._id + '/received'
			}).then(function () {

				Thunder.notify('success', context.m('markAsReceivedSuccess'));

				return Thunder.render($container, implementation.name, $.extend(context.options, {
					updateTransactions: false
				}));
			}, function (err) {
				return Thunder.util.requestErrorHandler(err.responseJSON, errors);
			});
		}

		function markAsNotReceived() {

			var errors = {
				'invalid-order-status': context.m('invalidOrderStatus'),
				default: context.m('markAsNotReceivedFailed')
			};

			return Thunder.request({
				method: 'DELETE',
				url: '/v1/me/orders/' + order._id + '/received'
			}).then(function () {

				Thunder.notify('success', context.m('markAsNotReceivedSuccess'));

				return Thunder.render($container, implementation.name, $.extend(context.options, {
					updateTransactions: false
				}));
			}, function (err) {
				return Thunder.util.requestErrorHandler(err.responseJSON, errors);
			});
		}

		function startCancellation() {
			$(this).addClass('hidden');
			$cancellationForm.removeClass('hidden');
			$cancellationReason.focus();
		}

		function cancelOrder(event) {

			event.preventDefault();

			var data = Thunder.util.formToJSON($cancellationForm.serializeArray());

			var errors = {
				'invalid-order-status': context.m('invalidOrderStatus'),
				default: context.m('cancellationFailed')
			};

			var resetState = function resetState() {
				cancelButtonSpinner.done();
			};

			return Thunder.request({
				method: 'POST',
				url: '/v1/me/orders/' + order._id + '/cancellation',
				data: data
			}).then(function () {

				resetState();

				Thunder.notify('success', context.m('cancellationSuccess'));

				return Thunder.render($container, implementation.name, $.extend(context.options, {
					updateTransactions: false
				}));
			}, function (err) {
				return Thunder.util.requestErrorHandler(err.responseJSON, errors, resetState);
			});
		}

		function requestRefund() {
			Thunder.execute(context.options.onRequestRefund, $container, context, order);
		}

		function startRefundCancellation(event) {

			event.preventDefault();

			var $refund = $(this).parents('[data-refund]');
			var $cancellationForm = $refund.find('.thunder--refund-cancellation-form');

			$(this).addClass('hidden');
			$cancellationForm.removeClass('hidden');
		}

		function cancelRefund(event) {

			event.preventDefault();

			var $refund = $(this).parents('[data-refund]');
			var $cancellationForm = $refund.find('.thunder--refund-cancellation-form');
			var refundId = $refund.data('refund');

			var data = Thunder.util.formToJSON($cancellationForm.serializeArray());

			return cancel().then(function () {
				Thunder.notify('success', context.m('refundCancellationSuccess'));
				return Thunder.render($container, implementation.name, $.extend(context.options, {
					updateTransactions: false
				}));
			});

			function cancel() {

				var errors = {
					'invalid-refund-status': context.m('invalidRefundStatus'),
					default: context.m('refundCancellationFailed')
				};

				return Thunder.request({
					method: 'POST',
					url: '/v1/me/orders/' + order._id + '/refunds/' + refundId + '/cancellation',
					data: data
				}).then(null, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors);
				});
			}
		}
	};

	return implementation;
};

},{"lodash.camelcase":340,"lodash.get":341,"lodash.set":345}],43:[function(require,module,exports){
'use strict';

module.exports = function (Thunder) {

	var implementation = {
		name: 'order-list'
	};

	implementation.options = function () {
		return {
			page: 1, // Which page of orders?
			limit: 10, // How many orders at once?
			usePagination: true, // Use pagination?
			onViewOrder: function onViewOrder($container, context, orderId) {

				return Thunder.render($container, 'order-detail', {
					order: orderId,
					back: {
						$container: $container,
						component: implementation.name,
						options: context.options
					}
				});
			}
		};
	};

	implementation.pre = function (context, callback) {

		var errors = {
			default: context.m('orderListFailed')
		};

		return $.when(Thunder.request({
			method: 'GET',
			url: '/v1/me/orders',
			query: {
				page: context.options.page,
				limit: context.options.limit,
				sort: '-createdAt',
				fields: ['subscription', 'status', 'items.type', 'items.product', 'items.bundleItems.type', 'fulfillments.status', 'total.price.withTax', 'cancellation', 'receivedAt', 'createdAt'].join(',')
			}
		}), context.options.usePagination ? Thunder.request({
			method: 'GET',
			url: '/v1/me/orders/count',
			query: {
				raw: true
			}
		}) : null).then(function (orders, count) {

			context.orders = (orders[0] || []).map(function (order) {
				order.shippingStatus = Thunder.util.orderShippingStatus(order);
				return order;
			});

			context.count = count ? count[0].count : null;

			return callback(null, context);
		}, function (err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
		});
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $order = $(this).find('[data-order]');
		var $pagination = $(this).find('.thunder--order-list-pagination');

		$order.on('click', ['.thunder--order-id', '.thunder--order-thumbnail', '.thunder--order-first-item', '.thunder--order-rest-items'].join(','), function (event) {
			return Thunder.execute(context.options.onViewOrder, $container, context, $(event.delegateTarget).data('order'));
		});

		if (context.options.usePagination) {

			Thunder.plugins.pagination({
				container: $pagination,
				currentPage: context.options.page,
				totalResult: context.count,
				resultPerPage: context.options.limit,
				onPageChange: function onPageChange(_ref) {
					var page = _ref.page;
					return Thunder.render($container, implementation.name, $.extend(context.options, { page: page }));
				}
			});
		}
	};

	return implementation;
};

},{}],44:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var set = require('lodash.set');

module.exports = function (Thunder) {

			var implementation = {
						name: 'order-request-refund'
			};

			implementation.options = function () {
						return {
									order: '', // Order ID to refund
									reasonCategories: Thunder.options.refundReasonCategories,

									onRequestRefundSuccess: function onRequestRefundSuccess($container, context, refund) {

												Thunder.notify('success', context.m('requestRefundSuccess'));

												var back = context.options.back;

												if (!back) return;

												return Thunder.render(back.$container, back.component, back.options);
									}
						};
			};

			implementation.pre = function (context, callback) {

						var order = null;

						return fetchOrder(context.options.order).then(function (o) {
									order = o;
									return fetchCurrency(order.currency.payment.code);
						}).then(function (_ref) {
									var _ref2 = _slicedToArray(_ref, 1),
									    currency = _ref2[0];

									return success(order, currency);
						});

						function success(order, currency) {

									context.currency = $.extend(currency, {
												// Override precision with a snapshot version
												precision: order.currency.payment.precision
									});

									var refundsInProcess = order.refunds.filter(function (_ref3) {
												var status = _ref3.status;
												return status !== 'cancelled';
									});

									// { [itemId]: shipment, ... }
									var itemToShipmentMap = order.shipments.reduce(function (o, shipment) {

												return shipment.items.reduce(function (o, item) {

															return set(o, item._id, shipment);
												}, o);
									}, {});

									// { [itemId]: quantity, ... }
									var refundedItemQuantityMap = refundsInProcess.reduce(function (o, refund) {

												return refund.items.reduce(function (o, _ref4) {
															var item = _ref4.item,
															    quantity = _ref4.quantity;

															o[item._id] = o[item._id] || 0;
															o[item._id] += quantity.raw;
															return o;
												}, o);
									}, {});

									// { [shipmentId]: amount, ... }
									var refundedShipmentAmountMap = refundsInProcess.reduce(function (o, refund) {

												return refund.shipments.reduce(function (o, _ref5) {
															var shipment = _ref5.shipment,
															    fee = _ref5.fee;

															o[shipment._id] = o[shipment._id] || 0;
															o[shipment._id] = Thunder.util.toPrecision(o[shipment._id] + fee.withTax.raw, context.currency.precision);
															return o;
												}, o);
									}, {});

									order.items.forEach(function (item) {
												return [].concat(item, item.bundleItems || []).forEach(function (item) {

															var shipment = itemToShipmentMap[item._id];
															var refundedItemQuantity = refundedItemQuantityMap[item._id] || 0;

															item.shipment = shipment;
															item.refundableQuantity = item.quantity.raw - refundedItemQuantity;
												});
									});

									order.shipments.forEach(function (shipment) {

												var refundedShipmentAmount = refundedShipmentAmountMap[shipment._id] || 0;

												shipment.refundableFee = Thunder.util.toPrecision(shipment.fee.withTax.raw - refundedShipmentAmount, context.currency.precision);
									});

									order.hasRefundableItem = order.items.some(function (item) {
												return [].concat(item, item.bundleItems || []).some(function (item) {
															return item.refundableQuantity > 0;
												});
									});

									return callback(null, set(context, 'order', order));
						}

						function fetchOrder(order) {

									var errors = {
												default: context.m('orderReadFailed')
									};

									return Thunder.request({
												method: 'GET',
												url: '/v1/me/orders/' + order,
												fields: ['items', 'shipments', 'refunds', 'transactions', 'total'].join(',')
									}).then(null, function (err) {
												return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
									});
						}

						function fetchCurrency(code) {

									var errors = {
												default: context.m('currencyReadFailed')
									};

									return Thunder.request({
												method: 'GET',
												url: '/v1/currencies',
												query: { code: code }
									}).then(null, function (err) {
												return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
									});
						}
			};

			implementation.init = function (context) {
						var order = context.order,
						    currency = context.currency;


						var categoryMap = context.options.reasonCategories.reduce(function (o, category) {
									return set(o, category.label, category);
						}, {});

						var itemMap = order.items.reduce(function (o, item) {
									return [].concat(item, item.bundleItems || []).reduce(function (o, item) {
												return set(o, item._id, item);
									}, o);
						}, {});

						var shipmentMap = order.shipments.reduce(function (o, shipment) {
									return set(o, shipment._id, shipment);
						}, {});

						var shipmentItemQuantityMap = order.shipments.reduce(function (o, shipment) {
									return shipment.items.reduce(function (o, item) {
												return set(o, [shipment._id, item._id], item.quantity.raw);
									}, o);
						}, {});

						var $container = $(this);
						var $backToOrder = $(this).find('.thunder--back-to-order');
						var $cartItems = $(this).find('.thunder--cart-item');
						var $toggleItemSelection = $(this).find('.thunder--toggle-item-selection');
						var $refundQuantity = $(this).find('.thunder--cart-item input[name="refundQuantity"]');
						var $refundCategory = $(this).find('.thunder--refund-category');
						var $refundReason = $(this).find('.thunder--refund-reason');
						var $requiresReason = $(this).find('.thunder--requires-refund-reason');
						var $totalDetail = $(this).find('.thunder--refund-total-detail');
						var $refundItemsTotal = $(this).find('.thunder--refund-items-total td');
						var $refundShippingTotal = $(this).find('.thunder--refund-shipping-total td');
						var $refundTotal = $(this).find('.thunder--refund-total td');
						var $requestRefund = $(this).find('.thunder--request-refund');
						var requestButtonSpinner = Thunder.util.makeAsyncButton($requestRefund, { bind: false });

						$toggleItemSelection.on('click', toggleItemSelection);
						$refundQuantity.on('change', refundQuantityChanged);
						$refundCategory.on('change', updateRefundTotal);

						Thunder.util.bindBackButton($backToOrder, context);

						Thunder.util.makeRecaptcha({
									componentName: implementation.name,
									button: $requestRefund,
									validate: validateRequest,
									callback: requestRefund
						});

						updateRefundTotal();

						function getOneItemPrice(item) {
									return item.price.withTax.raw / item.quantity.raw;
						}

						function markItemActive($cartItem, active, quantity) {

									var $toggleButton = $cartItem.find('.thunder--toggle-item-selection');
									var $refundQuantity = $cartItem.find('input[name="refundQuantity"]');
									var item = itemMap[$cartItem.data('item')];

									if (active) {
												$cartItem.data('active', true).removeClass('inactive');
												$toggleButton.text(context.m('removeFromRefund'));
												$refundQuantity.val(quantity === undefined ? item.refundableQuantity : quantity);
									} else {
												$cartItem.data('active', false).addClass('inactive');
												$toggleButton.text(context.m('addToRefund'));
												$refundQuantity.val(0);
									}
						}

						function toggleItemSelection(event) {

									event.preventDefault();

									var $cartItem = $(this).parents('.thunder--cart-item');

									markItemActive($cartItem, !$cartItem.data('active'));
									updateRefundTotal();
						}

						function refundQuantityChanged() {

									var $cartItem = $(this).parents('.thunder--cart-item');
									var quantity = parseInt($(this).val());

									markItemActive($cartItem, !!quantity, quantity);
									updateRefundTotal();
						}

						function updateRefundTotal() {

									$cartItems.each(function () {

												var $cartItem = $(this);
												var $refundAmount = $cartItem.find('.thunder--cart-item-refund-amount');
												var item = itemMap[$cartItem.data('item')];
												var quantity = parseInt($cartItem.find('input[name="refundQuantity"]').val());

												var refundAmount = Thunder.util.formatPrice(getOneItemPrice(item) * quantity, currency);

												$refundAmount.text(refundAmount);
									});

									var category = categoryMap[$refundCategory.val()];

									if (!category) {
												$requiresReason.removeClass('hidden');
												$totalDetail.addClass('hidden');
												return;
									}

									var refundItems = getRefundItems();
									var refundShipments = getRefundShipments(category, refundItems);

									var itemsTotal = refundItems.reduce(function (sum, _ref6) {
												var item = _ref6.item,
												    quantity = _ref6.quantity;

												return sum + getOneItemPrice(item) * quantity;
									}, 0);

									var shippingTotal = refundShipments.reduce(function (sum, shipment) {
												return sum + shipment.refundableFee;
									}, 0);

									var total = itemsTotal + shippingTotal;

									$refundItemsTotal.text(Thunder.util.formatPrice(itemsTotal, currency));
									$refundShippingTotal.text(Thunder.util.formatPrice(shippingTotal, currency));
									$refundTotal.text(Thunder.util.formatPrice(total, currency));

									$requiresReason.addClass('hidden');
									$totalDetail.removeClass('hidden');
						}

						function getRefundItems() {

									return $refundQuantity.map(function () {

												return {
															item: itemMap[$(this).parents('[data-item]').data('item')],
															quantity: parseInt($(this).val())
												};
									}).get().filter(function (_ref7) {
												var quantity = _ref7.quantity;
												return quantity;
									});
						}

						function getRefundShipments(category, refundItems) {

									if (!category) {
												return [];
									}

									var shipmentToRefundItems = {};

									refundItems.forEach(function (refundItem) {

												var shipment = refundItem.item.shipment;

												if (!shipment) return;

												shipmentToRefundItems[shipment._id] = (shipmentToRefundItems[shipment._id] || []).concat(refundItem);
									});

									var shipmentIdsToRefund = Object.keys(shipmentToRefundItems);

									return shipmentIdsToRefund.map(function (shipmentId) {

												// Clone first to avoid side effects
												var shipmentItemQuantity = $.extend({}, shipmentItemQuantityMap[shipmentId]);
												var refundItems = shipmentToRefundItems[shipmentId];

												refundItems.forEach(function (_ref8) {
															var item = _ref8.item,
															    quantity = _ref8.quantity;

															shipmentItemQuantity[item._id] -= quantity;
												});

												var areAllItemsRefunded = Object.keys(shipmentItemQuantity).every(function (itemId) {
															return shipmentItemQuantity[itemId] === 0;
												});

												return {
															shipment: shipmentMap[shipmentId],
															shouldRefund: areAllItemsRefunded ? category.shippingFee.allItems : category.shippingFee.someItems
												};
									}).filter(function (_ref9) {
												var shipment = _ref9.shipment,
												    shouldRefund = _ref9.shouldRefund;


												// When the shipment should be refunded
												// and its refundable fee is greater than 0
												return shouldRefund && shipment.refundableFee > 0;
									}).map(function (_ref10) {
												var shipment = _ref10.shipment;
												return shipment;
									});
						}

						function getRequestDetail() {

									var category = categoryMap[$refundCategory.val()];
									var items = getRefundItems();
									var shipments = getRefundShipments(category, items).map(function (s) {
												return s._id;
									});

									items.forEach(function (detail) {
												return detail.item = detail.item._id;
									});

									var reason = {
												category: category ? context.m(category.label) : null,
												body: $refundReason.val()
									};

									return { items: items, shipments: shipments, reason: reason };
						}

						function validateRequest() {
									var _getRequestDetail = getRequestDetail(),
									    items = _getRequestDetail.items,
									    category = _getRequestDetail.reason.category;

									if (!items.length) {
												Thunder.notify('error', context.m('atLeastOneItemRequired'));
												return false;
									}

									if (!category) {
												Thunder.notify('error', context.m('reasonCategoryRequired'));
												return false;
									}

									return true;
						}

						function requestRefund(token, resetRecaptcha) {

									requestButtonSpinner.run();

									var detail = getRequestDetail();

									detail.reason = ('[' + detail.reason.category + '] ' + (detail.reason.body || '')).trim();

									var resetState = function resetState() {
												requestButtonSpinner.done();
												return resetRecaptcha && resetRecaptcha();
									};

									var errors = {
												'invalid-order-status': context.m('invalidOrderStatus'),
												default: context.m('requestRefundFailed')
									};

									return Thunder.request({
												method: 'POST',
												url: '/v1/me/orders/' + order._id + '/refunds',
												data: detail,
												recaptcha: token
									}).then(function (refund) {

												resetState();

												Thunder.execute(context.options.onRequestRefundSuccess, $container, context, refund);
									}, function (err) {
												return Thunder.util.requestErrorHandler(err.responseJSON, errors, resetState);
									});
						}
			};

			return implementation;
};

},{"lodash.set":345}],45:[function(require,module,exports){
'use strict';

var get = require('lodash.get');
var set = require('lodash.set');
var camelCase = require('lodash.camelcase');

module.exports = function (Thunder) {

			var implementation = {
						name: 'payment-form'
			};

			implementation.options = function () {
						return {
									type: 'order', // 'order' or 'subscription'
									paymentMethods: null
						};
			};

			implementation.pre = function (context, callback) {
						var type = context.options.type;


						var paymentMethodFilter = context.options.paymentMethods;
						var defaultPaymentMethods = Thunder.options.paymentMethods[type] || [];

						context.paymentMethods = context.options.paymentMethods ? defaultPaymentMethods.filter(function (paymentMethod) {
									return paymentMethodFilter.some(function (p) {
												return paymentMethod.id === p;
									});
						}) : defaultPaymentMethods;

						return callback(null, context);
			};

			implementation.init = function (context) {

						var owner = {
									person: { label: context.m('cardOwnerBirthdate'), format: 'YYMMDD' },
									company: { label: context.m('cardOwnerCompanyNumber'), format: 'XXXXXXXXXX' }
						};

						var paymentMethodMap = context.paymentMethods.reduce(function (o, p) {
									return set(o, [p.id + '.' + p.label], p);
						}, {});

						var $cardForm = $(this).find('.thunder--payment-card-detail');
						var $paymentMethod = $(this).find('[name="paymentMethod"]');
						var $cardNumber = $(this).find('[name="card.number"]');
						var $isCompanyCard = $(this).find('.thunder--is-company-card input[type="checkbox"]');
						var $cardOwnerLabel = $(this).find('.thunder--card-owner label');
						var $cardOwnerInput = $(this).find('.thunder--card-owner input[type="text"]');

						$paymentMethod.on('change', displayCardForm);
						$cardNumber.on('keyup', normalizeCardNumber);
						$isCompanyCard.on('change', decideCardOwner);

						decideCardOwner();

						function getPaymentMethodId() {
									return $paymentMethod.val() || null;
						}

						function getPaymentMethod() {
									return paymentMethodMap[getPaymentMethodId()] || null;
						}

						function getCard() {

									var paymentMethod = getPaymentMethod();

									if (!paymentMethod || !paymentMethod.cardFields) {
												return null;
									}

									var data = {};

									$cardForm.find('[name]').each(function () {
												set(data, $(this).prop('name'), $(this).val() || null);
									});

									var card = data.card;

									if (card) {
												if (card.number) {
															card.number = card.number.replace(/\s/g, '-');
												}
									}

									return card;
						}

						function validate() {

									var card = getCard();
									var paymentMethod = getPaymentMethod();

									if (!paymentMethod) {

												var code = 'paymentMethodRequired';
												var err = new Error(context.m(code));

												err.code = code;

												return err;
									}

									if (!paymentMethod.cardFields) {
												return null;
									}

									// Validate if the payment method requires manual card inputs

									var fields = $cardForm.find('[name]').map(function () {
												return $(this).prop('name');
									}).get();

									var _iteratorNormalCompletion = true;
									var _didIteratorError = false;
									var _iteratorError = undefined;

									try {
												for (var _iterator = fields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
															var field = _step.value;


															var value = get(card, field.replace('card.', ''));

															if (value) continue;

															var _code = camelCase([field, 'required']);
															var _err = new Error(context.m(_code));

															_err.code = _code;

															return _err;
												}
									} catch (err) {
												_didIteratorError = true;
												_iteratorError = err;
									} finally {
												try {
															if (!_iteratorNormalCompletion && _iterator.return) {
																		_iterator.return();
															}
												} finally {
															if (_didIteratorError) {
																		throw _iteratorError;
															}
												}
									}

									return null;
						}

						function normalizeCardNumber() {

									var value = ($(this).val() || '').replace(/[^\d]/g, '');

									var normalized = [0, 1, 2, 3].reduce(function (numbers, i) {

												return numbers.concat(value.slice(i * 4, (i + 1) * 4));
									}, []);

									$(this).val(normalized.filter(function (v) {
												return v;
									}).join(' '));
						}

						function decideCardOwner() {

									var isCompanyCard = $isCompanyCard.is(':checked');

									var _ref = isCompanyCard ? owner.company : owner.person,
									    label = _ref.label,
									    format = _ref.format;

									$cardOwnerLabel.text(label);
									$cardOwnerInput.prop('placeholder', format);

									// Reset card owner input's value
									$cardOwnerInput.val('');
						}

						function resetCard() {

									// Reset all input values
									$cardForm.find('input').each(function () {

												return $(this).is('[type="checkbox"]') ? $(this).prop('checked', false) : $(this).val('');
									});

									decideCardOwner();
						}

						function displayCardForm() {

									// Reset all input values
									resetCard();

									var paymentMethod = getPaymentMethod();

									return paymentMethod.cardFields ? $cardForm.show() : $cardForm.hide();
						}

						function makePayment(_ref2, callback) {
									var cart = _ref2.cart,
									    order = _ref2.order,
									    subscription = _ref2.subscription,
									    customer = _ref2.customer;


									var paymentMethod = getPaymentMethod();

									if (!paymentMethod) {
												return callback(new Error(context.m('paymentMethodRequired')));
									}

									if (paymentMethod.payLater) {
												// If a payment is to be made after all checkout processes,
												// simply finish checkout processes.
												return callback();
									}

									return Thunder.plugins.makePayment({
												paymentMethod: paymentMethod,
												cart: cart,
												order: order,
												subscription: subscription,
												customer: customer
									}, function (err) {
												return callback(err);
									});
						}

						// Return interfaces
						return {
									getPaymentMethodId: getPaymentMethodId,
									getPaymentMethod: getPaymentMethod,
									getCard: getCard,
									resetCard: resetCard,
									validate: validate,
									makePayment: makePayment
						};
			};

			return implementation;
};

},{"lodash.camelcase":340,"lodash.get":341,"lodash.set":345}],46:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var set = require('lodash.set');
var productCatalog = require('./lib/productCatalog.js');

module.exports = function (Thunder) {

	var implementation = {
		name: 'product-detail'
	};

	implementation.options = function () {
		return {
			product: '', // Product ID to render
			productActions: Thunder.options.productActions, // ['add-to-cart', 'buy-now'],
			optionSelector: Thunder.options.productOptionSelector, // 'combined' || 'separated'
			descriptionStyle: 'detailed', // 'simple' || 'detailed'
			useFollowingNav: true, // Use following navigation?
			useReviews: Thunder.options.productReview, // Use reviews?
			useRating: // Use review rating?
			Thunder.options.productReview && Thunder.options.productReviewRating,

			onBuyNow: function onBuyNow($container, context, item) {
				return Thunder.render($container, 'cart', { items: [item._id] });
			},
			onItemAdd: function onItemAdd($container, context) {
				return Thunder.notify('success', context.m('itemAddSuccess'));
			},
			onGoToCart: function onGoToCart($container, context) {
				return Thunder.render($container, 'cart');
			}
		};
	};

	implementation.pre = function (context, callback) {

		context.options.productActions = Thunder.util.parseArrayString(context.options.productActions);

		var product = context.options.product;


		context.isUnavailableProduct = function (product) {

			return (
				// A product is unavailable
				!product.available || product.variants && ( // While a product has variants array

				// A product doesn't have any variants
				!product.variants.length ||
				// All variants are unavailable
				product.variants.every(function (v) {
					return !v.available;
				})) ||
				// A tangible product doesn't support any shipping methods
				product.type === 'tangible' && product.shipping.methods.length === 0
			);
		};

		context.isSoldOutProduct = function (product) {
			return product.variants.every(function (v) {
				return v.quantity && v.quantity.raw === 0;
			});
		};

		context.isUnavailableVariant = function (product, variant) {

			if (context.isUnavailableProduct(product) || !variant.available) {
				return 'notAvailableVariant';
			}

			if (variant.quantity && variant.quantity.raw === 0) {
				return 'soldOutVariant';
			}
		};

		context.showOptionSelector = function () {
			return context.options.optionSelector === 'separated' && context.product.options.length >= 2 && context.product.variants.length >= 2;
		};

		var errors = {
			'not-existing-product': context.m('notExistingProduct'),
			default: context.m('productReadFailed')
		};

		return Thunder.request({
			method: 'GET',
			url: '/v1/products/' + product,
			query: {
				embed: '+bundles.items.product.shipping'
			}
		}).then(function (product, textStatus, jqXHR) {

			return Thunder.util.getCurrency(jqXHR.getResponseHeader('content-currency')).then(function (currency) {

				context.currency = currency;
				context.product = moveUnavailablesToEnd(product);

				return callback(null, context);
			});

			function moveUnavailablesToEnd(product) {

				var okVariants = [];
				var notOkVariants = [];

				product.variants.forEach(function (variant) {
					return context.isUnavailableVariant(product, variant) ? notOkVariants.push(variant) : okVariants.push(variant);
				});

				product.variants = [].concat(okVariants, notOkVariants);

				product.bundles.forEach(function (bundle) {

					var okItems = [];
					var notOkItems = [];

					bundle.items.forEach(function (item) {
						return context.isUnavailableVariant(item.product, item.variant) ? notOkItems.push(item) : okItems.push(item);
					});

					bundle.items = [].concat(okItems, notOkItems);
				});

				return product;
			}
		}, function (err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
		});
	};

	implementation.bind = function (context) {

		var $container = $(this);
		var $followingNav = $(this).find('.thunder--following-nav-container');

		Thunder.util.followingNavigation($followingNav, context.options.useFollowingNav, [{
			name: context.m('productInfo'),
			$el: $container.find('.thunder--product-detail')
		}, context.options.useReviews ? {
			name: [context.m('productReviews'), '<span class="thunder--product-total-comments">(' + context.product.totalReview.converted + ')</span>'].join(' '),
			$el: $container.find('.thunder--product-reviews-wrapper')
		} : null].filter(function (v) {
			return v;
		}));
	};

	implementation.init = function (context) {

		var product = context.product;

		var variantMap = [].concat(context.product.variants, context.product.bundles.reduce(function (variants, bundle) {
			return bundle.items.reduce(function (variants, item) {
				return variants.concat(item.variant);
			}, variants);
		}, [])).reduce(function (o, variant) {
			return set(o, variant._id, variant);
		}, {});

		var bundleProductMap = context.product.bundles.reduce(function (o, bundle) {
			return bundle.items.reduce(function (o, item) {
				return set(o, item.product._id, item.product);
			}, o);
		}, {});

		var variantToBundleMap = context.product.bundles.reduce(function (o, bundle) {
			return bundle.items.reduce(function (o, item) {
				return set(o, item.variant._id, bundle);
			}, o);
		}, {});

		var $container = $(this);
		var $optionSelect = $(this).find('.thunder--product-option-wrap select');
		var $variantSelector = $(this).find('.thunder--product-info .thunder--product-option .thunder--product-variant select');
		var $shippingMethodSelector = $(this).find('.thunder--shipping-method select');
		var $itemQuantityInput = $(this).find('.thunder--item-quantity input');
		var $bundleItems = $(this).find('.thunder--product-bundle-item');
		var $bundleItemSelectors = $bundleItems.find('select');
		var $totalWrap = $(this).find('.thunder--price-total-wrap');
		var $totalValue = $(this).find('.thunder--price-total-value');
		var $addToCart = $(this).find('.thunder--add-to-cart');
		var $buyNow = $(this).find('.thunder--buy-now');
		var $goToCart = $(this).find('.thunder--go-to-cart');

		var variationToVariants = context.product.variants.reduce(function (o, v) {

			var key = v.types.map(function (type) {
				return type.variation._id;
			}).sort().join('.');

			return set(o, [key], v._id);
		}, {});

		var addToCartSpinner = Thunder.util.makeAsyncButton($addToCart);

		productCatalog($container);

		$bundleItemSelectors.on('change', function () {

			var value = $(this).val();
			var $quantity = $(this).closest('.thunder--product-bundle-item').find('input[type="number"]');

			$quantity.val(value ? 1 : 0);
		});

		var calculatePrice = function calculatePrice() {

			var item = buildItemData();

			if (!item || !item.variant || !item.quantity) {
				return $totalWrap.hide();
			}

			var price = [].concat(item, item.bundleItems || []).map(function (item) {

				var variant = variantMap[item.variant];
				var quantity = item.quantity;

				return variant && quantity ? variant.price.sale.raw * quantity : 0;
			}).reduce(function (sum, price) {
				return sum + price;
			}, 0);

			$totalValue.text(Thunder.util.formatPrice(price, context.currency));

			return price ? $totalWrap.fadeIn(400) : $totalWrap.hide();
		};

		$variantSelector.on('change', function () {

			var variant = variantMap[$(this).val()];

			if (!variant) return;

			variant.types.forEach(function (_ref) {
				var option = _ref.option,
				    variation = _ref.variation;

				$optionSelect.filter('[name="' + option._id + '"]').val(variation._id);
			});
		});

		// 옵션 선택 이벤트 ('separated')
		$optionSelect.on('change', function () {

			var variations = $optionSelect.map(function () {
				return $(this).val();
			}).get().sort();

			var key = variations.join('.');

			var value = variationToVariants[key] || null;

			if (!value && variations.length === $optionSelect.length) {
				$totalWrap.hide();
				$totalValue.text('');
				Thunder.notify('error', context.m('notExistingVariant'));
			}

			return $variantSelector.val() === value ? null : $variantSelector.val(value);
		});

		$container.find('input,select').on('change', calculatePrice);

		$addToCart.on('click', function () {
			return addToCart();
		});

		$buyNow.on('click', function () {
			return addToCart(function (item) {
				return Thunder.execute(context.options.onBuyNow, $container, context, item);
			});
		});

		$goToCart.on('click', function () {
			return Thunder.execute(context.options.onGoToCart, $container, context);
		});

		if (context.options.useReviews) {

			var $reviewsContainer = $(this).find('.thunder--product-reviews-wrapper');

			Thunder.render($reviewsContainer, 'product-reviews', {
				product: context.product._id,
				productRating: context.options.useRating ? product.rating : null,
				useRating: context.options.useRating
			});
		}

		function clearAllOptions() {
			$totalWrap.hide();
			$totalValue.text('');
			$container.find('.thunder--product-option select').val('');
			$container.find('.thunder--product-option input[type="number"]').val(1);
			$container.find('.thunder--product-bundles select').val('');
			$container.find('.thunder--product-bundles input[type="number"]').val(0);
		}

		function addToCart(success) {
			var item = buildItemData();

			success = success || function () {

				$goToCart.show();

				Thunder.execute(context.options.onItemAdd, $container, context);
			};

			if (!validateItemData(item)) {
				return addToCartSpinner.done();
			}

			var errors = {
				'items-exceeded': context.m('itemsExceeded'),
				default: context.m('itemAddFailed')
			};

			if (Thunder.authenticated()) {

				return Thunder.request({
					method: 'POST',
					url: '/v1/me/cart/items',
					data: item
				}).then(function (item) {
					addToCartSpinner.done();
					clearAllOptions();
					return success(item);
				}, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors, function (err) {
						return addToCartSpinner.done();
					});
				});
			} else {

				Thunder.Cart.addItem(item, function (err) {

					if (err) {
						addToCartSpinner.done();
						return Thunder.notify('error', errors[err.code || 'default'] || errors.default);
					}

					addToCartSpinner.done();
					clearAllOptions();
					return success(item);
				});
			}
		}

		function validateItemData(itemData) {
			if (!itemData.variant) {
				Thunder.notify('error', context.m('variantRequired'));
				return false;
			}

			if (!validateQuantity(product.name, itemData)) {
				return false;
			}

			var selectedBundles = [];

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = (itemData.bundleItems || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var item = _step.value;


					var bundle = variantToBundleMap[item.variant];

					selectedBundles.push(bundle);

					if (!validateQuantity(bundle.name, item)) {
						return false;
					}

					if (bundle.required && item.quantity !== itemData.quantity) {
						Thunder.notify('error', context.m('invalidRequiredBundleItemQuantity', { bundle: bundle.name }));
						return false;
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			var requiredBundles = product.bundles.filter(function (b) {
				return b.required;
			});

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = requiredBundles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var bundle = _step2.value;


					if (selectedBundles.indexOf(bundle) === -1) {
						Thunder.notify('error', context.m('requiredBundleItemRequired', { bundle: bundle.name }));
						return false;
					}
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			return true;

			function validateQuantity(scope, item) {

				if (!item.quantity) {
					Thunder.notify('error', context.m('itemQuantityRequired', { scope: scope }));
					return false;
				}

				var variant = variantMap[item.variant];

				if (variant.quantity && variant.quantity.raw < item.quantity) {
					Thunder.notify('error', context.m('exceededItemQuantity', { scope: scope }));
					return false;
				}

				return true;
			}
		}

		function buildItemData() {

			var shippingMethod = $shippingMethodSelector.val();
			var bundleItems = [];

			$bundleItems.each(function () {
				var _split = ($(this).find('select').val() || '').split('.'),
				    _split2 = _slicedToArray(_split, 2),
				    product = _split2[0],
				    variant = _split2[1];

				var bundleItemQuantity = $(this).find('input[type="number"]').val() || 0;

				if (!product || !variant) return;

				bundleItems.push({
					product: product,
					variant: variant,
					shippingMethod: bundleProductMap[product].type === 'tangible' ? shippingMethod : null,
					quantity: bundleItemQuantity ? parseInt(bundleItemQuantity) : null
				});
			});

			var itemQuantity = $itemQuantityInput.val() || 0;
			var variant = $variantSelector.val() || (product.variants.length === 1 ? product.variants[0]._id : null) || null;

			return {
				product: product._id,
				variant: variant,
				shippingMethod: shippingMethod,
				quantity: itemQuantity ? parseInt(itemQuantity) : null,
				bundleItems: bundleItems
			};
		}
	};
	return implementation;
};

},{"./lib/productCatalog.js":47,"lodash.set":345}],47:[function(require,module,exports){
'use strict';

module.exports = function ($container) {

	var catalogMap = {};

	var $details = $container.find('.thunder--product-catalog-detail');
	var $thumbnails = $container.find('.thunder--product-catalog-thumbnails img');

	$details.each(function () {
		catalogMap[getImageId($(this))] = $(this);
	});

	setCurrentImage(getImageId($details.eq(0)));

	// Click events for mobile devices..
	$thumbnails.on('click', function () {
		setCurrentImage(getImageId($(this)));
	});

	// Hover events for laptops
	$thumbnails.hover(function () {
		catalogMap[getImageId($(this))].addClass('active');
	}, function () {
		catalogMap[getImageId($(this))].removeClass('active');
	});

	function setCurrentImage(imageId) {
		setAnchor($details, imageId);
		setAnchor($thumbnails, imageId);
	}

	function setAnchor(images, imageId) {

		images.removeClass('anchored').filter(function () {
			return $(this).data().catalogImage === imageId;
		}).addClass('anchored');
	}

	function getImageId(selector) {

		return selector.data('catalogImage') || null;
	}
};

},{}],48:[function(require,module,exports){
'use strict';

module.exports = function (Thunder) {

	var implementation = {
		name: 'product-list'
	};

	implementation.options = function () {
		return {
			page: 1, // Which page of products?
			limit: 24, // How many products at once?
			sort: '-createdAt', // Default sort order
			fields: '', // Additional fields
			columns: 4, // How many columns? (css supports for 1-12)
			filter: '', // Extra filters. e.g., brand=abcd
			labels: Thunder.options.productLabels, // Product labels (unavailable, sold-out, discounted)
			imageWidth: 240, // Image width
			imageHeight: 240, // Image height
			showSummary: true, // Show `product.summary`
			showRating: // Show `product.rating`
			Thunder.options.productReview && Thunder.options.productReviewRating,
			showComparePrice: true, // Show `product.price.original`
			usePagination: true, // Use pagination?
			onViewProduct: function onViewProduct($container, context, productId) {
				return Thunder.open('product-detail', {
					product: productId
				});
			}
		};
	};

	implementation.pre = function (context, callback) {
		var _$;

		var options = context.options;

		var query = $.extend({
			bundled: false // Only display root products
		}, Thunder.util.parseQueryString(options.filter));

		var listQuery = $.extend({
			fields: ['thumbnail', 'slug', 'name', 'summary', 'price', 'discount', 'rating', 'available', 'variants.available', 'variants.quantity'].concat(Thunder.util.parseArrayString(options.fields)).join(','),
			page: options.page, // Page option
			limit: options.limit, // Limit option
			sort: options.sort // Sort option
		}, query);

		var countQuery = $.extend({
			raw: true
		}, query);

		var errors = {
			default: context.m('productListFailed')
		};

		var labels = Thunder.util.parseArrayString(options.labels).map(function (label) {
			return {
				label: label,
				check: {
					unavailable: function unavailable(product) {
						return !product.available || product.variants.every(function (v) {
							return !v.available;
						});
					},
					'sold-out': function soldOut(product) {
						return product.variants.every(function (v) {
							return v.quantity && v.quantity.raw === 0;
						});
					},
					discounted: function discounted(product) {
						return !!product.discount.type;
					}
				}[label]
			};
		}, {});

		return (_$ = $).when.apply(_$, [Thunder.request({
			method: 'GET',
			url: '/v1/products',
			query: listQuery
		}), context.options.usePagination ? Thunder.request({
			method: 'GET',
			url: '/v1/products/count',
			query: countQuery
		}) : null]).then(function (products, count) {

			context.count = count ? count[0].count : null;
			context.products = products[0].map(function (product) {

				product.label = (labels.find(function (_ref) {
					var check = _ref.check;
					return check(product);
				}) || { label: null }).label;

				return product;
			});

			return callback(null, context);
		}, function (err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
		});
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $product = $(this).find('.thunder--product');
		var $pagination = $(this).find('.thunder--product-list-pagination');

		$product.on('click', ['.thunder--product-thumbnail-wrapper', '.thunder--product-name', '.thunder--product-summary'].join(','), function (event) {
			return Thunder.execute(context.options.onViewProduct, $container, context, $(event.delegateTarget).data('product'));
		});

		if (context.options.usePagination) {

			Thunder.plugins.pagination({
				container: $pagination,
				currentPage: context.options.page,
				totalResult: context.count,
				resultPerPage: context.options.limit,
				onPageChange: function onPageChange(_ref2) {
					var page = _ref2.page;
					return Thunder.render($container, implementation.name, $.extend(context.options, { page: page }));
				}
			});
		}
	};

	return implementation;
};

},{}],49:[function(require,module,exports){
'use strict';

var get = require('lodash.get');
var set = require('lodash.set');

module.exports = function (Thunder) {

	var commentFields = ['customer', 'collaborator', 'body', 'flagged', 'createdAt'];

	// Implementation
	var implementation = {
		name: 'product-review-comments'
	};

	implementation.options = function () {
		return {
			review: null, // Review ID
			page: 1, // Which page of comments?
			limit: 10, // How many comments at once?
			sort: 'createdAt', // Default sort value
			filter: null, // Extra query filter
			useBodyExcerpt: 140, // Length of a body excerpt || false
			useFlag: true, // Use flag?
			usePagination: true, // Use Pagination?
			hasNoComments: false, // Has no comments? (when it's already known)
			confirmOnDelete: Thunder.options.confirmation.reviewCommentDelete, // Whether to confirm before deleting a review comment

			onUnauthenticatedWriteComment: function onUnauthenticatedWriteComment($container, context) {
				return Thunder.notify('info', context.m('loginRequired'));
			}
		};
	};

	implementation.pre = function (context, callback) {

		if (context.options.hasNoComments) {
			// If the review doesn't have any comments, do not call APIs.
			context.comments = [];
			context.count = { raw: 0, formatted: '0', converted: '0' };
			return callback(null, context);
		}

		var errors = {
			default: context.m('commentListFailed')
		};

		var defaultQuery = $.extend({
			review: context.options.review
		}, Thunder.util.parseQueryString(context.options.filter));

		return $.when(fetchComments(), countComments()).then(function (comments, count) {
			return callback(null, $.extend(context, {
				comments: (comments[0] || []).map(function (c) {
					return buildReviewComment(c, context.options.useBodyExcerpt);
				}),
				count: count ? count[0].count : null
			}));
		}, function (err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
		});

		function fetchComments() {

			var query = $.extend({}, defaultQuery, {
				page: context.options.page,
				limit: context.options.limit,
				sort: context.options.sort,
				fields: commentFields.join(',')
			});

			return Thunder.request({
				method: 'GET',
				url: '/v1/products/reviews/comments',
				query: query
			});
		}

		function countComments() {

			var query = $.extend({}, defaultQuery);

			delete query.ids;

			return Thunder.request({
				method: 'GET',
				url: '/v1/products/reviews/comments/count',
				query: query
			});
		}
	};

	implementation.init = function (context) {

		var commentMap = {};

		var $container = $(this);
		var $writeComment = $(this).find('.thunder--write-comment');
		var $hasNoComments = $(this).find('.thunder--review-has-no-comments');
		var $commentWriterContainer = $(this).find('.thunder--comment-writer-container');
		var $commentBody = $commentWriterContainer.find('textarea');
		var $postComment = $commentWriterContainer.find('.thunder--post-comment');
		var $cancelComment = $commentWriterContainer.find('.thunder--cancel-comment');
		var $commentList = $(this).find('.thunder--review-comment-list');
		var $pagination = $(this).find('.thunder--review-comment-list-pagination');

		updateCommentMap();

		$writeComment.on('click', startCommentWriting);
		$cancelComment.on('click', cancelComment);

		$container.on('click', '.thunder--read-more', readMore);
		$container.on('click', '.thunder--edit-review-comment', editComment);
		$container.on('click', '.thunder--delete-review-comment', deleteComment);
		$container.on('click', '.thunder--flag', flagComment);

		Thunder.util.makeRecaptcha({
			componentName: implementation.name,
			button: $postComment,
			validate: validateComment,
			callback: postComment
		});

		if (context.options.usePagination) {

			Thunder.plugins.pagination({
				type: 'simple',
				container: $pagination,
				currentPage: context.options.page,
				totalResult: context.count.raw,
				resultPerPage: context.options.limit,
				onPageChange: function onPageChange(_ref) {
					var page = _ref.page;
					return Thunder.render($container, implementation.name, $.extend(context.options, { page: page }));
				}
			});
		}

		function updateCommentMap() {

			commentMap = context.comments.reduce(function (o, comment) {
				return set(o, comment._id, comment);
			}, {});
		}

		function startCommentWriting(event) {

			event.preventDefault();

			if (Thunder.authenticated()) {
				return showCommentWriter();
			}

			return Thunder.execute(context.options.onUnauthenticatedWriteComment, $container, context);
		}

		function getComment() {
			return {
				review: context.options.review,
				body: $commentBody.val()
			};
		}

		function validateComment(comment) {

			comment = comment || getComment();

			if (!comment.body) {
				Thunder.notify('error', context.m('bodyRequired'));
				return false;
			}

			return true;
		}

		function postComment(token, resetRecaptcha) {

			var resetState = function resetState() {
				return resetRecaptcha && resetRecaptcha();
			};

			var data = getComment();

			return createComment(data).then(function (comment) {
				return fetchComment(comment);
			}).then(function (comment) {
				return done(comment);
			});

			function done(comment) {

				comment = buildReviewComment(comment, context.options.useBodyExcerpt);

				context.comments.unshift(comment);

				updateCommentMap();

				var $template = $(Thunder.component(implementation.name).template($.extend({}, context, {
					comments: [comment]
				})));

				var $comment = $($template.find('.thunder--review-comment-list').html());

				$commentList.prepend($comment);

				cancelComment();

				resetState();

				$hasNoComments.remove();

				return Thunder.notify('success', context.m('commentPostSuccess'));
			}

			function createComment(data) {

				var errors = {
					default: context.m('commentPostFailed')
				};

				return Thunder.request({
					method: 'POST',
					url: '/v1/me/products/reviews/comments',
					data: data,
					recaptcha: token
				}).then(null, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors, resetState);
				});
			}

			function fetchComment(comment) {

				var errors = {
					default: context.m('commentReadFailed')
				};

				return Thunder.request({
					method: 'GET',
					url: '/v1/products/reviews/comments/' + comment._id,
					query: {
						fields: commentFields.join(',')
					}
				}).then(null, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors, resetState);
				});
			}
		}

		function cancelComment(event) {

			if (event) event.preventDefault();

			$commentBody.val(null);
			hideCommentWriter();
		}

		function showCommentWriter() {
			$writeComment.hide();
			$commentWriterContainer.show();
		}

		function hideCommentWriter() {
			$writeComment.show();
			$commentWriterContainer.hide();
		}

		function readMore(event) {

			event.preventDefault();

			var $comment = $(this).parents('[data-review-comment]');
			var commentId = $comment.data('reviewComment');
			var body = commentMap[commentId].body;

			$comment.find('.thunder--review-comment-body').html(body);
		}

		function editComment(event) {
			var _this = this;

			event.preventDefault();

			var isEditing = $(this).data('editing');
			var $comment = $(this).parents('[data-review-comment]');
			var commentId = $comment.data('reviewComment');

			if (isEditing) {

				var $input = $comment.find('textarea.thunder--review-comment-body');

				var data = { body: $input.val() || null };

				if (!validateComment(data)) {
					return;
				}

				var errors = {
					default: context.m('saveFailed')
				};

				return Thunder.request({
					method: 'PUT',
					url: '/v1/me/products/reviews/comments/' + commentId,
					data: data
				}).then(function (comment) {

					$(_this).text(context.m('editComment'));
					$(_this).data('editing', false);

					var $body = $('<div class="' + $input.attr('class') + '"></div>');

					$body.html(comment.body);

					$input.replaceWith($body);

					return Thunder.notify('success', context.m('saveSuccess'));
				}, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors);
				});
			} else {

				var comment = commentMap[commentId];

				var $body = $comment.find('.thunder--review-comment-body');

				var _$input = $('<textarea class="' + $body.attr('class') + '">' + (comment.body || '') + '</textarea>');

				$body.replaceWith(_$input);

				$(this).text(context.m('saveComment'));
				$(this).data('editing', true);
			}
		}

		function deleteComment(event) {
			var _this2 = this;

			if (event) event.preventDefault();

			var removeComment = function removeComment() {

				var $comment = $(_this2).parents('[data-review-comment]');
				var commentId = $comment.data('reviewComment');

				var errors = {
					default: context.m('deleteFailed')
				};

				return Thunder.request({
					method: 'DELETE',
					url: '/v1/me/products/reviews/comments/' + commentId
				}).then(function () {
					$comment.addClass('hidden').hide();
					return Thunder.notify('success', context.m('deleteSuccess'));
				}, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors);
				});
			};

			if (!context.options.confirmOnDelete) {
				return removeComment();
			}

			return Thunder.plugins.confirmation(context.m('deleteConfirm'), function () {
				return removeComment();
			});
		}

		function flagComment(event) {

			if (event) event.preventDefault();

			var commentId = $(this).parents('[data-review-comment]').data('reviewComment');

			var errors = {
				default: context.m('flagFailed'),
				'duplicated-flag': context.m('duplicatedFlag')
			};

			return Thunder.request({
				method: 'POST',
				url: '/v1/me/products/reviews/comments/' + commentId + '/flags'
			}).then(function () {
				return Thunder.notify('success', context.m('flagSuccess'));
			}, function (err) {
				return Thunder.util.requestErrorHandler(err.responseJSON, errors);
			});
		}
	};

	return implementation;

	function buildReviewComment(comment, useBodyExcerpt) {

		var customer = get(Thunder.authenticated('customer'), 'sub', 'unauthenticated');

		comment.editable = get(comment, 'customer._id') === customer;
		comment.excerpt = Thunder.util.excerpt(comment.body, useBodyExcerpt) || '';
		comment.body = comment.body || '';

		return comment;
	}
};

},{"lodash.get":341,"lodash.set":345}],50:[function(require,module,exports){
'use strict';

module.exports = function (Thunder) {

	var reviewFields = ['customer', 'title', 'body', 'images', 'rating', 'helped', 'flagged', 'totalComment', 'createdAt'];

	// Implementation
	var implementation = {
		name: 'product-review-writer'
	};

	implementation.options = function () {
		return {

			product: null, // Product ID to write a review
			useRating: Thunder.options.productReviewRating, // Use rating?

			onReviewPost: function onReviewPost($container, context, review) {},
			onReviewCancel: function onReviewCancel($container, context) {}

		};
	};

	implementation.pre = function (context, callback) {

		return callback(null, context);
	};

	implementation.init = function (context) {

		var review = { images: [] };

		var $container = $(this);
		var $writeReviewForm = $(this).find('.thunder--write-review-form');
		var $writeReviewImageForm = $(this).find('.thunder--review-image-form');
		var $writeReviewImages = $writeReviewImageForm.find('.thunder--review-images');
		var $postReview = $(this).find('.thunder--post-product-review');
		var $cancelReview = $(this).find('.thunder--cancel-product-review');

		$cancelReview.on('click', cancelReviewWriting);

		$container.on('click', '.thunder--delete-review-image', function () {

			var imageId = $(this).parents('[data-image]').data('image');

			return removeImage(imageId);
		});

		Thunder.util.makeRecaptcha({
			componentName: implementation.name,
			button: $postReview,
			validate: validateReview,
			callback: postReview
		});

		Thunder.util.imageUploader($writeReviewImageForm, function (image) {
			return addImage(image);
		}, function () {
			return Thunder.notify('error', context.m('imageUploadFailed'));
		});

		function cancelReviewWriting(event) {

			if (event) event.preventDefault();

			// Possibly a bug from Babel?
			// `review.images` actually contains multiple id,
			// but `removeImage()` only gets called once in `.forEach`
			review.images.forEach(function (imageId) {
				setTimeout(function () {
					return removeImage(imageId);
				}, 0);
			});

			resetForm();

			return Thunder.execute(context.options.onReviewCancel, $container, context);
		}

		function resetForm() {

			review.images.forEach(function (imageId) {
				return removeImage(imageId, true);
			});

			$writeReviewForm.find('select').val(5);
			$writeReviewForm.find('input[type="text"],textarea').each(function () {
				$(this).val(null);
			});
			$writeReviewImageForm.find('input[type="file"]').val(null);
		}

		function getReview() {

			return $.extend(Thunder.util.formToJSON($writeReviewForm.serializeArray()), review);
		}

		function addImage(image) {

			// Update review
			review.images.push(image._id);

			// Update DOM
			$writeReviewImages.append(('\n\t\t\t\t<div class="thunder--review-image" data-image="' + image._id + '">\n\t\t\t\t\t<img src="' + Thunder.util.imageURL(image, 120, 120) + '">\n\t\t\t\t\t<span class="thunder--delete-review-image">' + context.m('deleteImage') + '</span>\n\t\t\t\t</div>\n\t\t\t').trim());
		}

		function removeImage(imageId) {
			var doNotDelete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


			// Update review
			review.images.splice(review.images.indexOf(imageId), 1);

			// Update DOM
			$writeReviewImages.find('[data-image="' + imageId + '"]').remove();

			if (doNotDelete) return;

			// Remove from the storage (Fire & Forget)
			return Thunder.request({
				method: 'DELETE',
				url: '/v1/me/images/' + imageId
			});
		}

		function validateReview() {

			var review = getReview();

			if (!review.title) {
				Thunder.notify('error', context.m('titleRequired'));
				return false;
			}

			return true;
		}

		function postReview(token, resetRecaptcha) {

			var resetState = function resetState() {
				return resetRecaptcha && resetRecaptcha();
			};

			return createReview().then(function (review) {
				return fetchReview(review);
			}).then(function (review) {
				return done(review);
			});

			function done(review) {

				resetForm();

				Thunder.notify('success', context.m('reviewPostSuccess'));

				return Thunder.execute(context.options.onReviewPost, $container, context, review);
			}

			function createReview() {

				var errors = {
					'not-purchased-product': context.m('notPurchasedProduct'),
					default: context.m('reviewPostFailed')
				};

				return Thunder.request({
					method: 'POST',
					url: '/v1/me/products/reviews',
					data: getReview(),
					recaptcha: token
				}).then(null, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors, resetState);
				});
			}

			function fetchReview(review) {

				var errors = {
					default: context.m('reviewReadFailed')
				};

				return Thunder.request({
					method: 'GET',
					url: '/v1/products/reviews/published/' + review._id,
					query: { fields: reviewFields.join(',') }
				}).then(null, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors, resetState);
				});
			}
		}
	};

	return implementation;
};

},{}],51:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var get = require('lodash.get');
var set = require('lodash.set');

module.exports = function (Thunder) {

	var reviewQuery = function reviewQuery(showProduct) {
		return {
			fields: ['customer', 'title', 'body', 'images', 'rating', 'helped', 'flagged', 'totalComment', 'createdAt'].concat(showProduct ? 'product' : []).join(','),
			embed: '+product.thumbnail'
		};
	};

	// Implementation
	var implementation = {
		name: 'product-review'
	};

	implementation.options = function () {
		return {
			review: null, // Review ID or review object
			useCustomerAvatar: Thunder.options.customerAvatar, // Use customer avatar
			useBodyExcerpt: 140, // Body excerpt length || false
			useRating: Thunder.options.productReviewRating, // Use rating?
			useHelpVote: true, // Use helpful votes?
			useFlag: true, // Use flag?
			useComments: Thunder.options.productReviewComment, // Use review comments?
			confirmOnDelete: Thunder.options.confirmation.reviewDelete, // Whether to confirm before deleting a review
			showProduct: false, // Show product detail?
			// Load & Show comments from the beginning?
			// (If it's an object, it will be passed as an option to `product-review-comments` component)
			showComments: false,

			onDelete: function onDelete($container, context) {

				return Thunder.notify('success', context.m('deleteSuccess'));
			}
		};
	};

	implementation.pre = function (context, callback) {

		var review = context.options.review;

		if ((typeof review === 'undefined' ? 'undefined' : _typeof(review)) === 'object') {

			return callback(null, setReview(review));
		}

		var errors = {
			default: context.m('reviewReadFailed')
		};

		return Thunder.request({
			method: 'GET',
			url: '/v1/products/reviews/published/' + review,
			query: reviewQuery(context.options.showProduct)
		}).then(function (review) {

			return callback(null, setReview(review));
		}, function (err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
		});

		function setReview(review) {
			return set(context, 'review', buildReview(review, context.options.useBodyExcerpt));
		}
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $review = $container.find('.thunder--product-review');
		var $imageForm = $container.find('.thunder--edit-review-image-form');
		var $reviewImages = $container.find('.thunder--review-images');

		$container.on('click', '.thunder--helped-vote', helpVote);
		$container.on('click', '.thunder--flag', flag);
		$container.on('click', '.thunder--edit-product-review', editReview);
		$container.on('click', '.thunder--delete-product-review', deleteReview);
		$container.on('click', '.thunder--delete-review-image', function () {

			var $imageList = $(this).parents('.thunder--review-images');
			var imageId = $(this).parents('[data-image]').data('image');

			return removeImage($imageList, context.review, imageId);
		});

		$container.on('click', '.thunder--read-more', function () {

			var $reviewBody = $(this).parents('.thunder--product-review-body');

			$reviewBody.html(context.review.body);
		});

		$container.on('click', '.thunder--show-product-review-comment', showComments);

		Thunder.util.imageUploader($imageForm, function (image) {
			return addImage($reviewImages, context.review, image);
		}, function () {
			return Thunder.notify('error', context.m('imageUploadFailed'));
		});

		if (context.options.useComments && context.options.showComments) {
			// If `showComments` option is set to `true`,
			// render comments when the component initiates.
			showComments();
		}

		function validateReview(review) {

			if (!review.title) {
				return 'titleRequired';
			}

			return null;
		}

		function addImage($imageList, review, image) {

			// Update review
			review.images.push(image);

			// Update DOM
			$imageList.append(('\n\t\t\t\t<div class="thunder--review-image" data-image="' + image._id + '">\n\t\t\t\t\t<img src="' + Thunder.util.imageURL(image, 120, 120) + '">\n\t\t\t\t\t<span class="thunder--delete-review-image">' + context.m('deleteImage') + '</span>\n\t\t\t\t</div>\n\t\t\t').trim());
		}

		function removeImage($imageList, review, imageId) {

			var image = review.images.find(function (image) {
				return image && image._id === imageId;
			});

			if (!image) return;

			// Update review
			review.images.splice(review.images.indexOf(image), 1);

			// Update DOM
			$imageList.find('[data-image="' + imageId + '"]').remove();

			// Remove from the storage (Fire & Forget)
			return Thunder.request({
				method: 'DELETE',
				url: '/v1/me/images/' + imageId
			});
		}

		function helpVote(event) {

			event.preventDefault();

			var review = context.review;
			var upDown = $(this).data('type');

			var errors = {
				unauthorized: { type: 'info', message: context.m('loginRequired') },
				'duplicated-vote': context.m('duplicatedVote'),
				default: context.m('helpVoteFailed')
			};

			return Thunder.request({
				method: 'POST',
				url: '/v1/me/products/reviews/' + review._id + '/helped/' + upDown
			}).then(function () {
				return Thunder.notify('success', context.m('helpVoteSuccess'));
			}, function (err) {
				return Thunder.util.requestErrorHandler(err.responseJSON, errors);
			});
		}

		function flag(event) {

			event.preventDefault();

			var review = context.review;

			var errors = {
				unauthorized: { type: 'info', message: context.m('loginRequired') },
				'duplicated-flag': context.m('duplicatedFlag'),
				default: context.m('flagFailed')
			};

			return Thunder.request({
				method: 'POST',
				url: '/v1/me/products/reviews/' + review._id + '/flags'
			}).then(function () {
				return Thunder.notify('success', context.m('flagSuccess'));
			}, function (err) {
				return Thunder.util.requestErrorHandler(err.responseJSON, errors);
			});
		}

		function editReview(event) {

			event.preventDefault();

			var isEditing = $review.data('editing') || false;

			if (isEditing) {
				endReviewEditing();
				$review.removeClass('editing');
				$(this).text(context.m('editReview'));
			} else {
				startReviewEditing();
				$review.addClass('editing');
				$(this).text(context.m('saveReview'));
			}

			$review.data('editing', !isEditing);
		}

		function startReviewEditing() {

			var review = context.review;

			var $rating = $container.find('.thunder--review-stars');
			var $title = $container.find('.thunder--product-review-title');
			var $body = $container.find('.thunder--product-review-body');

			var $newRating = $(Thunder.ui('review-star-rating')($rating.data('rating'))).addClass($rating.attr('class'));
			var $newTitle = $('<input class="' + $title.attr('class') + '" type="text" value="' + review.title + '" required>');
			var $newBody = $('<textarea class="' + $body.attr('class') + '">' + review.body + '</textarea>');

			$rating.replaceWith($newRating);
			$title.replaceWith($newTitle);
			$body.replaceWith($newBody);
		}

		function endReviewEditing() {

			var review = context.review;

			var data = {
				rating: $container.find('.thunder--review-stars').val(),
				title: $container.find('.thunder--product-review-title').val(),
				body: $container.find('.thunder--product-review-body').val(),
				images: $container.find('.thunder--review-images [data-image]').map(function () {
					return $(this).data('image');
				}).get()
			};

			var errorCode = validateReview(data);

			if (errorCode) {
				return Thunder.notify('error', context.m(errorCode));
			}

			return updateReview(data).then(function (review) {
				return fetchReview(review);
			}).then(function (review) {
				return done(review);
			});

			function done(review) {

				context.review = review;

				Thunder.render($container, implementation.name, context);

				return Thunder.notify('success', context.m('reviewSaveSuccess'));
			}

			function updateReview(data) {

				var errors = {
					default: context.m('reviewSaveFailed')
				};

				return Thunder.request({
					method: 'PUT',
					url: '/v1/me/products/reviews/' + review._id,
					data: data
				}).then(null, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors);
				});
			}

			function fetchReview(review) {

				var errors = {
					default: context.m('reviewReadFailed')
				};

				return Thunder.request({
					method: 'GET',
					url: '/v1/products/reviews/published/' + review._id,
					query: reviewQuery(context.options.showProduct)
				}).then(null, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors);
				});
			}
		}

		function deleteReview(event) {

			event.preventDefault();

			var removeReview = function removeReview() {

				var review = context.review;

				deleteReviewImages(review);

				var errors = {
					default: context.m('deleteFailed')
				};

				return Thunder.request({
					method: 'DELETE',
					url: '/v1/me/products/reviews/' + review._id
				}).then(function () {

					// Hide the review
					$container.addClass('hidden').hide();

					// Hide comments of the review
					$container.next('.thunder--review-comments-container').addClass('hidden').hide();

					return Thunder.execute(context.options.onDelete, $container, context);
				}, function (err) {
					return Thunder.util.requestErrorHandler(err.responseJSON, errors);
				});
			};

			if (!context.options.confirmOnDelete) {
				return removeReview();
			}

			return Thunder.plugins.confirmation(context.m('deleteConfirm'), function () {
				return removeReview();
			});
		}

		function deleteReviewImages(review) {
			var _$;

			var errors = {
				default: context.m('imageDeleteFailed')
			};

			return (_$ = $).when.apply(_$, _toConsumableArray(review.images.map(function (image) {
				return Thunder.request({
					method: 'DELETE',
					url: '/v1/me/images/' + (image._id || image)
				});
			}))).then(null, function (err) {
				return Thunder.util.requestErrorHandler(err.responseJSON, errors);
			});
		}

		function showComments() {

			if (context.commentsLoaded) {
				return;
			}

			context.commentsLoaded = true;

			var review = context.review;

			var $commentsContainer = $('<div class="thunder--review-comments-container" data-review="' + review._id + '"></div>');

			$commentsContainer.insertAfter($container);

			return Thunder.render($commentsContainer, 'product-review-comments', $.extend(
			// Use `showComments` as an option when it's an object.
			_typeof(context.options.showComments) === 'object' ? context.options.showComments : {}, {
				review: review._id,
				hasNoComments: context.review.totalComment.raw === 0
			}));
		}
	};

	return implementation;

	function buildReview(review, useBodyExcerpt) {

		var customer = get(Thunder.authenticated('customer'), 'sub', 'unauthenticated');

		review.editable = get(review, 'customer._id') === customer;
		review.excerpt = Thunder.util.excerpt(review.body, useBodyExcerpt) || '';
		review.body = review.body || '';

		return review;
	}
};

},{"lodash.get":341,"lodash.set":345}],52:[function(require,module,exports){
'use strict';

module.exports = function (Thunder) {

	var implementation = {
		name: 'product-reviews'
	};

	implementation.options = function () {
		return {
			product: null, // Product ID
			page: 1, // Which page of products?
			limit: 10, // How many products at once?
			sort: '-createdAt', // Default sort value
			productRating: null, // Product rating?
			useCustomerAvatar: Thunder.options.customerAvatar, // Use customer avatar?
			useBodyExcerpt: 140, // Body excerpt length || false
			useRating: // Use rating?
			Thunder.options.productReview && Thunder.options.productReviewRating,
			useHelpVote: true, // Use helpful votes?
			useFlag: true, // Use flag?
			useComments: Thunder.options.productReviewComment, // Use comments?
			usePagination: true, // Use Pagination?

			onUnauthenticatedWriteReview: function onUnauthenticatedWriteReview($container, context) {
				return Thunder.notify('info', context.m('loginRequired'));
			}
		};
	};

	implementation.pre = function (context, callback) {

		var errors = {
			default: context.m('reviewListFailed')
		};

		return $.when(fetchReviews(), countReviews()).then(function (reviews, count) {
			return callback(null, $.extend(context, {
				reviews: reviews[0] || [],
				count: count ? count[0].count : null
			}));
		}, function (err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
		});

		function fetchReviews() {
			return Thunder.request({
				method: 'GET',
				url: '/v1/products/reviews/published',
				query: {
					product: context.options.product,
					page: context.options.page,
					limit: context.options.limit,
					sort: context.options.sort,
					fields: ['customer', 'title', 'body', 'images', 'rating', 'helped', 'flagged', 'totalComment', 'createdAt'].join(',')
				}
			});
		}

		function countReviews() {

			return Thunder.request({
				method: 'GET',
				url: '/v1/products/reviews/published/count',
				query: {
					product: context.options.product
				}
			});
		}
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $writeReview = $(this).find('.thunder--write-review');
		var $reviewList = $(this).find('.thunder--product-review-list');
		var $pagination = $(this).find('.thunder--product-review-list-pagination');
		var $reviewWriterContainer = $(this).find('.thunder--review-writer-container');

		$writeReview.on('click', startReviewWriting);

		Thunder.render($reviewWriterContainer, 'product-review-writer', {
			product: context.options.product,
			useRating: context.options.useRating,
			onReviewPost: onReviewPost,
			onReviewCancel: function onReviewCancel() {
				return hideReviewWriter();
			}
		});

		context.reviews.forEach(function (review) {
			return renderReview('append', review);
		});

		if (context.options.usePagination) {

			Thunder.plugins.pagination({
				container: $pagination,
				currentPage: context.options.page,
				totalResult: context.count.raw,
				resultPerPage: context.options.limit,
				onPageChange: function onPageChange(_ref) {
					var page = _ref.page;
					return Thunder.render($container, implementation.name, $.extend(context.options, { page: page }));
				}
			});
		}

		function renderReview(command, review) {

			var $reviewContainer = $('<div class="thunder--product-review-wrapper" data-review="' + review._id + '"></div>');

			$reviewList[command]($reviewContainer);

			return Thunder.render($reviewContainer, 'product-review', {
				review: review,
				useCustomerAvatar: context.options.useCustomerAvatar,
				useBodyExcerpt: context.options.useBodyExcerpt,
				useRating: context.options.useRating,
				useHelpVote: context.options.useHelpVote,
				useFlag: context.options.useFlag,
				useComments: context.options.useComments,
				showProduct: false,
				showComments: false
			});
		}

		function startReviewWriting(event) {

			event.preventDefault();

			if (Thunder.authenticated()) {
				return showReviewWriter();
			}

			return Thunder.execute(context.options.onUnauthenticatedWriteReview, $container, context);
		}

		function onReviewPost(_$container, _context, review) {

			context.reviews.unshift(review);

			hideReviewWriter();
			renderReview('prepend', review);
		}

		function showReviewWriter() {
			$writeReview.hide();
			$reviewWriterContainer.show();
		}

		function hideReviewWriter() {
			$writeReview.show();
			$reviewWriterContainer.hide();
		}
	};

	return implementation;
};

},{}],53:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

module.exports = function (Thunder) {

	var implementation = {
		name: 'search-purchase'
	};

	implementation.options = function () {
		return {
			type: 'order', // 'order' || 'subscription'

			onSearch: function onSearch($container, context, subject) {

				var type = context.options.type;

				Thunder.render($container, type + '-detail', _defineProperty({}, type, subject));
			}
		};
	};

	implementation.pre = function (context, callback) {

		var translationKeys = {
			'name.first': 'firstName',
			'name.last': 'lastName',
			'name.full': 'fullName'
		};

		context.authFields = Thunder.options.orderAuthFields.map(function (field) {
			return {
				key: field,
				translationKey: translationKeys[field] || field
			};
		});

		context.showLinks = {
			order: true,
			subscription: !!Thunder.options.paymentMethods.subscription
		};

		return callback(null, context);
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $form = $(this).find('.thunder--search-purchase-form');
		var $button = $form.find('.thunder--search-purchase');
		var $goToSearch = $(this).find('.thunder--go-to-search-purchase');
		var buttonSpinner = Thunder.util.makeAsyncButton($button);

		$goToSearch.on('click', goToSearch);

		Thunder.util.makeRecaptcha(implementation.name, $button, function (token, resetRecaptcha) {

			var type = context.options.type;
			var data = Thunder.util.formToJSON($form.serializeArray());
			var subject = data.subject;

			delete data.subject;

			var resetState = function resetState() {
				buttonSpinner.done();
				return resetRecaptcha && resetRecaptcha();
			};

			var errors = {
				'not-existing-order': context.m('notExistingOrder'),
				'not-existing-subscription': context.m('notExistingSubscription'),
				'invalid-customer-info': context.m('invalidCustomerInfo'),
				default: context.m('searchFailed')
			};

			return Thunder.request({
				method: 'POST',
				url: '/v1/' + type + 's/' + subject + '/auth',
				data: data
			}).then(function (authResult) {

				var storage = Thunder.plugins.credentialStorage;
				var token = authResult.token;

				// Set auth token in the storage.
				storage.setItem(Thunder.options.authStorage.order, token);

				Thunder.execute(context.options.onSearch, $container, context, subject);

				return resetState();
			}, function (err) {
				return Thunder.util.requestErrorHandler(err.responseJSON, errors, function () {
					return resetState();
				});
			});
		});

		function goToSearch() {

			return Thunder.render($container, 'search-purchase', {
				type: $(this).data('type')
			});
		}
	};

	return implementation;
};

},{}],54:[function(require,module,exports){
'use strict';

var get = require('lodash.get');
var set = require('lodash.set');
var camelCase = require('lodash.camelcase');

module.exports = function (Thunder) {

	var implementation = {
		name: 'subscription-detail'
	};

	implementation.options = function () {
		return {
			subscription: '', // Subscription ID to render
			customerFields: Thunder.options.customerOrderFields.map(function (field) {
				return field.split(':')[0];
			}),
			recipientFields: Thunder.options.recipientFields.map(function (field) {
				return field.split(':')[0];
			})
		};
	};

	implementation.pre = function (context, callback) {
		var subscription = context.options.subscription;


		context.couponDetail = function (coupon) {

			if (!coupon) return '';

			return [context.m('discountedBy', { value: coupon.discount.value.converted }), '&#10;(', context.m({
				first: 'firstNTimesDiscounted',
				last: 'lastNTimesDiscounted',
				every: 'allDiscounted'
			}[coupon.subscription.type], {
				count: get(coupon.subscription, 'value.converted'),
				smart_count: get(coupon.subscription, 'value.raw')
			}), ')'].join('');
		};

		var translationKeys = {
			'name.first': 'firstName',
			'name.last': 'lastName',
			'name.full': 'fullName'
		};

		context.customerFields = Thunder.util.parseArrayString(context.options.customerFields).map(function (key) {
			return {
				key: key,
				translationKey: camelCase(['customer', translationKeys[key] || key])
			};
		});

		context.recipientFields = Thunder.util.parseArrayString(context.options.recipientFields).map(function (key) {
			return {
				key: key,
				translationKey: camelCase(['address', translationKeys[key] || key])
			};
		});

		var errors = {
			default: context.m('subscriptionReadFailed')
		};

		return Thunder.request({
			method: 'GET',
			url: '/v1/me/subscriptions/' + subscription
		}).then(function (subscription) {

			var itemMap = subscription.items.reduce(function (o, item) {
				return [].concat(item, item.bundleItems || []).reduce(function (o, item) {
					return set(o, item._id, item);
				}, o);
			}, {});

			var discount = subscription.discount || {};

			Object.keys(discount).forEach(function (scope) {

				if (scope === 'shipping') {
					// IMPORTANT: For now we will only display 'items' and 'cart' coupons
					return;
				}

				[].concat(discount[scope]).forEach(function (_ref) {
					var item = _ref.item,
					    coupon = _ref.coupon;


					if (!coupon) return;

					return item ? set(itemMap[item._id], 'appliedCoupon', coupon) : set(subscription, 'appliedCoupon', coupon);
				});
			});

			var scheduleStatus = subscription.status === 'cancelled' ? 'cancelled' : null;

			subscription.schedules.forEach(function (schedule) {
				// When the subscription is cancelled,
				// make all schedules' statuses as 'cancelled' as well unless a schedule is 'done'.
				schedule.status = schedule.status === 'done' ? schedule.status : scheduleStatus || schedule.status;
			});

			context.subscription = subscription;

			// Set payment details.
			var paymentMethod = subscription.paymentMethod;

			var thunderPaymentMethodMap = Thunder.options.paymentMethods.subscription.reduce(function (o, p) {
				return set(o, p.id, p);
			}, {});

			var thunderPaymentMethod = thunderPaymentMethodMap[paymentMethod._id] || thunderPaymentMethodMap[paymentMethod.slug];

			var shouldPay = subscription.status === 'pending' && thunderPaymentMethod;

			context.paymentMethod = thunderPaymentMethod;
			context.shouldPay = shouldPay;

			return callback(null, context);
		}, function (err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
		});
	};

	implementation.init = function (context) {
		var subscription = context.subscription,
		    paymentMethod = context.paymentMethod,
		    shouldPay = context.shouldPay;


		var $container = $(this);
		var $backToSubscriptions = $(this).find('.thunder--back-to-subscriptions');
		var $cancelSubscription = $(this).find('.thunder--cancel-subscription');
		var $cancellationForm = $(this).find('.thunder--subscription-cancellation-form');
		var $cancellationReason = $cancellationForm.find('textarea');
		var $cancelButton = $cancellationForm.find('button');
		var $viewOrder = $(this).find('[data-order][data-status="done"]');
		var $omittedSchedules = $(this).find('.thunder--subscription-omitted-schedules');
		var $viewAllSchedules = $(this).find('.thunder--view-all-schedules');
		var $hiddenSchedules = $(this).find('.thunder--subscription-schedule.hidden');

		var cancelButtonSpinner = Thunder.util.makeAsyncButton($cancelButton);

		$cancelSubscription.on('click', startCancellation);
		$cancelButton.on('click', cancelSubscription);
		$viewAllSchedules.on('click', viewAllSchedules);
		$viewOrder.on('click', '.thunder--schedule-order', function (event) {
			return Thunder.render($container, 'order-detail', {
				order: $(event.delegateTarget).data('order'),
				back: {
					$container: $container,
					component: implementation.name,
					options: context.options
				}
			});
		});

		Thunder.util.bindBackButton($backToSubscriptions, context);

		// Render a payment form if it's needed.
		if (shouldPay) {

			var $paymentFormContainer = $(this).find('.thunder--payment-form-container');
			var $makePayment = $(this).find('.thunder--make-payment');
			var makePaymentSpinner = Thunder.util.makeAsyncButton($makePayment, { bind: false });

			Thunder.render($paymentFormContainer, 'payment-form', {
				type: 'subscription',
				paymentMethods: [paymentMethod.id]
			}, function (err, _ref2) {
				var paymentHandler = _ref2.interfaces;
				return $makePayment.on('click', function () {

					var validationError = paymentHandler.validate();

					if (validationError) {
						return Thunder.notify('error', validationError.message);
					}

					var card = paymentHandler.getCard();

					makePaymentSpinner.run();

					return paymentHandler.makePayment({
						subscription: subscription,
						customer: subscription.customer
					}, function (err) {

						if (err) {
							Thunder.notify('error', context.m('paymentFailed'));
							return makePaymentSpinner.done();
						}

						var errors = {
							default: context.m('schedulingFailed')
						};

						return Thunder.request({
							method: 'POST',
							url: '/v1/me/subscriptions/' + subscription._id + '/scheduled',
							data: card ? { card: card } : {}
						}).then(function () {

							Thunder.notify('success', context.m('schedulingSuccess'));
							makePaymentSpinner.done();
							return Thunder.render($container, implementation.name, context.options);
						}, function (err) {
							return Thunder.util.requestErrorHandler(err.responseJSON, errors, function () {
								return makePaymentSpinner.done();
							});
						});
					});
				});
			});
		}

		function startCancellation() {
			$(this).addClass('hidden');
			$cancellationForm.removeClass('hidden');
			$cancellationReason.focus();
		}

		function cancelSubscription(event) {

			event.preventDefault();

			var data = Thunder.util.formToJSON($cancellationForm.serializeArray());

			var errors = {
				'invalid-subscription-status': context.m('invalidSubscriptionStatus'),
				default: context.m('cancellationFailed')
			};

			var resetState = function resetState() {
				cancelButtonSpinner.done();
			};

			return Thunder.request({
				method: 'POST',
				url: '/v1/me/subscriptions/' + subscription._id + '/cancellation',
				data: data
			}).then(function () {

				resetState();

				Thunder.notify('success', context.m('cancellationSuccess'));

				return Thunder.render($container, implementation.name, context.options);
			}, function (err) {
				return Thunder.util.requestErrorHandler(err.responseJSON, errors, resetState);
			});
		}

		function viewAllSchedules() {
			$omittedSchedules.addClass('hidden');
			$hiddenSchedules.removeClass('hidden');
		}
	};

	return implementation;
};

},{"lodash.camelcase":340,"lodash.get":341,"lodash.set":345}],55:[function(require,module,exports){
'use strict';

module.exports = function (Thunder) {

	var implementation = {
		name: 'subscription-list'
	};

	implementation.options = function () {
		return {
			page: 1, // Which page of subscriptions?
			limit: 10, // How many subscriptions at once?
			usePagination: true, // Use pagination?
			onViewSubscription: function onViewSubscription($container, context, subscriptionId) {

				return Thunder.render($container, 'subscription-detail', {
					subscription: subscriptionId,
					back: {
						$container: $container,
						component: implementation.name,
						options: context.options
					}
				});
			}
		};
	};

	implementation.pre = function (context, callback) {

		var errors = {
			default: context.m('subscriptionListFailed')
		};

		return $.when(Thunder.request({
			method: 'GET',
			url: '/v1/me/subscriptions',
			query: {
				page: context.options.page,
				limit: context.options.limit,
				sort: '-createdAt',
				fields: ['status', 'plan', 'schedules', 'items.product', 'cancellation', 'endsAt', 'createdAt'].join(',')
			}
		}), context.options.usePagination ? Thunder.request({
			method: 'GET',
			url: '/v1/me/subscriptions/count',
			query: {
				raw: true
			}
		}) : null).then(function (subscriptions, count) {

			context.subscriptions = (subscriptions[0] || []).map(function (s) {

				s.maxScheduledAmount = s.schedules.reduce(function (max, s) {
					return max > s.amount.raw ? max : s.amount;
				}, 0);

				s.duration = [s.schedules[0].time === 'now' ? s.createdAt : s.schedules[0].time, s.endsAt];

				return s;
			});

			context.count = count ? count[0].count : null;

			return callback(null, context);
		}, function (err) {
			return Thunder.util.requestErrorHandler(err.responseJSON, errors, callback);
		});
	};

	implementation.init = function (context) {

		var $container = $(this);
		var $subscription = $(this).find('[data-subscription]');
		var $pagination = $(this).find('.thunder--subscription-list-pagination');

		$subscription.on('click', ['.thunder--subscription-id', '.thunder--subscription-thumbnail', '.thunder--subscription-first-item', '.thunder--subscription-rest-items'].join(','), function (event) {
			return Thunder.execute(context.options.onViewSubscription, $container, context, $(event.delegateTarget).data('subscription'));
		});

		if (context.options.usePagination) {

			Thunder.plugins.pagination({
				container: $pagination,
				currentPage: context.options.page,
				totalResult: context.count,
				resultPerPage: context.options.limit,
				onPageChange: function onPageChange(_ref) {
					var page = _ref.page;
					return Thunder.render($container, implementation.name, $.extend(context.options, { page: page }));
				}
			});
		}
	};

	return implementation;
};

},{}],56:[function(require,module,exports){
"use strict";

module.exports = localStorage;

},{}],57:[function(require,module,exports){
"use strict";

module.exports = function (message, ok) {
	var no = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};


	return confirm("\uD83D\uDD14 " + message) ? ok() : no();
};

},{}],58:[function(require,module,exports){
"use strict";

module.exports = sessionStorage;

},{}],59:[function(require,module,exports){
'use strict';

var emojiByType = {
	error: '🚨',
	success: '✅',
	info: '💬'
};

module.exports = function (type, message) {

	return alert((emojiByType[type] || '') + ' ' + message);
};

},{}],60:[function(require,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var groupStart = function groupStart(group, pagesAtOnce) {
	return (group - 1) * pagesAtOnce + 1;
};

var groupEnd = function groupEnd(group, pagesAtOnce) {
	return groupStart(group, pagesAtOnce) + pagesAtOnce - 1;
};

module.exports = function () {
	var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	var _options$type = options.type,
	    type = _options$type === undefined ? 'normal' : _options$type,
	    container = options.container,
	    _options$currentPage = options.currentPage,
	    currentPage = _options$currentPage === undefined ? 1 : _options$currentPage,
	    totalResult = options.totalResult,
	    resultPerPage = options.resultPerPage,
	    _options$pagesAtOnce = options.pagesAtOnce,
	    pagesAtOnce = _options$pagesAtOnce === undefined ? 10 : _options$pagesAtOnce,
	    _options$onPageChange = options.onPageChange,
	    onPageChange = _options$onPageChange === undefined ? function () {} : _options$onPageChange;


	var lastPage = Math.ceil(totalResult / resultPerPage);
	var totalGroups = Math.ceil(lastPage / pagesAtOnce);
	var currentGroup = Math.ceil(currentPage / pagesAtOnce);
	var currentGroupStart = groupStart(currentGroup, pagesAtOnce);

	var iterator = Array.apply(null, Array(pagesAtOnce)).map(function (v, i) {
		return i;
	}).filter(function (v) {
		return currentGroupStart + v <= lastPage;
	});

	if (iterator.length <= 1) {
		return;
	}

	var page = function page(text, type, _page, current) {
		return ('\n\t\t<li data-page="' + _page + '"\n\t\t\tclass="' + type + ' ' + (_page === current ? 'current' : '') + '">\n\t\t\t<span>' + (text || _page) + '</span>\n\t\t</li>\n\t').trim();
	};

	var $pagination = $(['<ul class="thunder--pagination ' + type + '">', currentGroup <= 1 ? '' : page('<', 'thunder--pagination-prev', groupEnd(currentGroup - 1, pagesAtOnce))].concat(_toConsumableArray(iterator.map(function (i) {
		return page(null, 'thunder--pagination-page', currentGroupStart + i, currentPage);
	})), [currentGroup >= totalGroups ? '' : page('>', 'thunder--pagination-next', groupStart(currentGroup + 1, pagesAtOnce)), '</ul>']).join(''));

	container.html($pagination);

	$pagination.find('[data-page]').on('click', function () {

		var page = $(this).data('page');

		if (currentPage === page) return;

		var $overlay = $(this).parents('#thunder--overlay');

		var isOverlay = !!$overlay.length;

		var $scrollTarget = isOverlay ? $overlay.eq(0) : $('html, body');
		var $positionTarget = $(this).parents('.thunder--contents').eq(0);

		var offset = -60;

		var scrollTop = isOverlay ? $positionTarget.offset().top - $scrollTarget.offset().top + $scrollTarget.scrollTop() + offset : $positionTarget.offset().top + offset;

		var shouldNotScroll = !isOverlay && $scrollTarget.scrollTop() <= scrollTop;

		onPageChange({ page: page });

		if (shouldNotScroll) return;

		// 오버레이 창인 경우
		return setTimeout(function () {
			return $scrollTarget.animate({ scrollTop: scrollTop }, 400);
		}, 300);
	});
};

},{}],61:[function(require,module,exports){
"use strict";

module.exports = function (to) {

	return location.replace(to);
};

},{}],62:[function(require,module,exports){
"use strict";

module.exports = function () {
	return "data:image/png;base64,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";
};

},{}],63:[function(require,module,exports){
"use strict";

module.exports = function () {

	return "\n\t\t<span class=\"thunder--button-spinner\"></span>\n\t".trim();
};

},{}],64:[function(require,module,exports){
"use strict";

module.exports = function () {

	return "\n\t\t<div class=\"thunder--component-spinner-wrapper\">\n\t\t\t<div class=\"thunder--component-spinner\"></div>\n\t\t</div>\n\t".trim();
};

},{}],65:[function(require,module,exports){
"use strict";

module.exports = function () {
	return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAUCAMAAABVlYYBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAYFBMVEX////Y2NjW1tbT09PY2NjV1dXT09PX19fX19fX19fX19fW1tbW1tbW1tbV1dXV1dXU1NTV1dXT09PU1NTU1NTT09PU1NTV1dXW1tbX19fY2NjZ2dna2trb29vc3Nzd3d0MlpiEAAAAFXRSTlMAHy4wPD1AcIecr8DP3Ofv8vb5+/5ldZdlAAAAqElEQVQYGWXBgVrCIBgF0GtRuIgto/sjjnHf/y1dSvuanoPN6zueOXLAk8lKOuCBZ20W8CCdpQsddj7YJNmIP+4Yph9etKpMY/BYDWQu86KbOp+NDMCYtddKAgYW7VRGAANn/bNYxK/AWZvFJtxFNnXNTgfcOS7qGj06T23o0R2pjQ3oQpZUS2mSckAXsubMU2Kuyp/oohlHD/iJlid0L1/R4cbF7zesrqgiFx5ZJ+DfAAAAAElFTkSuQmCC";
};

},{}],66:[function(require,module,exports){
"use strict";

module.exports = function () {
	return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAUCAMAAABVlYYBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAaVBMVEX////4yQD2xwDywwD4yQD1xgDywwD4yQD3yAD3yAD3yAD2xwD2xwD2xwD1xgD1xgDzxAD0xQDywwDzxADzxADywwDzxAD0xQD1xgD2xwD3yAD4yQD5ygD6ywD7zAD8zQD9zgD+zwD/0ABDG/+EAAAAFXRSTlMAHy4wPD1AcIecr8DP3Ofv8vb5+/5ldZdlAAAAq0lEQVQYGWXBAVaDMBQEwK1GU4yB1rj8FETC3v+QYht50s5g8/yKR45s8KCzIR1wx3Ne+oA76SKNdNh5Y5FkLf64Y+g+OWo1M7XBY9WQNk5FV/PXxcgAtKa9ZUhAw1E734wAGk76p/QRvwInbUrf4SayqFrsfMCNY1FV6FF5akOP6kht+gZVMEnzMBRJOaAKWVPmOTHPyu+oohlbD/iOZh2qp1N0uHLx4wWrH9+RGLe/2RyqAAAAAElFTkSuQmCC";
};

},{}],67:[function(require,module,exports){
"use strict";

module.exports = function () {
	return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAACB0lEQVQ4jZ2UO2sUURTH/+fumdmdgCRWQhoVhJ0lWgiCERJibyUI+gEsLba28QNYaC8p/ABiIGAnRBA0WwlaTLNGe9vVedx7rpwZZ50M2Uf2wNmZvffc35znhfd+oabH2Pn57dWDZWxJf+ZJNqLLRYGTH+tfKQiC3X6//3GevZlLAyCC1wCIiOCcO1xkPxeYjWjHWuyFIRCGIURkI0mS4cpA53BojMKATqcDY4x6+XwlYDaioXPY6PX+r3W7XU08J0nydta5aVGyET30Ho+8xw0RbIog6nSAtbXK8PuFcfksiqJUIrJE9MsY8xnAhziOX5bA9BjDPMeL8g8BGqKCmKt3XWsCq1Q4zedUa6eY+YBF8EQPRlEFWEY0n6q1KFC9FpG7hghHIhrKcrCzRD221mrRjkzvtn8cBNjP89WgCsvzXD0ex3F8vwxSocz4kqbng2r+athgMLiGZttE2/4mM8YK1RQsEs1blmVa7T81DO0+jLZ9ubFgvKeiUGPM0+baKaCO2rLhUt1PLWk3yi2g6sNzQPdmeug9LrUPafhZVk1I+6pToPf+YnONW4fv1M2thdFWsrbasrYcOWJmnYjyovgn6zM9rEUrPZmUMMuMgyDA1a2t64aZ951zNk1TqFZO+CunvG6G8fsT7YrgvTGYGIM32p9nfVDvRBF5pvcjM9+L4/hduQHgL43IKyO6pNEvAAAAAElFTkSuQmCC";
};

},{}],68:[function(require,module,exports){
"use strict";

module.exports = function () {
	return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAABc0lEQVQ4EaVU203DQBAcIv5JCSlgpZgOQgXQAaYCXEJKgApiKiAdJFQAaKeA0IE7MBprHV0cJ85jpJPt83n2NeObuq4xBJITAGMz+xk6OzqRTETfJJ+uJgTwBqAC8BH3lxOSnAF4BFAAmKtskvNrMlRGX2a2NLNNPBckx2cTkswBTAHknQDVsdKbKUfEDMAsud4BeDezoifQAsBvDKtZZrZuCN1dk/uM8+mh9SGZRG+7wYUXEZbtCzOrDnbzCEJaGtZkFP2YniKJI1CWzwCWUA/dPXf32t0LPZ+z3D2Lb8vGde3HCWl+KmGQVS2Z1o6XSarsVwD3Q75NLLkxs6zd7+qwdcFB4SYYx3RTne4RtpEG/ypJBTvBe51yqXyE254M/9KNEHERlitbRwRkBL3f7nUzVPr6CTQWI6n7VexrCCuS67CfsFdJX8kZSR2UXxVZE5eLlMlDBFxEMAXR2qIrG2UiK6rhKq/JtouQjNrQeHrbcwD/48MIr+PHIqoAAAAASUVORK5CYII=";
};

},{}],69:[function(require,module,exports){
'use strict';

module.exports = function () {
	var _this = this;

	if (!this.options.header) return '';

	var templates = [];
	var items = this.options.header.items;


	var menuItem = function menuItem(component, message) {
		return '<li><a data-component="' + component + '">' + message + '</a></li>';
	};

	items.forEach(function (type) {

		if (type === 'customer') {

			if (_this.authenticated()) {

				templates.push('\n\t\t\t\t\t<li><a data-thunder-logout>' + _this.polyglot.t('header-navigation.logout') + '</a></li>\n\t\t\t\t');

				templates.push(menuItem('customer-dashboard', _this.polyglot.t('header-navigation.profile')));
			} else {

				templates.push(menuItem('customer-register', _this.polyglot.t('header-navigation.register')));

				templates.push(menuItem('customer-login', _this.polyglot.t('header-navigation.login')));
			}
		}

		if (type === 'search-purchase') {

			if (!_this.authenticated()) {

				templates.push(menuItem('search-purchase', _this.polyglot.t('header-navigation.searchOrder')));
			}
		}

		if (type === 'cart') {

			templates.push(menuItem('cart', _this.polyglot.t('header-navigation.cart')));
		}
	});

	return '\n\t\t<div id="thunder--header-navigation">\n\t\t\t<ul>\n\t\t\t\t' + templates.join('') + '\n\t\t\t</ul>\n\t\t</div>\n\t';
};

},{}],70:[function(require,module,exports){
"use strict";

module.exports = function () {
	return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAMAAAANIilAAAAAgVBMVEUAAAAAAAAAAADY2NgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADv7+8zMzMAAAAAAAAAAADa2toAAAAAAAAAAAAAAADd3d0AAADY2NjMzMzr6+vQ0NC9vb0AAAD39/fw8PDQ0NC7u7sjIyOgoKApKSmqqqo5OTl1dXVCQkL///+VHsZ8AAAAKnRSTlMABQu9EwlBIB4xLhEV3U9FIhi7PCklD7g0l4zhxGxX996cg3RmYmBHRj4AjhiCAAABJklEQVRIx+3Xy27DIBAFUA8xBhuaBNv4lSZ9v/j/D+yUdqRm15lGlSqZhXdH95rFaCh+fKAQHgDQGj8yqwbnnNIgsHrw1hjrBw1860JslvlovAK2LW3TjSmlo3UauLlo24RnNojZuVW2adkjZttNtmNtHTA7k227PiiQ5W6qhu6Lb3e1KVnWfbd7r0S5ZEHamaywM6yd186szpe3gs6EVei79stOnNwcbKYx2+vdFFkWcRmXT3uq+jCg5WDf333Ym4dTF2naMZLvc/LhiZIl/3zY0j9Lbvtqi9NSCWc8afgzrUpTn+uCp3+VvTZfm//H5hq1sDntYaLmL7QBSprfvtHuydBnW69Yz4Q5mjb9Z0uYNxVj/Ti/0vbJ1UHyuiFN76oLvujeAaPnQON4QEwtAAAAAElFTkSuQmCC";
};

},{}],71:[function(require,module,exports){
"use strict";

module.exports = function () {

	return "\n\t\t<div class=\"thunder--overlay-nav\">\n\t\t\t<span class=\"thunder--close-overlay\" data-thunder-close>&times;<span>\n\t\t</div>\n\t".trim();
};

},{}],72:[function(require,module,exports){
'use strict';

module.exports = function () {
	var defaultRating = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;


	var ratings = [1, 2, 3, 4, 5];

	return ('\n\t<select name="rating">' + ratings.map(function (r) {
		return ('\n\t\t<option value="' + r + '" ' + (defaultRating === r ? 'selected' : '') + '>' + '⭐'.repeat(r) + '</option>\n\t').trim();
	}).join('') + '\n\t</select>\n\t').trim();
};

},{}],73:[function(require,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

module.exports = function () {
	var _this = this;

	var starred = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;


	var stars = [];

	for (var i = 0; i < starred - 1; i++) {
		stars.push(1);
	}

	var rest = starred - stars.length;

	if (rest > 0) {
		stars.push(rest);
	}

	return ['<span class="thunder--review-stars" data-rating="' + starred + '">'].concat(_toConsumableArray(Array.apply(null, { length: 5 }).map(function (el, i) {
		return starred === 0 ? '<img src="' + _this.ui(star(-1))() + '">' : '<img src="' + _this.ui(star(stars[i] || 0))() + '">';
	})), ['</span>']).join('');
};

function star() {
	var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;


	if (n === -1) return 'hallow-star';
	if (n === 0) return 'empty-star';
	if (n === 1) return 'filled-star';

	return n >= 0.5 ? 'half-filled-star' : 'empty-star';
}

},{}],74:[function(require,module,exports){
"use strict";

module.exports = function () {
	return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAMAAAANIilAAAAAgVBMVEUAAAAAAAAAAAAAAAD5+fkAAAAAAAAAAAAAAAAAAAB1dXUAAAAAAAAAAACrq6ttbW0AAAAAAAAAAAAAAAAAAAD7+/sAAAB/f38AAAB4eHgAAAAAAADY2Ni+vr5iYmIAAAD39/f19fXw8PCvr6+amprNzc0AAACNjY1BQUFNTU3///8iU2L+AAAAKnRSTlMAAwYM9QkWNRwlaBArPY9wEiMZLR/0KGAxZTpOl4F8RObYy7qei2RWPjXdioHaAAABB0lEQVRIx+3XyW4DIQwG4AHChAnTlgFmy9J0X3j/B2wTEvmQ0+8cokj4/snCSJb/6qLEsSpWCSm1lpI4ZLWyziotBcMq52MXvVO4FtqZ3+32e4h11lhjP7ym1I9TlzWGTUjpX8+kIdwf9GK1bLJGsG/HBVdr1y1XuKaJrZ+4WlvTPjC1uKWWRRd9j7q7TjslK0yHs56DsVJA2sVp/5z12NQa3Il1s95k3QfP2Imbr/d0qGAyxjp/HO1L7gy9OewfE70Z3WgnO0/RaoFb+mfBtE1dbLHForbiWrrDcEvbDrd0e+5Yln/1Es67jiw0rze69PGMMew+f9pIFko3htINrq0DchU/0f0BP61AGpJ0kg4AAAAASUVORK5CYII=";
};

},{}],75:[function(require,module,exports){
"use strict";

module.exports = function () {

	return "\n\t\t<div class=\"thunder--section-spinner-wrapper\">\n\t\t\t<span class=\"thunder--section-spinner\"></span>\n\t\t</div>\n\t".trim();
};

},{}],76:[function(require,module,exports){
'use strict';

module.exports = function () {
	var _this = this;

	var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	var _options$type = options.type,
	    type = _options$type === undefined ? 'login' : _options$type,
	    _options$vendors = options.vendors,
	    vendors = _options$vendors === undefined ? ['facebook', 'google', 'instagram', 'naver', 'kakao'] : _options$vendors,
	    _options$logos = options.logos,
	    logos = _options$logos === undefined ? {
		facebook: '<svg xmlns="http://www.w3.org/2000/svg" width="21" height="21"><path d="M19.4.5H1.6C1 .5.5 1 .5 1.6v17.8c0 .6.5 1.1 1.1 1.1h9.6v-7.7H8.6v-3h2.6V7.5c0-2.6 1.6-4 3.9-4 .8 0 1.6 0 2.3.1v2.7h-1.6c-1.3 0-1.5.6-1.5 1.5v1.9h3l-.4 3h-2.6v7.7h5.1c.6 0 1.1-.5 1.1-1.1V1.6c0-.6-.5-1.1-1.1-1.1z" fill="#fff"/></svg>',
		google: '<svg xmlns="http://www.w3.org/2000/svg" width="21" height="21"><path d="M20.1 10.7c0-.7-.1-1.4-.2-2h-9.4v3.9h5.4c-.2 1.3-.9 2.3-2 3v2.5h3.2c1.9-1.8 3-4.3 3-7.4z" fill="#4285f4"/><path d="M10.5 20.5c2.7 0 5-.9 6.6-2.4l-3.2-2.5c-.9.6-2 1-3.4 1-2.6 0-4.8-1.8-5.6-4.1H1.6V15c1.6 3.3 5 5.5 8.9 5.5z" fill="#34a853"/><path d="M4.9 12.4c-.2-.6-.3-1.2-.3-1.9s.1-1.3.3-1.9V6H1.6C.9 7.4.5 8.9.5 10.5s.4 3.1 1.1 4.5l3.3-2.6z" fill="#fbbc05"/><path d="M10.5 4.5c1.5 0 2.8.5 3.8 1.5l2.9-2.9c-1.7-1.6-4-2.6-6.7-2.6C6.6.5 3.2 2.7 1.6 6l3.3 2.6c.8-2.4 3-4.1 5.6-4.1z" fill="#ea4335"/><path d="M.5.5h20v20H.5V.5z" fill="none"/></svg>',
		instagram: '<svg xmlns="http://www.w3.org/2000/svg" width="21" height="21"><style>.st0{fill:#fff}</style><path class="st0" d="M10.5 1.9c2.8 0 3.1 0 4.2.1 1 0 1.6.2 1.9.4.5.2.8.4 1.2.8.4.4.6.7.8 1.2.2.3.4.8.4 1.9.1 1.1.1 1.4.1 4.2s0 3.1-.1 4.2c0 1-.2 1.6-.4 1.9-.2.5-.4.8-.8 1.2-.4.4-.7.6-1.2.8-.4.1-.9.3-1.9.4-1.1.1-1.4.1-4.2.1s-3.1 0-4.2-.1c-1 0-1.6-.2-1.9-.4-.5-.2-.8-.4-1.2-.8-.4-.4-.6-.7-.8-1.2-.2-.3-.4-.8-.4-1.9-.1-1.1-.1-1.4-.1-4.2s0-3.1.1-4.2c0-1 .2-1.6.4-1.9.2-.5.4-.8.8-1.2.4-.4.7-.6 1.2-.8.3-.2.8-.4 1.9-.4 1.1-.1 1.4-.1 4.2-.1m0-1.9C7.6 0 7.3 0 6.2.1 5.1.1 4.3.3 3.6.6c-.7.2-1.3.6-1.8 1.2-.6.5-1 1.1-1.2 1.8-.3.7-.5 1.5-.5 2.6C0 7.3 0 7.6 0 10.5s0 3.2.1 4.3c.1 1.1.2 1.9.5 2.5.3.7.6 1.3 1.2 1.9.6.6 1.2.9 1.9 1.2.7.3 1.4.4 2.5.5 1.1.1 1.4.1 4.3.1s3.2 0 4.3-.1c1.1-.1 1.9-.2 2.5-.5.7-.3 1.3-.6 1.9-1.2.6-.6.9-1.2 1.2-1.9.3-.7.4-1.4.5-2.5.1-1.1.1-1.5.1-4.3s0-3.2-.1-4.3c-.1-1.1-.2-1.9-.5-2.5-.3-.7-.6-1.3-1.2-1.9-.6-.6-1.2-.9-1.9-1.2-.7-.3-1.4-.4-2.5-.5-1.1-.1-1.4-.1-4.3-.1z"/><path class="st0" d="M10.5 5.1c-3 0-5.4 2.4-5.4 5.4s2.4 5.4 5.4 5.4 5.4-2.4 5.4-5.4-2.4-5.4-5.4-5.4zm0 8.9C8.6 14 7 12.4 7 10.5S8.6 7 10.5 7 14 8.6 14 10.5 12.4 14 10.5 14z"/><circle class="st0" cx="16.1" cy="4.9" r="1.3"/></svg>',
		naver: '<svg xmlns="http://www.w3.org/2000/svg" width="21" height="21"><path fill="#fff" d="M13.5 1.8v8.8l-6-8.8H.9v17.5h6.6v-8.9l6 8.9h6.6V1.8z"/></svg>',
		kakao: '<svg xmlns="http://www.w3.org/2000/svg" width="21" height="21"><path d="M10.5 1.7C5 1.7.5 5.2.5 9.6c0 2.8 1.9 5.3 4.7 6.7-.2.8-.8 2.8-.9 3.3-.1.5.2.5.4.4.2-.1 2.7-1.9 3.8-2.6.6.1 1.2.1 1.9.1 5.5 0 10-3.5 10-7.9S16 1.7 10.5 1.7z" fill="#3c1e1e"/></svg>'
	} : _options$logos;


	vendors = typeof vendors === 'string' ? vendors.split(',').filter(function (v) {
		return v;
	}) : vendors;

	if (vendors.length === 0) {
		return '';
	}

	return ('\n\t\t<ul class="thunder--social-app-actions thunder--social-app-' + type + '">\n\t\t\t' + vendors.map(function (vendor) {
		return '\n\t\t\t<li class="thunder-social-app-' + vendor + '">\n\t\t\t\t<button data-social-app="' + vendor + '">\n\t\t\t\t\t<span class="thunder--social-app-logo">' + logos[vendor] + '</span>\n\t\t\t\t\t<span class="thunder--social-app-button-message">' + _this.polyglot.t('social-login.' + type + 'By' + (vendor[0].toUpperCase() + vendor.slice(1))) + '</span>\n\t\t\t\t</button>\n\t\t\t</li>\n\t\t\t';
	}).join('') + '\n\t\t</ul>\n\t').trim();
};

},{}],77:[function(require,module,exports){
"use strict";

module.exports = function (body) {

	return ("\n\t\t<div class=\"thunder--text-box-overlay\">\n\t\t\t<div class=\"thunder--text-box-overlay-header\">\n\t\t\t\t<span class=\"thunder--text-box-overlay-close\">\xD7</span>\n\t\t\t</div>\n\t\t\t<div class=\"thunder--text-box-overlay-body\">\n\t\t\t\t" + body + "\n\t\t\t</div>\n\t\t</div>\n\t").trim();
};

},{}],78:[function(require,module,exports){
'use strict';

module.exports = function (from, type, value) {

	var timeMap = {
		days: 86400000, // 하루를 밀리초로 환산
		weeks: 604800000 // 한 주를 밀리초로 환산
	};

	var toDate = function toDate(date) {
		return date ? new Date(date) : new Date();
	};

	var original = toDate(from);
	var originalTime = original.valueOf();
	var originalYear = original.getFullYear();
	var originalMonth = original.getMonth();
	var originalDate = original.getDate();

	// `days`, `weeks` 케이스 (단순히 오프셋을 계산해 더함)
	if (timeMap[type]) {

		var offset = timeMap[type] * Number(value);

		return toDate(originalTime + offset);
	}

	// 월 케이스
	if (type === 'months') {

		var yearOffset = Math.floor((originalMonth + Number(value)) / 12);
		var newMonth = (originalMonth + Number(value)) % 12;

		original.setFullYear(originalYear + yearOffset);
		original.setMonth(newMonth);

		if (newMonth !== original.getMonth()) {
			original.setDate(0);
		}

		return original;
	}

	// 년 케이스
	if (type === 'years') {

		var expiresYear = original.getFullYear() + Number(value);

		original.setFullYear(expiresYear);

		// 기존 날짜가 2월 29일이면서,
		// 더해진 날짜로 갔을 때 3월이 된 경우 (2월 29일이 없는 경우)
		if (originalMonth === 1 && originalDate === 29 && original.getMonth() === 2) {
			original.setDate(0);
		}

		return original;
	}

	throw new Error('Unsupported time type');
};

},{}],79:[function(require,module,exports){
'use strict';

module.exports = function (_ref) {
	var $terms = _ref.$terms,
	    agreements = _ref.agreements;


	var $all = $terms.filter('[data-agreement-scope="all"]');
	var $allCheck = $all.find('input[type="checkbox"]');

	$terms = $terms.filter('[data-agreement-scope!="all"]');
	var $termsChecks = $terms.find('input[type="checkbox"]');

	var $requiredTermsChecks = $terms.find('input[type="checkbox"][required]');

	$termsChecks.on('change', function () {

		$allCheck.prop('checked', $termsChecks.map(function () {
			return $(this).is(':checked');
		}).get().every(function (v) {
			return v;
		}));
	});

	$allCheck.on('change', function () {

		var checked = $allCheck.is(':checked');

		$termsChecks.each(function () {
			$(this).prop('checked', checked);
		});
	});

	$terms.find('a').filter(':not([href])').on('click', function (e) {

		e.preventDefault();

		var scope = $(this).parents('[data-agreement-scope]').data('agreementScope');
		var $overlay = $(Thunder.ui('text-box-overlay')(agreements[scope].text));
		var $close = $overlay.find('.thunder--text-box-overlay-close');

		$('body').append($overlay);

		$close.on('click', function () {
			$overlay.remove();
		});
	});

	return function () {

		if (!$requiredTermsChecks.length) {
			return true;
		}

		for (var i = 0; i < $requiredTermsChecks.length; i++) {

			var $term = $requiredTermsChecks.eq(i);

			if (!$term.is(':checked')) {

				var scope = $term.parents('[data-agreement-scope]').data('agreementScope');

				Thunder.notify('error', agreements[scope].error);

				return false;
			}
		}
		return true;
	};
};

},{}],80:[function(require,module,exports){
'use strict';

var get = require('lodash.get');

module.exports = function ($button, context) {
	var _this = this;

	var history = get(context, 'options.back');

	if (!$button || !history) return;

	var $container = history.$container,
	    component = history.component,
	    options = history.options;


	$button.on('click', function (event) {

		if (event) event.preventDefault();

		return _this.render($container, component, options || {});
	});
};

},{"lodash.get":341}],81:[function(require,module,exports){
"use strict";

module.exports = function () {
	var _this = this;

	this.options.recaptcha.queue.forEach(function (option) {

		_this.util.makeRecaptcha(option.componentName, option.$button, option.fn);
	});

	this.options.recaptcha.queue = [];
};

},{}],82:[function(require,module,exports){
'use strict';

module.exports = function ($container) {
	var validate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
		return true;
	};


	var Thunder = this;

	var $socialButton = $container.find('[data-social-app]');

	$socialButton.on('click', function () {

		if (!validate()) {
			return;
		}

		var vendor = $(this).data('socialApp');

		Thunder.request({
			method: 'POST',
			url: '/v1/customers/auth/' + vendor
		}).done(function (data) {

			location.replace(data.redirect);
		}).fail(function (res, status) {

			// TODO: Error handling

		});
	});
};

},{}],83:[function(require,module,exports){
'use strict';

var refundStatusToCheck = {
	requested: true,
	accepted: true
};

module.exports = function (order, itemId) {

	if (!Array.isArray(order.items) || !Array.isArray(order.refunds)) {
		throw new Error('Order must have items and refunds field to check item refund status.');
	}

	var itemQuantity = order.items.reduce(function (all, item) {
		return all.concat(item, item.bundleItems);
	}, []).find(function (item) {
		return item._id === itemId;
	}).quantity.raw;

	var refundedQuantity = order.refunds.filter(function (r) {
		return refundStatusToCheck[r.status];
	}) // requested, accepted 환불 내역에서
	.reduce(function (sum, r) {

		var item = r.items.find(function (i) {
			return i.item._id === itemId;
		});

		return sum + (item ? item.quantity.raw : 0);
	}, 0); // 이 아이템에 대해서 환불된 전체 수량을 계산

	if (itemQuantity <= refundedQuantity) {
		return true;
	}

	return false;
};

},{}],84:[function(require,module,exports){
'use strict';

module.exports = function (elem) {

		var $temp = $('<input>');

		$temp.css({
				position: 'absolute',
				left: '-9999px',
				top: '0'
		});

		$('body').append($temp);

		$temp.val($(elem).text().trim()).select();

		var result = false;

		try {
				result = document.execCommand('copy');
				this.notify('success', this.polyglot.t('general.copySucceeded'));
		} catch (err) {
				this.notify('error', this.polyglot.t('general.copyFailed'));
		}

		$temp.remove();

		return result;
};

},{}],85:[function(require,module,exports){
'use strict';

module.exports = function () {
	var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';


	if (!code || !name) return '';

	var flag = code.toUpperCase().replace(/./g, function (char) {
		return String.fromCodePoint(char.charCodeAt(0) + 127397);
	});

	return [flag, name].filter(function (v) {
		return v;
	}).join(' ');
};

},{}],86:[function(require,module,exports){
'use strict';

var get = require('lodash.get');

module.exports = function (customer) {

	if (!customer) return null;

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = this.options.customerIdentity[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var field = _step.value;


			var value = get(customer, field);

			if (value) {
				return value;
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return null;
};

},{"lodash.get":341}],87:[function(require,module,exports){
"use strict";

// David Walsh's debounce function snippets (slightly modified)
// Ref: https://davidwalsh.name/javascript-debounce-function
module.exports = function (func, wait, immediate) {

	var timeout = void 0;

	return function () {

		var context = this;
		var args = arguments;
		var callNow = immediate && !timeout;
		var later = function later() {
			timeout = null;
			if (!immediate) func.apply(context, args);
		};

		clearTimeout(timeout);
		timeout = setTimeout(later, wait);
		if (callNow) func.apply(context, args);
	};
};

},{}],88:[function(require,module,exports){
'use strict';

module.exports = function (text, length) {

	if (typeof length !== 'number') {
		return text;
	}

	// Remove HTML tags
	text = $('<div>' + (text || '') + '</div>').text();

	var reduced = text.replace(/\s+/g, ' ') // Replace all empty spaced to one space
	.trim().slice(0, length).trim();

	return text.length <= length ? reduced : reduced + '...';
};

},{}],89:[function(require,module,exports){
'use strict';

var set = require('lodash.set');

module.exports = function ($container, follow) {
	var menuItems = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];


	var id = Math.random().toString().slice(2);

	var itemMap = menuItems.reduce(function (o, item, i) {
		return set(o, [id + '.' + i], item);
	}, {});

	var items = menuItems.map(function (item, i) {
		return '<li><span data-scroll-to="' + id + '.' + i + '">' + item.name + '</span></li>';
	}).join('');

	$container.addClass('thunder--following-nav-container').addClass(follow ? 'sticky' : '').html('<ul class="thunder--following-nav">' + items + '</ul>');

	$container.on('click', '[data-scroll-to]', function (event) {

		event.preventDefault();

		var itemId = $(this).data('scrollTo');
		var item = itemMap[itemId];

		return item.$el.get(0).scrollIntoView();
	});
};

},{"lodash.set":345}],90:[function(require,module,exports){
'use strict';

var set = require('lodash.set');

module.exports = function (serialized) {

	var data = {};

	serialized.forEach(function (d) {
		return set(data, d.name, d.value || null);
	});

	return data;
};

},{"lodash.set":345}],91:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

module.exports = function (number) {
	var currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


	if (typeof number !== 'number') {

		return '';
	}

	var precision = currency.precision,
	    _currency$delimiter = currency.delimiter,
	    delimiter = _currency$delimiter === undefined ? {} : _currency$delimiter;
	var _delimiter$thousands = delimiter.thousands,
	    thousands = _delimiter$thousands === undefined ? '' : _delimiter$thousands,
	    _delimiter$decimal = delimiter.decimal,
	    decimal = _delimiter$decimal === undefined ? '.' : _delimiter$decimal;


	if (typeof precision === 'number') {

		number = this.util.toPrecision(number, precision);
	}

	var _String$split = String(number).split('.'),
	    _String$split2 = _slicedToArray(_String$split, 2),
	    a = _String$split2[0],
	    _String$split2$ = _String$split2[1],
	    b = _String$split2$ === undefined ? '' : _String$split2$;

	var reversedArray = a.split('').reverse();

	var segments = [];

	while (reversedArray.length) {

		segments.unshift(reversedArray.splice(0, 3).reverse().join(''));
	}

	if (precision) {

		var diff = precision - b.length;

		for (var i = 0; i < diff; i++) {
			b += '0';
		}
	}

	return [segments.join(thousands), b].join(b ? decimal : '');
};

},{}],92:[function(require,module,exports){
'use strict';

module.exports = function (number) {
	var currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


	var formattedNumber = this.util.formatNumber(number, currency);

	if (!formattedNumber) {

		return '';
	}

	var _currency$symbol = currency.symbol,
	    symbol = _currency$symbol === undefined ? '' : _currency$symbol,
	    _currency$format = currency.format,
	    format = _currency$format === undefined ? '{price}' : _currency$format;


	return format.replace('{symbol}', symbol).replace('{price}', formattedNumber);
};

},{}],93:[function(require,module,exports){
'use strict';

module.exports = function (code) {

	if (!code) {
		return deferred.reject(new Error('Currency code is required.'));
	}

	code = code.toUpperCase();

	var deferred = $.Deferred();
	var key = '__currency:' + code + '__';
	var saved = sessionStorage.getItem(key);

	if (saved) {

		return deferred.resolve(JSON.parse(saved));
	} else {

		Thunder.request({
			method: 'GET',
			url: '/v1/currencies',
			query: {
				raw: true,
				fields: ['code', 'delimiter', 'format', 'precision', 'symbol'].join(','),
				code: code
			}
		}).then(function (res) {
			sessionStorage.setItem(key, JSON.stringify(res[0]));
			return deferred.resolve(res[0]);
		});
	}

	return deferred.promise();
};

},{}],94:[function(require,module,exports){
'use strict';

module.exports = function () {
	var _util$urlQuery = this.util.urlQuery(),
	    action = _util$urlQuery.action,
	    customer = _util$urlQuery.customer,
	    token = _util$urlQuery.token;

	if (!action) {
		return null;
	}

	if (action && customer && token) {

		var storage = this.plugins.credentialStorage;

		storage.setItem(this.options.authStorage.customer, token);

		// Re-render header
		this.header();
	}

	var query = this.util.urlQuery();
	var payload = {};

	['action', 'customer', 'token', 'error'].forEach(function (field) {
		return payload[field] = query[field];
	});

	return payload;
};

},{}],95:[function(require,module,exports){
'use strict';

module.exports = function (image, width, height) {

	if (!image) return '';

	var dimension = [];

	width = width ? 'width=' + width : '';
	height = height ? 'height=' + height : '';

	if (width) dimension.push(width);
	if (height) dimension.push(height);

	dimension = dimension.length ? '?' + dimension.join('&') : '';

	return image.url + dimension;
};

},{}],96:[function(require,module,exports){
'use strict';

module.exports = function ($uploadForm, successCallback, errorCallback) {
	var _this = this;

	var $file = $uploadForm.find('input[type="file"]');
	var $label = $uploadForm.find('label[for="' + $file.attr('id') + '"]');
	var originalLabel = $label.text();

	return $file.on('change', function () {

		if (!$file.val()) {
			return $label.html(originalLabel);
		}

		$label.html(_this.ui('button-spinner'));

		$uploadForm.ajaxSubmit({
			method: 'POST',
			url: _this.options.baseURL + '/v1/me/images',
			headers: _this.request.getRequestHeaders(),
			success: function success() {
				$label.html(originalLabel);
				return successCallback.apply(undefined, arguments);
			},
			error: function error() {
				$label.html(originalLabel);
				return errorCallback.apply(undefined, arguments);
			}
		});
	});
};

},{}],97:[function(require,module,exports){
"use strict";

module.exports = function (date) {
	var timeToCompare = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();


	return new Date(date).valueOf() - timeToCompare < 0;
};

},{}],98:[function(require,module,exports){
'use strict';

module.exports = function () {
	var tags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	var message = arguments[1];


	var type = tags.indexOf('error') === -1 ? 'log' : 'error';

	return console[type]('[' + tags.join(',') + '] Thunder: ' + message);
};

},{}],99:[function(require,module,exports){
'use strict';

module.exports = function ($button, options) {
	var _this = this;

	options = options || {};

	var _options = options,
	    _options$bind = _options.bind,
	    bind = _options$bind === undefined ? true : _options$bind;


	var original = $button.html();

	var run = function run() {
		return $button.html(_this.ui('button-spinner'));
	};
	var done = function done() {
		return $button.html(original);
	};

	if (bind) {
		$button.on('click', run);
	}

	return { run: run, done: done };
};

},{}],100:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function (componentName, $button, _callback) {

	var validate = function validate() {
		return true;
	};

	if ((typeof componentName === 'undefined' ? 'undefined' : _typeof(componentName)) === 'object') {

		var options = componentName;

		componentName = options.componentName;
		$button = options.button;
		validate = options.validate || validate;
		_callback = options.callback;
	}

	var signature = 'thunder--recaptcha-handler';

	if (!$button.hasClass(signature)) {

		$button.addClass(signature);

		$button.data('execute', ($button.data('execute') || []).concat(_callback));

		$button.on('click', function (event) {

			event.preventDefault();

			if (!validate()) return;

			$button.data('execute').forEach(function (execute) {
				return execute();
			});
		});
	}

	if (!this.util.useRecaptcha(componentName)) {
		return $button.data('execute');
	}

	var grecaptcha = window.grecaptcha;

	if (!grecaptcha || !grecaptcha.render) {

		this.options.recaptcha.queue.push({
			componentName: componentName,
			$button: $button,
			fn: _callback
		});

		return $button.data('execute');
	}

	var $challenge = $('<div class="g-recaptcha"></div>');

	$button.before($challenge);

	var challenge = $challenge.get(0);

	var id = grecaptcha.render(challenge, {
		sitekey: this.options.recaptcha.sitekey,
		size: 'invisible',
		badge: 'bottomright',
		isolated: true,
		callback: function callback(token) {
			return _callback(token, function () {
				return grecaptcha.reset(id);
			});
		},
		'expired-callback': function expiredCallback(err) {
			// TODO: Implement callback
		},
		'error-callback': function errorCallback(err) {
			// TODO: Implement callback
		}
	});

	$challenge.prop('id', 'g-recaptcha-' + id);

	var callbacks = ($button.data('execute') || []).concat(function () {
		return grecaptcha.execute(id);
	}).filter(function (fn) {
		return fn !== _callback;
	}); // Remove original callback

	$button.data('execute', callbacks);

	return $button.data('execute');
};

},{}],101:[function(require,module,exports){
'use strict';

module.exports = function (order) {

	if (!order) return null;

	if (order.status === 'placed' || order.status === 'cancelled') {
		return null;
	}

	var hasTangibleItem = order.items.reduce(function (items, item) {
		return items.concat(item, item.bundleItems || []);
	}, []).some(function (item) {
		return item.type === 'tangible';
	});

	if (!hasTangibleItem) return null;

	if (order.receivedAt) {
		return 'received';
	}

	var countByStatus = order.fulfillments.reduce(function (o, _ref) {
		var status = _ref.status;

		o[status] = o[status] || 0;
		o[status]++;
		return o;
	}, {});

	if (order.fulfillments.length === 0 || order.fulfillments.length === countByStatus.pending) {
		return 'pending';
	}

	if (order.fulfillments.length === countByStatus.arrived) {
		return 'arrived';
	}

	return 'shipped';
};

},{}],102:[function(require,module,exports){
'use strict';

module.exports = function (value) {

		return typeof value === 'string' ? value.split(',').filter(function (v) {
				return v;
		}) : value;
};

},{}],103:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

var set = require('lodash.set');

module.exports = function (query) {

	query = query || {};

	if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
		return query;
	}

	if (typeof query !== 'string') {
		return {};
	}

	return query.split('&').reduce(function (o, segment) {
		var _segment$split = segment.split('='),
		    _segment$split2 = _toArray(_segment$split),
		    key = _segment$split2[0],
		    values = _segment$split2.slice(1);

		return set(o, [key], decodeURIComponent(values.join('=').replace(/\+/g, ' ')));
	}, {});
};

},{"lodash.set":345}],104:[function(require,module,exports){
'use strict';

module.exports = function (product, variant) {

	return [].concat(product.name, variant && variant.types.length ? this.util.variantName(variant) : []).join(' / ');
};

},{}],105:[function(require,module,exports){
'use strict';

module.exports = function ($container) {

		$container.find('.thunder--quantity').each(function () {
				var _this = this;

				var min = parseInt($(this).attr('min') || 0);
				var max = parseInt($(this).attr('max') || 100);

				var $wrapper = $('\n\t\t\t<span class="thunder--quantity-wrapper"></span>\n\t\t');

				$(this).wrap($wrapper);

				var $dec = $('<span class="thunder--quantity-action" data-type="dec">\n\t\t\t<span class="thunder--quantity-action-bar"></span>\n\t\t</span>');
				var $inc = $('<span class="thunder--quantity-action" data-type="inc">\n\t\t\t<span class="thunder--quantity-action-bar"></span>\n\t\t\t<span class="thunder--quantity-action-bar"></span>\n\t\t</span>');

				$dec.insertBefore($(this));
				$inc.insertAfter($(this));

				$dec.on('click', function () {

						var oldVal = parseInt($(_this).val());
						var newVal = oldVal - 1;

						if (oldVal === min) {
								return;
						}

						$(_this).val(newVal);
						$(_this).trigger('change');
				});

				$inc.on('click', function () {

						var oldVal = parseInt($(_this).val());
						var newVal = oldVal + 1;

						if (oldVal === max) {
								return;
						}

						$(_this).val(newVal);
						$(_this).trigger('change');
				});
		});
};

},{}],106:[function(require,module,exports){
'use strict';

var get = require('lodash.get');

var HandlerError = function HandlerError(code, message) {

	var error = new Error(message);

	error.code = code;

	return error;
};

module.exports = function (res, codeToMessage) {
	var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};


	if (!res.error) {
		// Not an error case
		return callback();
	}

	// Find a Clayful error code
	var errorCode = get(res, 'errorCode', null);

	var messageGetter = codeToMessage[errorCode];
	var defaultMessage = codeToMessage.default;
	var message = messageGetter ? typeof messageGetter === 'function' ? messageGetter(res) || defaultMessage : messageGetter.message || messageGetter || defaultMessage : defaultMessage;

	if (message) {
		this.plugins.notification(get(messageGetter, 'type') || 'error', message);
		return callback(HandlerError(errorCode, message));
	}

	return callback(HandlerError('unknown', 'Unknown Error'));
};

},{"lodash.get":341}],107:[function(require,module,exports){
'use strict';

module.exports = function () {
	var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';


	return $('<div>' + text + '</div>').text();
};

},{}],108:[function(require,module,exports){
"use strict";

module.exports = function () {
	var number = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;


	var n = Math.pow(10, precision);

	return Math.round(number * n) / n;
};

},{}],109:[function(require,module,exports){
'use strict';

module.exports = function (name) {

	return this.uis[name] ? this.uis[name]() : '';
};

},{}],110:[function(require,module,exports){
'use strict';

module.exports = function (data) {

	if (!data) return null;

	var recaptchaField = 'g-recaptcha-response';
	var response = data[recaptchaField];

	delete data[recaptchaField];

	return response || null;
};

},{}],111:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var parseQueryString = require('./parseQueryString.js');

module.exports = function () {

	// Since SPA(Single Page App) might use hashbang(/#/?hello=world) in its url,
	// `location.href` is being used to find query string.
	var _location$href$split = location.href.split('?'),
	    _location$href$split2 = _slicedToArray(_location$href$split, 2),
	    _location$href$split3 = _location$href$split2[1],
	    queryAfter = _location$href$split3 === undefined ? '' : _location$href$split3;

	// Remove URL hash


	var _queryAfter$split = queryAfter.split('#'),
	    _queryAfter$split2 = _slicedToArray(_queryAfter$split, 1),
	    search = _queryAfter$split2[0];

	if (!search) return {};

	return parseQueryString(search);
};

},{"./parseQueryString.js":103}],112:[function(require,module,exports){
"use strict";

module.exports = function (moduleName) {

	return this.options.recaptcha.sitekey && this.options.recaptcha.modules.some(function (m) {
		return m === moduleName;
	});
};

},{}],113:[function(require,module,exports){
'use strict';

module.exports = function (data) {

	if (!data.userIdOrEmail) {
		return data;
	}

	if (data.userIdOrEmail.indexOf('@') > 0) {
		data.email = data.userIdOrEmail;
	} else {
		data.userId = data.userIdOrEmail;
	}

	delete data.userIdOrEmail;

	return data;
};

},{}],114:[function(require,module,exports){
'use strict';

module.exports = function (variant) {

		return variant.types.map(function (type) {
				return type.option.name + ' - ' + type.variation.value;
		}).join(', ');
};

},{}],115:[function(require,module,exports){
module.exports="1.2.4"
},{}],116:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],117:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_hide":148,"./_wks":220}],118:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],119:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":157}],120:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-absolute-index":205,"./_to-length":209,"./_to-object":210}],121:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-absolute-index":205,"./_to-length":209,"./_to-object":210}],122:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":205,"./_to-iobject":208,"./_to-length":209}],123:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":125,"./_ctx":134,"./_iobject":153,"./_to-length":209,"./_to-object":210}],124:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":155,"./_is-object":157,"./_wks":220}],125:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":124}],126:[function(require,module,exports){
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":116,"./_invoke":152,"./_is-object":157}],127:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":128,"./_wks":220}],128:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],129:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":118,"./_ctx":134,"./_descriptors":136,"./_for-of":145,"./_iter-define":161,"./_iter-step":163,"./_meta":170,"./_object-create":174,"./_object-dp":175,"./_redefine-all":191,"./_set-species":195,"./_validate-collection":217}],130:[function(require,module,exports){
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_an-instance":118,"./_an-object":119,"./_array-methods":123,"./_for-of":145,"./_has":147,"./_is-object":157,"./_meta":170,"./_redefine-all":191,"./_validate-collection":217}],131:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":118,"./_export":140,"./_fails":142,"./_for-of":145,"./_global":146,"./_inherit-if-required":151,"./_is-object":157,"./_iter-detect":162,"./_meta":170,"./_redefine":192,"./_redefine-all":191,"./_set-to-string-tag":196}],132:[function(require,module,exports){
var core = module.exports = { version: '2.5.7' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],133:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":175,"./_property-desc":190}],134:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":116}],135:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],136:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":142}],137:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":146,"./_is-object":157}],138:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],139:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":180,"./_object-keys":183,"./_object-pie":184}],140:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":132,"./_ctx":134,"./_global":146,"./_hide":148,"./_redefine":192}],141:[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":220}],142:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],143:[function(require,module,exports){
'use strict';
var hide = require('./_hide');
var redefine = require('./_redefine');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./_defined":135,"./_fails":142,"./_hide":148,"./_redefine":192,"./_wks":220}],144:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":119}],145:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":119,"./_ctx":134,"./_is-array-iter":154,"./_iter-call":159,"./_to-length":209,"./core.get-iterator-method":221}],146:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],147:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],148:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":136,"./_object-dp":175,"./_property-desc":190}],149:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":146}],150:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":136,"./_dom-create":137,"./_fails":142}],151:[function(require,module,exports){
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":157,"./_set-proto":194}],152:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],153:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":128}],154:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":164,"./_wks":220}],155:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":128}],156:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":157}],157:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],158:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_cof":128,"./_is-object":157,"./_wks":220}],159:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":119}],160:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":148,"./_object-create":174,"./_property-desc":190,"./_set-to-string-tag":196,"./_wks":220}],161:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":140,"./_hide":148,"./_iter-create":160,"./_iterators":164,"./_library":165,"./_object-gpo":181,"./_redefine":192,"./_set-to-string-tag":196,"./_wks":220}],162:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":220}],163:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],164:[function(require,module,exports){
module.exports = {};

},{}],165:[function(require,module,exports){
module.exports = false;

},{}],166:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],167:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":169}],168:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],169:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],170:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":142,"./_has":147,"./_is-object":157,"./_object-dp":175,"./_uid":215}],171:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":128,"./_global":146,"./_task":204}],172:[function(require,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":116}],173:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":142,"./_iobject":153,"./_object-gops":180,"./_object-keys":183,"./_object-pie":184,"./_to-object":210}],174:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":119,"./_dom-create":137,"./_enum-bug-keys":138,"./_html":149,"./_object-dps":176,"./_shared-key":197}],175:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":119,"./_descriptors":136,"./_ie8-dom-define":150,"./_to-primitive":211}],176:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":119,"./_descriptors":136,"./_object-dp":175,"./_object-keys":183}],177:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":136,"./_has":147,"./_ie8-dom-define":150,"./_object-pie":184,"./_property-desc":190,"./_to-iobject":208,"./_to-primitive":211}],178:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":179,"./_to-iobject":208}],179:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":138,"./_object-keys-internal":182}],180:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],181:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":147,"./_shared-key":197,"./_to-object":210}],182:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":122,"./_has":147,"./_shared-key":197,"./_to-iobject":208}],183:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":138,"./_object-keys-internal":182}],184:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],185:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":132,"./_export":140,"./_fails":142}],186:[function(require,module,exports){
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};

},{"./_object-keys":183,"./_object-pie":184,"./_to-iobject":208}],187:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_an-object":119,"./_global":146,"./_object-gopn":179,"./_object-gops":180}],188:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],189:[function(require,module,exports){
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":119,"./_is-object":157,"./_new-promise-capability":172}],190:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],191:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":192}],192:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_core":132,"./_global":146,"./_has":147,"./_hide":148,"./_uid":215}],193:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],194:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":119,"./_ctx":134,"./_is-object":157,"./_object-gopd":177}],195:[function(require,module,exports){
'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_descriptors":136,"./_global":146,"./_object-dp":175,"./_wks":220}],196:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":147,"./_object-dp":175,"./_wks":220}],197:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":198,"./_uid":215}],198:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":132,"./_global":146,"./_library":165}],199:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":116,"./_an-object":119,"./_wks":220}],200:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":135,"./_to-integer":207}],201:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_defined":135,"./_is-regexp":158}],202:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_defined":135,"./_string-repeat":203,"./_to-length":209}],203:[function(require,module,exports){
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_defined":135,"./_to-integer":207}],204:[function(require,module,exports){
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":128,"./_ctx":134,"./_dom-create":137,"./_global":146,"./_html":149,"./_invoke":152}],205:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":207}],206:[function(require,module,exports){
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":207,"./_to-length":209}],207:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],208:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":135,"./_iobject":153}],209:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":207}],210:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":135}],211:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":157}],212:[function(require,module,exports){
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_an-instance":118,"./_array-copy-within":120,"./_array-fill":121,"./_array-includes":122,"./_array-methods":123,"./_classof":127,"./_ctx":134,"./_descriptors":136,"./_export":140,"./_fails":142,"./_global":146,"./_has":147,"./_hide":148,"./_is-array-iter":154,"./_is-object":157,"./_iter-detect":162,"./_iterators":164,"./_library":165,"./_object-create":174,"./_object-dp":175,"./_object-gopd":177,"./_object-gopn":179,"./_object-gpo":181,"./_property-desc":190,"./_redefine-all":191,"./_set-species":195,"./_species-constructor":199,"./_to-absolute-index":205,"./_to-index":206,"./_to-integer":207,"./_to-length":209,"./_to-object":210,"./_to-primitive":211,"./_typed":214,"./_typed-buffer":213,"./_uid":215,"./_wks":220,"./core.get-iterator-method":221,"./es6.array.iterator":227}],213:[function(require,module,exports){
'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_an-instance":118,"./_array-fill":121,"./_descriptors":136,"./_fails":142,"./_global":146,"./_hide":148,"./_library":165,"./_object-dp":175,"./_object-gopn":179,"./_redefine-all":191,"./_set-to-string-tag":196,"./_to-index":206,"./_to-integer":207,"./_to-length":209,"./_typed":214}],214:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":146,"./_hide":148,"./_uid":215}],215:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],216:[function(require,module,exports){
var global = require('./_global');
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"./_global":146}],217:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":157}],218:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":132,"./_global":146,"./_library":165,"./_object-dp":175,"./_wks-ext":219}],219:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":220}],220:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":146,"./_shared":198,"./_uid":215}],221:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":127,"./_core":132,"./_iterators":164,"./_wks":220}],222:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_add-to-unscopables":117,"./_array-copy-within":120,"./_export":140}],223:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_add-to-unscopables":117,"./_array-fill":121,"./_export":140}],224:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":117,"./_array-methods":123,"./_export":140}],225:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":117,"./_array-methods":123,"./_export":140}],226:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":133,"./_ctx":134,"./_export":140,"./_is-array-iter":154,"./_iter-call":159,"./_iter-detect":162,"./_to-length":209,"./_to-object":210,"./core.get-iterator-method":221}],227:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":117,"./_iter-define":161,"./_iter-step":163,"./_iterators":164,"./_to-iobject":208}],228:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_create-property":133,"./_export":140,"./_fails":142}],229:[function(require,module,exports){
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_descriptors":136,"./_object-dp":175}],230:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":131,"./_collection-strong":129,"./_validate-collection":217}],231:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":140,"./_math-log1p":168}],232:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":140}],233:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":140}],234:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":140,"./_math-sign":169}],235:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":140}],236:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":140}],237:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":140,"./_math-expm1":166}],238:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":140,"./_math-fround":167}],239:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":140}],240:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":140,"./_fails":142}],241:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":140}],242:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":140,"./_math-log1p":168}],243:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":140}],244:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":140,"./_math-sign":169}],245:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":140,"./_fails":142,"./_math-expm1":166}],246:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":140,"./_math-expm1":166}],247:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":140}],248:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":140}],249:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":140,"./_global":146}],250:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":140,"./_is-integer":156}],251:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":140}],252:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":140,"./_is-integer":156}],253:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":140}],254:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":140}],255:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":140,"./_object-assign":173}],256:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":157,"./_meta":170,"./_object-sap":185}],257:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":177,"./_object-sap":185,"./_to-iobject":208}],258:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-gopn-ext":178,"./_object-sap":185}],259:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":181,"./_object-sap":185,"./_to-object":210}],260:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":157,"./_object-sap":185}],261:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":157,"./_object-sap":185}],262:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":157,"./_object-sap":185}],263:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":140,"./_same-value":193}],264:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_object-keys":183,"./_object-sap":185,"./_to-object":210}],265:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":157,"./_meta":170,"./_object-sap":185}],266:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":157,"./_meta":170,"./_object-sap":185}],267:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":140,"./_set-proto":194}],268:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var userAgent = require('./_user-agent');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":116,"./_an-instance":118,"./_classof":127,"./_core":132,"./_ctx":134,"./_export":140,"./_for-of":145,"./_global":146,"./_is-object":157,"./_iter-detect":162,"./_library":165,"./_microtask":171,"./_new-promise-capability":172,"./_perform":188,"./_promise-resolve":189,"./_redefine-all":191,"./_set-species":195,"./_set-to-string-tag":196,"./_species-constructor":199,"./_task":204,"./_user-agent":216,"./_wks":220}],269:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_a-function":116,"./_an-object":119,"./_export":140,"./_fails":142,"./_global":146}],270:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_a-function":116,"./_an-object":119,"./_bind":126,"./_export":140,"./_fails":142,"./_global":146,"./_is-object":157,"./_object-create":174}],271:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":119,"./_export":140,"./_fails":142,"./_object-dp":175,"./_to-primitive":211}],272:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_an-object":119,"./_export":140,"./_object-gopd":177}],273:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_an-object":119,"./_export":140,"./_object-gopd":177}],274:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_an-object":119,"./_export":140,"./_object-gpo":181}],275:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_an-object":119,"./_export":140,"./_has":147,"./_is-object":157,"./_object-gopd":177,"./_object-gpo":181}],276:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":140}],277:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_an-object":119,"./_export":140}],278:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":140,"./_own-keys":187}],279:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":119,"./_export":140}],280:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":140,"./_set-proto":194}],281:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_an-object":119,"./_export":140,"./_has":147,"./_is-object":157,"./_object-dp":175,"./_object-gopd":177,"./_object-gpo":181,"./_property-desc":190}],282:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":136,"./_flags":144,"./_object-dp":175}],283:[function(require,module,exports){
// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});

},{"./_fix-re-wks":143}],284:[function(require,module,exports){
// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

},{"./_fix-re-wks":143}],285:[function(require,module,exports){
// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});

},{"./_fix-re-wks":143}],286:[function(require,module,exports){
// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = require('./_is-regexp');
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

},{"./_fix-re-wks":143,"./_is-regexp":158}],287:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":131,"./_collection-strong":129,"./_validate-collection":217}],288:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":140,"./_string-at":200}],289:[function(require,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":140,"./_fails-is-regexp":141,"./_string-context":201,"./_to-length":209}],290:[function(require,module,exports){
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":140,"./_to-absolute-index":205}],291:[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":140,"./_fails-is-regexp":141,"./_string-context":201}],292:[function(require,module,exports){
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":140,"./_to-iobject":208,"./_to-length":209}],293:[function(require,module,exports){
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":140,"./_string-repeat":203}],294:[function(require,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":140,"./_fails-is-regexp":141,"./_string-context":201,"./_to-length":209}],295:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":119,"./_descriptors":136,"./_enum-keys":139,"./_export":140,"./_fails":142,"./_global":146,"./_has":147,"./_hide":148,"./_is-array":155,"./_is-object":157,"./_library":165,"./_meta":170,"./_object-create":174,"./_object-dp":175,"./_object-gopd":177,"./_object-gopn":179,"./_object-gopn-ext":178,"./_object-gops":180,"./_object-keys":183,"./_object-pie":184,"./_property-desc":190,"./_redefine":192,"./_set-to-string-tag":196,"./_shared":198,"./_to-iobject":208,"./_to-primitive":211,"./_uid":215,"./_wks":220,"./_wks-define":218,"./_wks-ext":219}],296:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_an-object":119,"./_export":140,"./_fails":142,"./_global":146,"./_is-object":157,"./_set-species":195,"./_species-constructor":199,"./_to-absolute-index":205,"./_to-length":209,"./_typed":214,"./_typed-buffer":213}],297:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":212}],298:[function(require,module,exports){
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":212}],299:[function(require,module,exports){
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":212}],300:[function(require,module,exports){
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":212}],301:[function(require,module,exports){
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":212}],302:[function(require,module,exports){
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":212}],303:[function(require,module,exports){
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":212}],304:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":212}],305:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":212}],306:[function(require,module,exports){
'use strict';
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var fails = require('./_fails');
var validate = require('./_validate-collection');
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_array-methods":123,"./_collection":131,"./_collection-weak":130,"./_fails":142,"./_is-object":157,"./_meta":170,"./_object-assign":173,"./_redefine":192,"./_validate-collection":217}],307:[function(require,module,exports){
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection":131,"./_collection-weak":130,"./_validate-collection":217}],308:[function(require,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_add-to-unscopables":117,"./_array-includes":122,"./_export":140}],309:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":140,"./_object-to-array":186}],310:[function(require,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_create-property":133,"./_export":140,"./_object-gopd":177,"./_own-keys":187,"./_to-iobject":208}],311:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":140,"./_object-to-array":186}],312:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":140,"./_string-pad":202,"./_user-agent":216}],313:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":140,"./_string-pad":202,"./_user-agent":216}],314:[function(require,module,exports){
var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./_global":146,"./_hide":148,"./_iterators":164,"./_object-keys":183,"./_redefine":192,"./_wks":220,"./es6.array.iterator":227}],315:[function(require,module,exports){
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":140,"./_task":204}],316:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var userAgent = require('./_user-agent');
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_export":140,"./_global":146,"./_user-agent":216}],317:[function(require,module,exports){
'use strict';

var keys = require('object-keys');
var foreach = require('foreach');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

var toStr = Object.prototype.toString;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
        /* eslint-disable no-unused-vars, no-restricted-syntax */
        for (var _ in obj) { return false; }
        /* eslint-enable no-unused-vars, no-restricted-syntax */
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		Object.defineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = props.concat(Object.getOwnPropertySymbols(map));
	}
	foreach(props, function (name) {
		defineProperty(object, name, map[name], predicates[name]);
	});
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"foreach":330,"object-keys":318}],318:[function(require,module,exports){
'use strict';

// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = require('./isArguments');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var excludedKeys = {
	$applicationCache: true,
	$console: true,
	$external: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$innerHeight: true,
	$innerWidth: true,
	$outerHeight: true,
	$outerWidth: true,
	$pageXOffset: true,
	$pageYOffset: true,
	$parent: true,
	$scrollLeft: true,
	$scrollTop: true,
	$scrollX: true,
	$scrollY: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./isArguments":319}],319:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],320:[function(require,module,exports){
'use strict';

/* globals
	Set,
	Map,
	WeakSet,
	WeakMap,

	Promise,

	Symbol,
	Proxy,

	Atomics,
	SharedArrayBuffer,

	ArrayBuffer,
	DataView,
	Uint8Array,
	Float32Array,
	Float64Array,
	Int8Array,
	Int16Array,
	Int32Array,
	Uint8ClampedArray,
	Uint16Array,
	Uint32Array,
*/

var undefined; // eslint-disable-line no-shadow-restricted-names

var ThrowTypeError = Object.getOwnPropertyDescriptor
	? (function () { return Object.getOwnPropertyDescriptor(arguments, 'callee').get; }())
	: function () { throw new TypeError(); };

var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var generator; // = function * () {};
var generatorFunction = generator ? getProto(generator) : undefined;
var asyncFn; // async function() {};
var asyncFunction = asyncFn ? asyncFn.constructor : undefined;
var asyncGen; // async function * () {};
var asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined;
var asyncGenIterator = asyncGen ? asyncGen() : undefined;

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'$ %Array%': Array,
	'$ %ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'$ %ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer.prototype,
	'$ %ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'$ %ArrayPrototype%': Array.prototype,
	'$ %ArrayProto_entries%': Array.prototype.entries,
	'$ %ArrayProto_forEach%': Array.prototype.forEach,
	'$ %ArrayProto_keys%': Array.prototype.keys,
	'$ %ArrayProto_values%': Array.prototype.values,
	'$ %AsyncFromSyncIteratorPrototype%': undefined,
	'$ %AsyncFunction%': asyncFunction,
	'$ %AsyncFunctionPrototype%': asyncFunction ? asyncFunction.prototype : undefined,
	'$ %AsyncGenerator%': asyncGen ? getProto(asyncGenIterator) : undefined,
	'$ %AsyncGeneratorFunction%': asyncGenFunction,
	'$ %AsyncGeneratorPrototype%': asyncGenFunction ? asyncGenFunction.prototype : undefined,
	'$ %AsyncIteratorPrototype%': asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined,
	'$ %Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'$ %Boolean%': Boolean,
	'$ %BooleanPrototype%': Boolean.prototype,
	'$ %DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'$ %DataViewPrototype%': typeof DataView === 'undefined' ? undefined : DataView.prototype,
	'$ %Date%': Date,
	'$ %DatePrototype%': Date.prototype,
	'$ %decodeURI%': decodeURI,
	'$ %decodeURIComponent%': decodeURIComponent,
	'$ %encodeURI%': encodeURI,
	'$ %encodeURIComponent%': encodeURIComponent,
	'$ %Error%': Error,
	'$ %ErrorPrototype%': Error.prototype,
	'$ %eval%': eval, // eslint-disable-line no-eval
	'$ %EvalError%': EvalError,
	'$ %EvalErrorPrototype%': EvalError.prototype,
	'$ %Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'$ %Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined : Float32Array.prototype,
	'$ %Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'$ %Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined : Float64Array.prototype,
	'$ %Function%': Function,
	'$ %FunctionPrototype%': Function.prototype,
	'$ %Generator%': generator ? getProto(generator()) : undefined,
	'$ %GeneratorFunction%': generatorFunction,
	'$ %GeneratorPrototype%': generatorFunction ? generatorFunction.prototype : undefined,
	'$ %Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'$ %Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined : Int8Array.prototype,
	'$ %Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'$ %Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined : Int8Array.prototype,
	'$ %Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'$ %Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined : Int32Array.prototype,
	'$ %isFinite%': isFinite,
	'$ %isNaN%': isNaN,
	'$ %IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'$ %JSON%': JSON,
	'$ %JSONParse%': JSON.parse,
	'$ %Map%': typeof Map === 'undefined' ? undefined : Map,
	'$ %MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'$ %MapPrototype%': typeof Map === 'undefined' ? undefined : Map.prototype,
	'$ %Math%': Math,
	'$ %Number%': Number,
	'$ %NumberPrototype%': Number.prototype,
	'$ %Object%': Object,
	'$ %ObjectPrototype%': Object.prototype,
	'$ %ObjProto_toString%': Object.prototype.toString,
	'$ %ObjProto_valueOf%': Object.prototype.valueOf,
	'$ %parseFloat%': parseFloat,
	'$ %parseInt%': parseInt,
	'$ %Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'$ %PromisePrototype%': typeof Promise === 'undefined' ? undefined : Promise.prototype,
	'$ %PromiseProto_then%': typeof Promise === 'undefined' ? undefined : Promise.prototype.then,
	'$ %Promise_all%': typeof Promise === 'undefined' ? undefined : Promise.all,
	'$ %Promise_reject%': typeof Promise === 'undefined' ? undefined : Promise.reject,
	'$ %Promise_resolve%': typeof Promise === 'undefined' ? undefined : Promise.resolve,
	'$ %Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'$ %RangeError%': RangeError,
	'$ %RangeErrorPrototype%': RangeError.prototype,
	'$ %ReferenceError%': ReferenceError,
	'$ %ReferenceErrorPrototype%': ReferenceError.prototype,
	'$ %Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'$ %RegExp%': RegExp,
	'$ %RegExpPrototype%': RegExp.prototype,
	'$ %Set%': typeof Set === 'undefined' ? undefined : Set,
	'$ %SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'$ %SetPrototype%': typeof Set === 'undefined' ? undefined : Set.prototype,
	'$ %SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'$ %SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer.prototype,
	'$ %String%': String,
	'$ %StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'$ %StringPrototype%': String.prototype,
	'$ %Symbol%': hasSymbols ? Symbol : undefined,
	'$ %SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined,
	'$ %SyntaxError%': SyntaxError,
	'$ %SyntaxErrorPrototype%': SyntaxError.prototype,
	'$ %ThrowTypeError%': ThrowTypeError,
	'$ %TypedArray%': TypedArray,
	'$ %TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined,
	'$ %TypeError%': TypeError,
	'$ %TypeErrorPrototype%': TypeError.prototype,
	'$ %Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'$ %Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array.prototype,
	'$ %Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'$ %Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray.prototype,
	'$ %Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'$ %Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array.prototype,
	'$ %Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'$ %Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array.prototype,
	'$ %URIError%': URIError,
	'$ %URIErrorPrototype%': URIError.prototype,
	'$ %WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'$ %WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined : WeakMap.prototype,
	'$ %WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
	'$ %WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined : WeakSet.prototype
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new TypeError('"allowMissing" argument must be a boolean');
	}

	var key = '$ ' + name;
	if (!(key in INTRINSICS)) {
		throw new SyntaxError('intrinsic ' + name + ' does not exist!');
	}

	// istanbul ignore if // hopefully this is impossible to test :-)
	if (typeof INTRINSICS[key] === 'undefined' && !allowMissing) {
		throw new TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
	}
	return INTRINSICS[key];
};

},{}],321:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('./GetIntrinsic');

var $Object = GetIntrinsic('%Object%');
var $TypeError = GetIntrinsic('%TypeError%');
var $String = GetIntrinsic('%String%');

var $isNaN = require('./helpers/isNaN');
var $isFinite = require('./helpers/isFinite');

var sign = require('./helpers/sign');
var mod = require('./helpers/mod');

var IsCallable = require('is-callable');
var toPrimitive = require('es-to-primitive/es5');

var has = require('has');

// https://es5.github.io/#x9
var ES5 = {
	ToPrimitive: toPrimitive,

	ToBoolean: function ToBoolean(value) {
		return !!value;
	},
	ToNumber: function ToNumber(value) {
		return +value; // eslint-disable-line no-implicit-coercion
	},
	ToInteger: function ToInteger(value) {
		var number = this.ToNumber(value);
		if ($isNaN(number)) { return 0; }
		if (number === 0 || !$isFinite(number)) { return number; }
		return sign(number) * Math.floor(Math.abs(number));
	},
	ToInt32: function ToInt32(x) {
		return this.ToNumber(x) >> 0;
	},
	ToUint32: function ToUint32(x) {
		return this.ToNumber(x) >>> 0;
	},
	ToUint16: function ToUint16(value) {
		var number = this.ToNumber(value);
		if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
		var posInt = sign(number) * Math.floor(Math.abs(number));
		return mod(posInt, 0x10000);
	},
	ToString: function ToString(value) {
		return $String(value);
	},
	ToObject: function ToObject(value) {
		this.CheckObjectCoercible(value);
		return $Object(value);
	},
	CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
		/* jshint eqnull:true */
		if (value == null) {
			throw new $TypeError(optMessage || 'Cannot call method on ' + value);
		}
		return value;
	},
	IsCallable: IsCallable,
	SameValue: function SameValue(x, y) {
		if (x === y) { // 0 === -0, but they are not identical.
			if (x === 0) { return 1 / x === 1 / y; }
			return true;
		}
		return $isNaN(x) && $isNaN(y);
	},

	// https://www.ecma-international.org/ecma-262/5.1/#sec-8
	Type: function Type(x) {
		if (x === null) {
			return 'Null';
		}
		if (typeof x === 'undefined') {
			return 'Undefined';
		}
		if (typeof x === 'function' || typeof x === 'object') {
			return 'Object';
		}
		if (typeof x === 'number') {
			return 'Number';
		}
		if (typeof x === 'boolean') {
			return 'Boolean';
		}
		if (typeof x === 'string') {
			return 'String';
		}
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
	IsPropertyDescriptor: function IsPropertyDescriptor(Desc) {
		if (this.Type(Desc) !== 'Object') {
			return false;
		}
		var allowed = {
			'[[Configurable]]': true,
			'[[Enumerable]]': true,
			'[[Get]]': true,
			'[[Set]]': true,
			'[[Value]]': true,
			'[[Writable]]': true
		};
		// jscs:disable
		for (var key in Desc) { // eslint-disable-line
			if (has(Desc, key) && !allowed[key]) {
				return false;
			}
		}
		// jscs:enable
		var isData = has(Desc, '[[Value]]');
		var IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');
		if (isData && IsAccessor) {
			throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');
		}
		return true;
	},

	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.1
	IsAccessorDescriptor: function IsAccessorDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return false;
		}

		if (!this.IsPropertyDescriptor(Desc)) {
			throw new $TypeError('Desc must be a Property Descriptor');
		}

		if (!has(Desc, '[[Get]]') && !has(Desc, '[[Set]]')) {
			return false;
		}

		return true;
	},

	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.2
	IsDataDescriptor: function IsDataDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return false;
		}

		if (!this.IsPropertyDescriptor(Desc)) {
			throw new $TypeError('Desc must be a Property Descriptor');
		}

		if (!has(Desc, '[[Value]]') && !has(Desc, '[[Writable]]')) {
			return false;
		}

		return true;
	},

	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.3
	IsGenericDescriptor: function IsGenericDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return false;
		}

		if (!this.IsPropertyDescriptor(Desc)) {
			throw new $TypeError('Desc must be a Property Descriptor');
		}

		if (!this.IsAccessorDescriptor(Desc) && !this.IsDataDescriptor(Desc)) {
			return true;
		}

		return false;
	},

	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.4
	FromPropertyDescriptor: function FromPropertyDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return Desc;
		}

		if (!this.IsPropertyDescriptor(Desc)) {
			throw new $TypeError('Desc must be a Property Descriptor');
		}

		if (this.IsDataDescriptor(Desc)) {
			return {
				value: Desc['[[Value]]'],
				writable: !!Desc['[[Writable]]'],
				enumerable: !!Desc['[[Enumerable]]'],
				configurable: !!Desc['[[Configurable]]']
			};
		} else if (this.IsAccessorDescriptor(Desc)) {
			return {
				get: Desc['[[Get]]'],
				set: Desc['[[Set]]'],
				enumerable: !!Desc['[[Enumerable]]'],
				configurable: !!Desc['[[Configurable]]']
			};
		} else {
			throw new $TypeError('FromPropertyDescriptor must be called with a fully populated Property Descriptor');
		}
	},

	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.5
	ToPropertyDescriptor: function ToPropertyDescriptor(Obj) {
		if (this.Type(Obj) !== 'Object') {
			throw new $TypeError('ToPropertyDescriptor requires an object');
		}

		var desc = {};
		if (has(Obj, 'enumerable')) {
			desc['[[Enumerable]]'] = this.ToBoolean(Obj.enumerable);
		}
		if (has(Obj, 'configurable')) {
			desc['[[Configurable]]'] = this.ToBoolean(Obj.configurable);
		}
		if (has(Obj, 'value')) {
			desc['[[Value]]'] = Obj.value;
		}
		if (has(Obj, 'writable')) {
			desc['[[Writable]]'] = this.ToBoolean(Obj.writable);
		}
		if (has(Obj, 'get')) {
			var getter = Obj.get;
			if (typeof getter !== 'undefined' && !this.IsCallable(getter)) {
				throw new TypeError('getter must be a function');
			}
			desc['[[Get]]'] = getter;
		}
		if (has(Obj, 'set')) {
			var setter = Obj.set;
			if (typeof setter !== 'undefined' && !this.IsCallable(setter)) {
				throw new $TypeError('setter must be a function');
			}
			desc['[[Set]]'] = setter;
		}

		if ((has(desc, '[[Get]]') || has(desc, '[[Set]]')) && (has(desc, '[[Value]]') || has(desc, '[[Writable]]'))) {
			throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
		}
		return desc;
	}
};

module.exports = ES5;

},{"./GetIntrinsic":320,"./helpers/isFinite":322,"./helpers/isNaN":323,"./helpers/mod":324,"./helpers/sign":325,"es-to-primitive/es5":326,"has":333,"is-callable":335}],322:[function(require,module,exports){
var $isNaN = Number.isNaN || function (a) { return a !== a; };

module.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };

},{}],323:[function(require,module,exports){
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};

},{}],324:[function(require,module,exports){
module.exports = function mod(number, modulo) {
	var remain = number % modulo;
	return Math.floor(remain >= 0 ? remain : remain + modulo);
};

},{}],325:[function(require,module,exports){
module.exports = function sign(number) {
	return number >= 0 ? 1 : -1;
};

},{}],326:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

var isPrimitive = require('./helpers/isPrimitive');

var isCallable = require('is-callable');

// https://es5.github.io/#x8.12
var ES5internalSlots = {
	'[[DefaultValue]]': function (O, hint) {
		var actualHint = hint || (toStr.call(O) === '[object Date]' ? String : Number);

		if (actualHint === String || actualHint === Number) {
			var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
			var value, i;
			for (i = 0; i < methods.length; ++i) {
				if (isCallable(O[methods[i]])) {
					value = O[methods[i]]();
					if (isPrimitive(value)) {
						return value;
					}
				}
			}
			throw new TypeError('No default value');
		}
		throw new TypeError('invalid [[DefaultValue]] hint supplied');
	}
};

// https://es5.github.io/#x9
module.exports = function ToPrimitive(input, PreferredType) {
	if (isPrimitive(input)) {
		return input;
	}
	return ES5internalSlots['[[DefaultValue]]'](input, PreferredType);
};

},{"./helpers/isPrimitive":327,"is-callable":335}],327:[function(require,module,exports){
module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};

},{}],328:[function(require,module,exports){
/**
 * EvEmitter v1.1.0
 * Lil' event emitter
 * MIT License
 */

/* jshint unused: true, undef: true, strict: true */

( function( global, factory ) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, window */
  if ( typeof define == 'function' && define.amd ) {
    // AMD - RequireJS
    define( factory );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS - Browserify, Webpack
    module.exports = factory();
  } else {
    // Browser globals
    global.EvEmitter = factory();
  }

}( typeof window != 'undefined' ? window : this, function() {

"use strict";

function EvEmitter() {}

var proto = EvEmitter.prototype;

proto.on = function( eventName, listener ) {
  if ( !eventName || !listener ) {
    return;
  }
  // set events hash
  var events = this._events = this._events || {};
  // set listeners array
  var listeners = events[ eventName ] = events[ eventName ] || [];
  // only add once
  if ( listeners.indexOf( listener ) == -1 ) {
    listeners.push( listener );
  }

  return this;
};

proto.once = function( eventName, listener ) {
  if ( !eventName || !listener ) {
    return;
  }
  // add event
  this.on( eventName, listener );
  // set once flag
  // set onceEvents hash
  var onceEvents = this._onceEvents = this._onceEvents || {};
  // set onceListeners object
  var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
  // set flag
  onceListeners[ listener ] = true;

  return this;
};

proto.off = function( eventName, listener ) {
  var listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) {
    return;
  }
  var index = listeners.indexOf( listener );
  if ( index != -1 ) {
    listeners.splice( index, 1 );
  }

  return this;
};

proto.emitEvent = function( eventName, args ) {
  var listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) {
    return;
  }
  // copy over to avoid interference if .off() in listener
  listeners = listeners.slice(0);
  args = args || [];
  // once stuff
  var onceListeners = this._onceEvents && this._onceEvents[ eventName ];

  for ( var i=0; i < listeners.length; i++ ) {
    var listener = listeners[i]
    var isOnce = onceListeners && onceListeners[ listener ];
    if ( isOnce ) {
      // remove listener
      // remove before trigger to prevent recursion
      this.off( eventName, listener );
      // unset once flag
      delete onceListeners[ listener ];
    }
    // trigger listener
    listener.apply( this, args );
  }

  return this;
};

proto.allOff = function() {
  delete this._events;
  delete this._onceEvents;
};

return EvEmitter;

}));

},{}],329:[function(require,module,exports){
'use strict';

var isCallable = require('is-callable');

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (toStr.call(list) === '[object Array]') {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

module.exports = forEach;

},{"is-callable":335}],330:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],331:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],332:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":331}],333:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":332}],334:[function(require,module,exports){
/*!
 * imagesLoaded v4.1.4
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

( function( window, factory ) { 'use strict';
  // universal module definition

  /*global define: false, module: false, require: false */

  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( [
      'ev-emitter/ev-emitter'
    ], function( EvEmitter ) {
      return factory( window, EvEmitter );
    });
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
      window,
      require('ev-emitter')
    );
  } else {
    // browser global
    window.imagesLoaded = factory(
      window,
      window.EvEmitter
    );
  }

})( typeof window !== 'undefined' ? window : this,

// --------------------------  factory -------------------------- //

function factory( window, EvEmitter ) {

'use strict';

var $ = window.jQuery;
var console = window.console;

// -------------------------- helpers -------------------------- //

// extend objects
function extend( a, b ) {
  for ( var prop in b ) {
    a[ prop ] = b[ prop ];
  }
  return a;
}

var arraySlice = Array.prototype.slice;

// turn element or nodeList into an array
function makeArray( obj ) {
  if ( Array.isArray( obj ) ) {
    // use object if already an array
    return obj;
  }

  var isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
  if ( isArrayLike ) {
    // convert nodeList to array
    return arraySlice.call( obj );
  }

  // array of single index
  return [ obj ];
}

// -------------------------- imagesLoaded -------------------------- //

/**
 * @param {Array, Element, NodeList, String} elem
 * @param {Object or Function} options - if function, use as callback
 * @param {Function} onAlways - callback function
 */
function ImagesLoaded( elem, options, onAlways ) {
  // coerce ImagesLoaded() without new, to be new ImagesLoaded()
  if ( !( this instanceof ImagesLoaded ) ) {
    return new ImagesLoaded( elem, options, onAlways );
  }
  // use elem as selector string
  var queryElem = elem;
  if ( typeof elem == 'string' ) {
    queryElem = document.querySelectorAll( elem );
  }
  // bail if bad element
  if ( !queryElem ) {
    console.error( 'Bad element for imagesLoaded ' + ( queryElem || elem ) );
    return;
  }

  this.elements = makeArray( queryElem );
  this.options = extend( {}, this.options );
  // shift arguments if no options set
  if ( typeof options == 'function' ) {
    onAlways = options;
  } else {
    extend( this.options, options );
  }

  if ( onAlways ) {
    this.on( 'always', onAlways );
  }

  this.getImages();

  if ( $ ) {
    // add jQuery Deferred object
    this.jqDeferred = new $.Deferred();
  }

  // HACK check async to allow time to bind listeners
  setTimeout( this.check.bind( this ) );
}

ImagesLoaded.prototype = Object.create( EvEmitter.prototype );

ImagesLoaded.prototype.options = {};

ImagesLoaded.prototype.getImages = function() {
  this.images = [];

  // filter & find items if we have an item selector
  this.elements.forEach( this.addElementImages, this );
};

/**
 * @param {Node} element
 */
ImagesLoaded.prototype.addElementImages = function( elem ) {
  // filter siblings
  if ( elem.nodeName == 'IMG' ) {
    this.addImage( elem );
  }
  // get background image on element
  if ( this.options.background === true ) {
    this.addElementBackgroundImages( elem );
  }

  // find children
  // no non-element nodes, #143
  var nodeType = elem.nodeType;
  if ( !nodeType || !elementNodeTypes[ nodeType ] ) {
    return;
  }
  var childImgs = elem.querySelectorAll('img');
  // concat childElems to filterFound array
  for ( var i=0; i < childImgs.length; i++ ) {
    var img = childImgs[i];
    this.addImage( img );
  }

  // get child background images
  if ( typeof this.options.background == 'string' ) {
    var children = elem.querySelectorAll( this.options.background );
    for ( i=0; i < children.length; i++ ) {
      var child = children[i];
      this.addElementBackgroundImages( child );
    }
  }
};

var elementNodeTypes = {
  1: true,
  9: true,
  11: true
};

ImagesLoaded.prototype.addElementBackgroundImages = function( elem ) {
  var style = getComputedStyle( elem );
  if ( !style ) {
    // Firefox returns null if in a hidden iframe https://bugzil.la/548397
    return;
  }
  // get url inside url("...")
  var reURL = /url\((['"])?(.*?)\1\)/gi;
  var matches = reURL.exec( style.backgroundImage );
  while ( matches !== null ) {
    var url = matches && matches[2];
    if ( url ) {
      this.addBackground( url, elem );
    }
    matches = reURL.exec( style.backgroundImage );
  }
};

/**
 * @param {Image} img
 */
ImagesLoaded.prototype.addImage = function( img ) {
  var loadingImage = new LoadingImage( img );
  this.images.push( loadingImage );
};

ImagesLoaded.prototype.addBackground = function( url, elem ) {
  var background = new Background( url, elem );
  this.images.push( background );
};

ImagesLoaded.prototype.check = function() {
  var _this = this;
  this.progressedCount = 0;
  this.hasAnyBroken = false;
  // complete if no images
  if ( !this.images.length ) {
    this.complete();
    return;
  }

  function onProgress( image, elem, message ) {
    // HACK - Chrome triggers event before object properties have changed. #83
    setTimeout( function() {
      _this.progress( image, elem, message );
    });
  }

  this.images.forEach( function( loadingImage ) {
    loadingImage.once( 'progress', onProgress );
    loadingImage.check();
  });
};

ImagesLoaded.prototype.progress = function( image, elem, message ) {
  this.progressedCount++;
  this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
  // progress event
  this.emitEvent( 'progress', [ this, image, elem ] );
  if ( this.jqDeferred && this.jqDeferred.notify ) {
    this.jqDeferred.notify( this, image );
  }
  // check if completed
  if ( this.progressedCount == this.images.length ) {
    this.complete();
  }

  if ( this.options.debug && console ) {
    console.log( 'progress: ' + message, image, elem );
  }
};

ImagesLoaded.prototype.complete = function() {
  var eventName = this.hasAnyBroken ? 'fail' : 'done';
  this.isComplete = true;
  this.emitEvent( eventName, [ this ] );
  this.emitEvent( 'always', [ this ] );
  if ( this.jqDeferred ) {
    var jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';
    this.jqDeferred[ jqMethod ]( this );
  }
};

// --------------------------  -------------------------- //

function LoadingImage( img ) {
  this.img = img;
}

LoadingImage.prototype = Object.create( EvEmitter.prototype );

LoadingImage.prototype.check = function() {
  // If complete is true and browser supports natural sizes,
  // try to check for image status manually.
  var isComplete = this.getIsImageComplete();
  if ( isComplete ) {
    // report based on naturalWidth
    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
    return;
  }

  // If none of the checks above matched, simulate loading on detached element.
  this.proxyImage = new Image();
  this.proxyImage.addEventListener( 'load', this );
  this.proxyImage.addEventListener( 'error', this );
  // bind to image as well for Firefox. #191
  this.img.addEventListener( 'load', this );
  this.img.addEventListener( 'error', this );
  this.proxyImage.src = this.img.src;
};

LoadingImage.prototype.getIsImageComplete = function() {
  // check for non-zero, non-undefined naturalWidth
  // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671
  return this.img.complete && this.img.naturalWidth;
};

LoadingImage.prototype.confirm = function( isLoaded, message ) {
  this.isLoaded = isLoaded;
  this.emitEvent( 'progress', [ this, this.img, message ] );
};

// ----- events ----- //

// trigger specified handler for event type
LoadingImage.prototype.handleEvent = function( event ) {
  var method = 'on' + event.type;
  if ( this[ method ] ) {
    this[ method ]( event );
  }
};

LoadingImage.prototype.onload = function() {
  this.confirm( true, 'onload' );
  this.unbindEvents();
};

LoadingImage.prototype.onerror = function() {
  this.confirm( false, 'onerror' );
  this.unbindEvents();
};

LoadingImage.prototype.unbindEvents = function() {
  this.proxyImage.removeEventListener( 'load', this );
  this.proxyImage.removeEventListener( 'error', this );
  this.img.removeEventListener( 'load', this );
  this.img.removeEventListener( 'error', this );
};

// -------------------------- Background -------------------------- //

function Background( url, element ) {
  this.url = url;
  this.element = element;
  this.img = new Image();
}

// inherit LoadingImage prototype
Background.prototype = Object.create( LoadingImage.prototype );

Background.prototype.check = function() {
  this.img.addEventListener( 'load', this );
  this.img.addEventListener( 'error', this );
  this.img.src = this.url;
  // check if image is already complete
  var isComplete = this.getIsImageComplete();
  if ( isComplete ) {
    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
    this.unbindEvents();
  }
};

Background.prototype.unbindEvents = function() {
  this.img.removeEventListener( 'load', this );
  this.img.removeEventListener( 'error', this );
};

Background.prototype.confirm = function( isLoaded, message ) {
  this.isLoaded = isLoaded;
  this.emitEvent( 'progress', [ this, this.element, message ] );
};

// -------------------------- jQuery -------------------------- //

ImagesLoaded.makeJQueryPlugin = function( jQuery ) {
  jQuery = jQuery || window.jQuery;
  if ( !jQuery ) {
    return;
  }
  // set local variable
  $ = jQuery;
  // $().imagesLoaded()
  $.fn.imagesLoaded = function( options, callback ) {
    var instance = new ImagesLoaded( this, options, callback );
    return instance.jqDeferred.promise( $(this) );
  };
};
// try making plugin
ImagesLoaded.makeJQueryPlugin();

// --------------------------  -------------------------- //

return ImagesLoaded;

});

},{"ev-emitter":328}],335:[function(require,module,exports){
'use strict';

var fnToStr = Function.prototype.toString;

var constructorRegex = /^\s*class /;
var isES6ClassFn = function isES6ClassFn(value) {
	try {
		var fnStr = fnToStr.call(value);
		var singleStripped = fnStr.replace(/\/\/.*\n/g, '');
		var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, '');
		var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' ');
		return constructorRegex.test(spaceStripped);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionObject(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isCallable(value) {
	if (!value) { return false; }
	if (typeof value !== 'function' && typeof value !== 'object') { return false; }
	if (hasToStringTag) { return tryFunctionObject(value); }
	if (isES6ClassFn(value)) { return false; }
	var strClass = toStr.call(value);
	return strClass === fnClass || strClass === genClass;
};

},{}],336:[function(require,module,exports){
(function (global){
/*!
 * jQuery Form Plugin
 * version: 4.2.2
 * Requires jQuery v1.7.2 or later
 * Project repository: https://github.com/jquery-form/form

 * Copyright 2017 Kevin Morris
 * Copyright 2006 M. Alsup

 * Dual licensed under the LGPL-2.1+ or MIT licenses
 * https://github.com/jquery-form/form#license

 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 */
!function(e){"function"==typeof define&&define.amd?define(["jquery"],e):"object"==typeof module&&module.exports?module.exports=function(t,r){return void 0===r&&(r="undefined"!=typeof window?(typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null):(typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null)(t)),e(r),r}:e(jQuery)}(function(e){"use strict";function t(t){var r=t.data;t.isDefaultPrevented()||(t.preventDefault(),e(t.target).closest("form").ajaxSubmit(r))}function r(t){var r=t.target,a=e(r);if(!a.is("[type=submit],[type=image]")){var n=a.closest("[type=submit]");if(0===n.length)return;r=n[0]}var i=r.form;if(i.clk=r,"image"===r.type)if(void 0!==t.offsetX)i.clk_x=t.offsetX,i.clk_y=t.offsetY;else if("function"==typeof e.fn.offset){var o=a.offset();i.clk_x=t.pageX-o.left,i.clk_y=t.pageY-o.top}else i.clk_x=t.pageX-r.offsetLeft,i.clk_y=t.pageY-r.offsetTop;setTimeout(function(){i.clk=i.clk_x=i.clk_y=null},100)}function a(){if(e.fn.ajaxSubmit.debug){var t="[jquery.form] "+Array.prototype.join.call(arguments,"");window.console&&window.console.log?window.console.log(t):window.opera&&window.opera.postError&&window.opera.postError(t)}}var n=/\r?\n/g,i={};i.fileapi=void 0!==e('<input type="file">').get(0).files,i.formdata=void 0!==window.FormData;var o=!!e.fn.prop;e.fn.attr2=function(){if(!o)return this.attr.apply(this,arguments);var e=this.prop.apply(this,arguments);return e&&e.jquery||"string"==typeof e?e:this.attr.apply(this,arguments)},e.fn.ajaxSubmit=function(t,r,n,s){function u(r){var a,n,i=e.param(r,t.traditional).split("&"),o=i.length,s=[];for(a=0;a<o;a++)i[a]=i[a].replace(/\+/g," "),n=i[a].split("="),s.push([decodeURIComponent(n[0]),decodeURIComponent(n[1])]);return s}function c(r){function n(e){var t=null;try{e.contentWindow&&(t=e.contentWindow.document)}catch(e){a("cannot get iframe.contentWindow document: "+e)}if(t)return t;try{t=e.contentDocument?e.contentDocument:e.document}catch(r){a("cannot get iframe.contentDocument: "+r),t=e.document}return t}function i(){function t(){try{var e=n(v).readyState;a("state = "+e),e&&"uninitialized"===e.toLowerCase()&&setTimeout(t,50)}catch(e){a("Server abort: ",e," (",e.name,")"),s(L),j&&clearTimeout(j),j=void 0}}var r=p.attr2("target"),i=p.attr2("action"),o=p.attr("enctype")||p.attr("encoding")||"multipart/form-data";w.setAttribute("target",m),l&&!/post/i.test(l)||w.setAttribute("method","POST"),i!==f.url&&w.setAttribute("action",f.url),f.skipEncodingOverride||l&&!/post/i.test(l)||p.attr({encoding:"multipart/form-data",enctype:"multipart/form-data"}),f.timeout&&(j=setTimeout(function(){T=!0,s(A)},f.timeout));var u=[];try{if(f.extraData)for(var c in f.extraData)f.extraData.hasOwnProperty(c)&&(e.isPlainObject(f.extraData[c])&&f.extraData[c].hasOwnProperty("name")&&f.extraData[c].hasOwnProperty("value")?u.push(e('<input type="hidden" name="'+f.extraData[c].name+'">',k).val(f.extraData[c].value).appendTo(w)[0]):u.push(e('<input type="hidden" name="'+c+'">',k).val(f.extraData[c]).appendTo(w)[0]));f.iframeTarget||h.appendTo(D),v.attachEvent?v.attachEvent("onload",s):v.addEventListener("load",s,!1),setTimeout(t,15);try{w.submit()}catch(e){document.createElement("form").submit.apply(w)}}finally{w.setAttribute("action",i),w.setAttribute("enctype",o),r?w.setAttribute("target",r):p.removeAttr("target"),e(u).remove()}}function s(t){if(!x.aborted&&!X){if((O=n(v))||(a("cannot access response document"),t=L),t===A&&x)return x.abort("timeout"),void S.reject(x,"timeout");if(t===L&&x)return x.abort("server abort"),void S.reject(x,"error","server abort");if(O&&O.location.href!==f.iframeSrc||T){v.detachEvent?v.detachEvent("onload",s):v.removeEventListener("load",s,!1);var r,i="success";try{if(T)throw"timeout";var o="xml"===f.dataType||O.XMLDocument||e.isXMLDoc(O);if(a("isXml="+o),!o&&window.opera&&(null===O.body||!O.body.innerHTML)&&--C)return a("requeing onLoad callback, DOM not available"),void setTimeout(s,250);var u=O.body?O.body:O.documentElement;x.responseText=u?u.innerHTML:null,x.responseXML=O.XMLDocument?O.XMLDocument:O,o&&(f.dataType="xml"),x.getResponseHeader=function(e){return{"content-type":f.dataType}[e.toLowerCase()]},u&&(x.status=Number(u.getAttribute("status"))||x.status,x.statusText=u.getAttribute("statusText")||x.statusText);var c=(f.dataType||"").toLowerCase(),l=/(json|script|text)/.test(c);if(l||f.textarea){var p=O.getElementsByTagName("textarea")[0];if(p)x.responseText=p.value,x.status=Number(p.getAttribute("status"))||x.status,x.statusText=p.getAttribute("statusText")||x.statusText;else if(l){var m=O.getElementsByTagName("pre")[0],g=O.getElementsByTagName("body")[0];m?x.responseText=m.textContent?m.textContent:m.innerText:g&&(x.responseText=g.textContent?g.textContent:g.innerText)}}else"xml"===c&&!x.responseXML&&x.responseText&&(x.responseXML=q(x.responseText));try{M=N(x,c,f)}catch(e){i="parsererror",x.error=r=e||i}}catch(e){a("error caught: ",e),i="error",x.error=r=e||i}x.aborted&&(a("upload aborted"),i=null),x.status&&(i=x.status>=200&&x.status<300||304===x.status?"success":"error"),"success"===i?(f.success&&f.success.call(f.context,M,"success",x),S.resolve(x.responseText,"success",x),d&&e.event.trigger("ajaxSuccess",[x,f])):i&&(void 0===r&&(r=x.statusText),f.error&&f.error.call(f.context,x,i,r),S.reject(x,"error",r),d&&e.event.trigger("ajaxError",[x,f,r])),d&&e.event.trigger("ajaxComplete",[x,f]),d&&!--e.active&&e.event.trigger("ajaxStop"),f.complete&&f.complete.call(f.context,x,i),X=!0,f.timeout&&clearTimeout(j),setTimeout(function(){f.iframeTarget?h.attr("src",f.iframeSrc):h.remove(),x.responseXML=null},100)}}}var u,c,f,d,m,h,v,x,y,b,T,j,w=p[0],S=e.Deferred();if(S.abort=function(e){x.abort(e)},r)for(c=0;c<g.length;c++)u=e(g[c]),o?u.prop("disabled",!1):u.removeAttr("disabled");(f=e.extend(!0,{},e.ajaxSettings,t)).context=f.context||f,m="jqFormIO"+(new Date).getTime();var k=w.ownerDocument,D=p.closest("body");if(f.iframeTarget?(b=(h=e(f.iframeTarget,k)).attr2("name"))?m=b:h.attr2("name",m):(h=e('<iframe name="'+m+'" src="'+f.iframeSrc+'" />',k)).css({position:"absolute",top:"-1000px",left:"-1000px"}),v=h[0],x={aborted:0,responseText:null,responseXML:null,status:0,statusText:"n/a",getAllResponseHeaders:function(){},getResponseHeader:function(){},setRequestHeader:function(){},abort:function(t){var r="timeout"===t?"timeout":"aborted";a("aborting upload... "+r),this.aborted=1;try{v.contentWindow.document.execCommand&&v.contentWindow.document.execCommand("Stop")}catch(e){}h.attr("src",f.iframeSrc),x.error=r,f.error&&f.error.call(f.context,x,r,t),d&&e.event.trigger("ajaxError",[x,f,r]),f.complete&&f.complete.call(f.context,x,r)}},(d=f.global)&&0==e.active++&&e.event.trigger("ajaxStart"),d&&e.event.trigger("ajaxSend",[x,f]),f.beforeSend&&!1===f.beforeSend.call(f.context,x,f))return f.global&&e.active--,S.reject(),S;if(x.aborted)return S.reject(),S;(y=w.clk)&&(b=y.name)&&!y.disabled&&(f.extraData=f.extraData||{},f.extraData[b]=y.value,"image"===y.type&&(f.extraData[b+".x"]=w.clk_x,f.extraData[b+".y"]=w.clk_y));var A=1,L=2,F=e("meta[name=csrf-token]").attr("content"),E=e("meta[name=csrf-param]").attr("content");E&&F&&(f.extraData=f.extraData||{},f.extraData[E]=F),f.forceSync?i():setTimeout(i,10);var M,O,X,C=50,q=e.parseXML||function(e,t){return window.ActiveXObject?((t=new ActiveXObject("Microsoft.XMLDOM")).async="false",t.loadXML(e)):t=(new DOMParser).parseFromString(e,"text/xml"),t&&t.documentElement&&"parsererror"!==t.documentElement.nodeName?t:null},_=e.parseJSON||function(e){return window.eval("("+e+")")},N=function(t,r,a){var n=t.getResponseHeader("content-type")||"",i=("xml"===r||!r)&&n.indexOf("xml")>=0,o=i?t.responseXML:t.responseText;return i&&"parsererror"===o.documentElement.nodeName&&e.error&&e.error("parsererror"),a&&a.dataFilter&&(o=a.dataFilter(o,r)),"string"==typeof o&&(("json"===r||!r)&&n.indexOf("json")>=0?o=_(o):("script"===r||!r)&&n.indexOf("javascript")>=0&&e.globalEval(o)),o};return S}if(!this.length)return a("ajaxSubmit: skipping submit process - no element selected"),this;var l,f,d,p=this;"function"==typeof t?t={success:t}:"string"==typeof t||!1===t&&arguments.length>0?(t={url:t,data:r,dataType:n},"function"==typeof s&&(t.success=s)):void 0===t&&(t={}),l=t.method||t.type||this.attr2("method"),(d=(d="string"==typeof(f=t.url||this.attr2("action"))?e.trim(f):"")||window.location.href||"")&&(d=(d.match(/^([^#]+)/)||[])[1]),t=e.extend(!0,{url:d,success:e.ajaxSettings.success,type:l||e.ajaxSettings.type,iframeSrc:/^https/i.test(window.location.href||"")?"javascript:false":"about:blank"},t);var m={};if(this.trigger("form-pre-serialize",[this,t,m]),m.veto)return a("ajaxSubmit: submit vetoed via form-pre-serialize trigger"),this;if(t.beforeSerialize&&!1===t.beforeSerialize(this,t))return a("ajaxSubmit: submit aborted via beforeSerialize callback"),this;var h=t.traditional;void 0===h&&(h=e.ajaxSettings.traditional);var v,g=[],x=this.formToArray(t.semantic,g,t.filtering);if(t.data){var y=e.isFunction(t.data)?t.data(x):t.data;t.extraData=y,v=e.param(y,h)}if(t.beforeSubmit&&!1===t.beforeSubmit(x,this,t))return a("ajaxSubmit: submit aborted via beforeSubmit callback"),this;if(this.trigger("form-submit-validate",[x,this,t,m]),m.veto)return a("ajaxSubmit: submit vetoed via form-submit-validate trigger"),this;var b=e.param(x,h);v&&(b=b?b+"&"+v:v),"GET"===t.type.toUpperCase()?(t.url+=(t.url.indexOf("?")>=0?"&":"?")+b,t.data=null):t.data=b;var T=[];if(t.resetForm&&T.push(function(){p.resetForm()}),t.clearForm&&T.push(function(){p.clearForm(t.includeHidden)}),!t.dataType&&t.target){var j=t.success||function(){};T.push(function(r,a,n){var i=arguments,o=t.replaceTarget?"replaceWith":"html";e(t.target)[o](r).each(function(){j.apply(this,i)})})}else t.success&&(e.isArray(t.success)?e.merge(T,t.success):T.push(t.success));if(t.success=function(e,r,a){for(var n=t.context||this,i=0,o=T.length;i<o;i++)T[i].apply(n,[e,r,a||p,p])},t.error){var w=t.error;t.error=function(e,r,a){var n=t.context||this;w.apply(n,[e,r,a,p])}}if(t.complete){var S=t.complete;t.complete=function(e,r){var a=t.context||this;S.apply(a,[e,r,p])}}var k=e("input[type=file]:enabled",this).filter(function(){return""!==e(this).val()}).length>0,D="multipart/form-data",A=p.attr("enctype")===D||p.attr("encoding")===D,L=i.fileapi&&i.formdata;a("fileAPI :"+L);var F,E=(k||A)&&!L;!1!==t.iframe&&(t.iframe||E)?t.closeKeepAlive?e.get(t.closeKeepAlive,function(){F=c(x)}):F=c(x):F=(k||A)&&L?function(r){for(var a=new FormData,n=0;n<r.length;n++)a.append(r[n].name,r[n].value);if(t.extraData){var i=u(t.extraData);for(n=0;n<i.length;n++)i[n]&&a.append(i[n][0],i[n][1])}t.data=null;var o=e.extend(!0,{},e.ajaxSettings,t,{contentType:!1,processData:!1,cache:!1,type:l||"POST"});t.uploadProgress&&(o.xhr=function(){var r=e.ajaxSettings.xhr();return r.upload&&r.upload.addEventListener("progress",function(e){var r=0,a=e.loaded||e.position,n=e.total;e.lengthComputable&&(r=Math.ceil(a/n*100)),t.uploadProgress(e,a,n,r)},!1),r}),o.data=null;var s=o.beforeSend;return o.beforeSend=function(e,r){t.formData?r.data=t.formData:r.data=a,s&&s.call(this,e,r)},e.ajax(o)}(x):e.ajax(t),p.removeData("jqxhr").data("jqxhr",F);for(var M=0;M<g.length;M++)g[M]=null;return this.trigger("form-submit-notify",[this,t]),this},e.fn.ajaxForm=function(n,i,o,s){if(("string"==typeof n||!1===n&&arguments.length>0)&&(n={url:n,data:i,dataType:o},"function"==typeof s&&(n.success=s)),n=n||{},n.delegation=n.delegation&&e.isFunction(e.fn.on),!n.delegation&&0===this.length){var u={s:this.selector,c:this.context};return!e.isReady&&u.s?(a("DOM not ready, queuing ajaxForm"),e(function(){e(u.s,u.c).ajaxForm(n)}),this):(a("terminating; zero elements found by selector"+(e.isReady?"":" (DOM not ready)")),this)}return n.delegation?(e(document).off("submit.form-plugin",this.selector,t).off("click.form-plugin",this.selector,r).on("submit.form-plugin",this.selector,n,t).on("click.form-plugin",this.selector,n,r),this):this.ajaxFormUnbind().on("submit.form-plugin",n,t).on("click.form-plugin",n,r)},e.fn.ajaxFormUnbind=function(){return this.off("submit.form-plugin click.form-plugin")},e.fn.formToArray=function(t,r,a){var n=[];if(0===this.length)return n;var o,s=this[0],u=this.attr("id"),c=t||void 0===s.elements?s.getElementsByTagName("*"):s.elements;if(c&&(c=e.makeArray(c)),u&&(t||/(Edge|Trident)\//.test(navigator.userAgent))&&(o=e(':input[form="'+u+'"]').get()).length&&(c=(c||[]).concat(o)),!c||!c.length)return n;e.isFunction(a)&&(c=e.map(c,a));var l,f,d,p,m,h,v;for(l=0,h=c.length;l<h;l++)if(m=c[l],(d=m.name)&&!m.disabled)if(t&&s.clk&&"image"===m.type)s.clk===m&&(n.push({name:d,value:e(m).val(),type:m.type}),n.push({name:d+".x",value:s.clk_x},{name:d+".y",value:s.clk_y}));else if((p=e.fieldValue(m,!0))&&p.constructor===Array)for(r&&r.push(m),f=0,v=p.length;f<v;f++)n.push({name:d,value:p[f]});else if(i.fileapi&&"file"===m.type){r&&r.push(m);var g=m.files;if(g.length)for(f=0;f<g.length;f++)n.push({name:d,value:g[f],type:m.type});else n.push({name:d,value:"",type:m.type})}else null!==p&&void 0!==p&&(r&&r.push(m),n.push({name:d,value:p,type:m.type,required:m.required}));if(!t&&s.clk){var x=e(s.clk),y=x[0];(d=y.name)&&!y.disabled&&"image"===y.type&&(n.push({name:d,value:x.val()}),n.push({name:d+".x",value:s.clk_x},{name:d+".y",value:s.clk_y}))}return n},e.fn.formSerialize=function(t){return e.param(this.formToArray(t))},e.fn.fieldSerialize=function(t){var r=[];return this.each(function(){var a=this.name;if(a){var n=e.fieldValue(this,t);if(n&&n.constructor===Array)for(var i=0,o=n.length;i<o;i++)r.push({name:a,value:n[i]});else null!==n&&void 0!==n&&r.push({name:this.name,value:n})}}),e.param(r)},e.fn.fieldValue=function(t){for(var r=[],a=0,n=this.length;a<n;a++){var i=this[a],o=e.fieldValue(i,t);null===o||void 0===o||o.constructor===Array&&!o.length||(o.constructor===Array?e.merge(r,o):r.push(o))}return r},e.fieldValue=function(t,r){var a=t.name,i=t.type,o=t.tagName.toLowerCase();if(void 0===r&&(r=!0),r&&(!a||t.disabled||"reset"===i||"button"===i||("checkbox"===i||"radio"===i)&&!t.checked||("submit"===i||"image"===i)&&t.form&&t.form.clk!==t||"select"===o&&-1===t.selectedIndex))return null;if("select"===o){var s=t.selectedIndex;if(s<0)return null;for(var u=[],c=t.options,l="select-one"===i,f=l?s+1:c.length,d=l?s:0;d<f;d++){var p=c[d];if(p.selected&&!p.disabled){var m=p.value;if(m||(m=p.attributes&&p.attributes.value&&!p.attributes.value.specified?p.text:p.value),l)return m;u.push(m)}}return u}return e(t).val().replace(n,"\r\n")},e.fn.clearForm=function(t){return this.each(function(){e("input,select,textarea",this).clearFields(t)})},e.fn.clearFields=e.fn.clearInputs=function(t){var r=/^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i;return this.each(function(){var a=this.type,n=this.tagName.toLowerCase();r.test(a)||"textarea"===n?this.value="":"checkbox"===a||"radio"===a?this.checked=!1:"select"===n?this.selectedIndex=-1:"file"===a?/MSIE/.test(navigator.userAgent)?e(this).replaceWith(e(this).clone(!0)):e(this).val(""):t&&(!0===t&&/hidden/.test(a)||"string"==typeof t&&e(this).is(t))&&(this.value="")})},e.fn.resetForm=function(){return this.each(function(){var t=e(this),r=this.tagName.toLowerCase();switch(r){case"input":this.checked=this.defaultChecked;case"textarea":return this.value=this.defaultValue,!0;case"option":case"optgroup":var a=t.parents("select");return a.length&&a[0].multiple?"option"===r?this.selected=this.defaultSelected:t.find("option").resetForm():a.resetForm(),!0;case"select":return t.find("option").each(function(e){if(this.selected=this.defaultSelected,this.defaultSelected&&!t[0].multiple)return t[0].selectedIndex=e,!1}),!0;case"label":var n=e(t.attr("for")),i=t.find("input,select,textarea");return n[0]&&i.unshift(n[0]),i.resetForm(),!0;case"form":return("function"==typeof this.reset||"object"==typeof this.reset&&!this.reset.nodeType)&&this.reset(),!0;default:return t.find("form,input,label,select,textarea").resetForm(),!0}})},e.fn.enable=function(e){return void 0===e&&(e=!0),this.each(function(){this.disabled=!e})},e.fn.selected=function(t){return void 0===t&&(t=!0),this.each(function(){var r=this.type;if("checkbox"===r||"radio"===r)this.checked=t;else if("option"===this.tagName.toLowerCase()){var a=e(this).parent("select");t&&a[0]&&"select-one"===a[0].type&&a.find("option").selected(!1),this.selected=t}})},e.fn.ajaxSubmit.debug=!1});


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],337:[function(require,module,exports){
(function (global){
/**
* jquery-match-height 0.7.2 by @liabru
* http://brm.io/jquery-match-height/
* License: MIT
*/

;(function(factory) { // eslint-disable-line no-extra-semi
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery'], factory);
    } else if (typeof module !== 'undefined' && module.exports) {
        // CommonJS
        module.exports = factory((typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null));
    } else {
        // Global
        factory(jQuery);
    }
})(function($) {
    /*
    *  internal
    */

    var _previousResizeWidth = -1,
        _updateTimeout = -1;

    /*
    *  _parse
    *  value parse utility function
    */

    var _parse = function(value) {
        // parse value and convert NaN to 0
        return parseFloat(value) || 0;
    };

    /*
    *  _rows
    *  utility function returns array of jQuery selections representing each row
    *  (as displayed after float wrapping applied by browser)
    */

    var _rows = function(elements) {
        var tolerance = 1,
            $elements = $(elements),
            lastTop = null,
            rows = [];

        // group elements by their top position
        $elements.each(function(){
            var $that = $(this),
                top = $that.offset().top - _parse($that.css('margin-top')),
                lastRow = rows.length > 0 ? rows[rows.length - 1] : null;

            if (lastRow === null) {
                // first item on the row, so just push it
                rows.push($that);
            } else {
                // if the row top is the same, add to the row group
                if (Math.floor(Math.abs(lastTop - top)) <= tolerance) {
                    rows[rows.length - 1] = lastRow.add($that);
                } else {
                    // otherwise start a new row group
                    rows.push($that);
                }
            }

            // keep track of the last row top
            lastTop = top;
        });

        return rows;
    };

    /*
    *  _parseOptions
    *  handle plugin options
    */

    var _parseOptions = function(options) {
        var opts = {
            byRow: true,
            property: 'height',
            target: null,
            remove: false
        };

        if (typeof options === 'object') {
            return $.extend(opts, options);
        }

        if (typeof options === 'boolean') {
            opts.byRow = options;
        } else if (options === 'remove') {
            opts.remove = true;
        }

        return opts;
    };

    /*
    *  matchHeight
    *  plugin definition
    */

    var matchHeight = $.fn.matchHeight = function(options) {
        var opts = _parseOptions(options);

        // handle remove
        if (opts.remove) {
            var that = this;

            // remove fixed height from all selected elements
            this.css(opts.property, '');

            // remove selected elements from all groups
            $.each(matchHeight._groups, function(key, group) {
                group.elements = group.elements.not(that);
            });

            // TODO: cleanup empty groups

            return this;
        }

        if (this.length <= 1 && !opts.target) {
            return this;
        }

        // keep track of this group so we can re-apply later on load and resize events
        matchHeight._groups.push({
            elements: this,
            options: opts
        });

        // match each element's height to the tallest element in the selection
        matchHeight._apply(this, opts);

        return this;
    };

    /*
    *  plugin global options
    */

    matchHeight.version = '0.7.2';
    matchHeight._groups = [];
    matchHeight._throttle = 80;
    matchHeight._maintainScroll = false;
    matchHeight._beforeUpdate = null;
    matchHeight._afterUpdate = null;
    matchHeight._rows = _rows;
    matchHeight._parse = _parse;
    matchHeight._parseOptions = _parseOptions;

    /*
    *  matchHeight._apply
    *  apply matchHeight to given elements
    */

    matchHeight._apply = function(elements, options) {
        var opts = _parseOptions(options),
            $elements = $(elements),
            rows = [$elements];

        // take note of scroll position
        var scrollTop = $(window).scrollTop(),
            htmlHeight = $('html').outerHeight(true);

        // get hidden parents
        var $hiddenParents = $elements.parents().filter(':hidden');

        // cache the original inline style
        $hiddenParents.each(function() {
            var $that = $(this);
            $that.data('style-cache', $that.attr('style'));
        });

        // temporarily must force hidden parents visible
        $hiddenParents.css('display', 'block');

        // get rows if using byRow, otherwise assume one row
        if (opts.byRow && !opts.target) {

            // must first force an arbitrary equal height so floating elements break evenly
            $elements.each(function() {
                var $that = $(this),
                    display = $that.css('display');

                // temporarily force a usable display value
                if (display !== 'inline-block' && display !== 'flex' && display !== 'inline-flex') {
                    display = 'block';
                }

                // cache the original inline style
                $that.data('style-cache', $that.attr('style'));

                $that.css({
                    'display': display,
                    'padding-top': '0',
                    'padding-bottom': '0',
                    'margin-top': '0',
                    'margin-bottom': '0',
                    'border-top-width': '0',
                    'border-bottom-width': '0',
                    'height': '100px',
                    'overflow': 'hidden'
                });
            });

            // get the array of rows (based on element top position)
            rows = _rows($elements);

            // revert original inline styles
            $elements.each(function() {
                var $that = $(this);
                $that.attr('style', $that.data('style-cache') || '');
            });
        }

        $.each(rows, function(key, row) {
            var $row = $(row),
                targetHeight = 0;

            if (!opts.target) {
                // skip apply to rows with only one item
                if (opts.byRow && $row.length <= 1) {
                    $row.css(opts.property, '');
                    return;
                }

                // iterate the row and find the max height
                $row.each(function(){
                    var $that = $(this),
                        style = $that.attr('style'),
                        display = $that.css('display');

                    // temporarily force a usable display value
                    if (display !== 'inline-block' && display !== 'flex' && display !== 'inline-flex') {
                        display = 'block';
                    }

                    // ensure we get the correct actual height (and not a previously set height value)
                    var css = { 'display': display };
                    css[opts.property] = '';
                    $that.css(css);

                    // find the max height (including padding, but not margin)
                    if ($that.outerHeight(false) > targetHeight) {
                        targetHeight = $that.outerHeight(false);
                    }

                    // revert styles
                    if (style) {
                        $that.attr('style', style);
                    } else {
                        $that.css('display', '');
                    }
                });
            } else {
                // if target set, use the height of the target element
                targetHeight = opts.target.outerHeight(false);
            }

            // iterate the row and apply the height to all elements
            $row.each(function(){
                var $that = $(this),
                    verticalPadding = 0;

                // don't apply to a target
                if (opts.target && $that.is(opts.target)) {
                    return;
                }

                // handle padding and border correctly (required when not using border-box)
                if ($that.css('box-sizing') !== 'border-box') {
                    verticalPadding += _parse($that.css('border-top-width')) + _parse($that.css('border-bottom-width'));
                    verticalPadding += _parse($that.css('padding-top')) + _parse($that.css('padding-bottom'));
                }

                // set the height (accounting for padding and border)
                $that.css(opts.property, (targetHeight - verticalPadding) + 'px');
            });
        });

        // revert hidden parents
        $hiddenParents.each(function() {
            var $that = $(this);
            $that.attr('style', $that.data('style-cache') || null);
        });

        // restore scroll position if enabled
        if (matchHeight._maintainScroll) {
            $(window).scrollTop((scrollTop / htmlHeight) * $('html').outerHeight(true));
        }

        return this;
    };

    /*
    *  matchHeight._applyDataApi
    *  applies matchHeight to all elements with a data-match-height attribute
    */

    matchHeight._applyDataApi = function() {
        var groups = {};

        // generate groups by their groupId set by elements using data-match-height
        $('[data-match-height], [data-mh]').each(function() {
            var $this = $(this),
                groupId = $this.attr('data-mh') || $this.attr('data-match-height');

            if (groupId in groups) {
                groups[groupId] = groups[groupId].add($this);
            } else {
                groups[groupId] = $this;
            }
        });

        // apply matchHeight to each group
        $.each(groups, function() {
            this.matchHeight(true);
        });
    };

    /*
    *  matchHeight._update
    *  updates matchHeight on all current groups with their correct options
    */

    var _update = function(event) {
        if (matchHeight._beforeUpdate) {
            matchHeight._beforeUpdate(event, matchHeight._groups);
        }

        $.each(matchHeight._groups, function() {
            matchHeight._apply(this.elements, this.options);
        });

        if (matchHeight._afterUpdate) {
            matchHeight._afterUpdate(event, matchHeight._groups);
        }
    };

    matchHeight._update = function(throttle, event) {
        // prevent update if fired from a resize event
        // where the viewport width hasn't actually changed
        // fixes an event looping bug in IE8
        if (event && event.type === 'resize') {
            var windowWidth = $(window).width();
            if (windowWidth === _previousResizeWidth) {
                return;
            }
            _previousResizeWidth = windowWidth;
        }

        // throttle updates
        if (!throttle) {
            _update(event);
        } else if (_updateTimeout === -1) {
            _updateTimeout = setTimeout(function() {
                _update(event);
                _updateTimeout = -1;
            }, matchHeight._throttle);
        }
    };

    /*
    *  bind events
    */

    // apply on DOM ready event
    $(matchHeight._applyDataApi);

    // use on or bind where supported
    var on = $.fn.on ? 'on' : 'bind';

    // update heights on load and resize events
    $(window)[on]('load', function(event) {
        matchHeight._update(false, event);
    });

    // throttled update heights on resize events
    $(window)[on]('resize orientationchange', function(event) {
        matchHeight._update(true, event);
    });

});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],338:[function(require,module,exports){
(function (root) {/*global exports, Intl*/
/**
 * This script gives you the zone info key representing your device's time zone setting.
 *
 * @name jsTimezoneDetect
 * @version 1.0.6
 * @author Jon Nylander
 * @license MIT License - https://bitbucket.org/pellepim/jstimezonedetect/src/default/LICENCE.txt
 *
 * For usage and examples, visit:
 * http://pellepim.bitbucket.org/jstz/
 *
 * Copyright (c) Jon Nylander
 */


/**
 * Namespace to hold all the code for timezone detection.
 */
var jstz = (function () {
    'use strict';
    var HEMISPHERE_SOUTH = 's',

        consts = {
            DAY: 86400000,
            HOUR: 3600000,
            MINUTE: 60000,
            SECOND: 1000,
            BASELINE_YEAR: 2014,
            MAX_SCORE: 864000000, // 10 days
            AMBIGUITIES: {
                'America/Denver':       ['America/Mazatlan'],
                'Europe/London':        ['Africa/Casablanca'],
                'America/Chicago':      ['America/Mexico_City'],
                'America/Asuncion':     ['America/Campo_Grande', 'America/Santiago'],
                'America/Montevideo':   ['America/Sao_Paulo', 'America/Santiago'],
                // Europe/Minsk should not be in this list... but Windows.
                'Asia/Beirut':          ['Asia/Amman', 'Asia/Jerusalem', 'Europe/Helsinki', 'Asia/Damascus', 'Africa/Cairo', 'Asia/Gaza', 'Europe/Minsk'],
                'Pacific/Auckland':     ['Pacific/Fiji'],
                'America/Los_Angeles':  ['America/Santa_Isabel'],
                'America/New_York':     ['America/Havana'],
                'America/Halifax':      ['America/Goose_Bay'],
                'America/Godthab':      ['America/Miquelon'],
                'Asia/Dubai':           ['Asia/Yerevan'],
                'Asia/Jakarta':         ['Asia/Krasnoyarsk'],
                'Asia/Shanghai':        ['Asia/Irkutsk', 'Australia/Perth'],
                'Australia/Sydney':     ['Australia/Lord_Howe'],
                'Asia/Tokyo':           ['Asia/Yakutsk'],
                'Asia/Dhaka':           ['Asia/Omsk'],
                // In the real world Yerevan is not ambigous for Baku... but Windows.
                'Asia/Baku':            ['Asia/Yerevan'],
                'Australia/Brisbane':   ['Asia/Vladivostok'],
                'Pacific/Noumea':       ['Asia/Vladivostok'],
                'Pacific/Majuro':       ['Asia/Kamchatka', 'Pacific/Fiji'],
                'Pacific/Tongatapu':    ['Pacific/Apia'],
                'Asia/Baghdad':         ['Europe/Minsk', 'Europe/Moscow'],
                'Asia/Karachi':         ['Asia/Yekaterinburg'],
                'Africa/Johannesburg':  ['Asia/Gaza', 'Africa/Cairo']
            }
        },

        /**
         * Gets the offset in minutes from UTC for a certain date.
         * @param {Date} date
         * @returns {Number}
         */
        get_date_offset = function get_date_offset(date) {
            var offset = -date.getTimezoneOffset();
            return (offset !== null ? offset : 0);
        },

        /**
         * This function does some basic calculations to create information about
         * the user's timezone. It uses REFERENCE_YEAR as a solid year for which
         * the script has been tested rather than depend on the year set by the
         * client device.
         *
         * Returns a key that can be used to do lookups in jstz.olson.timezones.
         * eg: "720,1,2".
         *
         * @returns {String}
         */
        lookup_key = function lookup_key() {
            var january_offset = get_date_offset(new Date(consts.BASELINE_YEAR, 0, 2)),
                june_offset = get_date_offset(new Date(consts.BASELINE_YEAR, 5, 2)),
                diff = january_offset - june_offset;

            if (diff < 0) {
                return january_offset + ",1";
            } else if (diff > 0) {
                return june_offset + ",1," + HEMISPHERE_SOUTH;
            }

            return january_offset + ",0";
        },


        /**
         * Tries to get the time zone key directly from the operating system for those
         * environments that support the ECMAScript Internationalization API.
         */
        get_from_internationalization_api = function get_from_internationalization_api() {
            var format, timezone;
            if (typeof Intl === "undefined" || typeof Intl.DateTimeFormat === "undefined") {
                return;
            }

            format = Intl.DateTimeFormat();

            if (typeof format === "undefined" || typeof format.resolvedOptions === "undefined") {
                return;
            }

            timezone = format.resolvedOptions().timeZone;

            if (timezone && (timezone.indexOf("/") > -1 || timezone === 'UTC')) {
                return timezone;
            }

        },

        /**
         * Starting point for getting all the DST rules for a specific year
         * for the current timezone (as described by the client system).
         *
         * Returns an object with start and end attributes, or false if no
         * DST rules were found for the year.
         *
         * @param year
         * @returns {Object} || {Boolean}
         */
        dst_dates = function dst_dates(year) {
            var yearstart = new Date(year, 0, 1, 0, 0, 1, 0).getTime();
            var yearend = new Date(year, 12, 31, 23, 59, 59).getTime();
            var current = yearstart;
            var offset = (new Date(current)).getTimezoneOffset();
            var dst_start = null;
            var dst_end = null;

            while (current < yearend - 86400000) {
                var dateToCheck = new Date(current);
                var dateToCheckOffset = dateToCheck.getTimezoneOffset();

                if (dateToCheckOffset !== offset) {
                    if (dateToCheckOffset < offset) {
                        dst_start = dateToCheck;
                    }
                    if (dateToCheckOffset > offset) {
                        dst_end = dateToCheck;
                    }
                    offset = dateToCheckOffset;
                }

                current += 86400000;
            }

            if (dst_start && dst_end) {
                return {
                    s: find_dst_fold(dst_start).getTime(),
                    e: find_dst_fold(dst_end).getTime()
                };
            }

            return false;
        },

        /**
         * Probably completely unnecessary function that recursively finds the
         * exact (to the second) time when a DST rule was changed.
         *
         * @param a_date - The candidate Date.
         * @param padding - integer specifying the padding to allow around the candidate
         *                  date for finding the fold.
         * @param iterator - integer specifying how many milliseconds to iterate while
         *                   searching for the fold.
         *
         * @returns {Date}
         */
        find_dst_fold = function find_dst_fold(a_date, padding, iterator) {
            if (typeof padding === 'undefined') {
                padding = consts.DAY;
                iterator = consts.HOUR;
            }

            var date_start = new Date(a_date.getTime() - padding).getTime();
            var date_end = a_date.getTime() + padding;
            var offset = new Date(date_start).getTimezoneOffset();

            var current = date_start;

            var dst_change = null;
            while (current < date_end - iterator) {
                var dateToCheck = new Date(current);
                var dateToCheckOffset = dateToCheck.getTimezoneOffset();

                if (dateToCheckOffset !== offset) {
                    dst_change = dateToCheck;
                    break;
                }
                current += iterator;
            }

            if (padding === consts.DAY) {
                return find_dst_fold(dst_change, consts.HOUR, consts.MINUTE);
            }

            if (padding === consts.HOUR) {
                return find_dst_fold(dst_change, consts.MINUTE, consts.SECOND);
            }

            return dst_change;
        },

        windows7_adaptations = function windows7_adaptions(rule_list, preliminary_timezone, score, sample) {
            if (score !== 'N/A') {
                return score;
            }
            if (preliminary_timezone === 'Asia/Beirut') {
                if (sample.name === 'Africa/Cairo') {
                    if (rule_list[6].s === 1398376800000 && rule_list[6].e === 1411678800000) {
                        return 0;
                    }
                }
                if (sample.name === 'Asia/Jerusalem') {
                    if (rule_list[6].s === 1395964800000 && rule_list[6].e === 1411858800000) {
                        return 0;
                }
            }
            } else if (preliminary_timezone === 'America/Santiago') {
                if (sample.name === 'America/Asuncion') {
                    if (rule_list[6].s === 1412481600000 && rule_list[6].e === 1397358000000) {
                        return 0;
                    }
                }
                if (sample.name === 'America/Campo_Grande') {
                    if (rule_list[6].s === 1413691200000 && rule_list[6].e === 1392519600000) {
                        return 0;
                    }
                }
            } else if (preliminary_timezone === 'America/Montevideo') {
                if (sample.name === 'America/Sao_Paulo') {
                    if (rule_list[6].s === 1413687600000 && rule_list[6].e === 1392516000000) {
                        return 0;
                    }
                }
            } else if (preliminary_timezone === 'Pacific/Auckland') {
                if (sample.name === 'Pacific/Fiji') {
                    if (rule_list[6].s === 1414245600000 && rule_list[6].e === 1396101600000) {
                        return 0;
                    }
                }
            }

            return score;
        },

        /**
         * Takes the DST rules for the current timezone, and proceeds to find matches
         * in the jstz.olson.dst_rules.zones array.
         *
         * Compares samples to the current timezone on a scoring basis.
         *
         * Candidates are ruled immediately if either the candidate or the current zone
         * has a DST rule where the other does not.
         *
         * Candidates are ruled out immediately if the current zone has a rule that is
         * outside the DST scope of the candidate.
         *
         * Candidates are included for scoring if the current zones rules fall within the
         * span of the samples rules.
         *
         * Low score is best, the score is calculated by summing up the differences in DST
         * rules and if the consts.MAX_SCORE is overreached the candidate is ruled out.
         *
         * Yah follow? :)
         *
         * @param rule_list
         * @param preliminary_timezone
         * @returns {*}
         */
        best_dst_match = function best_dst_match(rule_list, preliminary_timezone) {
            var score_sample = function score_sample(sample) {
                var score = 0;

                for (var j = 0; j < rule_list.length; j++) {

                    // Both sample and current time zone report DST during the year.
                    if (!!sample.rules[j] && !!rule_list[j]) {

                        // The current time zone's DST rules are inside the sample's. Include.
                        if (rule_list[j].s >= sample.rules[j].s && rule_list[j].e <= sample.rules[j].e) {
                            score = 0;
                            score += Math.abs(rule_list[j].s - sample.rules[j].s);
                            score += Math.abs(sample.rules[j].e - rule_list[j].e);

                        // The current time zone's DST rules are outside the sample's. Discard.
                        } else {
                            score = 'N/A';
                            break;
                        }

                        // The max score has been reached. Discard.
                        if (score > consts.MAX_SCORE) {
                            score = 'N/A';
                            break;
                        }
                    }
                }

                score = windows7_adaptations(rule_list, preliminary_timezone, score, sample);

                return score;
            };
            var scoreboard = {};
            var dst_zones = jstz.olson.dst_rules.zones;
            var dst_zones_length = dst_zones.length;
            var ambiguities = consts.AMBIGUITIES[preliminary_timezone];

            for (var i = 0; i < dst_zones_length; i++) {
                var sample = dst_zones[i];
                var score = score_sample(dst_zones[i]);

                if (score !== 'N/A') {
                    scoreboard[sample.name] = score;
                }
            }

            for (var tz in scoreboard) {
                if (scoreboard.hasOwnProperty(tz)) {
                    for (var j = 0; j < ambiguities.length; j++) {
                        if (ambiguities[j] === tz) {
                            return tz;
                        }
                    }
                }
            }

            return preliminary_timezone;
        },

        /**
         * Takes the preliminary_timezone as detected by lookup_key().
         *
         * Builds up the current timezones DST rules for the years defined
         * in the jstz.olson.dst_rules.years array.
         *
         * If there are no DST occurences for those years, immediately returns
         * the preliminary timezone. Otherwise proceeds and tries to solve
         * ambiguities.
         *
         * @param preliminary_timezone
         * @returns {String} timezone_name
         */
        get_by_dst = function get_by_dst(preliminary_timezone) {
            var get_rules = function get_rules() {
                var rule_list = [];
                for (var i = 0; i < jstz.olson.dst_rules.years.length; i++) {
                    var year_rules = dst_dates(jstz.olson.dst_rules.years[i]);
                    rule_list.push(year_rules);
                }
                return rule_list;
            };
            var check_has_dst = function check_has_dst(rules) {
                for (var i = 0; i < rules.length; i++) {
                    if (rules[i] !== false) {
                        return true;
                    }
                }
                return false;
            };
            var rules = get_rules();
            var has_dst = check_has_dst(rules);

            if (has_dst) {
                return best_dst_match(rules, preliminary_timezone);
            }

            return preliminary_timezone;
        },

        /**
         * Uses get_timezone_info() to formulate a key to use in the olson.timezones dictionary.
         *
         * Returns an object with one function ".name()"
         *
         * @returns Object
         */
        determine = function determine() {
            var preliminary_tz = get_from_internationalization_api();

            if (!preliminary_tz) {
                preliminary_tz = jstz.olson.timezones[lookup_key()];

                if (typeof consts.AMBIGUITIES[preliminary_tz] !== 'undefined') {
                    preliminary_tz = get_by_dst(preliminary_tz);
                }
            }

            return {
                name: function () {
                    return preliminary_tz;
                }
            };
        };

    return {
        determine: determine
    };
}());


jstz.olson = jstz.olson || {};

/**
 * The keys in this dictionary are comma separated as such:
 *
 * First the offset compared to UTC time in minutes.
 *
 * Then a flag which is 0 if the timezone does not take daylight savings into account and 1 if it
 * does.
 *
 * Thirdly an optional 's' signifies that the timezone is in the southern hemisphere,
 * only interesting for timezones with DST.
 *
 * The mapped arrays is used for constructing the jstz.TimeZone object from within
 * jstz.determine();
 */
jstz.olson.timezones = {
    '-720,0': 'Etc/GMT+12',
    '-660,0': 'Pacific/Pago_Pago',
    '-660,1,s': 'Pacific/Apia', // Why? Because windows... cry!
    '-600,1': 'America/Adak',
    '-600,0': 'Pacific/Honolulu',
    '-570,0': 'Pacific/Marquesas',
    '-540,0': 'Pacific/Gambier',
    '-540,1': 'America/Anchorage',
    '-480,1': 'America/Los_Angeles',
    '-480,0': 'Pacific/Pitcairn',
    '-420,0': 'America/Phoenix',
    '-420,1': 'America/Denver',
    '-360,0': 'America/Guatemala',
    '-360,1': 'America/Chicago',
    '-360,1,s': 'Pacific/Easter',
    '-300,0': 'America/Bogota',
    '-300,1': 'America/New_York',
    '-270,0': 'America/Caracas',
    '-240,1': 'America/Halifax',
    '-240,0': 'America/Santo_Domingo',
    '-240,1,s': 'America/Asuncion',
    '-210,1': 'America/St_Johns',
    '-180,1': 'America/Godthab',
    '-180,0': 'America/Argentina/Buenos_Aires',
    '-180,1,s': 'America/Montevideo',
    '-120,0': 'America/Noronha',
    '-120,1': 'America/Noronha',
    '-60,1': 'Atlantic/Azores',
    '-60,0': 'Atlantic/Cape_Verde',
    '0,0': 'UTC',
    '0,1': 'Europe/London',
    '60,1': 'Europe/Berlin',
    '60,0': 'Africa/Lagos',
    '60,1,s': 'Africa/Windhoek',
    '120,1': 'Asia/Beirut',
    '120,0': 'Africa/Johannesburg',
    '180,0': 'Asia/Baghdad',
    '180,1': 'Europe/Moscow',
    '210,1': 'Asia/Tehran',
    '240,0': 'Asia/Dubai',
    '240,1': 'Asia/Baku',
    '270,0': 'Asia/Kabul',
    '300,1': 'Asia/Yekaterinburg',
    '300,0': 'Asia/Karachi',
    '330,0': 'Asia/Kolkata',
    '345,0': 'Asia/Kathmandu',
    '360,0': 'Asia/Dhaka',
    '360,1': 'Asia/Omsk',
    '390,0': 'Asia/Rangoon',
    '420,1': 'Asia/Krasnoyarsk',
    '420,0': 'Asia/Jakarta',
    '480,0': 'Asia/Shanghai',
    '480,1': 'Asia/Irkutsk',
    '525,0': 'Australia/Eucla',
    '525,1,s': 'Australia/Eucla',
    '540,1': 'Asia/Yakutsk',
    '540,0': 'Asia/Tokyo',
    '570,0': 'Australia/Darwin',
    '570,1,s': 'Australia/Adelaide',
    '600,0': 'Australia/Brisbane',
    '600,1': 'Asia/Vladivostok',
    '600,1,s': 'Australia/Sydney',
    '630,1,s': 'Australia/Lord_Howe',
    '660,1': 'Asia/Kamchatka',
    '660,0': 'Pacific/Noumea',
    '690,0': 'Pacific/Norfolk',
    '720,1,s': 'Pacific/Auckland',
    '720,0': 'Pacific/Majuro',
    '765,1,s': 'Pacific/Chatham',
    '780,0': 'Pacific/Tongatapu',
    '780,1,s': 'Pacific/Apia',
    '840,0': 'Pacific/Kiritimati'
};

/* Build time: 2015-11-02 13:01:00Z Build by invoking python utilities/dst.py generate */
jstz.olson.dst_rules = {
    "years": [
        2008,
        2009,
        2010,
        2011,
        2012,
        2013,
        2014
    ],
    "zones": [
        {
            "name": "Africa/Cairo",
            "rules": [
                {
                    "e": 1219957200000,
                    "s": 1209074400000
                },
                {
                    "e": 1250802000000,
                    "s": 1240524000000
                },
                {
                    "e": 1285880400000,
                    "s": 1284069600000
                },
                false,
                false,
                false,
                {
                    "e": 1411678800000,
                    "s": 1406844000000
                }
            ]
        },
        {
            "name": "Africa/Casablanca",
            "rules": [
                {
                    "e": 1220223600000,
                    "s": 1212278400000
                },
                {
                    "e": 1250809200000,
                    "s": 1243814400000
                },
                {
                    "e": 1281222000000,
                    "s": 1272758400000
                },
                {
                    "e": 1312066800000,
                    "s": 1301788800000
                },
                {
                    "e": 1348970400000,
                    "s": 1345428000000
                },
                {
                    "e": 1382839200000,
                    "s": 1376100000000
                },
                {
                    "e": 1414288800000,
                    "s": 1406944800000
                }
            ]
        },
        {
            "name": "America/Asuncion",
            "rules": [
                {
                    "e": 1205031600000,
                    "s": 1224388800000
                },
                {
                    "e": 1236481200000,
                    "s": 1255838400000
                },
                {
                    "e": 1270954800000,
                    "s": 1286078400000
                },
                {
                    "e": 1302404400000,
                    "s": 1317528000000
                },
                {
                    "e": 1333854000000,
                    "s": 1349582400000
                },
                {
                    "e": 1364094000000,
                    "s": 1381032000000
                },
                {
                    "e": 1395543600000,
                    "s": 1412481600000
                }
            ]
        },
        {
            "name": "America/Campo_Grande",
            "rules": [
                {
                    "e": 1203217200000,
                    "s": 1224388800000
                },
                {
                    "e": 1234666800000,
                    "s": 1255838400000
                },
                {
                    "e": 1266721200000,
                    "s": 1287288000000
                },
                {
                    "e": 1298170800000,
                    "s": 1318737600000
                },
                {
                    "e": 1330225200000,
                    "s": 1350792000000
                },
                {
                    "e": 1361070000000,
                    "s": 1382241600000
                },
                {
                    "e": 1392519600000,
                    "s": 1413691200000
                }
            ]
        },
        {
            "name": "America/Goose_Bay",
            "rules": [
                {
                    "e": 1225594860000,
                    "s": 1205035260000
                },
                {
                    "e": 1257044460000,
                    "s": 1236484860000
                },
                {
                    "e": 1289098860000,
                    "s": 1268539260000
                },
                {
                    "e": 1320555600000,
                    "s": 1299988860000
                },
                {
                    "e": 1352005200000,
                    "s": 1331445600000
                },
                {
                    "e": 1383454800000,
                    "s": 1362895200000
                },
                {
                    "e": 1414904400000,
                    "s": 1394344800000
                }
            ]
        },
        {
            "name": "America/Havana",
            "rules": [
                {
                    "e": 1224997200000,
                    "s": 1205643600000
                },
                {
                    "e": 1256446800000,
                    "s": 1236488400000
                },
                {
                    "e": 1288501200000,
                    "s": 1268542800000
                },
                {
                    "e": 1321160400000,
                    "s": 1300597200000
                },
                {
                    "e": 1352005200000,
                    "s": 1333256400000
                },
                {
                    "e": 1383454800000,
                    "s": 1362891600000
                },
                {
                    "e": 1414904400000,
                    "s": 1394341200000
                }
            ]
        },
        {
            "name": "America/Mazatlan",
            "rules": [
                {
                    "e": 1225008000000,
                    "s": 1207472400000
                },
                {
                    "e": 1256457600000,
                    "s": 1238922000000
                },
                {
                    "e": 1288512000000,
                    "s": 1270371600000
                },
                {
                    "e": 1319961600000,
                    "s": 1301821200000
                },
                {
                    "e": 1351411200000,
                    "s": 1333270800000
                },
                {
                    "e": 1382860800000,
                    "s": 1365325200000
                },
                {
                    "e": 1414310400000,
                    "s": 1396774800000
                }
            ]
        },
        {
            "name": "America/Mexico_City",
            "rules": [
                {
                    "e": 1225004400000,
                    "s": 1207468800000
                },
                {
                    "e": 1256454000000,
                    "s": 1238918400000
                },
                {
                    "e": 1288508400000,
                    "s": 1270368000000
                },
                {
                    "e": 1319958000000,
                    "s": 1301817600000
                },
                {
                    "e": 1351407600000,
                    "s": 1333267200000
                },
                {
                    "e": 1382857200000,
                    "s": 1365321600000
                },
                {
                    "e": 1414306800000,
                    "s": 1396771200000
                }
            ]
        },
        {
            "name": "America/Miquelon",
            "rules": [
                {
                    "e": 1225598400000,
                    "s": 1205038800000
                },
                {
                    "e": 1257048000000,
                    "s": 1236488400000
                },
                {
                    "e": 1289102400000,
                    "s": 1268542800000
                },
                {
                    "e": 1320552000000,
                    "s": 1299992400000
                },
                {
                    "e": 1352001600000,
                    "s": 1331442000000
                },
                {
                    "e": 1383451200000,
                    "s": 1362891600000
                },
                {
                    "e": 1414900800000,
                    "s": 1394341200000
                }
            ]
        },
        {
            "name": "America/Santa_Isabel",
            "rules": [
                {
                    "e": 1225011600000,
                    "s": 1207476000000
                },
                {
                    "e": 1256461200000,
                    "s": 1238925600000
                },
                {
                    "e": 1288515600000,
                    "s": 1270375200000
                },
                {
                    "e": 1319965200000,
                    "s": 1301824800000
                },
                {
                    "e": 1351414800000,
                    "s": 1333274400000
                },
                {
                    "e": 1382864400000,
                    "s": 1365328800000
                },
                {
                    "e": 1414314000000,
                    "s": 1396778400000
                }
            ]
        },
        {
            "name": "America/Santiago",
            "rules": [
                {
                    "e": 1206846000000,
                    "s": 1223784000000
                },
                {
                    "e": 1237086000000,
                    "s": 1255233600000
                },
                {
                    "e": 1270350000000,
                    "s": 1286683200000
                },
                {
                    "e": 1304823600000,
                    "s": 1313899200000
                },
                {
                    "e": 1335668400000,
                    "s": 1346558400000
                },
                {
                    "e": 1367118000000,
                    "s": 1378612800000
                },
                {
                    "e": 1398567600000,
                    "s": 1410062400000
                }
            ]
        },
        {
            "name": "America/Sao_Paulo",
            "rules": [
                {
                    "e": 1203213600000,
                    "s": 1224385200000
                },
                {
                    "e": 1234663200000,
                    "s": 1255834800000
                },
                {
                    "e": 1266717600000,
                    "s": 1287284400000
                },
                {
                    "e": 1298167200000,
                    "s": 1318734000000
                },
                {
                    "e": 1330221600000,
                    "s": 1350788400000
                },
                {
                    "e": 1361066400000,
                    "s": 1382238000000
                },
                {
                    "e": 1392516000000,
                    "s": 1413687600000
                }
            ]
        },
        {
            "name": "Asia/Amman",
            "rules": [
                {
                    "e": 1225404000000,
                    "s": 1206655200000
                },
                {
                    "e": 1256853600000,
                    "s": 1238104800000
                },
                {
                    "e": 1288303200000,
                    "s": 1269554400000
                },
                {
                    "e": 1319752800000,
                    "s": 1301608800000
                },
                false,
                false,
                {
                    "e": 1414706400000,
                    "s": 1395957600000
                }
            ]
        },
        {
            "name": "Asia/Damascus",
            "rules": [
                {
                    "e": 1225486800000,
                    "s": 1207260000000
                },
                {
                    "e": 1256850000000,
                    "s": 1238104800000
                },
                {
                    "e": 1288299600000,
                    "s": 1270159200000
                },
                {
                    "e": 1319749200000,
                    "s": 1301608800000
                },
                {
                    "e": 1351198800000,
                    "s": 1333058400000
                },
                {
                    "e": 1382648400000,
                    "s": 1364508000000
                },
                {
                    "e": 1414702800000,
                    "s": 1395957600000
                }
            ]
        },
        {
            "name": "Asia/Dubai",
            "rules": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Gaza",
            "rules": [
                {
                    "e": 1219957200000,
                    "s": 1206655200000
                },
                {
                    "e": 1252015200000,
                    "s": 1238104800000
                },
                {
                    "e": 1281474000000,
                    "s": 1269640860000
                },
                {
                    "e": 1312146000000,
                    "s": 1301608860000
                },
                {
                    "e": 1348178400000,
                    "s": 1333058400000
                },
                {
                    "e": 1380229200000,
                    "s": 1364508000000
                },
                {
                    "e": 1414098000000,
                    "s": 1395957600000
                }
            ]
        },
        {
            "name": "Asia/Irkutsk",
            "rules": [
                {
                    "e": 1224957600000,
                    "s": 1206813600000
                },
                {
                    "e": 1256407200000,
                    "s": 1238263200000
                },
                {
                    "e": 1288461600000,
                    "s": 1269712800000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Jerusalem",
            "rules": [
                {
                    "e": 1223161200000,
                    "s": 1206662400000
                },
                {
                    "e": 1254006000000,
                    "s": 1238112000000
                },
                {
                    "e": 1284246000000,
                    "s": 1269561600000
                },
                {
                    "e": 1317510000000,
                    "s": 1301616000000
                },
                {
                    "e": 1348354800000,
                    "s": 1333065600000
                },
                {
                    "e": 1382828400000,
                    "s": 1364515200000
                },
                {
                    "e": 1414278000000,
                    "s": 1395964800000
                }
            ]
        },
        {
            "name": "Asia/Kamchatka",
            "rules": [
                {
                    "e": 1224943200000,
                    "s": 1206799200000
                },
                {
                    "e": 1256392800000,
                    "s": 1238248800000
                },
                {
                    "e": 1288450800000,
                    "s": 1269698400000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Krasnoyarsk",
            "rules": [
                {
                    "e": 1224961200000,
                    "s": 1206817200000
                },
                {
                    "e": 1256410800000,
                    "s": 1238266800000
                },
                {
                    "e": 1288465200000,
                    "s": 1269716400000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Omsk",
            "rules": [
                {
                    "e": 1224964800000,
                    "s": 1206820800000
                },
                {
                    "e": 1256414400000,
                    "s": 1238270400000
                },
                {
                    "e": 1288468800000,
                    "s": 1269720000000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Vladivostok",
            "rules": [
                {
                    "e": 1224950400000,
                    "s": 1206806400000
                },
                {
                    "e": 1256400000000,
                    "s": 1238256000000
                },
                {
                    "e": 1288454400000,
                    "s": 1269705600000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Yakutsk",
            "rules": [
                {
                    "e": 1224954000000,
                    "s": 1206810000000
                },
                {
                    "e": 1256403600000,
                    "s": 1238259600000
                },
                {
                    "e": 1288458000000,
                    "s": 1269709200000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Yekaterinburg",
            "rules": [
                {
                    "e": 1224968400000,
                    "s": 1206824400000
                },
                {
                    "e": 1256418000000,
                    "s": 1238274000000
                },
                {
                    "e": 1288472400000,
                    "s": 1269723600000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Yerevan",
            "rules": [
                {
                    "e": 1224972000000,
                    "s": 1206828000000
                },
                {
                    "e": 1256421600000,
                    "s": 1238277600000
                },
                {
                    "e": 1288476000000,
                    "s": 1269727200000
                },
                {
                    "e": 1319925600000,
                    "s": 1301176800000
                },
                false,
                false,
                false
            ]
        },
        {
            "name": "Australia/Lord_Howe",
            "rules": [
                {
                    "e": 1207407600000,
                    "s": 1223134200000
                },
                {
                    "e": 1238857200000,
                    "s": 1254583800000
                },
                {
                    "e": 1270306800000,
                    "s": 1286033400000
                },
                {
                    "e": 1301756400000,
                    "s": 1317483000000
                },
                {
                    "e": 1333206000000,
                    "s": 1349537400000
                },
                {
                    "e": 1365260400000,
                    "s": 1380987000000
                },
                {
                    "e": 1396710000000,
                    "s": 1412436600000
                }
            ]
        },
        {
            "name": "Australia/Perth",
            "rules": [
                {
                    "e": 1206813600000,
                    "s": 1224957600000
                },
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Europe/Helsinki",
            "rules": [
                {
                    "e": 1224982800000,
                    "s": 1206838800000
                },
                {
                    "e": 1256432400000,
                    "s": 1238288400000
                },
                {
                    "e": 1288486800000,
                    "s": 1269738000000
                },
                {
                    "e": 1319936400000,
                    "s": 1301187600000
                },
                {
                    "e": 1351386000000,
                    "s": 1332637200000
                },
                {
                    "e": 1382835600000,
                    "s": 1364691600000
                },
                {
                    "e": 1414285200000,
                    "s": 1396141200000
                }
            ]
        },
        {
            "name": "Europe/Minsk",
            "rules": [
                {
                    "e": 1224979200000,
                    "s": 1206835200000
                },
                {
                    "e": 1256428800000,
                    "s": 1238284800000
                },
                {
                    "e": 1288483200000,
                    "s": 1269734400000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Europe/Moscow",
            "rules": [
                {
                    "e": 1224975600000,
                    "s": 1206831600000
                },
                {
                    "e": 1256425200000,
                    "s": 1238281200000
                },
                {
                    "e": 1288479600000,
                    "s": 1269730800000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Pacific/Apia",
            "rules": [
                false,
                false,
                false,
                {
                    "e": 1301752800000,
                    "s": 1316872800000
                },
                {
                    "e": 1333202400000,
                    "s": 1348927200000
                },
                {
                    "e": 1365256800000,
                    "s": 1380376800000
                },
                {
                    "e": 1396706400000,
                    "s": 1411826400000
                }
            ]
        },
        {
            "name": "Pacific/Fiji",
            "rules": [
                false,
                false,
                {
                    "e": 1269698400000,
                    "s": 1287842400000
                },
                {
                    "e": 1327154400000,
                    "s": 1319292000000
                },
                {
                    "e": 1358604000000,
                    "s": 1350741600000
                },
                {
                    "e": 1390050000000,
                    "s": 1382796000000
                },
                {
                    "e": 1421503200000,
                    "s": 1414850400000
                }
            ]
        },
        {
            "name": "Europe/London",
            "rules": [
                {
                    "e": 1224982800000,
                    "s": 1206838800000
                },
                {
                    "e": 1256432400000,
                    "s": 1238288400000
                },
                {
                    "e": 1288486800000,
                    "s": 1269738000000
                },
                {
                    "e": 1319936400000,
                    "s": 1301187600000
                },
                {
                    "e": 1351386000000,
                    "s": 1332637200000
                },
                {
                    "e": 1382835600000,
                    "s": 1364691600000
                },
                {
                    "e": 1414285200000,
                    "s": 1396141200000
                }
            ]
        }
    ]
};
if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = jstz;
} else if ((typeof define !== 'undefined' && define !== null) && (define.amd != null)) {
    define([], function() {
        return jstz;
    });
} else {
    if (typeof root === 'undefined') {
        window.jstz = jstz;
    } else {
        root.jstz = jstz;
    }
}
}());

},{}],339:[function(require,module,exports){
/*! lightslider - v1.1.6 - 2016-10-25
* https://github.com/sachinchoolur/lightslider
* Copyright (c) 2016 Sachin N; Licensed MIT */
!function(a,b){"use strict";var c={item:3,autoWidth:!1,slideMove:1,slideMargin:10,addClass:"",mode:"slide",useCSS:!0,cssEasing:"ease",easing:"linear",speed:400,auto:!1,pauseOnHover:!1,loop:!1,slideEndAnimation:!0,pause:2e3,keyPress:!1,controls:!0,prevHtml:"",nextHtml:"",rtl:!1,adaptiveHeight:!1,vertical:!1,verticalHeight:500,vThumbWidth:100,thumbItem:10,pager:!0,gallery:!1,galleryMargin:5,thumbMargin:5,currentPagerPosition:"middle",enableTouch:!0,enableDrag:!0,freeMove:!0,swipeThreshold:40,responsive:[],onBeforeStart:function(a){},onSliderLoad:function(a){},onBeforeSlide:function(a,b){},onAfterSlide:function(a,b){},onBeforeNextSlide:function(a,b){},onBeforePrevSlide:function(a,b){}};a.fn.lightSlider=function(b){if(0===this.length)return this;if(this.length>1)return this.each(function(){a(this).lightSlider(b)}),this;var d={},e=a.extend(!0,{},c,b),f={},g=this;d.$el=this,"fade"===e.mode&&(e.vertical=!1);var h=g.children(),i=a(window).width(),j=null,k=null,l=0,m=0,n=!1,o=0,p="",q=0,r=e.vertical===!0?"height":"width",s=e.vertical===!0?"margin-bottom":"margin-right",t=0,u=0,v=0,w=0,x=null,y="ontouchstart"in document.documentElement,z={};return z.chbreakpoint=function(){if(i=a(window).width(),e.responsive.length){var b;if(e.autoWidth===!1&&(b=e.item),i<e.responsive[0].breakpoint)for(var c=0;c<e.responsive.length;c++)i<e.responsive[c].breakpoint&&(j=e.responsive[c].breakpoint,k=e.responsive[c]);if("undefined"!=typeof k&&null!==k)for(var d in k.settings)k.settings.hasOwnProperty(d)&&(("undefined"==typeof f[d]||null===f[d])&&(f[d]=e[d]),e[d]=k.settings[d]);if(!a.isEmptyObject(f)&&i>e.responsive[0].breakpoint)for(var g in f)f.hasOwnProperty(g)&&(e[g]=f[g]);e.autoWidth===!1&&t>0&&v>0&&b!==e.item&&(q=Math.round(t/((v+e.slideMargin)*e.slideMove)))}},z.calSW=function(){e.autoWidth===!1&&(v=(o-(e.item*e.slideMargin-e.slideMargin))/e.item)},z.calWidth=function(a){var b=a===!0?p.find(".lslide").length:h.length;if(e.autoWidth===!1)m=b*(v+e.slideMargin);else{m=0;for(var c=0;b>c;c++)m+=parseInt(h.eq(c).width())+e.slideMargin}return m},d={doCss:function(){var a=function(){for(var a=["transition","MozTransition","WebkitTransition","OTransition","msTransition","KhtmlTransition"],b=document.documentElement,c=0;c<a.length;c++)if(a[c]in b.style)return!0};return e.useCSS&&a()?!0:!1},keyPress:function(){e.keyPress&&a(document).on("keyup.lightslider",function(b){a(":focus").is("input, textarea")||(b.preventDefault?b.preventDefault():b.returnValue=!1,37===b.keyCode?g.goToPrevSlide():39===b.keyCode&&g.goToNextSlide())})},controls:function(){e.controls&&(g.after('<div class="lSAction"><a class="lSPrev">'+e.prevHtml+'</a><a class="lSNext">'+e.nextHtml+"</a></div>"),e.autoWidth?z.calWidth(!1)<o&&p.find(".lSAction").hide():l<=e.item&&p.find(".lSAction").hide(),p.find(".lSAction a").on("click",function(b){return b.preventDefault?b.preventDefault():b.returnValue=!1,"lSPrev"===a(this).attr("class")?g.goToPrevSlide():g.goToNextSlide(),!1}))},initialStyle:function(){var a=this;"fade"===e.mode&&(e.autoWidth=!1,e.slideEndAnimation=!1),e.auto&&(e.slideEndAnimation=!1),e.autoWidth&&(e.slideMove=1,e.item=1),e.loop&&(e.slideMove=1,e.freeMove=!1),e.onBeforeStart.call(this,g),z.chbreakpoint(),g.addClass("lightSlider").wrap('<div class="lSSlideOuter '+e.addClass+'"><div class="lSSlideWrapper"></div></div>'),p=g.parent(".lSSlideWrapper"),e.rtl===!0&&p.parent().addClass("lSrtl"),e.vertical?(p.parent().addClass("vertical"),o=e.verticalHeight,p.css("height",o+"px")):o=g.outerWidth(),h.addClass("lslide"),e.loop===!0&&"slide"===e.mode&&(z.calSW(),z.clone=function(){if(z.calWidth(!0)>o){for(var b=0,c=0,d=0;d<h.length&&(b+=parseInt(g.find(".lslide").eq(d).width())+e.slideMargin,c++,!(b>=o+e.slideMargin));d++);var f=e.autoWidth===!0?c:e.item;if(f<g.find(".clone.left").length)for(var i=0;i<g.find(".clone.left").length-f;i++)h.eq(i).remove();if(f<g.find(".clone.right").length)for(var j=h.length-1;j>h.length-1-g.find(".clone.right").length;j--)q--,h.eq(j).remove();for(var k=g.find(".clone.right").length;f>k;k++)g.find(".lslide").eq(k).clone().removeClass("lslide").addClass("clone right").appendTo(g),q++;for(var l=g.find(".lslide").length-g.find(".clone.left").length;l>g.find(".lslide").length-f;l--)g.find(".lslide").eq(l-1).clone().removeClass("lslide").addClass("clone left").prependTo(g);h=g.children()}else h.hasClass("clone")&&(g.find(".clone").remove(),a.move(g,0))},z.clone()),z.sSW=function(){l=h.length,e.rtl===!0&&e.vertical===!1&&(s="margin-left"),e.autoWidth===!1&&h.css(r,v+"px"),h.css(s,e.slideMargin+"px"),m=z.calWidth(!1),g.css(r,m+"px"),e.loop===!0&&"slide"===e.mode&&n===!1&&(q=g.find(".clone.left").length)},z.calL=function(){h=g.children(),l=h.length},this.doCss()&&p.addClass("usingCss"),z.calL(),"slide"===e.mode?(z.calSW(),z.sSW(),e.loop===!0&&(t=a.slideValue(),this.move(g,t)),e.vertical===!1&&this.setHeight(g,!1)):(this.setHeight(g,!0),g.addClass("lSFade"),this.doCss()||(h.fadeOut(0),h.eq(q).fadeIn(0))),e.loop===!0&&"slide"===e.mode?h.eq(q).addClass("active"):h.first().addClass("active")},pager:function(){var a=this;if(z.createPager=function(){w=(o-(e.thumbItem*e.thumbMargin-e.thumbMargin))/e.thumbItem;var b=p.find(".lslide"),c=p.find(".lslide").length,d=0,f="",h=0;for(d=0;c>d;d++){"slide"===e.mode&&(e.autoWidth?h+=(parseInt(b.eq(d).width())+e.slideMargin)*e.slideMove:h=d*(v+e.slideMargin)*e.slideMove);var i=b.eq(d*e.slideMove).attr("data-thumb");if(f+=e.gallery===!0?'<li style="width:100%;'+r+":"+w+"px;"+s+":"+e.thumbMargin+'px"><a href="#"><img src="'+i+'" /></a></li>':'<li><a href="#">'+(d+1)+"</a></li>","slide"===e.mode&&h>=m-o-e.slideMargin){d+=1;var j=2;e.autoWidth&&(f+='<li><a href="#">'+(d+1)+"</a></li>",j=1),j>d?(f=null,p.parent().addClass("noPager")):p.parent().removeClass("noPager");break}}var k=p.parent();k.find(".lSPager").html(f),e.gallery===!0&&(e.vertical===!0&&k.find(".lSPager").css("width",e.vThumbWidth+"px"),u=d*(e.thumbMargin+w)+.5,k.find(".lSPager").css({property:u+"px","transition-duration":e.speed+"ms"}),e.vertical===!0&&p.parent().css("padding-right",e.vThumbWidth+e.galleryMargin+"px"),k.find(".lSPager").css(r,u+"px"));var l=k.find(".lSPager").find("li");l.first().addClass("active"),l.on("click",function(){return e.loop===!0&&"slide"===e.mode?q+=l.index(this)-k.find(".lSPager").find("li.active").index():q=l.index(this),g.mode(!1),e.gallery===!0&&a.slideThumb(),!1})},e.pager){var b="lSpg";e.gallery&&(b="lSGallery"),p.after('<ul class="lSPager '+b+'"></ul>');var c=e.vertical?"margin-left":"margin-top";p.parent().find(".lSPager").css(c,e.galleryMargin+"px"),z.createPager()}setTimeout(function(){z.init()},0)},setHeight:function(a,b){var c=null,d=this;c=e.loop?a.children(".lslide ").first():a.children().first();var f=function(){var d=c.outerHeight(),e=0,f=d;b&&(d=0,e=100*f/o),a.css({height:d+"px","padding-bottom":e+"%"})};f(),c.find("img").length?c.find("img")[0].complete?(f(),x||d.auto()):c.find("img").on("load",function(){setTimeout(function(){f(),x||d.auto()},100)}):x||d.auto()},active:function(a,b){this.doCss()&&"fade"===e.mode&&p.addClass("on");var c=0;if(q*e.slideMove<l){a.removeClass("active"),this.doCss()||"fade"!==e.mode||b!==!1||a.fadeOut(e.speed),c=b===!0?q:q*e.slideMove;var d,f;b===!0&&(d=a.length,f=d-1,c+1>=d&&(c=f)),e.loop===!0&&"slide"===e.mode&&(c=b===!0?q-g.find(".clone.left").length:q*e.slideMove,b===!0&&(d=a.length,f=d-1,c+1===d?c=f:c+1>d&&(c=0))),this.doCss()||"fade"!==e.mode||b!==!1||a.eq(c).fadeIn(e.speed),a.eq(c).addClass("active")}else a.removeClass("active"),a.eq(a.length-1).addClass("active"),this.doCss()||"fade"!==e.mode||b!==!1||(a.fadeOut(e.speed),a.eq(c).fadeIn(e.speed))},move:function(a,b){e.rtl===!0&&(b=-b),this.doCss()?a.css(e.vertical===!0?{transform:"translate3d(0px, "+-b+"px, 0px)","-webkit-transform":"translate3d(0px, "+-b+"px, 0px)"}:{transform:"translate3d("+-b+"px, 0px, 0px)","-webkit-transform":"translate3d("+-b+"px, 0px, 0px)"}):e.vertical===!0?a.css("position","relative").animate({top:-b+"px"},e.speed,e.easing):a.css("position","relative").animate({left:-b+"px"},e.speed,e.easing);var c=p.parent().find(".lSPager").find("li");this.active(c,!0)},fade:function(){this.active(h,!1);var a=p.parent().find(".lSPager").find("li");this.active(a,!0)},slide:function(){var a=this;z.calSlide=function(){m>o&&(t=a.slideValue(),a.active(h,!1),t>m-o-e.slideMargin?t=m-o-e.slideMargin:0>t&&(t=0),a.move(g,t),e.loop===!0&&"slide"===e.mode&&(q>=l-g.find(".clone.left").length/e.slideMove&&a.resetSlide(g.find(".clone.left").length),0===q&&a.resetSlide(p.find(".lslide").length)))},z.calSlide()},resetSlide:function(a){var b=this;p.find(".lSAction a").addClass("disabled"),setTimeout(function(){q=a,p.css("transition-duration","0ms"),t=b.slideValue(),b.active(h,!1),d.move(g,t),setTimeout(function(){p.css("transition-duration",e.speed+"ms"),p.find(".lSAction a").removeClass("disabled")},50)},e.speed+100)},slideValue:function(){var a=0;if(e.autoWidth===!1)a=q*(v+e.slideMargin)*e.slideMove;else{a=0;for(var b=0;q>b;b++)a+=parseInt(h.eq(b).width())+e.slideMargin}return a},slideThumb:function(){var a;switch(e.currentPagerPosition){case"left":a=0;break;case"middle":a=o/2-w/2;break;case"right":a=o-w}var b=q-g.find(".clone.left").length,c=p.parent().find(".lSPager");"slide"===e.mode&&e.loop===!0&&(b>=c.children().length?b=0:0>b&&(b=c.children().length));var d=b*(w+e.thumbMargin)-a;d+o>u&&(d=u-o-e.thumbMargin),0>d&&(d=0),this.move(c,d)},auto:function(){e.auto&&(clearInterval(x),x=setInterval(function(){g.goToNextSlide()},e.pause))},pauseOnHover:function(){var b=this;e.auto&&e.pauseOnHover&&(p.on("mouseenter",function(){a(this).addClass("ls-hover"),g.pause(),e.auto=!0}),p.on("mouseleave",function(){a(this).removeClass("ls-hover"),p.find(".lightSlider").hasClass("lsGrabbing")||b.auto()}))},touchMove:function(a,b){if(p.css("transition-duration","0ms"),"slide"===e.mode){var c=a-b,d=t-c;if(d>=m-o-e.slideMargin)if(e.freeMove===!1)d=m-o-e.slideMargin;else{var f=m-o-e.slideMargin;d=f+(d-f)/5}else 0>d&&(e.freeMove===!1?d=0:d/=5);this.move(g,d)}},touchEnd:function(a){if(p.css("transition-duration",e.speed+"ms"),"slide"===e.mode){var b=!1,c=!0;t-=a,t>m-o-e.slideMargin?(t=m-o-e.slideMargin,e.autoWidth===!1&&(b=!0)):0>t&&(t=0);var d=function(a){var c=0;if(b||a&&(c=1),e.autoWidth)for(var d=0,f=0;f<h.length&&(d+=parseInt(h.eq(f).width())+e.slideMargin,q=f+c,!(d>=t));f++);else{var g=t/((v+e.slideMargin)*e.slideMove);q=parseInt(g)+c,t>=m-o-e.slideMargin&&g%1!==0&&q++}};a>=e.swipeThreshold?(d(!1),c=!1):a<=-e.swipeThreshold&&(d(!0),c=!1),g.mode(c),this.slideThumb()}else a>=e.swipeThreshold?g.goToPrevSlide():a<=-e.swipeThreshold&&g.goToNextSlide()},enableDrag:function(){var b=this;if(!y){var c=0,d=0,f=!1;p.find(".lightSlider").addClass("lsGrab"),p.on("mousedown",function(b){return o>m&&0!==m?!1:void("lSPrev"!==a(b.target).attr("class")&&"lSNext"!==a(b.target).attr("class")&&(c=e.vertical===!0?b.pageY:b.pageX,f=!0,b.preventDefault?b.preventDefault():b.returnValue=!1,p.scrollLeft+=1,p.scrollLeft-=1,p.find(".lightSlider").removeClass("lsGrab").addClass("lsGrabbing"),clearInterval(x)))}),a(window).on("mousemove",function(a){f&&(d=e.vertical===!0?a.pageY:a.pageX,b.touchMove(d,c))}),a(window).on("mouseup",function(g){if(f){p.find(".lightSlider").removeClass("lsGrabbing").addClass("lsGrab"),f=!1,d=e.vertical===!0?g.pageY:g.pageX;var h=d-c;Math.abs(h)>=e.swipeThreshold&&a(window).on("click.ls",function(b){b.preventDefault?b.preventDefault():b.returnValue=!1,b.stopImmediatePropagation(),b.stopPropagation(),a(window).off("click.ls")}),b.touchEnd(h)}})}},enableTouch:function(){var a=this;if(y){var b={},c={};p.on("touchstart",function(a){c=a.originalEvent.targetTouches[0],b.pageX=a.originalEvent.targetTouches[0].pageX,b.pageY=a.originalEvent.targetTouches[0].pageY,clearInterval(x)}),p.on("touchmove",function(d){if(o>m&&0!==m)return!1;var f=d.originalEvent;c=f.targetTouches[0];var g=Math.abs(c.pageX-b.pageX),h=Math.abs(c.pageY-b.pageY);e.vertical===!0?(3*h>g&&d.preventDefault(),a.touchMove(c.pageY,b.pageY)):(3*g>h&&d.preventDefault(),a.touchMove(c.pageX,b.pageX))}),p.on("touchend",function(){if(o>m&&0!==m)return!1;var d;d=e.vertical===!0?c.pageY-b.pageY:c.pageX-b.pageX,a.touchEnd(d)})}},build:function(){var b=this;b.initialStyle(),this.doCss()&&(e.enableTouch===!0&&b.enableTouch(),e.enableDrag===!0&&b.enableDrag()),a(window).on("focus",function(){b.auto()}),a(window).on("blur",function(){clearInterval(x)}),b.pager(),b.pauseOnHover(),b.controls(),b.keyPress()}},d.build(),z.init=function(){z.chbreakpoint(),e.vertical===!0?(o=e.item>1?e.verticalHeight:h.outerHeight(),p.css("height",o+"px")):o=p.outerWidth(),e.loop===!0&&"slide"===e.mode&&z.clone(),z.calL(),"slide"===e.mode&&g.removeClass("lSSlide"),"slide"===e.mode&&(z.calSW(),z.sSW()),setTimeout(function(){"slide"===e.mode&&g.addClass("lSSlide")},1e3),e.pager&&z.createPager(),e.adaptiveHeight===!0&&e.vertical===!1&&g.css("height",h.eq(q).outerHeight(!0)),e.adaptiveHeight===!1&&("slide"===e.mode?e.vertical===!1?d.setHeight(g,!1):d.auto():d.setHeight(g,!0)),e.gallery===!0&&d.slideThumb(),"slide"===e.mode&&d.slide(),e.autoWidth===!1?h.length<=e.item?p.find(".lSAction").hide():p.find(".lSAction").show():z.calWidth(!1)<o&&0!==m?p.find(".lSAction").hide():p.find(".lSAction").show()},g.goToPrevSlide=function(){if(q>0)e.onBeforePrevSlide.call(this,g,q),q--,g.mode(!1),e.gallery===!0&&d.slideThumb();else if(e.loop===!0){if(e.onBeforePrevSlide.call(this,g,q),"fade"===e.mode){var a=l-1;q=parseInt(a/e.slideMove)}g.mode(!1),e.gallery===!0&&d.slideThumb()}else e.slideEndAnimation===!0&&(g.addClass("leftEnd"),setTimeout(function(){g.removeClass("leftEnd")},400))},g.goToNextSlide=function(){var a=!0;if("slide"===e.mode){var b=d.slideValue();a=b<m-o-e.slideMargin}q*e.slideMove<l-e.slideMove&&a?(e.onBeforeNextSlide.call(this,g,q),q++,g.mode(!1),e.gallery===!0&&d.slideThumb()):e.loop===!0?(e.onBeforeNextSlide.call(this,g,q),q=0,g.mode(!1),e.gallery===!0&&d.slideThumb()):e.slideEndAnimation===!0&&(g.addClass("rightEnd"),setTimeout(function(){g.removeClass("rightEnd")},400))},g.mode=function(a){e.adaptiveHeight===!0&&e.vertical===!1&&g.css("height",h.eq(q).outerHeight(!0)),n===!1&&("slide"===e.mode?d.doCss()&&(g.addClass("lSSlide"),""!==e.speed&&p.css("transition-duration",e.speed+"ms"),""!==e.cssEasing&&p.css("transition-timing-function",e.cssEasing)):d.doCss()&&(""!==e.speed&&g.css("transition-duration",e.speed+"ms"),""!==e.cssEasing&&g.css("transition-timing-function",e.cssEasing))),a||e.onBeforeSlide.call(this,g,q),"slide"===e.mode?d.slide():d.fade(),p.hasClass("ls-hover")||d.auto(),setTimeout(function(){a||e.onAfterSlide.call(this,g,q)},e.speed),n=!0},g.play=function(){g.goToNextSlide(),e.auto=!0,d.auto()},g.pause=function(){e.auto=!1,clearInterval(x)},g.refresh=function(){z.init()},g.getCurrentSlideCount=function(){var a=q;if(e.loop){var b=p.find(".lslide").length,c=g.find(".clone.left").length;a=c-1>=q?b+(q-c):q>=b+c?q-b-c:q-c}return a+1},g.getTotalSlideCount=function(){return p.find(".lslide").length},g.goToSlide=function(a){q=e.loop?a+g.find(".clone.left").length-1:a,g.mode(!1),e.gallery===!0&&d.slideThumb()},g.destroy=function(){g.lightSlider&&(g.goToPrevSlide=function(){},g.goToNextSlide=function(){},g.mode=function(){},g.play=function(){},g.pause=function(){},g.refresh=function(){},g.getCurrentSlideCount=function(){},g.getTotalSlideCount=function(){},g.goToSlide=function(){},g.lightSlider=null,z={init:function(){}},g.parent().parent().find(".lSAction, .lSPager").remove(),g.removeClass("lightSlider lSFade lSSlide lsGrab lsGrabbing leftEnd right").removeAttr("style").unwrap().unwrap(),g.children().removeAttr("style"),h.removeClass("lslide active"),g.find(".clone").remove(),h=null,x=null,n=!1,q=0)},setTimeout(function(){e.onSliderLoad.call(this,g)},10),a(window).on("resize orientationchange",function(a){setTimeout(function(){a.preventDefault?a.preventDefault():a.returnValue=!1,z.init()},200)}),this}}(jQuery);
},{}],340:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0',
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsAstral = '[' + rsAstralRange + ']',
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
  rsUpper + '+' + rsOptUpperContr,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 'ss'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = camelCase;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],341:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],342:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0',
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
  rsUpper + '+' + rsOptUpperContr,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 'ss'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

/**
 * Converts `string` to
 * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the kebab cased string.
 * @example
 *
 * _.kebabCase('Foo Bar');
 * // => 'foo-bar'
 *
 * _.kebabCase('fooBar');
 * // => 'foo-bar'
 *
 * _.kebabCase('__FOO_BAR__');
 * // => 'foo-bar'
 */
var kebabCase = createCompounder(function(result, word, index) {
  return result + (index ? '-' : '') + word.toLowerCase();
});

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = kebabCase;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],343:[function(require,module,exports){
(function (global){
/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Gets the value at `key`, unless `key` is "__proto__".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  return key == '__proto__'
    ? undefined
    : object[key];
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeMax = Math.max,
    nativeNow = Date.now;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = mergeWith;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],344:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeMax = Math.max;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, props) {
  object = Object(object);
  return basePickBy(object, props, function(value, key) {
    return key in object;
  });
}

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick from.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, props, predicate) {
  var index = -1,
      length = props.length,
      result = {};

  while (++index < length) {
    var key = props[index],
        value = object[key];

    if (predicate(value, key)) {
      result[key] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Creates an array of the own and inherited enumerable symbol properties
 * of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable string keyed properties of `object` that are
 * not omitted.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property identifiers to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = baseRest(function(object, props) {
  if (object == null) {
    return {};
  }
  props = arrayMap(baseFlatten(props, 1), toKey);
  return basePick(object, baseDifference(getAllKeysIn(object), props));
});

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = omit;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],345:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = isKey(path, object) ? [path] : castPath(path);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

module.exports = set;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],346:[function(require,module,exports){
//! moment.js

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date = new Date(y, m, d, h, M, s, ms);

        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        if (!m) {
            return isArray(this._weekdays) ? this._weekdays :
                this._weekdays['standalone'];
        }
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.22.2';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'YYYY-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));

},{}],347:[function(require,module,exports){
//     (c) 2012-2016 Airbnb, Inc.
//
//     polyglot.js may be freely distributed under the terms of the BSD
//     license. For all licensing information, details, and documention:
//     http://airbnb.github.com/polyglot.js
//
//
// Polyglot.js is an I18n helper library written in JavaScript, made to
// work both in the browser and in Node. It provides a simple solution for
// interpolation and pluralization, based off of Airbnb's
// experience adding I18n functionality to its Backbone.js and Node apps.
//
// Polylglot is agnostic to your translation backend. It doesn't perform any
// translation; it simply gives you a way to manage translated phrases from
// your client- or server-side JavaScript application.
//

'use strict';

var forEach = require('for-each');
var warning = require('warning');
var has = require('has');
var trim = require('string.prototype.trim');

var warn = function warn(message) {
  warning(false, message);
};

var replace = String.prototype.replace;
var split = String.prototype.split;

// #### Pluralization methods
// The string that separates the different phrase possibilities.
var delimeter = '||||';

// Mapping from pluralization group plural logic.
var pluralTypes = {
  arabic: function (n) {
    // http://www.arabeyes.org/Plural_Forms
    if (n < 3) { return n; }
    if (n % 100 >= 3 && n % 100 <= 10) return 3;
    return n % 100 >= 11 ? 4 : 5;
  },
  chinese: function () { return 0; },
  german: function (n) { return n !== 1 ? 1 : 0; },
  french: function (n) { return n > 1 ? 1 : 0; },
  russian: function (n) {
    if (n % 10 === 1 && n % 100 !== 11) { return 0; }
    return n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;
  },
  czech: function (n) {
    if (n === 1) { return 0; }
    return (n >= 2 && n <= 4) ? 1 : 2;
  },
  polish: function (n) {
    if (n === 1) { return 0; }
    return n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;
  },
  icelandic: function (n) { return (n % 10 !== 1 || n % 100 === 11) ? 1 : 0; }
};

// Mapping from pluralization group to individual locales.
var pluralTypeToLanguages = {
  arabic: ['ar'],
  chinese: ['fa', 'id', 'ja', 'ko', 'lo', 'ms', 'th', 'tr', 'zh'],
  german: ['da', 'de', 'en', 'es', 'fi', 'el', 'he', 'hu', 'it', 'nl', 'no', 'pt', 'sv'],
  french: ['fr', 'tl', 'pt-br'],
  russian: ['hr', 'ru', 'lt'],
  czech: ['cs', 'sk'],
  polish: ['pl'],
  icelandic: ['is']
};

function langToTypeMap(mapping) {
  var ret = {};
  forEach(mapping, function (langs, type) {
    forEach(langs, function (lang) {
      ret[lang] = type;
    });
  });
  return ret;
}

function pluralTypeName(locale) {
  var langToPluralType = langToTypeMap(pluralTypeToLanguages);
  return langToPluralType[locale]
    || langToPluralType[split.call(locale, /-/, 1)[0]]
    || langToPluralType.en;
}

function pluralTypeIndex(locale, count) {
  return pluralTypes[pluralTypeName(locale)](count);
}

var dollarRegex = /\$/g;
var dollarBillsYall = '$$';
var tokenRegex = /%\{(.*?)\}/g;

// ### transformPhrase(phrase, substitutions, locale)
//
// Takes a phrase string and transforms it by choosing the correct
// plural form and interpolating it.
//
//     transformPhrase('Hello, %{name}!', {name: 'Spike'});
//     // "Hello, Spike!"
//
// The correct plural form is selected if substitutions.smart_count
// is set. You can pass in a number instead of an Object as `substitutions`
// as a shortcut for `smart_count`.
//
//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 1}, 'en');
//     // "1 new message"
//
//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 2}, 'en');
//     // "2 new messages"
//
//     transformPhrase('%{smart_count} new messages |||| 1 new message', 5, 'en');
//     // "5 new messages"
//
// You should pass in a third argument, the locale, to specify the correct plural type.
// It defaults to `'en'` with 2 plural forms.
function transformPhrase(phrase, substitutions, locale) {
  if (typeof phrase !== 'string') {
    throw new TypeError('Polyglot.transformPhrase expects argument #1 to be string');
  }

  if (substitutions == null) {
    return phrase;
  }

  var result = phrase;

  // allow number as a pluralization shortcut
  var options = typeof substitutions === 'number' ? { smart_count: substitutions } : substitutions;

  // Select plural form: based on a phrase text that contains `n`
  // plural forms separated by `delimeter`, a `locale`, and a `substitutions.smart_count`,
  // choose the correct plural form. This is only done if `count` is set.
  if (options.smart_count != null && result) {
    var texts = split.call(result, delimeter);
    result = trim(texts[pluralTypeIndex(locale || 'en', options.smart_count)] || texts[0]);
  }

  // Interpolate: Creates a `RegExp` object for each interpolation placeholder.
  result = replace.call(result, tokenRegex, function (expression, argument) {
    if (!has(options, argument) || options[argument] == null) { return expression; }
    // Ensure replacement value is escaped to prevent special $-prefixed regex replace tokens.
    return replace.call(options[argument], dollarRegex, dollarBillsYall);
  });

  return result;
}

// ### Polyglot class constructor
function Polyglot(options) {
  var opts = options || {};
  this.phrases = {};
  this.extend(opts.phrases || {});
  this.currentLocale = opts.locale || 'en';
  var allowMissing = opts.allowMissing ? transformPhrase : null;
  this.onMissingKey = typeof opts.onMissingKey === 'function' ? opts.onMissingKey : allowMissing;
  this.warn = opts.warn || warn;
}

// ### polyglot.locale([locale])
//
// Get or set locale. Internally, Polyglot only uses locale for pluralization.
Polyglot.prototype.locale = function (newLocale) {
  if (newLocale) this.currentLocale = newLocale;
  return this.currentLocale;
};

// ### polyglot.extend(phrases)
//
// Use `extend` to tell Polyglot how to translate a given key.
//
//     polyglot.extend({
//       "hello": "Hello",
//       "hello_name": "Hello, %{name}"
//     });
//
// The key can be any string.  Feel free to call `extend` multiple times;
// it will override any phrases with the same key, but leave existing phrases
// untouched.
//
// It is also possible to pass nested phrase objects, which get flattened
// into an object with the nested keys concatenated using dot notation.
//
//     polyglot.extend({
//       "nav": {
//         "hello": "Hello",
//         "hello_name": "Hello, %{name}",
//         "sidebar": {
//           "welcome": "Welcome"
//         }
//       }
//     });
//
//     console.log(polyglot.phrases);
//     // {
//     //   'nav.hello': 'Hello',
//     //   'nav.hello_name': 'Hello, %{name}',
//     //   'nav.sidebar.welcome': 'Welcome'
//     // }
//
// `extend` accepts an optional second argument, `prefix`, which can be used
// to prefix every key in the phrases object with some string, using dot
// notation.
//
//     polyglot.extend({
//       "hello": "Hello",
//       "hello_name": "Hello, %{name}"
//     }, "nav");
//
//     console.log(polyglot.phrases);
//     // {
//     //   'nav.hello': 'Hello',
//     //   'nav.hello_name': 'Hello, %{name}'
//     // }
//
// This feature is used internally to support nested phrase objects.
Polyglot.prototype.extend = function (morePhrases, prefix) {
  forEach(morePhrases, function (phrase, key) {
    var prefixedKey = prefix ? prefix + '.' + key : key;
    if (typeof phrase === 'object') {
      this.extend(phrase, prefixedKey);
    } else {
      this.phrases[prefixedKey] = phrase;
    }
  }, this);
};

// ### polyglot.unset(phrases)
// Use `unset` to selectively remove keys from a polyglot instance.
//
//     polyglot.unset("some_key");
//     polyglot.unset({
//       "hello": "Hello",
//       "hello_name": "Hello, %{name}"
//     });
//
// The unset method can take either a string (for the key), or an object hash with
// the keys that you would like to unset.
Polyglot.prototype.unset = function (morePhrases, prefix) {
  if (typeof morePhrases === 'string') {
    delete this.phrases[morePhrases];
  } else {
    forEach(morePhrases, function (phrase, key) {
      var prefixedKey = prefix ? prefix + '.' + key : key;
      if (typeof phrase === 'object') {
        this.unset(phrase, prefixedKey);
      } else {
        delete this.phrases[prefixedKey];
      }
    }, this);
  }
};

// ### polyglot.clear()
//
// Clears all phrases. Useful for special cases, such as freeing
// up memory if you have lots of phrases but no longer need to
// perform any translation. Also used internally by `replace`.
Polyglot.prototype.clear = function () {
  this.phrases = {};
};

// ### polyglot.replace(phrases)
//
// Completely replace the existing phrases with a new set of phrases.
// Normally, just use `extend` to add more phrases, but under certain
// circumstances, you may want to make sure no old phrases are lying around.
Polyglot.prototype.replace = function (newPhrases) {
  this.clear();
  this.extend(newPhrases);
};


// ### polyglot.t(key, options)
//
// The most-used method. Provide a key, and `t` will return the
// phrase.
//
//     polyglot.t("hello");
//     => "Hello"
//
// The phrase value is provided first by a call to `polyglot.extend()` or
// `polyglot.replace()`.
//
// Pass in an object as the second argument to perform interpolation.
//
//     polyglot.t("hello_name", {name: "Spike"});
//     => "Hello, Spike"
//
// If you like, you can provide a default value in case the phrase is missing.
// Use the special option key "_" to specify a default.
//
//     polyglot.t("i_like_to_write_in_language", {
//       _: "I like to write in %{language}.",
//       language: "JavaScript"
//     });
//     => "I like to write in JavaScript."
//
Polyglot.prototype.t = function (key, options) {
  var phrase, result;
  var opts = options == null ? {} : options;
  if (typeof this.phrases[key] === 'string') {
    phrase = this.phrases[key];
  } else if (typeof opts._ === 'string') {
    phrase = opts._;
  } else if (this.onMissingKey) {
    var onMissingKey = this.onMissingKey;
    result = onMissingKey(key, opts, this.currentLocale);
  } else {
    this.warn('Missing translation for key: "' + key + '"');
    result = key;
  }
  if (typeof phrase === 'string') {
    result = transformPhrase(phrase, opts, this.currentLocale);
  }
  return result;
};


// ### polyglot.has(key)
//
// Check if polyglot has a translation for given key
Polyglot.prototype.has = function (key) {
  return has(this.phrases, key);
};

// export transformPhrase
Polyglot.transformPhrase = transformPhrase;

module.exports = Polyglot;

},{"for-each":329,"has":333,"string.prototype.trim":352,"warning":355}],348:[function(require,module,exports){
/*!
 * Pikaday
 *
 * Copyright © 2014 David Bushell | BSD & MIT license | https://github.com/dbushell/Pikaday
 */

(function (root, factory)
{
    'use strict';

    var moment;
    if (typeof exports === 'object') {
        // CommonJS module
        // Load moment.js as an optional dependency
        try { moment = require('moment'); } catch (e) {}
        module.exports = factory(moment);
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(function (req)
        {
            // Load moment.js as an optional dependency
            var id = 'moment';
            try { moment = req(id); } catch (e) {}
            return factory(moment);
        });
    } else {
        root.Pikaday = factory(root.moment);
    }
}(this, function (moment)
{
    'use strict';

    /**
     * feature detection and helper functions
     */
    var hasMoment = typeof moment === 'function',

    hasEventListeners = !!window.addEventListener,

    document = window.document,

    sto = window.setTimeout,

    addEvent = function(el, e, callback, capture)
    {
        if (hasEventListeners) {
            el.addEventListener(e, callback, !!capture);
        } else {
            el.attachEvent('on' + e, callback);
        }
    },

    removeEvent = function(el, e, callback, capture)
    {
        if (hasEventListeners) {
            el.removeEventListener(e, callback, !!capture);
        } else {
            el.detachEvent('on' + e, callback);
        }
    },

    trim = function(str)
    {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g,'');
    },

    hasClass = function(el, cn)
    {
        return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
    },

    addClass = function(el, cn)
    {
        if (!hasClass(el, cn)) {
            el.className = (el.className === '') ? cn : el.className + ' ' + cn;
        }
    },

    removeClass = function(el, cn)
    {
        el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));
    },

    isArray = function(obj)
    {
        return (/Array/).test(Object.prototype.toString.call(obj));
    },

    isDate = function(obj)
    {
        return (/Date/).test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
    },

    isWeekend = function(date)
    {
        var day = date.getDay();
        return day === 0 || day === 6;
    },

    isLeapYear = function(year)
    {
        // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    },

    getDaysInMonth = function(year, month)
    {
        return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    },

    setToStartOfDay = function(date)
    {
        if (isDate(date)) date.setHours(0,0,0,0);
    },

    compareDates = function(a,b)
    {
        // weak date comparison (use setToStartOfDay(date) to ensure correct result)
        return a.getTime() === b.getTime();
    },

    extend = function(to, from, overwrite)
    {
        var prop, hasProp;
        for (prop in from) {
            hasProp = to[prop] !== undefined;
            if (hasProp && typeof from[prop] === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {
                if (isDate(from[prop])) {
                    if (overwrite) {
                        to[prop] = new Date(from[prop].getTime());
                    }
                }
                else if (isArray(from[prop])) {
                    if (overwrite) {
                        to[prop] = from[prop].slice(0);
                    }
                } else {
                    to[prop] = extend({}, from[prop], overwrite);
                }
            } else if (overwrite || !hasProp) {
                to[prop] = from[prop];
            }
        }
        return to;
    },

    fireEvent = function(el, eventName, data)
    {
        var ev;

        if (document.createEvent) {
            ev = document.createEvent('HTMLEvents');
            ev.initEvent(eventName, true, false);
            ev = extend(ev, data);
            el.dispatchEvent(ev);
        } else if (document.createEventObject) {
            ev = document.createEventObject();
            ev = extend(ev, data);
            el.fireEvent('on' + eventName, ev);
        }
    },

    adjustCalendar = function(calendar) {
        if (calendar.month < 0) {
            calendar.year -= Math.ceil(Math.abs(calendar.month)/12);
            calendar.month += 12;
        }
        if (calendar.month > 11) {
            calendar.year += Math.floor(Math.abs(calendar.month)/12);
            calendar.month -= 12;
        }
        return calendar;
    },

    /**
     * defaults and localisation
     */
    defaults = {

        // bind the picker to a form field
        field: null,

        // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
        bound: undefined,

        // position of the datepicker, relative to the field (default to bottom & left)
        // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
        position: 'bottom left',

        // automatically fit in the viewport even if it means repositioning from the position option
        reposition: true,

        // the default output format for `.toString()` and `field` value
        format: 'YYYY-MM-DD',

        // the toString function which gets passed a current date object and format
        // and returns a string
        toString: null,

        // used to create date object from current input string
        parse: null,

        // the initial date to view when first opened
        defaultDate: null,

        // make the `defaultDate` the initial selected value
        setDefaultDate: false,

        // first day of week (0: Sunday, 1: Monday etc)
        firstDay: 0,

        // the default flag for moment's strict date parsing
        formatStrict: false,

        // the minimum/earliest date that can be selected
        minDate: null,
        // the maximum/latest date that can be selected
        maxDate: null,

        // number of years either side, or array of upper/lower range
        yearRange: 10,

        // show week numbers at head of row
        showWeekNumber: false,

        // Week picker mode
        pickWholeWeek: false,

        // used internally (don't config outside)
        minYear: 0,
        maxYear: 9999,
        minMonth: undefined,
        maxMonth: undefined,

        startRange: null,
        endRange: null,

        isRTL: false,

        // Additional text to append to the year in the calendar title
        yearSuffix: '',

        // Render the month after year in the calendar title
        showMonthAfterYear: false,

        // Render days of the calendar grid that fall in the next or previous month
        showDaysInNextAndPreviousMonths: false,

        // Allows user to select days that fall in the next or previous month
        enableSelectionDaysInNextAndPreviousMonths: false,

        // how many months are visible
        numberOfMonths: 1,

        // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
        // only used for the first display or when a selected date is not visible
        mainCalendar: 'left',

        // Specify a DOM element to render the calendar in
        container: undefined,

        // Blur field when date is selected
        blurFieldOnSelect : true,

        // internationalization
        i18n: {
            previousMonth : 'Previous Month',
            nextMonth     : 'Next Month',
            months        : ['January','February','March','April','May','June','July','August','September','October','November','December'],
            weekdays      : ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
            weekdaysShort : ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']
        },

        // Theme Classname
        theme: null,

        // events array
        events: [],

        // callback function
        onSelect: null,
        onOpen: null,
        onClose: null,
        onDraw: null,

        // Enable keyboard input
        keyboardInput: true
    },


    /**
     * templating functions to abstract HTML rendering
     */
    renderDayName = function(opts, day, abbr)
    {
        day += opts.firstDay;
        while (day >= 7) {
            day -= 7;
        }
        return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
    },

    renderDay = function(opts)
    {
        var arr = [];
        var ariaSelected = 'false';
        if (opts.isEmpty) {
            if (opts.showDaysInNextAndPreviousMonths) {
                arr.push('is-outside-current-month');

                if(!opts.enableSelectionDaysInNextAndPreviousMonths) {
                    arr.push('is-selection-disabled');
                }

            } else {
                return '<td class="is-empty"></td>';
            }
        }
        if (opts.isDisabled) {
            arr.push('is-disabled');
        }
        if (opts.isToday) {
            arr.push('is-today');
        }
        if (opts.isSelected) {
            arr.push('is-selected');
            ariaSelected = 'true';
        }
        if (opts.hasEvent) {
            arr.push('has-event');
        }
        if (opts.isInRange) {
            arr.push('is-inrange');
        }
        if (opts.isStartRange) {
            arr.push('is-startrange');
        }
        if (opts.isEndRange) {
            arr.push('is-endrange');
        }
        return '<td data-day="' + opts.day + '" class="' + arr.join(' ') + '" aria-selected="' + ariaSelected + '">' +
                 '<button class="pika-button pika-day" type="button" ' +
                    'data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' +
                        opts.day +
                 '</button>' +
               '</td>';
    },

    renderWeek = function (d, m, y) {
        // Lifted from http://javascript.about.com/library/blweekyear.htm, lightly modified.
        var onejan = new Date(y, 0, 1),
            weekNum = Math.ceil((((new Date(y, m, d) - onejan) / 86400000) + onejan.getDay()+1)/7);
        return '<td class="pika-week">' + weekNum + '</td>';
    },

    renderRow = function(days, isRTL, pickWholeWeek, isRowSelected)
    {
        return '<tr class="pika-row' + (pickWholeWeek ? ' pick-whole-week' : '') + (isRowSelected ? ' is-selected' : '') + '">' + (isRTL ? days.reverse() : days).join('') + '</tr>';
    },

    renderBody = function(rows)
    {
        return '<tbody>' + rows.join('') + '</tbody>';
    },

    renderHead = function(opts)
    {
        var i, arr = [];
        if (opts.showWeekNumber) {
            arr.push('<th></th>');
        }
        for (i = 0; i < 7; i++) {
            arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + '</abbr></th>');
        }
        return '<thead><tr>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</tr></thead>';
    },

    renderTitle = function(instance, c, year, month, refYear, randId)
    {
        var i, j, arr,
            opts = instance._o,
            isMinYear = year === opts.minYear,
            isMaxYear = year === opts.maxYear,
            html = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">',
            monthHtml,
            yearHtml,
            prev = true,
            next = true;

        for (arr = [], i = 0; i < 12; i++) {
            arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' +
                (i === month ? ' selected="selected"': '') +
                ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth) ? 'disabled="disabled"' : '') + '>' +
                opts.i18n.months[i] + '</option>');
        }

        monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join('') + '</select></div>';

        if (isArray(opts.yearRange)) {
            i = opts.yearRange[0];
            j = opts.yearRange[1] + 1;
        } else {
            i = year - opts.yearRange;
            j = 1 + year + opts.yearRange;
        }

        for (arr = []; i < j && i <= opts.maxYear; i++) {
            if (i >= opts.minYear) {
                arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"': '') + '>' + (i) + '</option>');
            }
        }
        yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join('') + '</select></div>';

        if (opts.showMonthAfterYear) {
            html += yearHtml + monthHtml;
        } else {
            html += monthHtml + yearHtml;
        }

        if (isMinYear && (month === 0 || opts.minMonth >= month)) {
            prev = false;
        }

        if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
            next = false;
        }

        if (c === 0) {
            html += '<button class="pika-prev' + (prev ? '' : ' is-disabled') + '" type="button">' + opts.i18n.previousMonth + '</button>';
        }
        if (c === (instance._o.numberOfMonths - 1) ) {
            html += '<button class="pika-next' + (next ? '' : ' is-disabled') + '" type="button">' + opts.i18n.nextMonth + '</button>';
        }

        return html += '</div>';
    },

    renderTable = function(opts, data, randId)
    {
        return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + '</table>';
    },


    /**
     * Pikaday constructor
     */
    Pikaday = function(options)
    {
        var self = this,
            opts = self.config(options);

        self._onMouseDown = function(e)
        {
            if (!self._v) {
                return;
            }
            e = e || window.event;
            var target = e.target || e.srcElement;
            if (!target) {
                return;
            }

            if (!hasClass(target, 'is-disabled')) {
                if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty') && !hasClass(target.parentNode, 'is-disabled')) {
                    self.setDate(new Date(target.getAttribute('data-pika-year'), target.getAttribute('data-pika-month'), target.getAttribute('data-pika-day')));
                    if (opts.bound) {
                        sto(function() {
                            self.hide();
                            if (opts.blurFieldOnSelect && opts.field) {
                                opts.field.blur();
                            }
                        }, 100);
                    }
                }
                else if (hasClass(target, 'pika-prev')) {
                    self.prevMonth();
                }
                else if (hasClass(target, 'pika-next')) {
                    self.nextMonth();
                }
            }
            if (!hasClass(target, 'pika-select')) {
                // if this is touch event prevent mouse events emulation
                if (e.preventDefault) {
                    e.preventDefault();
                } else {
                    e.returnValue = false;
                    return false;
                }
            } else {
                self._c = true;
            }
        };

        self._onChange = function(e)
        {
            e = e || window.event;
            var target = e.target || e.srcElement;
            if (!target) {
                return;
            }
            if (hasClass(target, 'pika-select-month')) {
                self.gotoMonth(target.value);
            }
            else if (hasClass(target, 'pika-select-year')) {
                self.gotoYear(target.value);
            }
        };

        self._onKeyChange = function(e)
        {
            e = e || window.event;

            if (self.isVisible()) {

                switch(e.keyCode){
                    case 13:
                    case 27:
                        if (opts.field) {
                            opts.field.blur();
                        }
                        break;
                    case 37:
                        e.preventDefault();
                        self.adjustDate('subtract', 1);
                        break;
                    case 38:
                        self.adjustDate('subtract', 7);
                        break;
                    case 39:
                        self.adjustDate('add', 1);
                        break;
                    case 40:
                        self.adjustDate('add', 7);
                        break;
                }
            }
        };

        self._onInputChange = function(e)
        {
            var date;

            if (e.firedBy === self) {
                return;
            }
            if (opts.parse) {
                date = opts.parse(opts.field.value, opts.format);
            } else if (hasMoment) {
                date = moment(opts.field.value, opts.format, opts.formatStrict);
                date = (date && date.isValid()) ? date.toDate() : null;
            }
            else {
                date = new Date(Date.parse(opts.field.value));
            }
            if (isDate(date)) {
              self.setDate(date);
            }
            if (!self._v) {
                self.show();
            }
        };

        self._onInputFocus = function()
        {
            self.show();
        };

        self._onInputClick = function()
        {
            self.show();
        };

        self._onInputBlur = function()
        {
            // IE allows pika div to gain focus; catch blur the input field
            var pEl = document.activeElement;
            do {
                if (hasClass(pEl, 'pika-single')) {
                    return;
                }
            }
            while ((pEl = pEl.parentNode));

            if (!self._c) {
                self._b = sto(function() {
                    self.hide();
                }, 50);
            }
            self._c = false;
        };

        self._onClick = function(e)
        {
            e = e || window.event;
            var target = e.target || e.srcElement,
                pEl = target;
            if (!target) {
                return;
            }
            if (!hasEventListeners && hasClass(target, 'pika-select')) {
                if (!target.onchange) {
                    target.setAttribute('onchange', 'return;');
                    addEvent(target, 'change', self._onChange);
                }
            }
            do {
                if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {
                    return;
                }
            }
            while ((pEl = pEl.parentNode));
            if (self._v && target !== opts.trigger && pEl !== opts.trigger) {
                self.hide();
            }
        };

        self.el = document.createElement('div');
        self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');

        addEvent(self.el, 'mousedown', self._onMouseDown, true);
        addEvent(self.el, 'touchend', self._onMouseDown, true);
        addEvent(self.el, 'change', self._onChange);

        if (opts.keyboardInput) {
            addEvent(document, 'keydown', self._onKeyChange);
        }

        if (opts.field) {
            if (opts.container) {
                opts.container.appendChild(self.el);
            } else if (opts.bound) {
                document.body.appendChild(self.el);
            } else {
                opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);
            }
            addEvent(opts.field, 'change', self._onInputChange);

            if (!opts.defaultDate) {
                if (hasMoment && opts.field.value) {
                    opts.defaultDate = moment(opts.field.value, opts.format).toDate();
                } else {
                    opts.defaultDate = new Date(Date.parse(opts.field.value));
                }
                opts.setDefaultDate = true;
            }
        }

        var defDate = opts.defaultDate;

        if (isDate(defDate)) {
            if (opts.setDefaultDate) {
                self.setDate(defDate, true);
            } else {
                self.gotoDate(defDate);
            }
        } else {
            self.gotoDate(new Date());
        }

        if (opts.bound) {
            this.hide();
            self.el.className += ' is-bound';
            addEvent(opts.trigger, 'click', self._onInputClick);
            addEvent(opts.trigger, 'focus', self._onInputFocus);
            addEvent(opts.trigger, 'blur', self._onInputBlur);
        } else {
            this.show();
        }
    };


    /**
     * public Pikaday API
     */
    Pikaday.prototype = {


        /**
         * configure functionality
         */
        config: function(options)
        {
            if (!this._o) {
                this._o = extend({}, defaults, true);
            }

            var opts = extend(this._o, options, true);

            opts.isRTL = !!opts.isRTL;

            opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;

            opts.theme = (typeof opts.theme) === 'string' && opts.theme ? opts.theme : null;

            opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);

            opts.trigger = (opts.trigger && opts.trigger.nodeName) ? opts.trigger : opts.field;

            opts.disableWeekends = !!opts.disableWeekends;

            opts.disableDayFn = (typeof opts.disableDayFn) === 'function' ? opts.disableDayFn : null;

            var nom = parseInt(opts.numberOfMonths, 10) || 1;
            opts.numberOfMonths = nom > 4 ? 4 : nom;

            if (!isDate(opts.minDate)) {
                opts.minDate = false;
            }
            if (!isDate(opts.maxDate)) {
                opts.maxDate = false;
            }
            if ((opts.minDate && opts.maxDate) && opts.maxDate < opts.minDate) {
                opts.maxDate = opts.minDate = false;
            }
            if (opts.minDate) {
                this.setMinDate(opts.minDate);
            }
            if (opts.maxDate) {
                this.setMaxDate(opts.maxDate);
            }

            if (isArray(opts.yearRange)) {
                var fallback = new Date().getFullYear() - 10;
                opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
                opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
            } else {
                opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
                if (opts.yearRange > 100) {
                    opts.yearRange = 100;
                }
            }

            return opts;
        },

        /**
         * return a formatted string of the current selection (using Moment.js if available)
         */
        toString: function(format)
        {
            format = format || this._o.format;
            if (!isDate(this._d)) {
                return '';
            }
            if (this._o.toString) {
              return this._o.toString(this._d, format);
            }
            if (hasMoment) {
              return moment(this._d).format(format);
            }
            return this._d.toDateString();
        },

        /**
         * return a Moment.js object of the current selection (if available)
         */
        getMoment: function()
        {
            return hasMoment ? moment(this._d) : null;
        },

        /**
         * set the current selection from a Moment.js object (if available)
         */
        setMoment: function(date, preventOnSelect)
        {
            if (hasMoment && moment.isMoment(date)) {
                this.setDate(date.toDate(), preventOnSelect);
            }
        },

        /**
         * return a Date object of the current selection
         */
        getDate: function()
        {
            return isDate(this._d) ? new Date(this._d.getTime()) : null;
        },

        /**
         * set the current selection
         */
        setDate: function(date, preventOnSelect)
        {
            if (!date) {
                this._d = null;

                if (this._o.field) {
                    this._o.field.value = '';
                    fireEvent(this._o.field, 'change', { firedBy: this });
                }

                return this.draw();
            }
            if (typeof date === 'string') {
                date = new Date(Date.parse(date));
            }
            if (!isDate(date)) {
                return;
            }

            var min = this._o.minDate,
                max = this._o.maxDate;

            if (isDate(min) && date < min) {
                date = min;
            } else if (isDate(max) && date > max) {
                date = max;
            }

            this._d = new Date(date.getTime());
            setToStartOfDay(this._d);
            this.gotoDate(this._d);

            if (this._o.field) {
                this._o.field.value = this.toString();
                fireEvent(this._o.field, 'change', { firedBy: this });
            }
            if (!preventOnSelect && typeof this._o.onSelect === 'function') {
                this._o.onSelect.call(this, this.getDate());
            }
        },

        /**
         * change view to a specific date
         */
        gotoDate: function(date)
        {
            var newCalendar = true;

            if (!isDate(date)) {
                return;
            }

            if (this.calendars) {
                var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
                    lastVisibleDate = new Date(this.calendars[this.calendars.length-1].year, this.calendars[this.calendars.length-1].month, 1),
                    visibleDate = date.getTime();
                // get the end of the month
                lastVisibleDate.setMonth(lastVisibleDate.getMonth()+1);
                lastVisibleDate.setDate(lastVisibleDate.getDate()-1);
                newCalendar = (visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate);
            }

            if (newCalendar) {
                this.calendars = [{
                    month: date.getMonth(),
                    year: date.getFullYear()
                }];
                if (this._o.mainCalendar === 'right') {
                    this.calendars[0].month += 1 - this._o.numberOfMonths;
                }
            }

            this.adjustCalendars();
        },

        adjustDate: function(sign, days) {

            var day = this.getDate() || new Date();
            var difference = parseInt(days)*24*60*60*1000;

            var newDay;

            if (sign === 'add') {
                newDay = new Date(day.valueOf() + difference);
            } else if (sign === 'subtract') {
                newDay = new Date(day.valueOf() - difference);
            }

            this.setDate(newDay);
        },

        adjustCalendars: function() {
            this.calendars[0] = adjustCalendar(this.calendars[0]);
            for (var c = 1; c < this._o.numberOfMonths; c++) {
                this.calendars[c] = adjustCalendar({
                    month: this.calendars[0].month + c,
                    year: this.calendars[0].year
                });
            }
            this.draw();
        },

        gotoToday: function()
        {
            this.gotoDate(new Date());
        },

        /**
         * change view to a specific month (zero-index, e.g. 0: January)
         */
        gotoMonth: function(month)
        {
            if (!isNaN(month)) {
                this.calendars[0].month = parseInt(month, 10);
                this.adjustCalendars();
            }
        },

        nextMonth: function()
        {
            this.calendars[0].month++;
            this.adjustCalendars();
        },

        prevMonth: function()
        {
            this.calendars[0].month--;
            this.adjustCalendars();
        },

        /**
         * change view to a specific full year (e.g. "2012")
         */
        gotoYear: function(year)
        {
            if (!isNaN(year)) {
                this.calendars[0].year = parseInt(year, 10);
                this.adjustCalendars();
            }
        },

        /**
         * change the minDate
         */
        setMinDate: function(value)
        {
            if(value instanceof Date) {
                setToStartOfDay(value);
                this._o.minDate = value;
                this._o.minYear  = value.getFullYear();
                this._o.minMonth = value.getMonth();
            } else {
                this._o.minDate = defaults.minDate;
                this._o.minYear  = defaults.minYear;
                this._o.minMonth = defaults.minMonth;
                this._o.startRange = defaults.startRange;
            }

            this.draw();
        },

        /**
         * change the maxDate
         */
        setMaxDate: function(value)
        {
            if(value instanceof Date) {
                setToStartOfDay(value);
                this._o.maxDate = value;
                this._o.maxYear = value.getFullYear();
                this._o.maxMonth = value.getMonth();
            } else {
                this._o.maxDate = defaults.maxDate;
                this._o.maxYear = defaults.maxYear;
                this._o.maxMonth = defaults.maxMonth;
                this._o.endRange = defaults.endRange;
            }

            this.draw();
        },

        setStartRange: function(value)
        {
            this._o.startRange = value;
        },

        setEndRange: function(value)
        {
            this._o.endRange = value;
        },

        /**
         * refresh the HTML
         */
        draw: function(force)
        {
            if (!this._v && !force) {
                return;
            }
            var opts = this._o,
                minYear = opts.minYear,
                maxYear = opts.maxYear,
                minMonth = opts.minMonth,
                maxMonth = opts.maxMonth,
                html = '',
                randId;

            if (this._y <= minYear) {
                this._y = minYear;
                if (!isNaN(minMonth) && this._m < minMonth) {
                    this._m = minMonth;
                }
            }
            if (this._y >= maxYear) {
                this._y = maxYear;
                if (!isNaN(maxMonth) && this._m > maxMonth) {
                    this._m = maxMonth;
                }
            }

            randId = 'pika-title-' + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 2);

            for (var c = 0; c < opts.numberOfMonths; c++) {
                html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId) + '</div>';
            }

            this.el.innerHTML = html;

            if (opts.bound) {
                if(opts.field.type !== 'hidden') {
                    sto(function() {
                        opts.trigger.focus();
                    }, 1);
                }
            }

            if (typeof this._o.onDraw === 'function') {
                this._o.onDraw(this);
            }

            if (opts.bound) {
                // let the screen reader user know to use arrow keys
                opts.field.setAttribute('aria-label', 'Use the arrow keys to pick a date');
            }
        },

        adjustPosition: function()
        {
            var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect;

            if (this._o.container) return;

            this.el.style.position = 'absolute';

            field = this._o.trigger;
            pEl = field;
            width = this.el.offsetWidth;
            height = this.el.offsetHeight;
            viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;

            if (typeof field.getBoundingClientRect === 'function') {
                clientRect = field.getBoundingClientRect();
                left = clientRect.left + window.pageXOffset;
                top = clientRect.bottom + window.pageYOffset;
            } else {
                left = pEl.offsetLeft;
                top  = pEl.offsetTop + pEl.offsetHeight;
                while((pEl = pEl.offsetParent)) {
                    left += pEl.offsetLeft;
                    top  += pEl.offsetTop;
                }
            }

            // default position is bottom & left
            if ((this._o.reposition && left + width > viewportWidth) ||
                (
                    this._o.position.indexOf('right') > -1 &&
                    left - width + field.offsetWidth > 0
                )
            ) {
                left = left - width + field.offsetWidth;
            }
            if ((this._o.reposition && top + height > viewportHeight + scrollTop) ||
                (
                    this._o.position.indexOf('top') > -1 &&
                    top - height - field.offsetHeight > 0
                )
            ) {
                top = top - height - field.offsetHeight;
            }

            this.el.style.left = left + 'px';
            this.el.style.top = top + 'px';
        },

        /**
         * render HTML for a particular month
         */
        render: function(year, month, randId)
        {
            var opts   = this._o,
                now    = new Date(),
                days   = getDaysInMonth(year, month),
                before = new Date(year, month, 1).getDay(),
                data   = [],
                row    = [];
            setToStartOfDay(now);
            if (opts.firstDay > 0) {
                before -= opts.firstDay;
                if (before < 0) {
                    before += 7;
                }
            }
            var previousMonth = month === 0 ? 11 : month - 1,
                nextMonth = month === 11 ? 0 : month + 1,
                yearOfPreviousMonth = month === 0 ? year - 1 : year,
                yearOfNextMonth = month === 11 ? year + 1 : year,
                daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, previousMonth);
            var cells = days + before,
                after = cells;
            while(after > 7) {
                after -= 7;
            }
            cells += 7 - after;
            var isWeekSelected = false;
            for (var i = 0, r = 0; i < cells; i++)
            {
                var day = new Date(year, month, 1 + (i - before)),
                    isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
                    isToday = compareDates(day, now),
                    hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false,
                    isEmpty = i < before || i >= (days + before),
                    dayNumber = 1 + (i - before),
                    monthNumber = month,
                    yearNumber = year,
                    isStartRange = opts.startRange && compareDates(opts.startRange, day),
                    isEndRange = opts.endRange && compareDates(opts.endRange, day),
                    isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
                    isDisabled = (opts.minDate && day < opts.minDate) ||
                                 (opts.maxDate && day > opts.maxDate) ||
                                 (opts.disableWeekends && isWeekend(day)) ||
                                 (opts.disableDayFn && opts.disableDayFn(day));

                if (isEmpty) {
                    if (i < before) {
                        dayNumber = daysInPreviousMonth + dayNumber;
                        monthNumber = previousMonth;
                        yearNumber = yearOfPreviousMonth;
                    } else {
                        dayNumber = dayNumber - days;
                        monthNumber = nextMonth;
                        yearNumber = yearOfNextMonth;
                    }
                }

                var dayConfig = {
                        day: dayNumber,
                        month: monthNumber,
                        year: yearNumber,
                        hasEvent: hasEvent,
                        isSelected: isSelected,
                        isToday: isToday,
                        isDisabled: isDisabled,
                        isEmpty: isEmpty,
                        isStartRange: isStartRange,
                        isEndRange: isEndRange,
                        isInRange: isInRange,
                        showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
                        enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
                    };

                if (opts.pickWholeWeek && isSelected) {
                    isWeekSelected = true;
                }

                row.push(renderDay(dayConfig));

                if (++r === 7) {
                    if (opts.showWeekNumber) {
                        row.unshift(renderWeek(i - before, month, year));
                    }
                    data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
                    row = [];
                    r = 0;
                    isWeekSelected = false;
                }
            }
            return renderTable(opts, data, randId);
        },

        isVisible: function()
        {
            return this._v;
        },

        show: function()
        {
            if (!this.isVisible()) {
                this._v = true;
                this.draw();
                removeClass(this.el, 'is-hidden');
                if (this._o.bound) {
                    addEvent(document, 'click', this._onClick);
                    this.adjustPosition();
                }
                if (typeof this._o.onOpen === 'function') {
                    this._o.onOpen.call(this);
                }
            }
        },

        hide: function()
        {
            var v = this._v;
            if (v !== false) {
                if (this._o.bound) {
                    removeEvent(document, 'click', this._onClick);
                }
                this.el.style.position = 'static'; // reset
                this.el.style.left = 'auto';
                this.el.style.top = 'auto';
                addClass(this.el, 'is-hidden');
                this._v = false;
                if (v !== undefined && typeof this._o.onClose === 'function') {
                    this._o.onClose.call(this);
                }
            }
        },

        /**
         * GAME OVER
         */
        destroy: function()
        {
            var opts = this._o;

            this.hide();
            removeEvent(this.el, 'mousedown', this._onMouseDown, true);
            removeEvent(this.el, 'touchend', this._onMouseDown, true);
            removeEvent(this.el, 'change', this._onChange);
            if (opts.keyboardInput) {
                removeEvent(document, 'keydown', this._onKeyChange);
            }
            if (opts.field) {
                removeEvent(opts.field, 'change', this._onInputChange);
                if (opts.bound) {
                    removeEvent(opts.trigger, 'click', this._onInputClick);
                    removeEvent(opts.trigger, 'focus', this._onInputFocus);
                    removeEvent(opts.trigger, 'blur', this._onInputBlur);
                }
            }
            if (this.el.parentNode) {
                this.el.parentNode.removeChild(this.el);
            }
        }

    };

    return Pikaday;
}));

},{"moment":346}],349:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],350:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);

},{}],351:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var ES = require('es-abstract/es5');
var replace = bind.call(Function.call, String.prototype.replace);

var leftWhitespace = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/;
var rightWhitespace = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/;

module.exports = function trim() {
	var S = ES.ToString(ES.CheckObjectCoercible(this));
	return replace(replace(S, leftWhitespace, ''), rightWhitespace, '');
};

},{"es-abstract/es5":321,"function-bind":332}],352:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var define = require('define-properties');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var boundTrim = bind.call(Function.call, getPolyfill());

define(boundTrim, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = boundTrim;

},{"./implementation":351,"./polyfill":353,"./shim":354,"define-properties":317,"function-bind":332}],353:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

var zeroWidthSpace = '\u200b';

module.exports = function getPolyfill() {
	if (String.prototype.trim && zeroWidthSpace.trim() === zeroWidthSpace) {
		return String.prototype.trim;
	}
	return implementation;
};

},{"./implementation":351}],354:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var getPolyfill = require('./polyfill');

module.exports = function shimStringTrim() {
	var polyfill = getPolyfill();
	define(String.prototype, { trim: polyfill }, { trim: function () { return String.prototype.trim !== polyfill; } });
	return polyfill;
};

},{"./polyfill":353,"define-properties":317}],355:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

}).call(this,require('_process'))

},{"_process":349}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvaW5kZXguanMiLCJhcHAvbGliL2F1dGhlbnRpY2F0ZWQuanMiLCJhcHAvbGliL2NhcnQuanMiLCJhcHAvbGliL2Nsb3NlLmpzIiwiYXBwL2xpYi9jcmVkZW50aWFsLmpzIiwiYXBwL2xpYi9leGVjdXRlLmpzIiwiYXBwL2xpYi9oZWFkZXIuanMiLCJhcHAvbGliL2luaXRpYWxpemUuanMiLCJhcHAvbGliL2xvZ291dC5qcyIsImFwcC9saWIvbm90aWZ5LmpzIiwiYXBwL2xpYi9vZmYuanMiLCJhcHAvbGliL29uLmpzIiwiYXBwL2xpYi9vcGVuLmpzIiwiYXBwL2xpYi9wcmVmZXJlbmNlLmpzIiwiYXBwL2xpYi9yZW5kZXIuanMiLCJhcHAvbGliL3JlcXVlc3QuanMiLCJhcHAvbGliL3NldE1lc3NhZ2VzLmpzIiwiYXBwL2xpYi90cmlnZ2VyLmpzIiwiYXBwL21vZHVsZXMvY2FydC9pbmRleC5qcyIsImFwcC9tb2R1bGVzL2NhdGFsb2ctc2xpZGVyL2luZGV4LmpzIiwiYXBwL21vZHVsZXMvY2hlY2tvdXQtc3VjY2Vzcy9pbmRleC5qcyIsImFwcC9tb2R1bGVzL2NoZWNrb3V0L2luZGV4LmpzIiwiYXBwL21vZHVsZXMvY2hlY2tvdXQvbGliL2FkZHJlc3NIYW5kbGVyLmpzIiwiYXBwL21vZHVsZXMvY2hlY2tvdXQvbGliL2NvdXBvbkhhbmRsZXIuanMiLCJhcHAvbW9kdWxlcy9jaGVja291dC9saWIvY3VzdG9tZXJIYW5kbGVyLmpzIiwiYXBwL21vZHVsZXMvY2hlY2tvdXQvbGliL3JlY2FwdGNoYUhhbmRsZXIuanMiLCJhcHAvbW9kdWxlcy9jaGVja291dC9saWIvc3Vic2NyaXB0aW9uSGFuZGxlci5qcyIsImFwcC9tb2R1bGVzL2N1c3RvbWVyLWNvdXBvbnMvaW5kZXguanMiLCJhcHAvbW9kdWxlcy9jdXN0b21lci1kYXNoYm9hcmQvaW5kZXguanMiLCJhcHAvbW9kdWxlcy9jdXN0b21lci1kZWxldGUtYWNjb3VudC9pbmRleC5qcyIsImFwcC9tb2R1bGVzL2N1c3RvbWVyLWxvZ2luL2luZGV4LmpzIiwiYXBwL21vZHVsZXMvY3VzdG9tZXItcmVnaXN0ZXIvaW5kZXguanMiLCJhcHAvbW9kdWxlcy9jdXN0b21lci1yZXNldC1wYXNzd29yZC9pbmRleC5qcyIsImFwcC9tb2R1bGVzL2N1c3RvbWVyLXJldmlldy1jb21tZW50L2luZGV4LmpzIiwiYXBwL21vZHVsZXMvY3VzdG9tZXItcmV2aWV3LWNvbW1lbnRzL2luZGV4LmpzIiwiYXBwL21vZHVsZXMvY3VzdG9tZXItcmV2aWV3L2luZGV4LmpzIiwiYXBwL21vZHVsZXMvY3VzdG9tZXItcmV2aWV3cy9pbmRleC5qcyIsImFwcC9tb2R1bGVzL2N1c3RvbWVyLXVwZGF0ZS1hZGRyZXNzL2luZGV4LmpzIiwiYXBwL21vZHVsZXMvY3VzdG9tZXItdXBkYXRlLWNyZWRlbnRpYWwvaW5kZXguanMiLCJhcHAvbW9kdWxlcy9jdXN0b21lci11cGRhdGUvaW5kZXguanMiLCJhcHAvbW9kdWxlcy9jdXN0b21lci12ZXJpZmljYXRpb24vaW5kZXguanMiLCJhcHAvbW9kdWxlcy9vcmRlci1kZXRhaWwvaW5kZXguanMiLCJhcHAvbW9kdWxlcy9vcmRlci1saXN0L2luZGV4LmpzIiwiYXBwL21vZHVsZXMvb3JkZXItcmVxdWVzdC1yZWZ1bmQvaW5kZXguanMiLCJhcHAvbW9kdWxlcy9wYXltZW50LWZvcm0vaW5kZXguanMiLCJhcHAvbW9kdWxlcy9wcm9kdWN0LWRldGFpbC9pbmRleC5qcyIsImFwcC9tb2R1bGVzL3Byb2R1Y3QtZGV0YWlsL2xpYi9wcm9kdWN0Q2F0YWxvZy5qcyIsImFwcC9tb2R1bGVzL3Byb2R1Y3QtbGlzdC9pbmRleC5qcyIsImFwcC9tb2R1bGVzL3Byb2R1Y3QtcmV2aWV3LWNvbW1lbnRzL2luZGV4LmpzIiwiYXBwL21vZHVsZXMvcHJvZHVjdC1yZXZpZXctd3JpdGVyL2luZGV4LmpzIiwiYXBwL21vZHVsZXMvcHJvZHVjdC1yZXZpZXcvaW5kZXguanMiLCJhcHAvbW9kdWxlcy9wcm9kdWN0LXJldmlld3MvaW5kZXguanMiLCJhcHAvbW9kdWxlcy9zZWFyY2gtcHVyY2hhc2UvaW5kZXguanMiLCJhcHAvbW9kdWxlcy9zdWJzY3JpcHRpb24tZGV0YWlsL2luZGV4LmpzIiwiYXBwL21vZHVsZXMvc3Vic2NyaXB0aW9uLWxpc3QvaW5kZXguanMiLCJhcHAvcGx1Z2lucy9jYXJ0U3RvcmFnZS5qcyIsImFwcC9wbHVnaW5zL2NvbmZpcm1hdGlvbi5qcyIsImFwcC9wbHVnaW5zL2NyZWRlbnRpYWxTdG9yYWdlLmpzIiwiYXBwL3BsdWdpbnMvbm90aWZpY2F0aW9uLmpzIiwiYXBwL3BsdWdpbnMvcGFnaW5hdGlvbi5qcyIsImFwcC9wbHVnaW5zL3JlZGlyZWN0LmpzIiwiYXBwL3VpL2F2YXRhci1wbGFjZWhvbGRlci5qcyIsImFwcC91aS9idXR0b24tc3Bpbm5lci5qcyIsImFwcC91aS9jb21wb25lbnQtc3Bpbm5lci5qcyIsImFwcC91aS9lbXB0eS1zdGFyLmpzIiwiYXBwL3VpL2ZpbGxlZC1zdGFyLmpzIiwiYXBwL3VpL2hhbGYtZmlsbGVkLXN0YXIuanMiLCJhcHAvdWkvaGFsbG93LXN0YXIuanMiLCJhcHAvdWkvaGVhZGVyLW5hdmlnYXRpb24uanMiLCJhcHAvdWkvbGVmdC1hcnJvdy5qcyIsImFwcC91aS9vdmVybGF5LW5hdmlnYXRpb24uanMiLCJhcHAvdWkvcmV2aWV3LXN0YXItcmF0aW5nLmpzIiwiYXBwL3VpL3Jldmlldy1zdGFycy5qcyIsImFwcC91aS9yaWdodC1hcnJvdy5qcyIsImFwcC91aS9zZWN0aW9uLXNwaW5uZXIuanMiLCJhcHAvdWkvc29jaWFsLWxvZ2luLmpzIiwiYXBwL3VpL3RleHQtYm94LW92ZXJsYXkuanMiLCJhcHAvdXRpbC9hZGRUaW1lLmpzIiwiYXBwL3V0aWwvYmluZEFncmVlbWVudHMuanMiLCJhcHAvdXRpbC9iaW5kQmFja0J1dHRvbi5qcyIsImFwcC91dGlsL2JpbmRSZWNhcHRjaGEuanMiLCJhcHAvdXRpbC9iaW5kU29jaWFsQXBwcy5qcyIsImFwcC91dGlsL2NoZWNrSXRlbVJlZnVuZGVkLmpzIiwiYXBwL3V0aWwvY29weVRvQ2xpcGJvYXJkLmpzIiwiYXBwL3V0aWwvY291bnRyeU5hbWUuanMiLCJhcHAvdXRpbC9jdXN0b21lcklkZW50aXR5LmpzIiwiYXBwL3V0aWwvZGVib3VuY2UuanMiLCJhcHAvdXRpbC9leGNlcnB0LmpzIiwiYXBwL3V0aWwvZm9sbG93aW5nTmF2aWdhdGlvbi5qcyIsImFwcC91dGlsL2Zvcm1Ub0pTT04uanMiLCJhcHAvdXRpbC9mb3JtYXROdW1iZXIuanMiLCJhcHAvdXRpbC9mb3JtYXRQcmljZS5qcyIsImFwcC91dGlsL2dldEN1cnJlbmN5LmpzIiwiYXBwL3V0aWwvaGFuZGxlU29jaWFsTG9naW4uanMiLCJhcHAvdXRpbC9pbWFnZVVSTC5qcyIsImFwcC91dGlsL2ltYWdlVXBsb2FkZXIuanMiLCJhcHAvdXRpbC9pc0V4cGlyZWQuanMiLCJhcHAvdXRpbC9sb2cuanMiLCJhcHAvdXRpbC9tYWtlQXN5bmNCdXR0b24uanMiLCJhcHAvdXRpbC9tYWtlUmVjYXB0Y2hhLmpzIiwiYXBwL3V0aWwvb3JkZXJTaGlwcGluZ1N0YXR1cy5qcyIsImFwcC91dGlsL3BhcnNlQXJyYXlTdHJpbmcuanMiLCJhcHAvdXRpbC9wYXJzZVF1ZXJ5U3RyaW5nLmpzIiwiYXBwL3V0aWwvcHJvZHVjdE5hbWUuanMiLCJhcHAvdXRpbC9xdWFudGl0eUlucHV0LmpzIiwiYXBwL3V0aWwvcmVxdWVzdEVycm9ySGFuZGxlci5qcyIsImFwcC91dGlsL3N0cmlwSFRNTC5qcyIsImFwcC91dGlsL3RvUHJlY2lzaW9uLmpzIiwiYXBwL3V0aWwvdWkuanMiLCJhcHAvdXRpbC91bnNldFJlY2FwdGNoYS5qcyIsImFwcC91dGlsL3VybFF1ZXJ5LmpzIiwiYXBwL3V0aWwvdXNlUmVjYXB0Y2hhLmpzIiwiYXBwL3V0aWwvdXNlcklkT3JFbWFpbC5qcyIsImFwcC91dGlsL3ZhcmlhbnROYW1lLmpzIiwiYXBwL3ZlcnNpb24uanNvbiIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2JpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19maXgtcmUtd2tzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWZyb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtbG9nMXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtdG8tYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BlcmZvcm0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcGFkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXJlcGVhdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdXNlci1hZ2VudC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3ZhbGlkYXRlLWNvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNicnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5oeXBvdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnRpbWVycy5qcyIsIm5vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydGllcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydGllcy9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2lzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L0dldEludHJpbnNpYy5qcyIsIm5vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9lczUuanMiLCJub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9pc0Zpbml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2lzTmFOLmpzIiwibm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvbW9kLmpzIiwibm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9lcy10by1wcmltaXRpdmUvZXM1LmpzIiwibm9kZV9tb2R1bGVzL2VzLXRvLXByaW1pdGl2ZS9oZWxwZXJzL2lzUHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2V2LWVtaXR0ZXIvZXYtZW1pdHRlci5qcyIsIm5vZGVfbW9kdWxlcy9mb3ItZWFjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mb3JlYWNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ltYWdlc2xvYWRlZC9pbWFnZXNsb2FkZWQuanMiLCJub2RlX21vZHVsZXMvaXMtY2FsbGFibGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanF1ZXJ5LWZvcm0vZGlzdC9qcXVlcnkuZm9ybS5taW4uanMiLCJub2RlX21vZHVsZXMvanF1ZXJ5LW1hdGNoLWhlaWdodC9kaXN0L2pxdWVyeS5tYXRjaEhlaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9qc3RpbWV6b25lZGV0ZWN0L2Rpc3QvanN0ei5qcyIsIm5vZGVfbW9kdWxlcy9saWdodHNsaWRlci9kaXN0L2pzL2xpZ2h0c2xpZGVyLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guY2FtZWxjYXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5nZXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmtlYmFiY2FzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gubWVyZ2VXaXRoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5vbWl0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5zZXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLXBvbHlnbG90L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Bpa2FkYXkvcGlrYWRheS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZy5wcm90b3R5cGUudHJpbS9pbXBsZW1lbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpbmcucHJvdG90eXBlLnRyaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nLnByb3RvdHlwZS50cmltL3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZy5wcm90b3R5cGUudHJpbS9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQ0EsUUFBUSxjQUFSO0FBQ0EsUUFBUSxhQUFSLEVBQXVCLE1BQXZCLEVBQStCLENBQS9CO0FBQ0EsUUFBUSxxQkFBUjtBQUNBLFFBQVEsd0NBQVI7O0FBRUEsSUFBTSxXQUFXLFFBQVEsZUFBUixDQUFqQjtBQUNBLElBQU0sT0FBTyxRQUFRLGtCQUFSLENBQWI7QUFDQSxJQUFNLFlBQVksUUFBUSxrQkFBUixDQUFsQjs7QUFFQSxJQUFNLFVBQVUsU0FBVixPQUFVLENBQVMsT0FBVCxFQUFrQjs7QUFFakMsS0FBTSxXQUFXLE9BQU8sU0FBUCxDQUFpQixZQUFqQixJQUNiLE9BQU8sU0FBUCxDQUFpQixRQURKLElBRWIsSUFGSjs7QUFJQSxLQUFNLFdBQVcsS0FBSyxTQUFMLEdBQWlCLElBQWpCLEVBQWpCOztBQUVBLEtBQU0sZ0JBQWdCLFNBQWhCLGFBQWdCLENBQUMsRUFBRCxFQUFLLEVBQUwsRUFBWTs7QUFFakMsTUFBSSxNQUFNLE9BQU4sQ0FBYyxFQUFkLEtBQXFCLE1BQU0sT0FBTixDQUFjLEVBQWQsQ0FBekIsRUFBNEM7QUFDM0MsVUFBTyxFQUFQO0FBQ0E7QUFFRCxFQU5EOztBQVFBLFdBQVUsVUFBVTtBQUNuQixVQUFlLElBREk7QUFFbkIsWUFBZSxRQUZJO0FBR25CLFlBQWUsSUFISTtBQUluQixZQUFlLFFBSkk7QUFLbkIsaUJBQWUsYUFBYSxJQUFiLEdBQW9CLElBQXBCLEdBQTJCLElB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6NUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdmxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ242QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMzZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOTlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Z0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJyZXF1aXJlKCdiYWJlbC1wb2x5ZmlsbCcpO1xyXG5yZXF1aXJlKCdpbWFnZXNsb2FkZWQnKTtcclxucmVxdWlyZSgnanF1ZXJ5LWZvcm0nKSh3aW5kb3csICQpO1xyXG5yZXF1aXJlKCdqcXVlcnktbWF0Y2gtaGVpZ2h0Jyk7XHJcbnJlcXVpcmUoJ2xpZ2h0c2xpZGVyL2Rpc3QvanMvbGlnaHRzbGlkZXIubWluLmpzJyk7XHJcblxyXG5jb25zdCBQb2x5Z2xvdCA9IHJlcXVpcmUoJ25vZGUtcG9seWdsb3QnKTtcclxuY29uc3QganN0eiA9IHJlcXVpcmUoJ2pzdGltZXpvbmVkZXRlY3QnKTtcclxuY29uc3QgbWVyZ2VXaXRoID0gcmVxdWlyZSgnbG9kYXNoLm1lcmdlV2l0aCcpO1xyXG5cclxuY29uc3QgVGh1bmRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHJcblx0Y29uc3QgbGFuZ3VhZ2UgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJMYW5ndWFnZSB8fFxyXG5cdFx0XHRcdFx0d2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZSB8fFxyXG5cdFx0XHRcdFx0bnVsbDtcclxuXHJcblx0Y29uc3QgdGltZXpvbmUgPSBqc3R6LmRldGVybWluZSgpLm5hbWUoKTtcclxuXHJcblx0Y29uc3Qgb3ZlcnJpZGVBcnJheSA9IChvdiwgc3YpID0+IHtcclxuXHJcblx0XHRpZiAoQXJyYXkuaXNBcnJheShvdikgJiYgQXJyYXkuaXNBcnJheShzdikpIHtcclxuXHRcdFx0cmV0dXJuIHN2O1xyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRvcHRpb25zID0gbWVyZ2VXaXRoKHtcclxuXHRcdGNsaWVudDogICAgICAgIG51bGwsXHJcblx0XHRsYW5ndWFnZTogICAgICBsYW5ndWFnZSxcclxuXHRcdGN1cnJlbmN5OiAgICAgIG51bGwsXHJcblx0XHR0aW1lem9uZTogICAgICB0aW1lem9uZSxcclxuXHRcdGRlYnVnTGFuZ3VhZ2U6IGxhbmd1YWdlID09PSAna28nID8gJ2tvJyA6ICdlbicsXHJcblx0XHRyb290OiAgICAgICAgICBgJHtsb2NhdGlvbi5wcm90b2NvbH0vLyR7bG9jYXRpb24uaG9zdH1gLFxyXG5cdFx0YmFzZVVSTDogICAgICAgbnVsbCxcclxuXHRcdGF1dGhTdG9yYWdlOiAgIHtcclxuXHRcdFx0Y3VzdG9tZXI6ICdfX3RjdF9fJyxcclxuXHRcdFx0b3JkZXI6ICAgICdfX3RvdF9fJyxcclxuXHRcdH0sXHJcblx0XHRkYXRlSW5wdXRGb3JtYXQ6ICdZWVlZLU1NLUREJyxcclxuXHRcdGxlZ2FsOiB7XHJcblx0XHRcdHJlZ2lzdHJhdGlvblRlcm1zOiAgIHsgbGluazogbnVsbCwgdGV4dDogbnVsbCB9LFxyXG5cdFx0XHRyZWdpc3RyYXRpb25Qcml2YWN5OiB7IGxpbms6IG51bGwsIHRleHQ6IG51bGwgfSxcclxuXHRcdFx0b3JkZXJUZXJtczogICAgICAgICAgeyBsaW5rOiBudWxsLCB0ZXh0OiBudWxsIH0sXHJcblx0XHRcdG9yZGVyUHJpdmFjeTogICAgICAgIHsgbGluazogbnVsbCwgdGV4dDogbnVsbCB9LFxyXG5cdFx0fSxcclxuXHRcdGNvbmZpcm1hdGlvbjoge1xyXG5cdFx0XHRjdXN0b21lckRlbGV0ZTogICAgICB0cnVlLFxyXG5cdFx0XHRjb3Vwb25EZWxldGU6ICAgICAgICBmYWxzZSxcclxuXHRcdFx0cmV2aWV3RGVsZXRlOiAgICAgICAgZmFsc2UsXHJcblx0XHRcdHJldmlld0NvbW1lbnREZWxldGU6IGZhbHNlLFxyXG5cdFx0fSxcclxuXHRcdHByb2R1Y3RBY3Rpb25zOiAgW1xyXG5cdFx0XHQnYWRkLXRvLWNhcnQnLFxyXG5cdFx0XHQnYnV5LW5vdydcclxuXHRcdF0sXHJcblx0XHRwcm9kdWN0TGFiZWxzOiAgICAgICAgW1xyXG5cdFx0XHQvLyAndW5hdmFpbGFibGUnLFxyXG5cdFx0XHQvLyAnc29sZC1vdXQnLFxyXG5cdFx0XHQvLyAnZGlzY291bnRlZCdcclxuXHRcdF0sXHJcblx0XHRwcm9kdWN0T3B0aW9uU2VsZWN0b3I6ICdjb21iaW5lZCcsXHJcblx0XHRwcm9kdWN0UmV2aWV3OiAgICAgICAgdHJ1ZSxcclxuXHRcdHByb2R1Y3RSZXZpZXdSYXRpbmc6ICB0cnVlLFxyXG5cdFx0cHJvZHVjdFJldmlld0NvbW1lbnQ6IHRydWUsXHJcblx0XHRwYXltZW50TWV0aG9kczogICAgICAge1xyXG5cdFx0XHRvcmRlcjogICAgICAgIFtdLFxyXG5cdFx0XHRzdWJzY3JpcHRpb246IFtdXHJcblx0XHR9LFxyXG5cdFx0cmVmdW5kUmVhc29uQ2F0ZWdvcmllczogIFtdLFxyXG5cdFx0c3Vic2NyaXB0aW9uUGxhbnM6ICAgICAgIFtdLFxyXG5cdFx0Y3VzdG9tZXJBdmF0YXI6ICAgICAgICAgIHRydWUsXHJcblx0XHRjdXN0b21lckRhc2hib2FyZExvZ291dDogZmFsc2UsXHJcblx0XHRjdXN0b21lcklkZW50aXR5OiAgICAgICAgW1xyXG5cdFx0XHQnbmFtZS5mdWxsJyxcclxuXHRcdFx0J2FsaWFzJyxcclxuXHRcdFx0J3VzZXJJZCdcclxuXHRcdF0sXHJcblx0XHRjdXN0b21lclJlZ2lzdHJhdGlvbkZpZWxkczogW1xyXG5cdFx0XHQndXNlcklkOnJlcXVpcmVkJyxcclxuXHRcdFx0J2VtYWlsOnJlcXVpcmVkJyxcclxuXHRcdFx0J3Bhc3N3b3JkOnJlcXVpcmVkJyxcclxuXHRcdFx0Ly8gJ2FsaWFzJyxcclxuXHRcdFx0Ly8gJ25hbWUuZmlyc3QnLFxyXG5cdFx0XHQvLyAnbmFtZS5sYXN0JyxcclxuXHRcdFx0J25hbWUuZnVsbDpyZXF1aXJlZCcsXHJcblx0XHRcdCdtb2JpbGU6cmVxdWlyZWQnLFxyXG5cdFx0XHQncGhvbmUnLFxyXG5cdFx0XHQvLyAnZ2VuZGVyJyxcclxuXHRcdFx0Ly8gJ2JpcnRoZGF0ZScsXHJcblx0XHRdLFxyXG5cdFx0Y3VzdG9tZXJVcGRhdGVGaWVsZHM6IFtcclxuXHRcdFx0J3VzZXJJZCcsXHJcblx0XHRcdCdlbWFpbCcsXHJcblx0XHRcdC8vICdhbGlhcycsXHJcblx0XHRcdC8vICduYW1lLmZpcnN0JyxcclxuXHRcdFx0Ly8gJ25hbWUubGFzdCcsXHJcblx0XHRcdCduYW1lLmZ1bGw6cmVxdWlyZWQnLFxyXG5cdFx0XHQnbW9iaWxlOnJlcXVpcmVkJyxcclxuXHRcdFx0J3Bob25lJyxcclxuXHRcdFx0Ly8gJ2dlbmRlcicsXHJcblx0XHRcdC8vICdiaXJ0aGRhdGUnLFxyXG5cdFx0XSxcclxuXHRcdGN1c3RvbWVyT3JkZXJGaWVsZHM6IFtcclxuXHRcdFx0Ly8gJ25hbWUuZmlyc3QnLFxyXG5cdFx0XHQvLyAnbmFtZS5sYXN0JyxcclxuXHRcdFx0J25hbWUuZnVsbDpyZXF1aXJlZCcsXHJcblx0XHRcdCdlbWFpbDpyZXF1aXJlZCcsXHJcblx0XHRcdCdtb2JpbGU6cmVxdWlyZWQnLFxyXG5cdFx0XHQncGhvbmUnLFxyXG5cdFx0XSxcclxuXHRcdHJlY2lwaWVudEZpZWxkczogICBbXHJcblx0XHRcdC8vICduYW1lLmZpcnN0JyxcclxuXHRcdFx0Ly8gJ25hbWUubGFzdCcsXHJcblx0XHRcdCduYW1lLmZ1bGw6cmVxdWlyZWQnLFxyXG5cdFx0XHQnbW9iaWxlOnJlcXVpcmVkJyxcclxuXHRcdFx0J3Bob25lJyxcclxuXHRcdF0sXHJcblx0XHRhZGRyZXNzRGlzYWJsZWQ6IFtcclxuXHRcdFx0J2NvdW50cnknLFxyXG5cdFx0XHQnc3RhdGUnLFxyXG5cdFx0XHQnY2l0eScsXHJcblx0XHRcdCdhZGRyZXNzMScsXHJcblx0XHRcdCdwb3N0Y29kZSdcclxuXHRcdF0sXHJcblx0XHRvcmRlckF1dGhGaWVsZHM6IFtcclxuXHRcdFx0Ly8gJ3VzZXJJZCcsXHJcblx0XHRcdC8vICdhbGlhcycsXHJcblx0XHRcdC8vICdlbWFpbCcsXHJcblx0XHRcdC8vICdtb2JpbGUnLFxyXG5cdFx0XHQvLyAncGhvbmUnLFxyXG5cdFx0XHQvLyAnbmFtZS5maXJzdCcsXHJcblx0XHRcdC8vICduYW1lLmxhc3QnLFxyXG5cdFx0XHQvLyAnbmFtZS5mdWxsJyxcclxuXHRcdF0sXHJcblx0XHRzb2NpYWxBcHBzOiBbXHJcblx0XHRcdC8vICdmYWNlYm9vaycsXHJcblx0XHRcdC8vICdnb29nbGUnLFxyXG5cdFx0XHQvLyAnaW5zdGFncmFtJyxcclxuXHRcdFx0Ly8gJ25hdmVyJyxcclxuXHRcdFx0Ly8gJ2tha2FvJyxcclxuXHRcdF0sXHJcblx0XHRoZWFkZXI6IGZhbHNlLFxyXG5cdFx0cmVjYXB0Y2hhOiB7XHJcblx0XHRcdHNpdGVrZXk6IG51bGwsXHJcblx0XHRcdG9ubG9hZDogICd0aHVuZGVyUmVjYXB0Y2hhJyxcclxuXHRcdFx0bW9kdWxlczogW1xyXG5cdFx0XHRcdCdjdXN0b21lci1yZWdpc3RlcicsXHJcblx0XHRcdFx0J2N1c3RvbWVyLWxvZ2luJyxcclxuXHRcdFx0XHQnY3VzdG9tZXItcmVzZXQtcGFzc3dvcmQnLFxyXG5cdFx0XHRcdCdjdXN0b21lci12ZXJpZmljYXRpb24nLFxyXG5cdFx0XHRcdC8vICdjdXN0b21lci11cGRhdGUnLFxyXG5cdFx0XHRcdC8vICdjdXN0b21lci11cGRhdGUtY3JlZGVudGlhbCcsXHJcblx0XHRcdFx0Ly8gJ2N1c3RvbWVyLXVwZGF0ZS1hZGRyZXNzJyxcclxuXHRcdFx0XHQncHJvZHVjdC1yZXZpZXctd3JpdGVyJyxcclxuXHRcdFx0XHQncHJvZHVjdC1yZXZpZXctY29tbWVudHMnLFxyXG5cdFx0XHRcdCdjaGVja291dCcsXHJcblx0XHRcdFx0J29yZGVyLXJlcXVlc3QtcmVmdW5kJyxcclxuXHRcdFx0XHQnc2VhcmNoLXB1cmNoYXNlJyxcclxuXHRcdFx0XSxcclxuXHRcdFx0cXVldWU6IFtdXHJcblx0XHR9LFxyXG5cdFx0cGx1Z2luczogICB7fSxcclxuXHRcdGxpc3RlbmVyczoge30sXHJcblx0XHRtZXNzYWdlczogIHt9LFxyXG5cdH0sIG9wdGlvbnMsIG92ZXJyaWRlQXJyYXkpO1xyXG5cclxuXHRpZiAob3B0aW9ucy5wbHVnaW5zKSB7XHJcblx0XHQkLmV4dGVuZChUaHVuZGVyLnBsdWdpbnMsIG9wdGlvbnMucGx1Z2lucyk7XHJcblx0fVxyXG5cclxuXHRpZiAob3B0aW9ucy5saXN0ZW5lcnMpIHtcclxuXHRcdE9iamVjdC5rZXlzKG9wdGlvbnMubGlzdGVuZXJzKS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XHJcblx0XHRcdFRodW5kZXIubGlzdGVuZXJzW2V2ZW50TmFtZV0gPVxyXG5cdFx0XHRcdFRodW5kZXIubGlzdGVuZXJzW2V2ZW50TmFtZV1cclxuXHRcdFx0XHRcdC5jb25jYXQob3B0aW9ucy5saXN0ZW5lcnNbZXZlbnROYW1lXSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGlmIChvcHRpb25zLnBheW1lbnRNZXRob2RzKSB7XHJcblxyXG5cdFx0T2JqZWN0LmtleXMob3B0aW9ucy5wYXltZW50TWV0aG9kcykuZm9yRWFjaCh0eXBlID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IHBheW1lbnRNZXRob2RzID0gb3B0aW9ucy5wYXltZW50TWV0aG9kc1t0eXBlXTtcclxuXHJcblx0XHRcdGlmIChwYXltZW50TWV0aG9kcy5sZW5ndGggPiAwKSByZXR1cm47XHJcblxyXG5cdFx0XHRkZWxldGUgb3B0aW9ucy5wYXltZW50TWV0aG9kc1t0eXBlXTtcclxuXHJcblx0XHR9KTtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAob3B0aW9ucy5oZWFkZXIpIHtcclxuXHJcblx0XHRjb25zdCBkZWZhdWx0SGVhZGVyT3B0aW9ucyA9IHtcclxuXHRcdFx0aXRlbXM6IFtcclxuXHRcdFx0XHQnY3VzdG9tZXInLCAgICAgICAgLy8gUmVnaXN0ZXIsIExvZ2luIHwgTXkgUHJvZmlsZVxyXG5cdFx0XHRcdCdzZWFyY2gtcHVyY2hhc2UnLCAvLyBTZWFyY2ggT3JkZXJcclxuXHRcdFx0XHQnY2FydCcsICAgICAgICAgICAgLy8gQ2FydFxyXG5cdFx0XHRdLFxyXG5cdFx0XHRhY3Rpb25zOiB7XHJcblx0XHRcdFx0J2N1c3RvbWVyLWRhc2hib2FyZCc6ICgpID0+IFRodW5kZXIub3BlbignY3VzdG9tZXItZGFzaGJvYXJkJyksXHJcblx0XHRcdFx0J2N1c3RvbWVyLXJlZ2lzdGVyJzogICgpID0+IFRodW5kZXIub3BlbignY3VzdG9tZXItcmVnaXN0ZXInKSxcclxuXHRcdFx0XHQnY3VzdG9tZXItbG9naW4nOiAgICAgKCkgPT4gVGh1bmRlci5vcGVuKCdjdXN0b21lci1sb2dpbicpLFxyXG5cdFx0XHRcdCdvcmRlci1saXN0JzogICAgICAgICAoKSA9PiBUaHVuZGVyLm9wZW4oJ29yZGVyLWxpc3QnKSxcclxuXHRcdFx0XHQnc2VhcmNoLXB1cmNoYXNlJzogICAgKCkgPT4gVGh1bmRlci5vcGVuKCdzZWFyY2gtcHVyY2hhc2UnKSxcclxuXHRcdFx0XHRjYXJ0OiAgICAgICAgICAgICAgICAgKCkgPT4gVGh1bmRlci5vcGVuKCdjYXJ0JyksXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuaGVhZGVyID09PSB0cnVlKSB7XHJcblx0XHRcdG9wdGlvbnMuaGVhZGVyID0gZGVmYXVsdEhlYWRlck9wdGlvbnM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvcHRpb25zLmhlYWRlciA9IG1lcmdlV2l0aChkZWZhdWx0SGVhZGVyT3B0aW9ucywgb3B0aW9ucy5oZWFkZXIsIG92ZXJyaWRlQXJyYXkpO1xyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGlmIChvcHRpb25zLm1lc3NhZ2VzKSB7XHJcblx0XHRUaHVuZGVyLnNldE1lc3NhZ2VzKG9wdGlvbnMubWVzc2FnZXMpO1xyXG5cdH1cclxuXHJcblx0aWYgKG9wdGlvbnMucmVjYXB0Y2hhLnNpdGVrZXkpIHtcclxuXHRcdHdpbmRvd1tvcHRpb25zLnJlY2FwdGNoYS5vbmxvYWRdID0gVGh1bmRlci51dGlsLmJpbmRSZWNhcHRjaGE7XHJcblx0fVxyXG5cclxuXHRUaHVuZGVyLm9wdGlvbnMgPSB7XHJcblx0XHRyb290OiAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yb290LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm9vdCBwYWdlIFVSTFxyXG5cdFx0YmFzZVVSTDogICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYmFzZVVSTCB8fCAnaHR0cHM6Ly9hcGkuY2xheWZ1bC5pbycsIC8vIEFQSSBiYXNlIFVSTFxyXG5cdFx0bGFuZ3VhZ2U6ICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubGFuZ3VhZ2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRlbnQgbGFuZ3VhZ2VcclxuXHRcdGN1cnJlbmN5OiAgICAgICAgICAgICAgICAgICBvcHRpb25zLmN1cnJlbmN5LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb250ZW50IGN1cnJlbmN5XHJcblx0XHR0aW1lem9uZTogICAgICAgICAgICAgICAgICAgb3B0aW9ucy50aW1lem9uZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udGVudCB0aW1lIHpvbmVcclxuXHRcdGF1dGhTdG9yYWdlOiAgICAgICAgICAgICAgICBvcHRpb25zLmF1dGhTdG9yYWdlLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdXRoIHRva2VuIHN0b3JhZ2VcclxuXHRcdGRhdGVJbnB1dEZvcm1hdDogICAgICAgICAgICBvcHRpb25zLmRhdGVJbnB1dEZvcm1hdCwgICAgICAgICAgICAgICAgICAgICAvLyBEYXRlIGlucHV0IGZvcm1hdFxyXG5cdFx0bGVnYWw6ICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubGVnYWwsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZ2FsIGluZm9ybWF0aW9uXHJcblx0XHRjb25maXJtYXRpb246ICAgICAgICAgICAgICAgb3B0aW9ucy5jb25maXJtYXRpb24sICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZmlybWF0aW9uIHNldHRpbmdzXHJcblx0XHRwcm9kdWN0QWN0aW9uczogICAgICAgICAgICAgb3B0aW9ucy5wcm9kdWN0QWN0aW9ucywgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydGVkIHByb2R1Y3Qgb3B0aW9uc1xyXG5cdFx0cHJvZHVjdExhYmVsczogICAgICAgICAgICAgIG9wdGlvbnMucHJvZHVjdExhYmVscywgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb2R1Y3QgbGFiZWxzIHRvIGRpc3BsYXlcclxuXHRcdHByb2R1Y3RSZXZpZXc6ICAgICAgICAgICAgICBvcHRpb25zLnByb2R1Y3RSZXZpZXcsXHJcblx0XHRwcm9kdWN0UmV2aWV3UmF0aW5nOiAgICAgICAgb3B0aW9ucy5wcm9kdWN0UmV2aWV3UmF0aW5nLFxyXG5cdFx0cHJvZHVjdFJldmlld0NvbW1lbnQ6ICAgICAgIG9wdGlvbnMucHJvZHVjdFJldmlld0NvbW1lbnQsXHJcblx0XHRwcm9kdWN0T3B0aW9uU2VsZWN0b3I6ICAgICAgb3B0aW9ucy5wcm9kdWN0T3B0aW9uU2VsZWN0b3IsXHJcblx0XHRwYXltZW50TWV0aG9kczogICAgICAgICAgICAgb3B0aW9ucy5wYXltZW50TWV0aG9kcywgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydGVkIHBheW1lbnQgbWV0aG9kc1xyXG5cdFx0cmVmdW5kUmVhc29uQ2F0ZWdvcmllczogICAgIG9wdGlvbnMucmVmdW5kUmVhc29uQ2F0ZWdvcmllcywgICAgICAgICAgICAgIC8vIFJlZnVuZCByZWFzb24gY2F0ZWdvcmllc1xyXG5cdFx0c3Vic2NyaXB0aW9uUGxhbnM6ICAgICAgICAgIG9wdGlvbnMuc3Vic2NyaXB0aW9uUGxhbnMsICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnRlZCBzdWJzY3JpcHRpb24gcGxhbiBpZHNcclxuXHRcdGN1c3RvbWVyQXZhdGFyOiAgICAgICAgICAgICBvcHRpb25zLmN1c3RvbWVyQXZhdGFyLCAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgY3VzdG9tZXIgYXZhdGFyIGZvciBgY3VzdG9tZXItdXBkYXRlYCwgYHByb2R1Y3QtcmV2aWV3c2A/XHJcblx0XHRjdXN0b21lckRhc2hib2FyZExvZ291dDogICAgb3B0aW9ucy5jdXN0b21lckRhc2hib2FyZExvZ291dCwgICAgICAgICAgICAgLy8gU2hvdyBMb2dvdXQgYnV0dG9uIGluIGBjdXN0b21lci1kYXNoYm9hcmRgP1xyXG5cdFx0Y3VzdG9tZXJJZGVudGl0eTogICAgICAgICAgIG9wdGlvbnMuY3VzdG9tZXJJZGVudGl0eSwgICAgICAgICAgICAgICAgICAgIC8vIEN1c3RvbWVyIGlkZW50aXR5IGZpZWxkc1xyXG5cdFx0Y3VzdG9tZXJSZWdpc3RyYXRpb25GaWVsZHM6IG9wdGlvbnMuY3VzdG9tZXJSZWdpc3RyYXRpb25GaWVsZHMsICAgICAgICAgIC8vIEN1c3RvbWVyIHJlZ2lzdHJhdGlvbiBmaWVsZHNcclxuXHRcdGN1c3RvbWVyVXBkYXRlRmllbGRzOiAgICAgICBvcHRpb25zLmN1c3RvbWVyVXBkYXRlRmllbGRzLCAgICAgICAgICAgICAgICAvLyBDdXN0b21lciB1cGRhdGUgZmllbGRzXHJcblx0XHRjdXN0b21lck9yZGVyRmllbGRzOiAgICAgICAgb3B0aW9ucy5jdXN0b21lck9yZGVyRmllbGRzLCAgICAgICAgICAgICAgICAgLy8gQ3VzdG9tZXIgZmllbGRzIGZvciBvcmRlcnMgYW5kIHN1YnNjcmlwdGlvbnNcclxuXHRcdHJlY2lwaWVudEZpZWxkczogICAgICAgICAgICBvcHRpb25zLnJlY2lwaWVudEZpZWxkcywgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvd2VkIHJlY2lwaWVudCBmaWVsZHMgZm9yIGFkZHJlc3Nlc1xyXG5cdFx0YWRkcmVzc0Rpc2FibGVkOiAgICAgICAgICAgIG9wdGlvbnMuYWRkcmVzc0Rpc2FibGVkLCAgICAgICAgICAgICAgICAgICAgIC8vIERpc2FibGVkIGFkZHJlc3MgZmllbGRzICh3aGVuIHNlYXJjaCBwbHVnaW4gZXhpc3RzKVxyXG5cdFx0b3JkZXJBdXRoRmllbGRzOiAgICAgICAgICAgIG9wdGlvbnMub3JkZXJBdXRoRmllbGRzLCAgICAgICAgICAgICAgICAgICAgIC8vIEZpZWxkcyB0byBhdXRoZW50aWNhdGUgZm9yIG9yZGVycyAmIHN1YnNjcmlwdGlvbnNcclxuXHRcdHNvY2lhbEFwcHM6ICAgICAgICAgICAgICAgICBvcHRpb25zLnNvY2lhbEFwcHMsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0ZWQgc29jaWFsIGFwcHMgZm9yIGN1c3RvbWVyIGFjY291bnRzXHJcblx0XHRoZWFkZXI6ICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVhZGVyIG5hdmlnYXRpb24gbWVudSBpdGVtc1xyXG5cdFx0cmVjYXB0Y2hhOiAgICAgICAgICAgICAgICAgIG9wdGlvbnMucmVjYXB0Y2hhLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSByZUNBUFRDSEEgb3B0aW9uc1xyXG5cdH07XHJcblxyXG5cdC8vIEV4cG9zZSBUaHVuZGVyLkNhcnQgYWZ0ZXIgY29uZmlndXJhdGlvbnNcclxuXHRUaHVuZGVyLkNhcnQgPSByZXF1aXJlKCcuL2xpYi9jYXJ0JykoVGh1bmRlcik7XHJcblxyXG5cdFRodW5kZXIuY3JlZGVudGlhbChvcHRpb25zLmNsaWVudCk7XHJcblx0VGh1bmRlci5wcmVmZXJlbmNlKG9wdGlvbnMpO1xyXG5cdFRodW5kZXIuaW5pdGlhbGl6ZSgpO1xyXG5cclxuXHRUaHVuZGVyLnRyaWdnZXIoJ2luaXQnKTtcclxuXHJcblx0cmV0dXJuIFRodW5kZXI7XHJcblxyXG59O1xyXG5cclxuLy8gVHJhbnNsYXRpb24gZGVwZW5kZW5jeVxyXG5UaHVuZGVyLnBvbHlnbG90ID0gbmV3IFBvbHlnbG90KCk7XHJcblxyXG4vLyBUT0RPOiBFdmVudCBsaXN0ZW5lcnNcclxuVGh1bmRlci5saXN0ZW5lcnMgPSB7XHJcblx0aW5pdDogICAgICAgICAgICBbXSxcclxuXHRjb21wb25lbnRSZW5kZXI6IFtdLFxyXG5cdGNvbXBvbmVudEluaXQ6ICAgW10sXHJcbn07XHJcblxyXG4vLyBDdXN0b20gbWV0aG9kc1xyXG5UaHVuZGVyLm1ldGhvZHMgPSB7fTtcclxuXHJcbi8vIFNwZWNzIGZvciBjb21wb25lbnRzXHJcblRodW5kZXIuY29tcG9uZW50cyA9IHtcclxuXHRjYXJ0OiAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQocmVxdWlyZSgnLi9tb2R1bGVzL2NhcnQnKShUaHVuZGVyKSksXHJcblx0J2NhdGFsb2ctc2xpZGVyJzogICAgICAgICAgICAgY29tcG9uZW50KHJlcXVpcmUoJy4vbW9kdWxlcy9jYXRhbG9nLXNsaWRlcicpKFRodW5kZXIpKSxcclxuXHRjaGVja291dDogICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQocmVxdWlyZSgnLi9tb2R1bGVzL2NoZWNrb3V0JykoVGh1bmRlcikpLFxyXG5cdCdjaGVja291dC1zdWNjZXNzJzogICAgICAgICAgIGNvbXBvbmVudChyZXF1aXJlKCcuL21vZHVsZXMvY2hlY2tvdXQtc3VjY2VzcycpKFRodW5kZXIpKSxcclxuXHQncHJvZHVjdC1saXN0JzogICAgICAgICAgICAgICBjb21wb25lbnQocmVxdWlyZSgnLi9tb2R1bGVzL3Byb2R1Y3QtbGlzdCcpKFRodW5kZXIpKSxcclxuXHQncHJvZHVjdC1kZXRhaWwnOiAgICAgICAgICAgICBjb21wb25lbnQocmVxdWlyZSgnLi9tb2R1bGVzL3Byb2R1Y3QtZGV0YWlsJykoVGh1bmRlcikpLFxyXG5cdCdwcm9kdWN0LXJldmlldyc6ICAgICAgICAgICAgIGNvbXBvbmVudChyZXF1aXJlKCcuL21vZHVsZXMvcHJvZHVjdC1yZXZpZXcnKShUaHVuZGVyKSksXHJcblx0J3Byb2R1Y3QtcmV2aWV3cyc6ICAgICAgICAgICAgY29tcG9uZW50KHJlcXVpcmUoJy4vbW9kdWxlcy9wcm9kdWN0LXJldmlld3MnKShUaHVuZGVyKSksXHJcblx0J3Byb2R1Y3QtcmV2aWV3LXdyaXRlcic6ICAgICAgY29tcG9uZW50KHJlcXVpcmUoJy4vbW9kdWxlcy9wcm9kdWN0LXJldmlldy13cml0ZXInKShUaHVuZGVyKSksXHJcblx0J3Byb2R1Y3QtcmV2aWV3LWNvbW1lbnRzJzogICAgY29tcG9uZW50KHJlcXVpcmUoJy4vbW9kdWxlcy9wcm9kdWN0LXJldmlldy1jb21tZW50cycpKFRodW5kZXIpKSxcclxuXHQnY3VzdG9tZXItcmVnaXN0ZXInOiAgICAgICAgICBjb21wb25lbnQocmVxdWlyZSgnLi9tb2R1bGVzL2N1c3RvbWVyLXJlZ2lzdGVyJykoVGh1bmRlcikpLFxyXG5cdCdjdXN0b21lci1sb2dpbic6ICAgICAgICAgICAgIGNvbXBvbmVudChyZXF1aXJlKCcuL21vZHVsZXMvY3VzdG9tZXItbG9naW4nKShUaHVuZGVyKSksXHJcblx0J2N1c3RvbWVyLXJlc2V0LXBhc3N3b3JkJzogICAgY29tcG9uZW50KHJlcXVpcmUoJy4vbW9kdWxlcy9jdXN0b21lci1yZXNldC1wYXNzd29yZCcpKFRodW5kZXIpKSxcclxuXHQnY3VzdG9tZXItdmVyaWZpY2F0aW9uJzogICAgICBjb21wb25lbnQocmVxdWlyZSgnLi9tb2R1bGVzL2N1c3RvbWVyLXZlcmlmaWNhdGlvbicpKFRodW5kZXIpKSxcclxuXHQnY3VzdG9tZXItZGFzaGJvYXJkJzogICAgICAgICBjb21wb25lbnQocmVxdWlyZSgnLi9tb2R1bGVzL2N1c3RvbWVyLWRhc2hib2FyZCcpKFRodW5kZXIpKSxcclxuXHQnY3VzdG9tZXItdXBkYXRlJzogICAgICAgICAgICBjb21wb25lbnQocmVxdWlyZSgnLi9tb2R1bGVzL2N1c3RvbWVyLXVwZGF0ZScpKFRodW5kZXIpKSxcclxuXHQnY3VzdG9tZXItdXBkYXRlLWNyZWRlbnRpYWwnOiBjb21wb25lbnQocmVxdWlyZSgnLi9tb2R1bGVzL2N1c3RvbWVyLXVwZGF0ZS1jcmVkZW50aWFsJykoVGh1bmRlcikpLFxyXG5cdCdjdXN0b21lci11cGRhdGUtYWRkcmVzcyc6ICAgIGNvbXBvbmVudChyZXF1aXJlKCcuL21vZHVsZXMvY3VzdG9tZXItdXBkYXRlLWFkZHJlc3MnKShUaHVuZGVyKSksXHJcblx0J2N1c3RvbWVyLXJldmlld3MnOiAgICAgICAgICAgY29tcG9uZW50KHJlcXVpcmUoJy4vbW9kdWxlcy9jdXN0b21lci1yZXZpZXdzJykoVGh1bmRlcikpLFxyXG5cdCdjdXN0b21lci1yZXZpZXcnOiAgICAgICAgICAgIGNvbXBvbmVudChyZXF1aXJlKCcuL21vZHVsZXMvY3VzdG9tZXItcmV2aWV3JykoVGh1bmRlcikpLFxyXG5cdCdjdXN0b21lci1yZXZpZXctY29tbWVudHMnOiAgIGNvbXBvbmVudChyZXF1aXJlKCcuL21vZHVsZXMvY3VzdG9tZXItcmV2aWV3LWNvbW1lbnRzJykoVGh1bmRlcikpLFxyXG5cdCdjdXN0b21lci1yZXZpZXctY29tbWVudCc6ICAgIGNvbXBvbmVudChyZXF1aXJlKCcuL21vZHVsZXMvY3VzdG9tZXItcmV2aWV3LWNvbW1lbnQnKShUaHVuZGVyKSksXHJcblx0J2N1c3RvbWVyLWRlbGV0ZS1hY2NvdW50JzogICAgY29tcG9uZW50KHJlcXVpcmUoJy4vbW9kdWxlcy9jdXN0b21lci1kZWxldGUtYWNjb3VudCcpKFRodW5kZXIpKSxcclxuXHQnY3VzdG9tZXItY291cG9ucyc6ICAgICAgICAgICBjb21wb25lbnQocmVxdWlyZSgnLi9tb2R1bGVzL2N1c3RvbWVyLWNvdXBvbnMnKShUaHVuZGVyKSksXHJcblx0J3NlYXJjaC1wdXJjaGFzZSc6ICAgICAgICAgICAgY29tcG9uZW50KHJlcXVpcmUoJy4vbW9kdWxlcy9zZWFyY2gtcHVyY2hhc2UnKShUaHVuZGVyKSksXHJcblx0J29yZGVyLWxpc3QnOiAgICAgICAgICAgICAgICAgY29tcG9uZW50KHJlcXVpcmUoJy4vbW9kdWxlcy9vcmRlci1saXN0JykoVGh1bmRlcikpLFxyXG5cdCdvcmRlci1kZXRhaWwnOiAgICAgICAgICAgICAgIGNvbXBvbmVudChyZXF1aXJlKCcuL21vZHVsZXMvb3JkZXItZGV0YWlsJykoVGh1bmRlcikpLFxyXG5cdCdvcmRlci1yZXF1ZXN0LXJlZnVuZCc6ICAgICAgIGNvbXBvbmVudChyZXF1aXJlKCcuL21vZHVsZXMvb3JkZXItcmVxdWVzdC1yZWZ1bmQnKShUaHVuZGVyKSksXHJcblx0J3N1YnNjcmlwdGlvbi1saXN0JzogICAgICAgICAgY29tcG9uZW50KHJlcXVpcmUoJy4vbW9kdWxlcy9zdWJzY3JpcHRpb24tbGlzdCcpKFRodW5kZXIpKSxcclxuXHQnc3Vic2NyaXB0aW9uLWRldGFpbCc6ICAgICAgICBjb21wb25lbnQocmVxdWlyZSgnLi9tb2R1bGVzL3N1YnNjcmlwdGlvbi1kZXRhaWwnKShUaHVuZGVyKSksXHJcblx0J3BheW1lbnQtZm9ybSc6ICAgICAgICAgICAgICAgY29tcG9uZW50KHJlcXVpcmUoJy4vbW9kdWxlcy9wYXltZW50LWZvcm0nKShUaHVuZGVyKSksXHJcbn07XHJcblxyXG5UaHVuZGVyLnVpcyA9IHtcclxuXHQnY29tcG9uZW50LXNwaW5uZXInOiAgcmVxdWlyZSgnLi91aS9jb21wb25lbnQtc3Bpbm5lcicpLmJpbmQoVGh1bmRlciksXHJcblx0J3NlY3Rpb24tc3Bpbm5lcic6ICAgIHJlcXVpcmUoJy4vdWkvc2VjdGlvbi1zcGlubmVyJykuYmluZChUaHVuZGVyKSxcclxuXHQnYnV0dG9uLXNwaW5uZXInOiAgICAgcmVxdWlyZSgnLi91aS9idXR0b24tc3Bpbm5lcicpLmJpbmQoVGh1bmRlciksXHJcblx0J292ZXJsYXktbmF2aWdhdGlvbic6IHJlcXVpcmUoJy4vdWkvb3ZlcmxheS1uYXZpZ2F0aW9uJykuYmluZChUaHVuZGVyKSxcclxuXHQnaGVhZGVyLW5hdmlnYXRpb24nOiAgcmVxdWlyZSgnLi91aS9oZWFkZXItbmF2aWdhdGlvbicpLmJpbmQoVGh1bmRlciksXHJcblx0J3NvY2lhbC1sb2dpbic6ICAgICAgIHJlcXVpcmUoJy4vdWkvc29jaWFsLWxvZ2luJykuYmluZChUaHVuZGVyKSxcclxuXHQnYXZhdGFyLXBsYWNlaG9sZGVyJzogcmVxdWlyZSgnLi91aS9hdmF0YXItcGxhY2Vob2xkZXInKS5iaW5kKFRodW5kZXIpLFxyXG5cdCdmaWxsZWQtc3Rhcic6ICAgICAgICByZXF1aXJlKCcuL3VpL2ZpbGxlZC1zdGFyJykuYmluZChUaHVuZGVyKSxcclxuXHQnaGFsZi1maWxsZWQtc3Rhcic6ICAgcmVxdWlyZSgnLi91aS9oYWxmLWZpbGxlZC1zdGFyJykuYmluZChUaHVuZGVyKSxcclxuXHQnZW1wdHktc3Rhcic6ICAgICAgICAgcmVxdWlyZSgnLi91aS9lbXB0eS1zdGFyJykuYmluZChUaHVuZGVyKSxcclxuXHQnaGFsbG93LXN0YXInOiAgICAgICAgcmVxdWlyZSgnLi91aS9oYWxsb3ctc3RhcicpLmJpbmQoVGh1bmRlciksXHJcblx0J3Jldmlldy1zdGFycyc6ICAgICAgIHJlcXVpcmUoJy4vdWkvcmV2aWV3LXN0YXJzJykuYmluZChUaHVuZGVyKSxcclxuXHQncmV2aWV3LXN0YXItcmF0aW5nJzogcmVxdWlyZSgnLi91aS9yZXZpZXctc3Rhci1yYXRpbmcnKS5iaW5kKFRodW5kZXIpLFxyXG5cdCd0ZXh0LWJveC1vdmVybGF5JzogICByZXF1aXJlKCcuL3VpL3RleHQtYm94LW92ZXJsYXknKS5iaW5kKFRodW5kZXIpLFxyXG5cdCdsZWZ0LWFycm93JzogICAgICAgICByZXF1aXJlKCcuL3VpL2xlZnQtYXJyb3cnKS5iaW5kKFRodW5kZXIpLFxyXG5cdCdyaWdodC1hcnJvdyc6ICAgICAgICByZXF1aXJlKCcuL3VpL3JpZ2h0LWFycm93JykuYmluZChUaHVuZGVyKVxyXG59O1xyXG5cclxuLy8gUGx1Z2lucyAoYWRkcmVzcyBzZWFyY2gsIHBheW1lbnQsIC4uLilcclxuVGh1bmRlci5wbHVnaW5zID0ge1xyXG5cdHNlYXJjaEFkZHJlc3M6ICAgICBudWxsLFxyXG5cdG1ha2VQYXltZW50OiAgICAgICBudWxsLFxyXG5cdHJlZGlyZWN0OiAgICAgICAgICByZXF1aXJlKCcuL3BsdWdpbnMvcmVkaXJlY3QnKSxcclxuXHRub3RpZmljYXRpb246ICAgICAgcmVxdWlyZSgnLi9wbHVnaW5zL25vdGlmaWNhdGlvbicpLFxyXG5cdGNvbmZpcm1hdGlvbjogICAgICByZXF1aXJlKCcuL3BsdWdpbnMvY29uZmlybWF0aW9uJyksXHJcblx0cGFnaW5hdGlvbjogICAgICAgIHJlcXVpcmUoJy4vcGx1Z2lucy9wYWdpbmF0aW9uJyksXHJcblx0Y2FydFN0b3JhZ2U6ICAgICAgIHJlcXVpcmUoJy4vcGx1Z2lucy9jYXJ0U3RvcmFnZScpLFxyXG5cdGNyZWRlbnRpYWxTdG9yYWdlOiByZXF1aXJlKCcuL3BsdWdpbnMvY3JlZGVudGlhbFN0b3JhZ2UnKSxcclxufTtcclxuXHJcbi8vIFV0aWxpdHkgbWV0aG9kc1xyXG5UaHVuZGVyLnV0aWwgPSB7XHJcblx0bG9nOiAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi91dGlsL2xvZycpLmJpbmQoVGh1bmRlciksXHJcblx0ZGVib3VuY2U6ICAgICAgICAgICAgcmVxdWlyZSgnLi91dGlsL2RlYm91bmNlJykuYmluZChUaHVuZGVyKSxcclxuXHR1aTogICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3V0aWwvdWknKS5iaW5kKFRodW5kZXIpLFxyXG5cdHN0cmlwSFRNTDogICAgICAgICAgIHJlcXVpcmUoJy4vdXRpbC9zdHJpcEhUTUwnKS5iaW5kKFRodW5kZXIpLFxyXG5cdGV4Y2VycHQ6ICAgICAgICAgICAgIHJlcXVpcmUoJy4vdXRpbC9leGNlcnB0JykuYmluZChUaHVuZGVyKSxcclxuXHRpbWFnZVVSTDogICAgICAgICAgICByZXF1aXJlKCcuL3V0aWwvaW1hZ2VVUkwnKS5iaW5kKFRodW5kZXIpLFxyXG5cdHRvUHJlY2lzaW9uOiAgICAgICAgIHJlcXVpcmUoJy4vdXRpbC90b1ByZWNpc2lvbicpLmJpbmQoVGh1bmRlciksXHJcblx0Zm9ybWF0TnVtYmVyOiAgICAgICAgcmVxdWlyZSgnLi91dGlsL2Zvcm1hdE51bWJlcicpLmJpbmQoVGh1bmRlciksXHJcblx0Zm9ybWF0UHJpY2U6ICAgICAgICAgcmVxdWlyZSgnLi91dGlsL2Zvcm1hdFByaWNlJykuYmluZChUaHVuZGVyKSxcclxuXHRnZXRDdXJyZW5jeTogICAgICAgICByZXF1aXJlKCcuL3V0aWwvZ2V0Q3VycmVuY3knKS5iaW5kKFRodW5kZXIpLFxyXG5cdGlzRXhwaXJlZDogICAgICAgICAgIHJlcXVpcmUoJy4vdXRpbC9pc0V4cGlyZWQnKS5iaW5kKFRodW5kZXIpLFxyXG5cdGFkZFRpbWU6ICAgICAgICAgICAgIHJlcXVpcmUoJy4vdXRpbC9hZGRUaW1lJykuYmluZChUaHVuZGVyKSxcclxuXHRjb3VudHJ5TmFtZTogICAgICAgICByZXF1aXJlKCcuL3V0aWwvY291bnRyeU5hbWUnKS5iaW5kKFRodW5kZXIpLFxyXG5cdGN1c3RvbWVySWRlbnRpdHk6ICAgIHJlcXVpcmUoJy4vdXRpbC9jdXN0b21lcklkZW50aXR5JykuYmluZChUaHVuZGVyKSxcclxuXHRwcm9kdWN0TmFtZTogICAgICAgICByZXF1aXJlKCcuL3V0aWwvcHJvZHVjdE5hbWUnKS5iaW5kKFRodW5kZXIpLFxyXG5cdHZhcmlhbnROYW1lOiAgICAgICAgIHJlcXVpcmUoJy4vdXRpbC92YXJpYW50TmFtZScpLmJpbmQoVGh1bmRlciksXHJcblx0b3JkZXJTaGlwcGluZ1N0YXR1czogcmVxdWlyZSgnLi91dGlsL29yZGVyU2hpcHBpbmdTdGF0dXMnKS5iaW5kKFRodW5kZXIpLFxyXG5cdGZvcm1Ub0pTT046ICAgICAgICAgIHJlcXVpcmUoJy4vdXRpbC9mb3JtVG9KU09OJykuYmluZChUaHVuZGVyKSxcclxuXHRwYXJzZVF1ZXJ5U3RyaW5nOiAgICByZXF1aXJlKCcuL3V0aWwvcGFyc2VRdWVyeVN0cmluZycpLmJpbmQoVGh1bmRlciksXHJcblx0cGFyc2VBcnJheVN0cmluZzogICAgcmVxdWlyZSgnLi91dGlsL3BhcnNlQXJyYXlTdHJpbmcnKS5iaW5kKFRodW5kZXIpLFxyXG5cdHVybFF1ZXJ5OiAgICAgICAgICAgIHJlcXVpcmUoJy4vdXRpbC91cmxRdWVyeScpLmJpbmQoVGh1bmRlciksXHJcblx0cmVxdWVzdEVycm9ySGFuZGxlcjogcmVxdWlyZSgnLi91dGlsL3JlcXVlc3RFcnJvckhhbmRsZXInKS5iaW5kKFRodW5kZXIpLFxyXG5cdHVzZXJJZE9yRW1haWw6ICAgICAgIHJlcXVpcmUoJy4vdXRpbC91c2VySWRPckVtYWlsJykuYmluZChUaHVuZGVyKSxcclxuXHRtYWtlQXN5bmNCdXR0b246ICAgICByZXF1aXJlKCcuL3V0aWwvbWFrZUFzeW5jQnV0dG9uJykuYmluZChUaHVuZGVyKSxcclxuXHRiaW5kQWdyZWVtZW50czogICAgICByZXF1aXJlKCcuL3V0aWwvYmluZEFncmVlbWVudHMnKS5iaW5kKFRodW5kZXIpLFxyXG5cdG1ha2VSZWNhcHRjaGE6ICAgICAgIHJlcXVpcmUoJy4vdXRpbC9tYWtlUmVjYXB0Y2hhJykuYmluZChUaHVuZGVyKSxcclxuXHR1bnNldFJlY2FwdGNoYTogICAgICByZXF1aXJlKCcuL3V0aWwvdW5zZXRSZWNhcHRjaGEnKS5iaW5kKFRodW5kZXIpLFxyXG5cdGJpbmRTb2NpYWxBcHBzOiAgICAgIHJlcXVpcmUoJy4vdXRpbC9iaW5kU29jaWFsQXBwcycpLmJpbmQoVGh1bmRlciksXHJcblx0aGFuZGxlU29jaWFsTG9naW46ICAgcmVxdWlyZSgnLi91dGlsL2hhbmRsZVNvY2lhbExvZ2luJykuYmluZChUaHVuZGVyKSxcclxuXHRiaW5kUmVjYXB0Y2hhOiAgICAgICByZXF1aXJlKCcuL3V0aWwvYmluZFJlY2FwdGNoYScpLmJpbmQoVGh1bmRlciksXHJcblx0dXNlUmVjYXB0Y2hhOiAgICAgICAgcmVxdWlyZSgnLi91dGlsL3VzZVJlY2FwdGNoYScpLmJpbmQoVGh1bmRlciksXHJcblx0aW1hZ2VVcGxvYWRlcjogICAgICAgcmVxdWlyZSgnLi91dGlsL2ltYWdlVXBsb2FkZXInKS5iaW5kKFRodW5kZXIpLFxyXG5cdGNvcHlUb0NsaXBib2FyZDogICAgIHJlcXVpcmUoJy4vdXRpbC9jb3B5VG9DbGlwYm9hcmQnKS5iaW5kKFRodW5kZXIpLFxyXG5cdGJpbmRCYWNrQnV0dG9uOiAgICAgIHJlcXVpcmUoJy4vdXRpbC9iaW5kQmFja0J1dHRvbicpLmJpbmQoVGh1bmRlciksXHJcblx0Zm9sbG93aW5nTmF2aWdhdGlvbjogcmVxdWlyZSgnLi91dGlsL2ZvbGxvd2luZ05hdmlnYXRpb24nKS5iaW5kKFRodW5kZXIpLFxyXG5cdHF1YW50aXR5SW5wdXQ6ICAgICAgIHJlcXVpcmUoJy4vdXRpbC9xdWFudGl0eUlucHV0JykuYmluZChUaHVuZGVyKSxcclxuXHRjaGVja0l0ZW1SZWZ1bmRlZDogICByZXF1aXJlKCcuL3V0aWwvY2hlY2tJdGVtUmVmdW5kZWQnKS5iaW5kKFRodW5kZXIpLFxyXG59O1xyXG5cclxuLy8gR2xvYmFsIHRlbXBsYXRlIG1ldGhvZHNcclxuVGh1bmRlci50ZW1wbGF0ZU1ldGhvZHMgPSB7XHJcblx0Z2V0OiAgICAgICAgICAgICAgcmVxdWlyZSgnbG9kYXNoLmdldCcpLFxyXG5cdGtlYmFiQ2FzZTogICAgICAgIHJlcXVpcmUoJ2xvZGFzaC5rZWJhYmNhc2UnKSxcclxuXHRjYW1lbENhc2U6ICAgICAgICByZXF1aXJlKCdsb2Rhc2guY2FtZWxjYXNlJyksXHJcblx0c3RyaXBIVE1MOiAgICAgICAgVGh1bmRlci51dGlsLnN0cmlwSFRNTCxcclxuXHRleGNlcnB0OiAgICAgICAgICBUaHVuZGVyLnV0aWwuZXhjZXJwdCxcclxuXHRpbWFnZVVSTDogICAgICAgICBUaHVuZGVyLnV0aWwuaW1hZ2VVUkwsXHJcblx0aXNFeHBpcmVkOiAgICAgICAgVGh1bmRlci51dGlsLmlzRXhwaXJlZCxcclxuXHRjb3VudHJ5TmFtZTogICAgICBUaHVuZGVyLnV0aWwuY291bnRyeU5hbWUsXHJcblx0Y3VzdG9tZXJJZGVudGl0eTogVGh1bmRlci51dGlsLmN1c3RvbWVySWRlbnRpdHksXHJcblx0cHJvZHVjdE5hbWU6ICAgICAgVGh1bmRlci51dGlsLnByb2R1Y3ROYW1lLFxyXG5cdHZhcmlhbnROYW1lOiAgICAgIFRodW5kZXIudXRpbC52YXJpYW50TmFtZSxcclxufTtcclxuXHJcblRodW5kZXIub3ZlcmxheSA9IHtcclxuXHRiYWNrZ3JvdW5kOiAnPGRpdiBpZD1cInRodW5kZXItLW92ZXJsYXktYmFja2dyb3VuZFwiIGRhdGEtdGh1bmRlci1jbG9zZT48L2Rpdj4nLFxyXG5cdGNvbnRhaW5lcjogICc8ZGl2IGlkPVwidGh1bmRlci0tb3ZlcmxheVwiPjxkaXYgaWQ9XCJ0aHVuZGVyLS1vdmVybGF5LWhlYWRlclwiPjwvZGl2PjxkaXYgaWQ9XCJ0aHVuZGVyLS1vdmVybGF5LWJvZHlcIj48L2Rpdj48L2Rpdj4nLFxyXG5cdGJvZHk6ICAgICAgIG51bGwsXHJcbn07XHJcblxyXG4kLmV4dGVuZChUaHVuZGVyLCB7XHJcblx0aW5pdGlhbGl6ZTogICAgcmVxdWlyZSgnLi9saWIvaW5pdGlhbGl6ZScpLmJpbmQoVGh1bmRlciksIC8vIEluaXRpYWxpemUgYW4gYXBwXHJcblx0Y3JlZGVudGlhbDogICAgcmVxdWlyZSgnLi9saWIvY3JlZGVudGlhbCcpLmJpbmQoVGh1bmRlciksIC8vIENsaWVudCBzZXR0ZXJcclxuXHRwcmVmZXJlbmNlOiAgICByZXF1aXJlKCcuL2xpYi9wcmVmZXJlbmNlJykuYmluZChUaHVuZGVyKSwgLy8gUHJlZmVyZW5jZSBzZXR0ZXJcclxuXHRzZXRNZXNzYWdlczogICByZXF1aXJlKCcuL2xpYi9zZXRNZXNzYWdlcycpLmJpbmQoVGh1bmRlciksIC8vIFNldHMgdHJhbnNsYXRpb24gbWVzc2FnZXNcclxuXHRvbjogICAgICAgICAgICByZXF1aXJlKCcuL2xpYi9vbicpLmJpbmQoVGh1bmRlciksICAgICAgICAgLy8gUmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVyc1xyXG5cdG9mZjogICAgICAgICAgIHJlcXVpcmUoJy4vbGliL29mZicpLmJpbmQoVGh1bmRlciksICAgICAgICAvLyBVbnJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnNcclxuXHR0cmlnZ2VyOiAgICAgICByZXF1aXJlKCcuL2xpYi90cmlnZ2VyJykuYmluZChUaHVuZGVyKSwgICAgLy8gVHJpZ2dlciByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVyc1xyXG5cdG1ldGhvZDogICAgICAgIGdldHRlclNldHRlcignbWV0aG9kcycpLCAgICAgICAgICAgICAgICAgICAvLyBNZXRob2QgZ2V0dGVyL3NldHRlclxyXG5cdGNvbXBvbmVudDogICAgIGdldHRlclNldHRlcignY29tcG9uZW50cycpLCAgICAgICAgICAgICAgICAvLyBDb21wb25lbnQgZ2V0dGVyL3NldHRlclxyXG5cdHRlbXBsYXRlOiAgICAgIGdldHRlclNldHRlcignY29tcG9uZW50cycsICd0ZW1wbGF0ZScpLCAgICAvLyBDdXN0b20gdGVtcGxhdGUgZ2V0dGVyL3NldHRlclxyXG5cdHBsdWdpbjogICAgICAgIGdldHRlclNldHRlcigncGx1Z2lucycpLCAgICAgICAgICAgICAgICAgICAvLyBQbHVnaW4gZ2V0dGVyL3NldHRlclxyXG5cdHVpOiAgICAgICAgICAgIGdldHRlclNldHRlcigndWlzJyksICAgICAgICAgICAgICAgICAgICAgICAvLyBDdXN0b20gVUkgZ2V0dGVyL3NldHRlclxyXG5cdHJlbmRlcjogICAgICAgIHJlcXVpcmUoJy4vbGliL3JlbmRlcicpLmJpbmQoVGh1bmRlciksICAgICAvLyBSZW5kZXJzIGEgY29tcG9uZW50XHJcblx0b3BlbjogICAgICAgICAgcmVxdWlyZSgnLi9saWIvb3BlbicpLmJpbmQoVGh1bmRlciksICAgICAgIC8vIE9wZW5zIGFuIG92ZXJsYXkgYW5kIHJlbmRlcnMgYSBjb21wb25lbnRcclxuXHRjbG9zZTogICAgICAgICByZXF1aXJlKCcuL2xpYi9jbG9zZScpLmJpbmQoVGh1bmRlciksICAgICAgLy8gQ2xvc2VzIGFuIG92ZXJsYXlcclxuXHRyZXF1ZXN0OiAgICAgICByZXF1aXJlKCcuL2xpYi9yZXF1ZXN0JykoVGh1bmRlciksICAgICAgICAgLy8gTWFrZSBhbiBBUEkgcmVxdWVzdFxyXG5cdGV4ZWN1dGU6ICAgICAgIHJlcXVpcmUoJy4vbGliL2V4ZWN1dGUnKS5iaW5kKFRodW5kZXIpLCAgICAvLyBFeGVjdXRlIGEgY3VzdG9tIG1ldGhvZFxyXG5cdG5vdGlmeTogICAgICAgIHJlcXVpcmUoJy4vbGliL25vdGlmeScpLmJpbmQoVGh1bmRlciksICAgICAvLyBTaG9ydGN1dCBmb3IgVGh1bmRlci5wbHVnaW5zLm5vdGlmaWNhdGlvblxyXG5cdGxvZ291dDogICAgICAgIHJlcXVpcmUoJy4vbGliL2xvZ291dCcpLmJpbmQoVGh1bmRlciksXHJcblx0aGVhZGVyOiAgICAgICAgcmVxdWlyZSgnLi9saWIvaGVhZGVyJykuYmluZChUaHVuZGVyKSxcclxuXHRhdXRoZW50aWNhdGVkOiByZXF1aXJlKCcuL2xpYi9hdXRoZW50aWNhdGVkJykuYmluZChUaHVuZGVyKSxcclxufSk7XHJcblxyXG5mdW5jdGlvbiBjb21wb25lbnQoZGVmaW5pdGlvbikge1xyXG5cclxuXHRyZXR1cm4gJC5leHRlbmQoe1xyXG5cdFx0b3B0aW9uczogIGZ1bmN0aW9uKCkgeyByZXR1cm4ge30gfSxcclxuXHRcdGRlZmF1bHQ6ICB7fSxcclxuXHRcdHByZTogICAgICBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaykgeyByZXR1cm4gY2FsbGJhY2sobnVsbCwgY29udGV4dCkgfSxcclxuXHRcdGluaXQ6ICAgICBmdW5jdGlvbigpIHt9LFxyXG5cdFx0dGVtcGxhdGU6IGZ1bmN0aW9uKGNvbnRleHQpIHsgcmV0dXJuICcnIH1cclxuXHR9LCBkZWZpbml0aW9uKTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldHRlclNldHRlcihmaWVsZCwgY2hpbGQpIHtcclxuXHJcblx0cmV0dXJuIGNoaWxkID9cclxuXHRcdGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcblxyXG5cdFx0XHRpZiAoIXZhbHVlKSByZXR1cm4gVGh1bmRlcltmaWVsZF1bbmFtZV1bY2hpbGRdO1xyXG5cclxuXHRcdFx0VGh1bmRlcltmaWVsZF1bbmFtZV1bY2hpbGRdID0gdmFsdWU7XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlcjtcclxuXHJcblx0XHR9IDpcclxuXHRcdGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcblxyXG5cdFx0XHRpZiAoIXZhbHVlKSByZXR1cm4gVGh1bmRlcltmaWVsZF1bbmFtZV07XHJcblxyXG5cdFx0XHRUaHVuZGVyW2ZpZWxkXVtuYW1lXSA9IHZhbHVlO1xyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXI7XHJcblxyXG5cdFx0fTtcclxuXHJcbn1cclxuXHJcblRodW5kZXIudmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbi5qc29uJyk7XHJcblxyXG53aW5kb3cuVGh1bmRlciA9IFRodW5kZXI7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzY29wZSA9ICdjdXN0b21lcicpIHtcclxuXHJcblx0Y29uc3Qgc3RvcmFnZSA9IHRoaXMucGx1Z2lucy5jcmVkZW50aWFsU3RvcmFnZTtcclxuXHJcblx0Ly8gQ3VzdG9tZXIgY2FzZVxyXG5cdGlmIChzY29wZSA9PT0gJ2N1c3RvbWVyJykge1xyXG5cclxuXHRcdGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLm9wdGlvbnMuYXV0aFN0b3JhZ2UuY3VzdG9tZXI7XHJcblx0XHRjb25zdCB0b2tlbiA9IHN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KTtcclxuXHJcblx0XHRpZiAoIXRva2VuKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNUb2tlbkV4cGlyZWQodG9rZW4pKSB7XHJcblx0XHRcdC8vIElmIHRoZSB0b2tlbiBleHBpcmVkLCBsb2cgb3V0IHRoZSBjdXN0b21lci5cclxuXHRcdFx0dGhpcy5sb2dvdXQoKTtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYXJzZVRva2VuKHRva2VuKTtcclxuXHR9XHJcblxyXG5cdC8vIE9yZGVyIG9yIFN1YnNjcmlwdGlvbiBjYXNlXHJcblx0aWYgKHNjb3BlID09PSAnb3JkZXInKSB7XHJcblxyXG5cdFx0Y29uc3Qgc3RvcmFnZUtleSA9IHRoaXMub3B0aW9ucy5hdXRoU3RvcmFnZS5vcmRlcjtcclxuXHRcdGNvbnN0IHRva2VuID0gc3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpO1xyXG5cclxuXHRcdGlmICghdG9rZW4pIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpc1Rva2VuRXhwaXJlZCh0b2tlbikpIHtcclxuXHRcdFx0Ly8gSWYgdGhlIHRva2VuIGV4cGlyZWQsIHVuc2V0IHRoZSB0b2tlbiBmcm9tIHRoZSBzdG9yYWdlLlxyXG5cdFx0XHRzdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5vcHRpb25zLmF1dGhTdG9yYWdlLm9yZGVyKTtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYXJzZVRva2VuKHRva2VuKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbmZ1bmN0aW9uIHBhcnNlVG9rZW4odG9rZW4pIHtcclxuXHJcblx0Y29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdCgnLicpO1xyXG5cdGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGF0b2IocGFydHNbMV0pKTtcclxuXHJcblx0cmV0dXJuIGRhdGE7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBpc1Rva2VuRXhwaXJlZCh0b2tlbikge1xyXG5cclxuXHRjb25zdCBleHBpcmVzQXQgPSBwYXJzZVRva2VuKHRva2VuKS5leHAgKiAxMDAwO1xyXG5cclxuXHRyZXR1cm4gZXhwaXJlc0F0IC0gRGF0ZS5ub3coKSA8PSAwO1xyXG5cclxufSIsIm1vZHVsZS5leHBvcnRzID0gVGh1bmRlciA9PiB7XHJcblxyXG5cdGNvbnN0IENhcnQgPSB7XHJcblx0XHRzdG9yYWdlOiAnX19pdGVtc19fJyxcclxuXHRcdGl0ZW1zOiAgIFtdXHJcblx0fTtcclxuXHJcblx0Q2FydC5sb2FkID0gKCkgPT4ge1xyXG5cclxuXHRcdGNvbnN0IHN0b3JhZ2UgPSBUaHVuZGVyLnBsdWdpbnMuY2FydFN0b3JhZ2U7XHJcblxyXG5cdFx0Q2FydC5pdGVtcyA9IEpTT04ucGFyc2Uoc3RvcmFnZS5nZXRJdGVtKENhcnQuc3RvcmFnZSkgfHwgJ1tdJyk7XHJcblx0fTtcclxuXHJcblx0Q2FydC5wZXJzaXN0ID0gKCkgPT4ge1xyXG5cclxuXHRcdGNvbnN0IHN0b3JhZ2UgPSBUaHVuZGVyLnBsdWdpbnMuY2FydFN0b3JhZ2U7XHJcblxyXG5cdFx0c3RvcmFnZS5zZXRJdGVtKENhcnQuc3RvcmFnZSwgSlNPTi5zdHJpbmdpZnkoQ2FydC5pdGVtcykpO1xyXG5cdH07XHJcblxyXG5cdENhcnQudG90YWxJdGVtcyA9IGl0ZW1zID0+IHtcclxuXHJcblx0XHRyZXR1cm4gKENhcnQuaXRlbXMgfHwgaXRlbXMpLnJlZHVjZSgoc3VtLCBpdGVtKSA9PiB7XHJcblx0XHRcdHJldHVybiBzdW0gKyAxICsgKGl0ZW0uYnVuZGxlSXRlbXMgPyBpdGVtLmJ1bmRsZUl0ZW1zLmxlbmd0aCA6IDApO1xyXG5cdFx0fSwgMCk7XHJcblxyXG5cdH07XHJcblxyXG5cdENhcnQuYWRkSXRlbSA9IChpdGVtLCBjYWxsYmFjaykgPT4ge1xyXG5cclxuXHRcdGNvbnN0IGl0ZW1zID0gJC5leHRlbmQodHJ1ZSwgW10sIENhcnQuaXRlbXMpO1xyXG5cclxuXHRcdGl0ZW0uX2lkID0gKE1hdGgucmFuZG9tKCkgKyAnJykuc2xpY2UoMiwgMTcpO1xyXG5cclxuXHRcdGlmIChpdGVtLmJ1bmRsZUl0ZW1zKSB7XHJcblx0XHRcdGl0ZW0uYnVuZGxlSXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuXHRcdFx0XHRpdGVtLl9pZCA9IChNYXRoLnJhbmRvbSgpICsgJycpLnNsaWNlKDIsIDE3KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aXRlbXMucHVzaChpdGVtKTtcclxuXHJcblx0XHRpZiAoQ2FydC50b3RhbEl0ZW1zKGl0ZW1zKSA+PSA1MCkge1xyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2soQ2FydEVycm9yKCdpdGVtcy1leGNlZWRlZCcpKTtcclxuXHRcdH1cclxuXHJcblx0XHRDYXJ0Lml0ZW1zID0gaXRlbXM7XHJcblxyXG5cdFx0Q2FydC5wZXJzaXN0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xyXG5cclxuXHR9O1xyXG5cclxuXHRDYXJ0LnVwZGF0ZUl0ZW0gPSAoaXRlbUlkLCB1cGRhdGUsIGNhbGxiYWNrKSA9PiB7XHJcblxyXG5cdFx0aXRlbUlkID0gaXRlbUlkICsgJyc7XHJcblxyXG5cdFx0Y29uc3QgaXRlbXMgPSAkLmV4dGVuZCh0cnVlLCBbXSwgQ2FydC5pdGVtcyk7XHJcblx0XHRjb25zdCBmb3VuZCA9IGl0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLl9pZCA9PT0gaXRlbUlkKTtcclxuXHJcblx0XHRpZiAoIWZvdW5kKSB7XHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhDYXJ0RXJyb3IoJ25vLWl0ZW0nKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgYnVuZGxlSXRlbXMgPSB1cGRhdGUuYnVuZGxlSXRlbXM7XHJcblxyXG5cdFx0ZGVsZXRlIHVwZGF0ZS5idW5kbGVJdGVtcztcclxuXHJcblx0XHQkLmV4dGVuZChmb3VuZCwgdXBkYXRlKTtcclxuXHJcblx0XHRpZiAoYnVuZGxlSXRlbXMpIHtcclxuXHJcblx0XHRcdGZvdW5kLmJ1bmRsZUl0ZW1zID0gZm91bmQuYnVuZGxlSXRlbXMgfHwgW107XHJcblxyXG5cdFx0XHRmb3IgKGNvbnN0IGJ1bmRsZUlkIGluIGJ1bmRsZUl0ZW1zKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGl0ZW0gPSBmb3VuZC5idW5kbGVJdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5faWQgPT09IGJ1bmRsZUlkKTtcclxuXHRcdFx0XHRjb25zdCB1cGRhdGUgPSBidW5kbGVJdGVtc1tidW5kbGVJZF07XHJcblxyXG5cdFx0XHRcdGlmICghaXRlbSAmJiB1cGRhdGUpIHtcclxuXHRcdFx0XHRcdGZvdW5kLmJ1bmRsZUl0ZW1zLnB1c2godXBkYXRlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICh1cGRhdGUpIHtcclxuXHRcdFx0XHRcdCQuZXh0ZW5kKGl0ZW0sIHVwZGF0ZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAodXBkYXRlID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IGZvdW5kLmJ1bmRsZUl0ZW1zLmluZGV4T2YoaXRlbSk7XHJcblxyXG5cdFx0XHRcdFx0Zm91bmQuYnVuZGxlSXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChDYXJ0LnRvdGFsSXRlbXMoaXRlbXMpID49IDUwKSB7XHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhDYXJ0RXJyb3IoJ2l0ZW1zLWV4Y2VlZGVkJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdENhcnQuaXRlbXMgPSBpdGVtcztcclxuXHJcblx0XHRDYXJ0LnBlcnNpc3QoKTtcclxuXHJcblx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgZm91bmQpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRDYXJ0LmRlbGV0ZUl0ZW0gPSAoaXRlbUlkLCBjYWxsYmFjaykgPT4ge1xyXG5cclxuXHRcdGl0ZW1JZCA9IGl0ZW1JZCArICcnO1xyXG5cclxuXHRcdGNvbnN0IGl0ZW1zID0gJC5leHRlbmQodHJ1ZSwgW10sIENhcnQuaXRlbXMpO1xyXG5cdFx0bGV0IGluZGV4ID0gbnVsbDtcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcblxyXG5cdFx0XHRjb25zdCBpdGVtID0gaXRlbXNbaV07XHJcblxyXG5cdFx0XHRpZiAoaXRlbS5faWQgPT09IGl0ZW1JZCkge1xyXG5cdFx0XHRcdGluZGV4ID0gaTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaW5kZXggPT09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKENhcnRFcnJvcignbm8taXRlbScpKTtcclxuXHRcdH1cclxuXHJcblx0XHRpdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuXHRcdENhcnQuaXRlbXMgPSBpdGVtcztcclxuXHJcblx0XHRDYXJ0LnBlcnNpc3QoKTtcclxuXHJcblx0XHRyZXR1cm4gY2FsbGJhY2soKTtcclxuXHJcblx0fTtcclxuXHJcblx0Q2FydC5lbXB0eSA9IGNhbGxiYWNrID0+IHtcclxuXHJcblx0XHRDYXJ0Lml0ZW1zID0gW107XHJcblxyXG5cdFx0Q2FydC5wZXJzaXN0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGNhbGxiYWNrKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdHJldHVybiBDYXJ0O1xyXG5cclxuXHRmdW5jdGlvbiBDYXJ0RXJyb3IoY29kZSwgbWVzc2FnZSA9IGNvZGUpIHtcclxuXHJcblx0XHRjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcblxyXG5cdFx0ZXJyLmNvZGUgPSBjb2RlO1xyXG5cclxuXHRcdHJldHVybiBlcnI7XHJcblxyXG5cdH1cclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0Ly8gRW1wdHkgdGhlIGNvbnRlbnRzIGFuZCBhZGQgYSAnaGlkZGVuJyBjbGFzc1xyXG5cdHRoaXMub3ZlcmxheS5jb250YWluZXIuYWRkQ2xhc3MoJ2hpZGRlbicpO1xyXG5cdHRoaXMub3ZlcmxheS5iYWNrZ3JvdW5kLmFkZENsYXNzKCdoaWRkZW4nKTtcclxuXHJcblx0dGhpcy5vdmVybGF5LmJvZHkuaHRtbCgnJyk7XHJcblxyXG5cdC8vIHNob3cgYm9keSBzY3JvbGxcclxuXHQkKCdodG1sLCBib2R5JykucmVtb3ZlQ2xhc3MoJ3RodW5kZXItLW92ZXJmbG93LWZpeCcpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjbGllbnQpIHtcclxuXHJcblx0dGhpcy5yZXF1ZXN0LnNldERlZmF1bHRIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7Y2xpZW50fWApO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgLi4uYXJncykge1xyXG5cclxuXHRmbiA9IHR5cGVvZiBmbiA9PT0gJ3N0cmluZycgP1xyXG5cdFx0XHR0aGlzLm1ldGhvZHNbZm5dIDpcclxuXHRcdFx0Zm47XHJcblxyXG5cdGlmICghZm4pIHJldHVybjtcclxuXHJcblx0cmV0dXJuIGZuKC4uLmFyZ3MpO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRpZiAoIXRoaXMub3B0aW9ucy5oZWFkZXIpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgJGhlYWRlck5hdiA9ICQoJyN0aHVuZGVyLS1oZWFkZXItbmF2aWdhdGlvbicpO1xyXG5cclxuXHRpZiAoISRoZWFkZXJOYXYubGVuZ3RoKSB7XHJcblxyXG5cdFx0Y29uc3QgYWN0aW9ucyA9IHRoaXMub3B0aW9ucy5oZWFkZXIuYWN0aW9ucztcclxuXHJcblx0XHQkKCdib2R5JykucHJlcGVuZCh0aGlzLnVpc1snaGVhZGVyLW5hdmlnYXRpb24nXSgpKTtcclxuXHRcdCQoJ2JvZHknKS5vbignY2xpY2snLCAnI3RodW5kZXItLWhlYWRlci1uYXZpZ2F0aW9uIFtkYXRhLWNvbXBvbmVudF0nLCBmdW5jdGlvbihlKSB7XHJcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0YWN0aW9uc1skKHRoaXMpLmRhdGEoJ2NvbXBvbmVudCcpXSgpO1xyXG5cdFx0fSk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0JGhlYWRlck5hdi5yZXBsYWNlV2l0aCh0aGlzLnVpc1snaGVhZGVyLW5hdmlnYXRpb24nXSgpKTtcclxuXHJcblx0fVxyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRjb25zdCBUaHVuZGVyID0gdGhpcztcclxuXHJcblx0Y29uc3QgYm9keSA9ICQoJ2JvZHknKTtcclxuXHJcblx0dGhpcy5DYXJ0LmxvYWQoKTtcclxuXHJcblx0Ly8gQ2FjaGUgb3ZlcmxheSBET01zXHJcblx0dGhpcy5vdmVybGF5LmJhY2tncm91bmQgPSAkKHRoaXMub3ZlcmxheS5iYWNrZ3JvdW5kKS5hZGRDbGFzcygnaGlkZGVuJyk7XHJcblx0dGhpcy5vdmVybGF5LmNvbnRhaW5lciA9ICQodGhpcy5vdmVybGF5LmNvbnRhaW5lcikuYWRkQ2xhc3MoJ2hpZGRlbicpO1xyXG5cdHRoaXMub3ZlcmxheS5ib2R5ID0gdGhpcy5vdmVybGF5LmNvbnRhaW5lci5maW5kKCcjdGh1bmRlci0tb3ZlcmxheS1ib2R5Jyk7XHJcblxyXG5cdC8vIEFwcGVuZCBjbG9zZSBidXR0b24gdG8gdGhlIG92ZXJsYXkncyBoZWFkZXJcclxuXHR0aGlzLm92ZXJsYXkuY29udGFpbmVyXHJcblx0XHQuZmluZCgnI3RodW5kZXItLW92ZXJsYXktaGVhZGVyJylcclxuXHRcdC5hcHBlbmQodGhpcy51aXNbJ292ZXJsYXktbmF2aWdhdGlvbiddKCkpO1xyXG5cclxuXHRib2R5LmFwcGVuZCh0aGlzLm92ZXJsYXkuYmFja2dyb3VuZCk7XHJcblx0Ym9keS5hcHBlbmQodGhpcy5vdmVybGF5LmNvbnRhaW5lcik7XHJcblxyXG5cdC8vIEJpbmQgY2xpY2sgZXZlbnRzIGZvciBET01zIHdpdGggZGF0YS10aHVuZGVyLSogYXR0cmlidXRlcy5cclxuXHRib2R5Lm9uKCdjbGljaycsICdbZGF0YS10aHVuZGVyLW9wZW5dJywgb3Blbk92ZXJsYXkpO1xyXG5cdGJvZHkub24oJ2NsaWNrJywgJ1tkYXRhLXRodW5kZXItY2xvc2VdJywgKCkgPT4gdGhpcy5jbG9zZSgpKTtcclxuXHRib2R5Lm9uKCdjbGljaycsICdbZGF0YS10aHVuZGVyLWxvZ291dF0nLCAoKSA9PiB0aGlzLmxvZ291dCgpKTtcclxuXHRib2R5Lm9uKCdjbGljaycsICdbZGF0YS10aHVuZGVyLXJlbmRlcl1bZGF0YS10aHVuZGVyLXJlbmRlci10YXJnZXRdJywgcmVuZGVyQ29tcG9uZW50SW5UYXJnZXQpO1xyXG5cclxuXHQvLyBSZW5kZXIgY29tcG9uZW50cyBmb3IgRE9NcyB3aXRoICdkYXRhLXRodW5kZXItcmVuZGVyJyxcclxuXHQvLyBhbmQgd2l0aG91dCAnZGF0YS10aHVuZGVyLXJlbmRlci10YXJnZXQnLlxyXG5cdGJvZHkuZmluZCgnW2RhdGEtdGh1bmRlci1yZW5kZXJdOm5vdChbZGF0YS10aHVuZGVyLXJlbmRlci10YXJnZXRdKScpLmVhY2gocmVuZGVyQ29tcG9uZW50KTtcclxuXHJcblx0dGhpcy5oZWFkZXIoKTtcclxuXHJcblx0Ly8gQ2hlY2sgd2hldGhlciBhdXRoZW50aWNhdGlvbiB0b2tlbnMgYXJlIGV4cGlyZWQuXHJcblx0Ly8gSWYgaXQgaXMgZXhwaXJlZCAtPiBMb2cgb3V0IGFuZCB1bnNldCBmcm9tIHRoZSBzdG9yYWdlLi4uXHJcblx0dGhpcy5hdXRoZW50aWNhdGVkKCdjdXN0b21lcicpO1xyXG5cdHRoaXMuYXV0aGVudGljYXRlZCgnb3JkZXInKTtcclxuXHJcblx0ZnVuY3Rpb24gb3Blbk92ZXJsYXkoJGV2ZW50KSB7XHJcblxyXG5cdFx0JGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9ICQodGhpcykuZGF0YSgpO1xyXG5cdFx0Y29uc3QgY29tcG9uZW50TmFtZSA9IGRhdGEudGh1bmRlck9wZW47XHJcblxyXG5cdFx0Ly8gUGFzcyB0aGUgZGF0YSBmcm9tIHRoZSBjYWxsZXIgRE9NXHJcblx0XHRUaHVuZGVyLm9wZW4oY29tcG9uZW50TmFtZSwgZGF0YSk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50KCkge1xyXG5cclxuXHRcdFRodW5kZXIucmVuZGVyKCQodGhpcyksICQodGhpcykuZGF0YSgndGh1bmRlclJlbmRlcicpLCB7fSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW5kZXJDb21wb25lbnRJblRhcmdldCgkZXZlbnQpIHtcclxuXHJcblx0XHQkZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcblx0XHRjb25zdCBkYXRhID0gJCh0aGlzKS5kYXRhKCk7XHJcblx0XHRjb25zdCB7IHRodW5kZXJSZW5kZXIsIHRodW5kZXJSZW5kZXJUYXJnZXQgfSA9IGRhdGE7XHJcblxyXG5cdFx0VGh1bmRlci5yZW5kZXIoJCh0aHVuZGVyUmVuZGVyVGFyZ2V0KSwgdGh1bmRlclJlbmRlciwgZGF0YSk7XHJcblx0fVxyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRjb25zdCBzdG9yYWdlID0gdGhpcy5wbHVnaW5zLmNyZWRlbnRpYWxTdG9yYWdlO1xyXG5cclxuXHRzdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5vcHRpb25zLmF1dGhTdG9yYWdlLmN1c3RvbWVyKTtcclxuXHJcblx0dGhpcy5oZWFkZXIoKTtcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiguLi5hcmdzKSB7XHJcblx0cmV0dXJuIHRoaXMucGx1Z2lucy5ub3RpZmljYXRpb24oLi4uYXJncyk7XHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzY29wZSwgbGlzdGVuZXIpIHtcclxuXHJcblx0Y29uc3QgaW5kZXggPSB0aGlzLmxpc3RlbmVyc1tzY29wZV0uaW5kZXhPZihsaXN0ZW5lcik7XHJcblxyXG5cdGlmIChpbmRleCA9PT0gLTEpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHRoaXMubGlzdGVuZXJzW3Njb3BlXS5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzY29wZSwgbGlzdGVuZXIpIHtcclxuXHJcblx0dGhpcy5saXN0ZW5lcnNbc2NvcGVdLnB1c2gobGlzdGVuZXIpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb21wb25lbnROYW1lLCBvcHRpb25zLCBjYWxsYmFjayA9ICgpID0+IHt9KSB7XHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRjYWxsYmFjayA9IHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucyA6IGNhbGxiYWNrO1xyXG5cclxuXHRpZiAodGhpcy5vdmVybGF5LmJhY2tncm91bmQuaGFzQ2xhc3MoJ2hpZGRlbicpKSB7XHJcblx0XHQvLyBSZW1vdmVzIGEgJ2hpZGRlbicgY2xhc3MgZmlyc3RcclxuXHRcdHRoaXMub3ZlcmxheS5iYWNrZ3JvdW5kLnJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcclxuXHRcdHRoaXMub3ZlcmxheS5jb250YWluZXIucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xyXG5cdH1cclxuXHQvLyBoaWRlIGJvZHkgc2Nyb2xsXHJcblx0JCgnaHRtbCwgYm9keScpLmFkZENsYXNzKCd0aHVuZGVyLS1vdmVyZmxvdy1maXgnKTtcclxuXHJcblx0Ly8gTWFyayBjdXJyZW50IHZpZXdcclxuXHQkLmV4dGVuZCh0cnVlLCBvcHRpb25zLCB7XHJcblx0XHR2aWV3OiB7XHJcblx0XHRcdGNvbXBvbmVudDogY29tcG9uZW50TmFtZSxcclxuXHRcdFx0Y3Vyc29yOiAgICB0aGlzLmN1cnNvcixcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0dGhpcy5yZW5kZXIodGhpcy5vdmVybGF5LmJvZHksIGNvbXBvbmVudE5hbWUsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmIChlcnIpIHtcclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoJCh0aGlzKSwgZXJyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCgkKHRoaXMpLCBlcnIsIGNvbnRleHQpO1xyXG5cclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cclxuXHRjb25zdCBsYW5ndWFnZSA9IG9wdGlvbnMubGFuZ3VhZ2U7XHJcblx0Y29uc3QgY3VycmVuY3kgPSBvcHRpb25zLmN1cnJlbmN5O1xyXG5cdGNvbnN0IHRpbWV6b25lID0gb3B0aW9ucy50aW1lem9uZTtcclxuXHRjb25zdCBkZWJ1Z0xhbmd1YWdlID0gb3B0aW9ucy5kZWJ1Z0xhbmd1YWdlO1xyXG5cclxuXHR0aGlzLm9wdGlvbnMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcclxuXHR0aGlzLm9wdGlvbnMuY3VycmVuY3kgPSBjdXJyZW5jeTtcclxuXHR0aGlzLm9wdGlvbnMudGltZXpvbmUgPSB0aW1lem9uZTtcclxuXHJcblx0dGhpcy5wb2x5Z2xvdC5sb2NhbGUodGhpcy5vcHRpb25zLmxhbmd1YWdlKTtcclxuXHJcblx0aWYgKGxhbmd1YWdlKSB0aGlzLnJlcXVlc3Quc2V0RGVmYXVsdEhlYWRlcignQWNjZXB0LUxhbmd1YWdlJywgbGFuZ3VhZ2UpO1xyXG5cdGlmIChjdXJyZW5jeSkgdGhpcy5yZXF1ZXN0LnNldERlZmF1bHRIZWFkZXIoJ0FjY2VwdC1DdXJyZW5jeScsIGN1cnJlbmN5KTtcclxuXHRpZiAodGltZXpvbmUpIHRoaXMucmVxdWVzdC5zZXREZWZhdWx0SGVhZGVyKCdBY2NlcHQtVGltZS1ab25lJywgdGltZXpvbmUpO1xyXG5cdGlmIChkZWJ1Z0xhbmd1YWdlKSB0aGlzLnJlcXVlc3Quc2V0RGVmYXVsdEhlYWRlcignQWNjZXB0LURlYnVnLUxhbmd1YWdlJywgZGVidWdMYW5ndWFnZSk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTsiLCJjb25zdCBtZXJnZVdpdGggPSByZXF1aXJlKCdsb2Rhc2gubWVyZ2VXaXRoJyk7XHJcbmNvbnN0IG9taXQgPSByZXF1aXJlKCdsb2Rhc2gub21pdCcpO1xyXG5jb25zdCBQaWthZGF5ID0gcmVxdWlyZSgncGlrYWRheScpO1xyXG5cclxuLy8gVHJhY2sgY29tcG9uZW50IElEc1xyXG5jb25zdCBjb21wb25lbnRJZHMgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbXBvbmVudE5hbWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcblxyXG5cdGNvbnN0IFRodW5kZXIgPSB0aGlzO1xyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRjYWxsYmFjayA9IHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucyA6IGNhbGxiYWNrO1xyXG5cclxuXHQvLyBJbmNyZW1lbnQgY29tcG9uZW50IGNvdW50ZXJcclxuXHRjb21wb25lbnRJZHNbY29tcG9uZW50TmFtZV0gPSBjb21wb25lbnRJZHNbY29tcG9uZW50TmFtZV0gfHwgMDtcclxuXHJcblx0Y29uc3QgaWQgPSBjb21wb25lbnRJZHNbY29tcG9uZW50TmFtZV0rKztcclxuXHJcblx0Y29uc3QgY29udGFpbmVyID0gKHNlbGVjdG9yIGluc3RhbmNlb2YgJCkgPyBzZWxlY3RvciA6ICQoc2VsZWN0b3IpO1xyXG5cdGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tjb21wb25lbnROYW1lXTtcclxuXHJcblx0Ly8gVGVtcGxhdGUgY29udGV4dFxyXG5cdGNvbnN0IGNvbnRleHQgPSB7XHJcblx0XHRpZDogYCR7Y29tcG9uZW50TmFtZX0tJHtpZH1gXHJcblx0fTtcclxuXHJcblx0Ly8gQWRkICd0aHVuZGVyLS1jb250ZW50cycgY2xhc3MgZm9yIGdsb2JhbCBjc3Mgc3R5bGVzXHJcblx0Y29udGFpbmVyLmFkZENsYXNzKCd0aHVuZGVyLS1jb250ZW50cycpO1xyXG5cclxuXHQvLyBVbmJpbmQgYWxsIGV2ZW50IGhhbmRsZXJzXHJcblx0Y29udGFpbmVyLm9mZigpO1xyXG5cdGNvbnRhaW5lci5maW5kKCcqJykub2ZmKCk7XHJcblx0Y29udGFpbmVyLmZpbmQoJ1tkYXRhLW1oXScpLm1hdGNoSGVpZ2h0KHsgcmVtb3ZlOiB0cnVlIH0pO1xyXG5cdGNvbnRhaW5lci5maW5kKCdbZGF0YS1waWNrYWRheV0nKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdGNvbnN0IHBpY2tlciA9ICQodGhpcykuZGF0YSgncGlja2FkYXknKTtcclxuXHJcblx0XHRyZXR1cm4gcGlja2VyID8gcGlja2VyLmRlc3Ryb3koKSA6IG51bGw7XHJcblxyXG5cdH0pO1xyXG5cclxuXHQvLyBTdGFydCBsb2FkaW5nIHNwaW5uZXJcclxuXHRjb250YWluZXIuaHRtbCh0aGlzLnVpc1snY29tcG9uZW50LXNwaW5uZXInXSgpKTtcclxuXHJcblx0Ly8gQ29weSBhbmQgZXh0ZW5kIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHJ1bnRpbWUgb3B0aW9uc1xyXG5cdG1lcmdlV2l0aChcclxuXHRcdGNvbnRleHQsXHJcblx0XHR7ICAgLy8gR2xvYmFsIGNvbnRleHRcclxuXHRcdFx0aXNBdXRoZW50aWNhdGVkOiAhIVRodW5kZXIuYXV0aGVudGljYXRlZCgpLCAvLyBDdXN0b21lciBpcyBhdXRoZW50aWNhdGVkP1xyXG5cdFx0fSxcclxuXHRcdHRoaXMudGVtcGxhdGVNZXRob2RzLCAvLyBUZW1wbGF0ZSBtZXRob2RzXHJcblx0XHR7ICAgLy8gVHJhbnNsYXRpb24gbWV0aG9kXHJcblx0XHRcdG06IChrZXksIGNvbnRleHQpID0+IFRodW5kZXIucG9seWdsb3QudChgJHsgY29tcG9uZW50TmFtZSB9LiR7IGtleSB9YCwgY29udGV4dCksXHJcblx0XHRcdHVpOiBUaHVuZGVyLnVpcyxcclxuXHRcdH0sXHJcblx0XHR7IG9wdGlvbnM6IGNvbXBvbmVudC5vcHRpb25zKCkgfSxcclxuXHRcdHsgb3B0aW9uczogY29tcG9uZW50LmRlZmF1bHQgfSxcclxuXHRcdHsgb3B0aW9uczogb21pdChjb250YWluZXIuZGF0YSgpLCBbJ2NvbXBvbmVudCcsICdjb250ZXh0J10pIH0sIC8vIERlY2xhcmF0aXZlIG9wdGlvbnNcclxuXHRcdHsgb3B0aW9uczogb3B0aW9ucyB9LCAvLyBFeHBsaWNpdCBvcHRpb25zXHJcblx0XHQob3YsIHN2KSA9PiB7XHJcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KG92KSAmJiBBcnJheS5pc0FycmF5KHN2KSkge1xyXG5cdFx0XHRcdHJldHVybiBzdjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdCk7XHJcblxyXG5cdGlmIChjb21wb25lbnQudmFsaWRhdGUpIHtcclxuXHJcblx0XHRjb25zdCBlcnIgPSBjb21wb25lbnQudmFsaWRhdGUoY29udGV4dC5vcHRpb25zKTtcclxuXHJcblx0XHRpZiAoZXJyKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnV0aWwubG9nKFsnZXJyb3InXSwgY29tcG9uZW50Lm5hbWUgKyAnIC0gJyArIGVycik7XHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Y29tcG9uZW50LnByZS5jYWxsKGNvbnRhaW5lciwgY29udGV4dCwgKGZ1bmN0aW9uKGVyciwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmIChlcnIpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENhY2hlIGNvbXBvbmVudFxyXG5cdFx0Y29udGFpbmVyLmRhdGEoJ2NvbXBvbmVudCcsIFRodW5kZXIuY29tcG9uZW50c1tjb21wb25lbnROYW1lXSk7XHJcblxyXG5cdFx0Ly8gQ2FjaGUgY29udGV4dCBkYXRhXHJcblx0XHRjb250YWluZXIuZGF0YSgnY29udGV4dCcsIGNvbnRleHQpO1xyXG5cclxuXHRcdGNvbnRhaW5lci5odG1sKGNvbXBvbmVudC50ZW1wbGF0ZShjb250ZXh0KSk7XHJcblxyXG5cdFx0VGh1bmRlci50cmlnZ2VyKCdjb21wb25lbnRSZW5kZXInLCBjb250YWluZXIsIGNvbXBvbmVudE5hbWUsIGNvbnRhaW5lciwgY29udGV4dCk7XHJcblxyXG5cdFx0VGh1bmRlci51dGlsLnF1YW50aXR5SW5wdXQoY29udGFpbmVyKTtcclxuXHJcblx0XHQvLyBCaW5kIGJlZm9yZSBhdXRvbWF0aWMgYmluZGluZ1xyXG5cdFx0aWYgKGNvbXBvbmVudC5iaW5kKSB7XHJcblx0XHRcdGNvbXBvbmVudC5iaW5kLmNhbGwoY29udGFpbmVyLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHJcblx0XHRjb250YWluZXIuaW1hZ2VzTG9hZGVkKCgpID0+IGNvbnRhaW5lci5maW5kKCdbZGF0YS1taF0nKS5tYXRjaEhlaWdodCgpKTtcclxuXHJcblx0XHRjb25zdCB0ID0ga2V5ID0+IFRodW5kZXIucG9seWdsb3QudChgZ2VuZXJhbC4ke2tleX1gKTtcclxuXHJcblx0XHRjb250YWluZXIuZmluZCgnW2RhdGEtcGlja2FkYXldJykuZWFjaChmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdCQodGhpcykuZGF0YSgncGlja2FkYXknLCBuZXcgUGlrYWRheSgkLmV4dGVuZCgkKHRoaXMpLmRhdGEoKSwge1xyXG5cdFx0XHRcdGZpZWxkOiAgJCh0aGlzKVswXSxcclxuXHRcdFx0XHRmb3JtYXQ6IFRodW5kZXIub3B0aW9ucy5kYXRlSW5wdXRGb3JtYXQsXHJcblx0XHRcdFx0aTE4bjoge1xyXG5cdFx0XHRcdFx0cHJldmlvdXNNb250aDogdCgncHJldmlvdXNNb250aCcpLFxyXG5cdFx0XHRcdFx0bmV4dE1vbnRoOiAgICAgdCgnbmV4dE1vbnRoJyksXHJcblx0XHRcdFx0XHRtb250aHM6ICAgICAgICBbXHJcblx0XHRcdFx0XHRcdHQoJ2phbnVhcnknKSxcclxuXHRcdFx0XHRcdFx0dCgnZmVicnVhcnknKSxcclxuXHRcdFx0XHRcdFx0dCgnbWFyY2gnKSxcclxuXHRcdFx0XHRcdFx0dCgnYXByaWwnKSxcclxuXHRcdFx0XHRcdFx0dCgnbWF5JyksXHJcblx0XHRcdFx0XHRcdHQoJ2p1bmUnKSxcclxuXHRcdFx0XHRcdFx0dCgnanVseScpLFxyXG5cdFx0XHRcdFx0XHR0KCdhdWd1c3QnKSxcclxuXHRcdFx0XHRcdFx0dCgnc2VwdGVtYmVyJyksXHJcblx0XHRcdFx0XHRcdHQoJ29jdG9iZXInKSxcclxuXHRcdFx0XHRcdFx0dCgnbm92ZW1iZXInKSxcclxuXHRcdFx0XHRcdFx0dCgnZGVjZW1iZXInKSxcclxuXHRcdFx0XHRcdF0sXHJcblx0XHRcdFx0XHR3ZWVrZGF5czogICAgICBbXHJcblx0XHRcdFx0XHRcdHQoJ3N1bmRheScpLFxyXG5cdFx0XHRcdFx0XHR0KCdtb25kYXknKSxcclxuXHRcdFx0XHRcdFx0dCgndHVlc2RheScpLFxyXG5cdFx0XHRcdFx0XHR0KCd3ZWRuZXNkYXknKSxcclxuXHRcdFx0XHRcdFx0dCgndGh1cnNkYXknKSxcclxuXHRcdFx0XHRcdFx0dCgnZnJpZGF5JyksXHJcblx0XHRcdFx0XHRcdHQoJ3NhdHVyZGF5JyksXHJcblx0XHRcdFx0XHRdLFxyXG5cdFx0XHRcdFx0d2Vla2RheXNTaG9ydDogW1xyXG5cdFx0XHRcdFx0XHR0KCdzdW5kYXlTaG9ydCcpLFxyXG5cdFx0XHRcdFx0XHR0KCdtb25kYXlTaG9ydCcpLFxyXG5cdFx0XHRcdFx0XHR0KCd0dWVzZGF5U2hvcnQnKSxcclxuXHRcdFx0XHRcdFx0dCgnd2VkbmVzZGF5U2hvcnQnKSxcclxuXHRcdFx0XHRcdFx0dCgndGh1cnNkYXlTaG9ydCcpLFxyXG5cdFx0XHRcdFx0XHR0KCdmcmlkYXlTaG9ydCcpLFxyXG5cdFx0XHRcdFx0XHR0KCdzYXR1cmRheVNob3J0JyksXHJcblx0XHRcdFx0XHRdXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KSkpO1xyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdGNvbnN0IGludGVyZmFjZXMgPSBjb21wb25lbnQuaW5pdC5jYWxsKGNvbnRhaW5lciwgY29udGV4dCkgfHwge307XHJcblxyXG5cdFx0VGh1bmRlci50cmlnZ2VyKCdjb21wb25lbnRJbml0JywgY29udGFpbmVyLCBjb21wb25lbnROYW1lLCBjb250YWluZXIsIGNvbnRleHQpO1xyXG5cclxuXHRcdHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKCQodGhpcyksIGVyciwgeyBpbnRlcmZhY2VzLCBjb250ZXh0IH0pO1xyXG5cclxuXHR9KS5iaW5kKGNvbnRhaW5lcikpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUaHVuZGVyKSB7XHJcblxyXG5cdGNvbnN0IHJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0T3B0aW9ucykge1xyXG5cclxuXHRcdGxldCBxdWVyeSA9ICQucGFyYW0ocmVxdWVzdE9wdGlvbnMucXVlcnkgfHwge30pO1xyXG5cclxuXHRcdHF1ZXJ5ID0gcXVlcnkgPyAoJz8nICsgcXVlcnkpIDogcXVlcnk7XHJcblxyXG5cdFx0cmVxdWVzdE9wdGlvbnMudXJsID0gVGh1bmRlci5vcHRpb25zLmJhc2VVUkwgKyByZXF1ZXN0T3B0aW9ucy51cmwgKyBxdWVyeTtcclxuXHJcblx0XHRjb25zdCByZWNhcHRjaGEgPSByZXF1ZXN0T3B0aW9ucy5yZWNhcHRjaGE7XHJcblxyXG5cdFx0ZGVsZXRlIHJlcXVlc3RPcHRpb25zLnF1ZXJ5O1xyXG5cdFx0ZGVsZXRlIHJlcXVlc3RPcHRpb25zLnJlY2FwdGNoYTtcclxuXHJcblx0XHRjb25zdCByZXEgPSAkLmV4dGVuZCh0cnVlLCB7XHJcblx0XHRcdGNyb3NzRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRoZWFkZXJzOiAgICAgJC5leHRlbmQoXHJcblx0XHRcdFx0cmVxdWVzdC5nZXRSZXF1ZXN0SGVhZGVycyhUaHVuZGVyKSxcclxuXHRcdFx0XHRyZWNhcHRjaGEgPyB7ICdSZWNhcHRjaGEtUmVzcG9uc2UnOiByZWNhcHRjaGEgfSA6IHt9XHJcblx0XHRcdCksXHJcblx0XHRcdHhockZpZWxkczoge1xyXG5cdFx0XHRcdHdpdGhDcmVkZW50aWFsczogdHJ1ZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRjb252ZXJ0ZXJzOiB7XHJcblx0XHRcdFx0J3RleHQganNvbic6IGRhdGEgPT4gJC5wYXJzZUpTT04oZGF0YSB8fCAnbnVsbCcpXHJcblx0XHRcdH1cclxuXHRcdH0sIHJlcXVlc3RPcHRpb25zKTtcclxuXHJcblx0XHRpZiAocmVxLmRhdGEpIHtcclxuXHJcblx0XHRcdGNvbnN0IHJlY2FwdGNoYSA9IFRodW5kZXIudXRpbC51bnNldFJlY2FwdGNoYShyZXEuZGF0YSk7XHJcblxyXG5cdFx0XHRpZiAocmVjYXB0Y2hhKSB7XHJcblx0XHRcdFx0cmVxLmhlYWRlcnNbJ3JlQ0FQVENIQS1SZXNwb25zZSddID0gcmVjYXB0Y2hhO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXEuZGF0YSA9IEpTT04uc3RyaW5naWZ5KHJlcS5kYXRhKTtcclxuXHRcdFx0cmVxLmRhdGFUeXBlID0gJ2pzb24nO1xyXG5cdFx0XHRyZXEuY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOCc7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuICQuYWpheChyZXEpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRyZXF1ZXN0LmRlZmF1bHRIZWFkZXJzID0ge1xyXG5cdFx0J0NsYXlmdWwtU0RLJzogJ2NsYXlmdWwtdGh1bmRlcidcclxuXHR9O1xyXG5cclxuXHRyZXF1ZXN0LnNldERlZmF1bHRIZWFkZXIgPSAoa2V5LCB2YWx1ZSkgPT4ge1xyXG5cdFx0cmVxdWVzdC5kZWZhdWx0SGVhZGVyc1trZXldID0gdmFsdWU7XHJcblx0fTtcclxuXHJcblx0cmVxdWVzdC5nZXRSZXF1ZXN0SGVhZGVycyA9ICgpID0+IHtcclxuXHJcblx0XHRjb25zdCBzdG9yYWdlID0gVGh1bmRlci5wbHVnaW5zLmNyZWRlbnRpYWxTdG9yYWdlO1xyXG5cclxuXHRcdC8vIDEuIElmIGEgY3VzdG9tZXIgaXMgbG9nZ2VkLWluLCBzZW5kIGEgY3VzdG9tZXIgdG9rZW4uXHJcblx0XHQvLyAyLiBJZiBhbiBvcmRlciB0b2tlbiBvciBhIHN1YnNjcmlwdGlvbiB0b2tlbiBleGlzdHMsIHNlbmQgdGhlIHRva2VuLlxyXG5cdFx0Ly8gMy4gT3IgZWxzZSwgc2ltcGx5IGRvIG5vdCBzZXQgYEF1dGhvcml6YXRpb24tQ3VzdG9tZXJgIGhlYWRlclxyXG5cdFx0Y29uc3QgY3VzdG9tZXJUb2tlbiA9XHJcblx0XHRcdFx0c3RvcmFnZS5nZXRJdGVtKFRodW5kZXIub3B0aW9ucy5hdXRoU3RvcmFnZS5jdXN0b21lcikgfHxcclxuXHRcdFx0XHRzdG9yYWdlLmdldEl0ZW0oVGh1bmRlci5vcHRpb25zLmF1dGhTdG9yYWdlLm9yZGVyKTtcclxuXHJcblx0XHRyZXR1cm4gJC5leHRlbmQoXHJcblx0XHRcdHt9LFxyXG5cdFx0XHRyZXF1ZXN0LmRlZmF1bHRIZWFkZXJzLFxyXG5cdFx0XHRjdXN0b21lclRva2VuID8ge1xyXG5cdFx0XHRcdCdBdXRob3JpemF0aW9uLUN1c3RvbWVyJzogY3VzdG9tZXJUb2tlblxyXG5cdFx0XHR9IDoge31cclxuXHRcdCk7XHJcblxyXG5cdH07XHJcblxyXG5cdHJldHVybiByZXF1ZXN0O1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1lc3NhZ2VzID0ge30pIHtcclxuXHJcblx0dGhpcy5wb2x5Z2xvdC5leHRlbmQobWVzc2FnZXMpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzY29wZSwgYmluZGVyLCAuLi5hcmdzKSB7XHJcblxyXG5cdHRoaXMubGlzdGVuZXJzW3Njb3BlXS5mb3JFYWNoKGNhbGxiYWNrID0+IHtcclxuXHRcdHJldHVybiBiaW5kZXIgP1xyXG5cdFx0XHRjYWxsYmFjay5jYWxsKGJpbmRlciwgLi4uYXJncykgOlxyXG5cdFx0XHRjYWxsYmFjayguLi5hcmdzKTtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59OyIsImNvbnN0IHNldCA9IHJlcXVpcmUoJ2xvZGFzaC5zZXQnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGh1bmRlciA9PiB7XHJcblxyXG5cdGNvbnN0IGltcGxlbWVudGF0aW9uID0ge1xyXG5cdFx0bmFtZTogJ2NhcnQnXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ub3B0aW9ucyA9ICgpID0+ICh7XHJcblx0XHRvcmRlckFjdGlvbnM6IE9iamVjdC5rZXlzKFRodW5kZXIub3B0aW9ucy5wYXltZW50TWV0aG9kcyksIC8vICdvcmRlcicsICdzdWJzY3JpcHRpb24nXHJcblx0XHRpdGVtczogICAgICAgIG51bGwsIC8vIEl0ZW0gZmlsdGVyIC0gZS5nLiwgWydpdGVtMScsICdpdGVtMicsIC4uLl1cclxuXHJcblx0XHRvbkNoZWNrb3V0OiBmdW5jdGlvbigkY29udGFpbmVyLCBjb250ZXh0LCB0eXBlKSB7XHJcblxyXG5cdFx0XHRUaHVuZGVyLnJlbmRlcigkY29udGFpbmVyLCAnY2hlY2tvdXQnLCB7XHJcblx0XHRcdFx0dHlwZTogIHR5cGUsXHJcblx0XHRcdFx0aXRlbXM6IGNvbnRleHQub3B0aW9ucy5pdGVtcyxcclxuXHRcdFx0XHRiYWNrOiAge1xyXG5cdFx0XHRcdFx0JGNvbnRhaW5lcjogJGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdGNvbXBvbmVudDogIGltcGxlbWVudGF0aW9uLm5hbWUsXHJcblx0XHRcdFx0XHRvcHRpb25zOiAgICBjb250ZXh0Lm9wdGlvbnNcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5wcmUgPSBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaykge1xyXG5cclxuXHRcdGNvbnRleHQub3B0aW9ucy5vcmRlckFjdGlvbnMgPSBUaHVuZGVyLnV0aWwucGFyc2VBcnJheVN0cmluZyhjb250ZXh0Lm9wdGlvbnMub3JkZXJBY3Rpb25zKTtcclxuXHJcblx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgnY2FydFJlYWRGYWlsZWQnKVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gZ2V0Q2FydChjb250ZXh0Lm9wdGlvbnMuaXRlbXMpLnRoZW4oY2FydCA9PiB7XHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBzZXQoY29udGV4dCwgJ2NhcnQnLCBjYXJ0LmNhcnQpKTtcclxuXHRcdH0sIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0ZXJyb3JzLFxyXG5cdFx0XHRjYWxsYmFja1xyXG5cdFx0KSk7XHJcblxyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLmluaXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcblxyXG5cdFx0Y29uc3QgJGNvbnRhaW5lciA9ICQodGhpcyk7XHJcblx0XHRjb25zdCAkY2FydEl0ZW1zID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tY2FydC1pdGVtcycpO1xyXG5cclxuXHRcdCRjb250YWluZXIub24oJ2NsaWNrJywgJy50aHVuZGVyLS1kZWxldGUtY2FydC1pdGVtJywgZGVsZXRlSXRlbSk7XHJcblx0XHQkY29udGFpbmVyLm9uKCdjbGljaycsICcudGh1bmRlci0tYXBwbHktY2hhbmdlcycsIGFwcGx5Q2hhbmdlcyk7XHJcblx0XHQkY29udGFpbmVyLm9uKCdjbGljaycsICcudGh1bmRlci0tY2hlY2tvdXQgYnV0dG9uJywgY2hlY2tvdXQpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHJlY2FsY3VsYXRlKCkge1xyXG5cclxuXHRcdFx0Y29uc3QgZXJyb3JzID0ge1xyXG5cdFx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgnY2FydFJlYWRGYWlsZWQnKVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0cmV0dXJuIGdldENhcnQoY29udGV4dC5vcHRpb25zLml0ZW1zKS50aGVuKGNhcnQgPT4ge1xyXG5cclxuXHRcdFx0XHRjb250ZXh0LmNhcnQgPSBjYXJ0LmNhcnQ7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHRlbXBsYXRlID0gVGh1bmRlci5jb21wb25lbnQoaW1wbGVtZW50YXRpb24ubmFtZSkudGVtcGxhdGUoY29udGV4dCk7XHJcblx0XHRcdFx0Y29uc3QgY2FydEl0ZW1zVGVtcGxhdGUgPSAkKHRlbXBsYXRlKS5maW5kKCcudGh1bmRlci0tY2FydC1pdGVtcycpLmh0bWwoKTtcclxuXHJcblx0XHRcdFx0JGNhcnRJdGVtcy5maW5kKCcqJykub2ZmKCk7XHJcblx0XHRcdFx0JGNhcnRJdGVtcy5odG1sKGNhcnRJdGVtc1RlbXBsYXRlKTtcclxuXHRcdFx0XHRUaHVuZGVyLnV0aWwucXVhbnRpdHlJbnB1dCgkY2FydEl0ZW1zKTtcclxuXHJcblx0XHRcdH0sIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdGVycm9yc1xyXG5cdFx0XHQpKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZGVsZXRlSXRlbSgpIHtcclxuXHJcblx0XHRcdGNvbnN0IHNwaW5uZXIgPSBUaHVuZGVyLnV0aWwubWFrZUFzeW5jQnV0dG9uKCQodGhpcyksIHsgYmluZDogZmFsc2UgfSk7XHJcblxyXG5cdFx0XHRzcGlubmVyLnJ1bigpO1xyXG5cclxuXHRcdFx0Y29uc3QgaXRlbUlkID0gJCh0aGlzKS5kYXRhKCdpdGVtJyk7XHJcblx0XHRcdGNvbnN0IGJ1bmRsZUl0ZW1JZCA9ICQodGhpcykuZGF0YSgnYnVuZGxlSXRlbScpO1xyXG5cclxuXHRcdFx0Y29uc3QgZXJyb3JzID0ge1xyXG5cdFx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgnZGVsZXRlSXRlbUZhaWxlZCcpXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpZiAoVGh1bmRlci5hdXRoZW50aWNhdGVkKCkpIHtcclxuXHJcblx0XHRcdFx0aWYgKGJ1bmRsZUl0ZW1JZCkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdFx0XHRtZXRob2Q6ICdQVVQnLFxyXG5cdFx0XHRcdFx0XHR1cmw6ICAgIGAvdjEvbWUvY2FydC9pdGVtcy8ke2l0ZW1JZH1gLFxyXG5cdFx0XHRcdFx0XHRkYXRhOiAgICB7IGJ1bmRsZUl0ZW1zOiB7IFtidW5kbGVJdGVtSWRdOiBudWxsIH0gfVxyXG5cdFx0XHRcdFx0fSkudGhlbigoKSA9PiB7XHJcblx0XHRcdFx0XHRcdHNwaW5uZXIuZG9uZSgpO1xyXG5cdFx0XHRcdFx0XHRyZWNhbGN1bGF0ZSgpO1xyXG5cdFx0XHRcdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdFx0XHRlcnJvcnMsXHJcblx0XHRcdFx0XHRcdGVyciA9PiBzcGlubmVyLmRvbmUoKVxyXG5cdFx0XHRcdFx0KSk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0XHRcdG1ldGhvZDogJ0RFTEVURScsXHJcblx0XHRcdFx0XHRcdHVybDogICAgYC92MS9tZS9jYXJ0L2l0ZW1zLyR7aXRlbUlkfWBcclxuXHRcdFx0XHRcdH0pLnRoZW4oKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRzcGlubmVyLmRvbmUoKTtcclxuXHRcdFx0XHRcdFx0cmVjYWxjdWxhdGUoKTtcclxuXHRcdFx0XHRcdH0sIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0XHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0XHRcdFx0ZXJyb3JzLFxyXG5cdFx0XHRcdFx0XHRlcnIgPT4gc3Bpbm5lci5kb25lKClcclxuXHRcdFx0XHRcdCkpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoYnVuZGxlSXRlbUlkKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlID0ge1xyXG5cdFx0XHRcdFx0XHRidW5kbGVJdGVtczogeyBbYnVuZGxlSXRlbUlkXTogbnVsbCB9XHJcblx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRcdFRodW5kZXIuQ2FydC51cGRhdGVJdGVtKGl0ZW1JZCwgdXBkYXRlLCBlcnIgPT4ge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdFx0XHRcdHNwaW5uZXIuZG9uZSgpO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBlcnJvcnNbZXJyLmNvZGUgfHwgJ2RlZmF1bHQnXSB8fCBlcnJvcnMuZGVmYXVsdCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHNwaW5uZXIuZG9uZSgpO1xyXG5cdFx0XHRcdFx0XHRyZWNhbGN1bGF0ZSgpO1xyXG5cclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBUaHVuZGVyLkNhcnQuZGVsZXRlSXRlbShpdGVtSWQsIGVyciA9PiB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoZXJyKSB7XHJcblx0XHRcdFx0XHRcdFx0c3Bpbm5lci5kb25lKCk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFRodW5kZXIubm90aWZ5KCdlcnJvcicsIGVycm9yc1tlcnIuY29kZSB8fCAnZGVmYXVsdCddIHx8IGVycm9ycy5kZWZhdWx0KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0c3Bpbm5lci5kb25lKCk7XHJcblx0XHRcdFx0XHRcdHJlY2FsY3VsYXRlKCk7XHJcblxyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYXBwbHlDaGFuZ2VzKCkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc3Bpbm5lciA9IFRodW5kZXIudXRpbC5tYWtlQXN5bmNCdXR0b24oJCh0aGlzKSwgeyBiaW5kOiBmYWxzZSB9KTtcclxuXHJcblx0XHRcdHNwaW5uZXIucnVuKCk7XHJcblxyXG5cdFx0XHRjb25zdCBxdWFudGl0eUNoYW5nZWQgPSBbXTtcclxuXHRcdFx0Y29uc3QgJHF1YW50aXR5SW5wdXRzID0gJGNvbnRhaW5lci5maW5kKCcudGh1bmRlci0tY2FydC1pdGVtLXF1YW50aXR5IGlucHV0Jyk7XHJcblxyXG5cdFx0XHQkcXVhbnRpdHlJbnB1dHMuZWFjaChmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgaXRlbUlkID0gJCh0aGlzKS5kYXRhKCdpdGVtJyk7XHJcblx0XHRcdFx0Y29uc3QgYnVuZGxlSWQgPSAkKHRoaXMpLmRhdGEoJ2J1bmRsZUl0ZW0nKTtcclxuXHRcdFx0XHRjb25zdCBvcmlnaW5hbFF1YW50aXR5ID0gJCh0aGlzKS5kYXRhKCdvcmlnaW5hbFF1YW50aXR5Jyk7XHJcblx0XHRcdFx0Y29uc3QgbmV3UXVhbnRpdHkgPSBwYXJzZUludCgkKHRoaXMpLnZhbCgpKTtcclxuXHJcblx0XHRcdFx0aWYgKG5ld1F1YW50aXR5ID09PSBvcmlnaW5hbFF1YW50aXR5KSByZXR1cm47XHJcblxyXG5cdFx0XHRcdHF1YW50aXR5Q2hhbmdlZC5wdXNoKHtcclxuXHRcdFx0XHRcdGl0ZW06ICAgICBpdGVtSWQsXHJcblx0XHRcdFx0XHRidW5kbGU6ICAgYnVuZGxlSWQgfHwgbnVsbCxcclxuXHRcdFx0XHRcdHF1YW50aXR5OiBuZXdRdWFudGl0eVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjb25zdCB1cGRhdGVzID0gcXVhbnRpdHlDaGFuZ2VkLnJlZHVjZSgobywgY2hhbmdlKSA9PiB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHsgaXRlbSwgYnVuZGxlLCBxdWFudGl0eSB9ID0gY2hhbmdlO1xyXG5cclxuXHRcdFx0XHRvW2l0ZW1dID0gb1tpdGVtXSB8fCB7fTtcclxuXHJcblx0XHRcdFx0Y29uc3QgdG9VcGRhdGUgPSBvW2l0ZW1dO1xyXG5cclxuXHRcdFx0XHRpZiAoYnVuZGxlKSB7XHJcblx0XHRcdFx0XHR0b1VwZGF0ZS5idW5kbGVJdGVtcyA9IHRvVXBkYXRlLmJ1bmRsZUl0ZW1zIHx8IHt9O1xyXG5cdFx0XHRcdFx0dG9VcGRhdGUuYnVuZGxlSXRlbXNbYnVuZGxlXSA9IHsgcXVhbnRpdHkgfTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dG9VcGRhdGUucXVhbnRpdHkgPSBxdWFudGl0eTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBvO1xyXG5cclxuXHRcdFx0fSwge30pO1xyXG5cclxuXHRcdFx0Y29uc3QgZXJyb3JzID0ge1xyXG5cdFx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgnaXRlbVVwZGF0ZUZhaWxlZCcpXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpZiAoVGh1bmRlci5hdXRoZW50aWNhdGVkKCkpIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgaXRlbUlkc1RvVXBkYXRlID0gT2JqZWN0LmtleXModXBkYXRlcyk7XHJcblxyXG5cdFx0XHRcdGlmIChpdGVtSWRzVG9VcGRhdGUubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHQvLyBUaGVyZSBhcmUgbm8gaXRlbXMgdG8gdXBkYXRlXHJcblx0XHRcdFx0XHRyZXR1cm4gc3Bpbm5lci5kb25lKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gJC53aGVuKC4uLml0ZW1JZHNUb1VwZGF0ZS5tYXAoaXRlbUlkID0+IHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRcdFx0bWV0aG9kOiAnUFVUJyxcclxuXHRcdFx0XHRcdFx0dXJsOiAgICBgL3YxL21lL2NhcnQvaXRlbXMvJHtpdGVtSWR9YCxcclxuXHRcdFx0XHRcdFx0ZGF0YTogICB1cGRhdGVzW2l0ZW1JZF1cclxuXHRcdFx0XHRcdH0pLnRoZW4oKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdFx0c3Bpbm5lci5kb25lKCk7XHJcblx0XHRcdFx0XHRcdHJldHVybiByZWNhbGN1bGF0ZSgpO1xyXG5cclxuXHRcdFx0XHRcdH0sIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0XHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0XHRcdFx0ZXJyb3JzLFxyXG5cdFx0XHRcdFx0XHRlcnIgPT4gc3Bpbm5lci5kb25lKClcclxuXHRcdFx0XHRcdCkpO1xyXG5cclxuXHRcdFx0XHR9KSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRPYmplY3Qua2V5cyh1cGRhdGVzKS5mb3JFYWNoKGl0ZW1JZCA9PiB7XHJcblx0XHRcdFx0XHRyZXR1cm4gVGh1bmRlci5DYXJ0LnVwZGF0ZUl0ZW0oaXRlbUlkLCB1cGRhdGVzW2l0ZW1JZF0sICQubm9vcCk7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHNwaW5uZXIuZG9uZSgpO1xyXG5cdFx0XHRcdHJldHVybiByZWNhbGN1bGF0ZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjaGVja291dCgpIHtcclxuXHJcblx0XHRcdGNvbnN0IGNhcnQgPSBjb250ZXh0LmNhcnQ7XHJcblx0XHRcdGNvbnN0IGhhc0Vycm9yID0gY29kZSA9PiBjYXJ0LmVycm9ycy5zb21lKGVyciA9PiBlcnIuY29kZSA9PT0gY29kZSk7XHJcblxyXG5cdFx0XHRpZiAoaGFzRXJyb3IoJ2VtcHR5LWNhcnQnKSkge1xyXG5cdFx0XHRcdHJldHVybiBUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBjb250ZXh0Lm0oJ2lzRW1wdHlDYXJ0JykpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaGFzRXJyb3IoJ2l0ZW0tZXJyb3InKSkge1xyXG5cdFx0XHRcdHJldHVybiBUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBjb250ZXh0Lm0oJ2hhc0VycmVkSXRlbScpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIuZXhlY3V0ZShcclxuXHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25DaGVja291dCxcclxuXHRcdFx0XHQkY29udGFpbmVyLFxyXG5cdFx0XHRcdGNvbnRleHQsXHJcblx0XHRcdFx0JCh0aGlzKS5kYXRhKCdjaGVja291dFR5cGUnKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0Q2FydChpdGVtcykge1xyXG5cclxuXHRcdGNvbnN0IHF1ZXJ5ID0gaXRlbXMgPyB7IGl0ZW1zOiBpdGVtcy50b1N0cmluZygpIH0gOiB7fTtcclxuXHJcblx0XHRjb25zdCByZXF1ZXN0ID0gVGh1bmRlci5hdXRoZW50aWNhdGVkKCkgPyB7XHJcblx0XHRcdG1ldGhvZDogJ1BPU1QnLFxyXG5cdFx0XHR1cmw6ICAgICcvdjEvbWUvY2FydCcsXHJcblx0XHRcdHF1ZXJ5OiAgcXVlcnlcclxuXHRcdH0gOiB7XHJcblx0XHRcdG1ldGhvZDogJ1BPU1QnLFxyXG5cdFx0XHR1cmw6ICAgICcvdjEvbWUvbm9uLXJlZ2lzdGVyZWQvY2FydCcsXHJcblx0XHRcdHF1ZXJ5OiAgcXVlcnksXHJcblx0XHRcdGRhdGE6ICAgeyBpdGVtczogVGh1bmRlci5DYXJ0Lml0ZW1zIH0sXHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3QocmVxdWVzdCk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xyXG5cclxufTsiLCJjb25zdCBzZXQgPSByZXF1aXJlKCdsb2Rhc2guc2V0Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRodW5kZXIgPT4ge1xyXG5cclxuXHQvLyBJbXBsZW1lbnRhdGlvblxyXG5cdGNvbnN0IGltcGxlbWVudGF0aW9uID0ge1xyXG5cdFx0bmFtZTogJ2NhdGFsb2ctc2xpZGVyJ1xyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLm9wdGlvbnMgPSAoKSA9PiAoe1xyXG5cdFx0Y2F0YWxvZzogICAgICcnLCAvLyBDYXRhbG9nIElEIHRvIHJlbmRlclxyXG5cdFx0dXNlTmF2OiAgICAgIHRydWUsXHJcblx0XHR1c2VQYWdlcjogICAgdHJ1ZSxcclxuXHRcdHNob3dDYXB0aW9uOiB0cnVlLFxyXG5cdFx0YXV0b0xvb3A6ICAgIDMwMDBcclxuXHR9KTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ucHJlID0gZnVuY3Rpb24oY29udGV4dCwgY2FsbGJhY2spIHtcclxuXHJcblx0XHRjb25zdCBlcnJvcnMgPSB7fTtcclxuXHRcdGNvbnN0IGNhdGFsb2dJZCA9IGNvbnRleHQub3B0aW9ucy5jYXRhbG9nO1xyXG5cclxuXHRcdGNvbnRleHQudGFyZ2V0Q2hlY2sgPSB1cmwgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3QgdXJsVGFyZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG5cclxuXHRcdFx0dXJsVGFyZ2V0LmhyZWYgPSB1cmw7XHJcblxyXG5cdFx0XHRyZXR1cm4gdXJsVGFyZ2V0Lmhvc3QgPT09IHdpbmRvdy5sb2NhdGlvbi5ob3N0ID8gJ19zZWxmJyA6ICdfYmxhbmsnO1xyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0bWV0aG9kOiAnR0VUJyxcclxuXHRcdFx0dXJsOiAgICBgL3YxL2NhdGFsb2dzLyR7Y2F0YWxvZ0lkfWAsXHJcblx0XHRcdHF1ZXJ5OiAge1xyXG5cdFx0XHRcdGZpZWxkczogW1xyXG5cdFx0XHRcdFx0J3NsdWcnLFxyXG5cdFx0XHRcdFx0J2l0ZW1zLmltYWdlJyxcclxuXHRcdFx0XHRcdCdpdGVtcy5saW5rJyxcclxuXHRcdFx0XHRcdCdpdGVtcy50aXRsZScsXHJcblx0XHRcdFx0XS5qb2luKCcsJylcclxuXHRcdFx0fVxyXG5cdFx0fSkudGhlbihkYXRhID0+IHtcclxuXHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBzZXQoY29udGV4dCwgJ2NhdGFsb2dTbGlkZXInLCBkYXRhKSk7XHJcblxyXG5cdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRlcnJvcnMsXHJcblx0XHRcdGNhbGxiYWNrXHJcblx0XHQpKTtcclxuXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24uaW5pdCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuXHJcblx0XHRjb25zdCBvcHRpb25zID0ge1xyXG5cdFx0XHRpdGVtOiAgICAgICAgICAgMSxcclxuXHRcdFx0c3BlZWQ6ICAgICAgICAgIDgwMCxcclxuXHRcdFx0c2xpZGVNYXJnaW46ICAgIDAsXHJcblx0XHRcdGdhbGxlcnk6ICAgICAgICBmYWxzZSxcclxuXHRcdFx0cGF1c2VPbkhvdmVyOiAgIHRydWUsXHJcblx0XHRcdGxvb3A6ICAgICAgICAgICB0cnVlLFxyXG5cdFx0XHRhZGFwdGl2ZUhlaWdodDogdHJ1ZSxcclxuXHRcdFx0cGFnZXI6ICAgICAgICAgIGNvbnRleHQub3B0aW9ucy51c2VQYWdlcixcclxuXHRcdFx0Y29udHJvbHM6ICAgICAgIGNvbnRleHQub3B0aW9ucy51c2VOYXYsXHJcblx0XHRcdGF1dG86ICAgICAgICAgICAhIWNvbnRleHQub3B0aW9ucy5hdXRvTG9vcCxcclxuXHRcdFx0cGF1c2U6ICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5hdXRvTG9vcCB8fCAzMDAwLFxyXG5cdFx0XHRwcmV2SHRtbDogICAgICAgYDxpbWcgc3JjPVwiJHtUaHVuZGVyLnVpc1snbGVmdC1hcnJvdyddKCl9XCI+YCxcclxuXHRcdFx0bmV4dEh0bWw6ICAgICAgIGA8aW1nIHNyYz1cIiR7VGh1bmRlci51aXNbJ3JpZ2h0LWFycm93J10oKX1cIj5gXHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IHNsaWRlciA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWNhdGxhb2ctc2xpZGVyJykubGlnaHRTbGlkZXIob3B0aW9ucyk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Ly8gRXhwb3NlIHNsaWRlciBtZXRob2RzXHJcblx0XHRcdGdvVG9TbGlkZTogICAgIHNsaWRlci5nb1RvU2xpZGUsXHJcblx0XHRcdGdvVG9QcmV2U2xpZGU6IHNsaWRlci5nb1RvUHJldlNsaWRlLFxyXG5cdFx0XHRnb1RvTmV4dFNsaWRlOiBzbGlkZXIuZ29Ub05leHRTbGlkZSxcclxuXHRcdFx0cGxheTogICAgICAgICAgc2xpZGVyLnBsYXksXHJcblx0XHRcdHBhdXNlOiAgICAgICAgIHNsaWRlci5wYXVzZSxcclxuXHRcdFx0Ly8gRXhwb3NlIGN1c3RvbSBkZXN0b3J5IG1ldGhvZFxyXG5cdFx0XHRkZXN0cm95OiAgICAgICAoKSA9PiB7XHJcblx0XHRcdFx0c2xpZGVyLnBhdXNlKCk7ICAgLy8gVG8gY2xlYXIgaW50ZXJ2YWxcclxuXHRcdFx0XHRzbGlkZXIuZGVzdHJveSgpOyAvLyBEZXN0cm95IHRoZSBzbGlkZXJcclxuXHRcdFx0XHRzbGlkZXIucmVtb3ZlKCk7ICAvLyBSZW1vdmUgdGhlIERPTVxyXG5cdFx0XHR9LFxyXG5cdFx0fTtcclxuXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xyXG5cclxufTsiLCJjb25zdCBzZXQgPSByZXF1aXJlKCdsb2Rhc2guc2V0Jyk7XHJcbmNvbnN0IGNhbWVsQ2FzZSA9IHJlcXVpcmUoJ2xvZGFzaC5jYW1lbGNhc2UnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGh1bmRlciA9PiB7XHJcblxyXG5cdGNvbnN0IGltcGxlbWVudGF0aW9uID0ge1xyXG5cdFx0bmFtZTogJ2NoZWNrb3V0LXN1Y2Nlc3MnXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ub3B0aW9ucyA9ICgpID0+ICh7XHJcblx0XHR0eXBlOiAgICAnb3JkZXInLCAvLyAnb3JkZXInIHx8ICdzdWJzY3JpcHRpb24nXHJcblx0XHRzdWJqZWN0OiBudWxsLCAgICAvLyBPcmRlci9TdWJzY3JpcHRpb24gSURcclxuXHRcdG9uVmlld0RldGFpbHM6IGZ1bmN0aW9uKCRjb250YWluZXIsIGNvbnRleHQpIHtcclxuXHJcblx0XHRcdGNvbnN0IHsgdHlwZSwgc3ViamVjdCB9ID0gY29udGV4dC5vcHRpb25zO1xyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIucmVuZGVyKCRjb250YWluZXIsIGAke3R5cGV9LWRldGFpbGAsIHtcclxuXHRcdFx0XHRbdHlwZV06IHN1YmplY3RcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5wcmUgPSBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaykge1xyXG5cclxuXHRcdGNvbnN0IHR5cGUgPSBjb250ZXh0Lm9wdGlvbnMudHlwZTtcclxuXHRcdGNvbnN0IHN1YmplY3QgPSBjb250ZXh0Lm9wdGlvbnMuc3ViamVjdDtcclxuXHJcblx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubShjYW1lbENhc2UoW3R5cGUsICdyZWFkRmFpbGVkJ10pKSxcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gR2V0IGFuIG9yZGVyIG9yIGEgc3Vic2NyaXB0aW9uXHJcblx0XHRyZXR1cm4gdHlwZSA9PT0gJ29yZGVyJyA/XHJcblx0XHRcdFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0bWV0aG9kOiAnUFVUJyxcclxuXHRcdFx0XHR1cmw6ICAgIGAvdjEvbWUvJHt0eXBlfXMvJHtzdWJqZWN0fS90cmFuc2FjdGlvbnNgXHJcblx0XHRcdH0pLnRoZW4oKCkgPT4gZ2V0U3ViamVjdCgpKSA6XHJcblx0XHRcdGdldFN1YmplY3QoKTtcclxuXHJcblx0XHRmdW5jdGlvbiBnZXRTdWJqZWN0KCkge1xyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRtZXRob2Q6ICdHRVQnLFxyXG5cdFx0XHRcdHVybDogICAgYC92MS9tZS8ke3R5cGV9cy8ke3N1YmplY3R9YFxyXG5cdFx0XHR9KS50aGVuKHN1YmplY3QgPT4ge1xyXG5cdFx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBzZXQoY29udGV4dCwgJ3N1YmplY3QnLCBzdWJqZWN0KSk7XHJcblx0XHRcdH0sIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdGVycm9ycyxcclxuXHRcdFx0XHRjYWxsYmFja1xyXG5cdFx0XHQpKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5pbml0ID0gZnVuY3Rpb24oY29udGV4dCkge1xyXG5cclxuXHRcdGNvbnN0ICRjb250YWluZXIgPSAkKHRoaXMpO1xyXG5cdFx0Y29uc3QgJHZpZXdNb3JlRGV0YWlscyA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXZpZXctbW9yZS1kZXRhaWxzJyk7XHJcblx0XHRjb25zdCAkY29weVRvSWQgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1jb3B5LXRvLWlkJyk7XHJcblx0XHRjb25zdCAkY29weVRvSWRCdXR0b24gPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1jb3B5LXRvLWlkLWJ1dHRvbicpO1xyXG5cclxuXHRcdCR2aWV3TW9yZURldGFpbHMub24oJ2NsaWNrJywgKCkgPT4gVGh1bmRlci5leGVjdXRlKFxyXG5cdFx0XHRjb250ZXh0Lm9wdGlvbnMub25WaWV3RGV0YWlscyxcclxuXHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0Y29udGV4dFxyXG5cdFx0KSk7XHJcblxyXG5cdFx0JGNvcHlUb0lkQnV0dG9uLm9uKCdjbGljaycsICgpID0+IHtcclxuXHRcdFx0VGh1bmRlci51dGlsLmNvcHlUb0NsaXBib2FyZCgkY29weVRvSWQpO1xyXG5cdFx0fSk7XHJcblxyXG5cdH07XHJcblxyXG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcclxuXHJcbn07IiwiY29uc3QgZ2V0ID0gcmVxdWlyZSgnbG9kYXNoLmdldCcpO1xyXG5jb25zdCBzZXQgPSByZXF1aXJlKCdsb2Rhc2guc2V0Jyk7XHJcbmNvbnN0IGNhbWVsQ2FzZSA9IHJlcXVpcmUoJ2xvZGFzaC5jYW1lbGNhc2UnKTtcclxuY29uc3QgQ291cG9uSGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL2NvdXBvbkhhbmRsZXIuanMnKTtcclxuY29uc3QgQ3VzdG9tZXJIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvY3VzdG9tZXJIYW5kbGVyLmpzJyk7XHJcbmNvbnN0IEFkZHJlc3NIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvYWRkcmVzc0hhbmRsZXIuanMnKTtcclxuY29uc3QgU3Vic2NyaXB0aW9uSGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL3N1YnNjcmlwdGlvbkhhbmRsZXIuanMnKTtcclxuY29uc3QgUmVjYXB0Y2hhSGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL3JlY2FwdGNoYUhhbmRsZXIuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGh1bmRlciA9PiB7XHJcblxyXG5cdGNvbnN0IHRyYW5zbGF0aW9uS2V5cyA9IHtcclxuXHRcdCduYW1lLmZpcnN0JzogJ2ZpcnN0TmFtZScsXHJcblx0XHQnbmFtZS5sYXN0JzogICdsYXN0TmFtZScsXHJcblx0XHQnbmFtZS5mdWxsJzogICdmdWxsTmFtZScsXHJcblx0fTtcclxuXHJcblx0Y29uc3QgaW1wbGVtZW50YXRpb24gPSB7XHJcblx0XHRuYW1lOiAnY2hlY2tvdXQnXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ub3B0aW9ucyA9ICgpID0+ICh7XHJcblx0XHR0eXBlOiAgICAgICAgICAgICAgJ29yZGVyJywgLy8gJ29yZGVyJyBvciAnc3Vic2NyaXB0aW9uJ1xyXG5cdFx0aXRlbXM6ICAgICAgICAgICAgIG51bGwsICAgIC8vIEl0ZW0gZmlsdGVyIC0gZS5nLiwgWydpdGVtMScsICdpdGVtMicsIC4uLl1cclxuXHRcdGN1c3RvbWVyRmllbGRzOiAgICBUaHVuZGVyLm9wdGlvbnMuY3VzdG9tZXJPcmRlckZpZWxkcyxcclxuXHRcdHJlY2lwaWVudEZpZWxkczogICBUaHVuZGVyLm9wdGlvbnMucmVjaXBpZW50RmllbGRzLFxyXG5cdFx0YWRkcmVzc0Rpc2FibGVkOiAgIFRodW5kZXIub3B0aW9ucy5hZGRyZXNzRGlzYWJsZWQsXHJcblx0XHRzdWJzY3JpcHRpb25QbGFuczogVGh1bmRlci5vcHRpb25zLnN1YnNjcmlwdGlvblBsYW5zLFxyXG5cdFx0dGVybXNMaW5rOiAgICAgICAgIFRodW5kZXIub3B0aW9ucy5sZWdhbC5vcmRlclRlcm1zLmxpbmssXHJcblx0XHR0ZXJtc1RleHQ6ICAgICAgICAgVGh1bmRlci5vcHRpb25zLmxlZ2FsLm9yZGVyVGVybXMudGV4dCxcclxuXHRcdHByaXZhY3lMaW5rOiAgICAgICBUaHVuZGVyLm9wdGlvbnMubGVnYWwub3JkZXJQcml2YWN5LmxpbmssXHJcblx0XHRwcml2YWN5VGV4dDogICAgICAgVGh1bmRlci5vcHRpb25zLmxlZ2FsLm9yZGVyUHJpdmFjeS50ZXh0LFxyXG5cdFx0b25DaGVja291dFN1Y2Nlc3M6IGZ1bmN0aW9uKCRjb250YWluZXIsIGNvbnRleHQsIGNoZWNrb3V0RGV0YWlsKSB7XHJcblxyXG5cdFx0XHRjb25zdCB7IG9yZGVyLCBzdWJzY3JpcHRpb24gfSA9IGNoZWNrb3V0RGV0YWlsO1xyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIucmVuZGVyKCRjb250YWluZXIsICdjaGVja291dC1zdWNjZXNzJywge1xyXG5cdFx0XHRcdHR5cGU6ICAgIHN1YnNjcmlwdGlvbiA/ICdzdWJzY3JpcHRpb24nIDogJ29yZGVyJyxcclxuXHRcdFx0XHRzdWJqZWN0OiAoc3Vic2NyaXB0aW9uIHx8IG9yZGVyKS5faWQsXHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHRcdG9uUGF5bWVudEZhaWx1cmU6IGZ1bmN0aW9uKCRjb250YWluZXIsIGNvbnRleHQsIGNoZWNrb3V0RGV0YWlsKSB7XHJcblxyXG5cdFx0XHRjb25zdCB7IG9yZGVyLCBzdWJzY3JpcHRpb24gfSA9IGNoZWNrb3V0RGV0YWlsO1xyXG5cdFx0XHRjb25zdCB0eXBlID0gc3Vic2NyaXB0aW9uID8gJ3N1YnNjcmlwdGlvbicgOiAnb3JkZXInO1xyXG5cclxuXHRcdFx0VGh1bmRlci5ub3RpZnkoJ2Vycm9yJywgY29udGV4dC5tKCdwYXltZW50RmFpbGVkJykpO1xyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIucmVuZGVyKCRjb250YWluZXIsIGAke3R5cGV9LWRldGFpbGAsIHtcclxuXHRcdFx0XHRbdHlwZV06IChzdWJzY3JpcHRpb24gfHwgb3JkZXIpLl9pZFxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLnByZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcblxyXG5cdFx0Y29uc3Qge1xyXG5cdFx0XHR0eXBlLFxyXG5cdFx0XHRpdGVtcyxcclxuXHRcdFx0Y3VzdG9tZXJGaWVsZHMsXHJcblx0XHRcdHJlY2lwaWVudEZpZWxkcyxcclxuXHRcdFx0c3Vic2NyaXB0aW9uUGxhbnMsXHJcblx0XHRcdHRlcm1zTGluayxcclxuXHRcdFx0dGVybXNUZXh0LFxyXG5cdFx0XHRwcml2YWN5TGluayxcclxuXHRcdFx0cHJpdmFjeVRleHQsXHJcblx0XHR9ID0gY29udGV4dC5vcHRpb25zO1xyXG5cclxuXHRcdGNvbnRleHQuYWdyZWVtZW50cyA9IFtcclxuXHRcdFx0KHRlcm1zTGluayB8fCB0ZXJtc1RleHQpID8gJ3Rlcm1zJyA6IG51bGwsXHJcblx0XHRcdChwcml2YWN5TGluayB8fCBwcml2YWN5VGV4dCkgPyAncHJpdmFjeScgOiBudWxsLFxyXG5cdFx0XS5maWx0ZXIodiA9PiB2KTtcclxuXHJcblx0XHRjb25zdCAkY29udGFpbmVyID0gJCh0aGlzKTtcclxuXHJcblx0XHRjb25zdCBkZWZhdWx0Q2FydFF1ZXJ5ID0gaXRlbXMgPyB7IGl0ZW1zOiBpdGVtcy50b1N0cmluZygpIH0gOiB7fTtcclxuXHRcdGNvbnN0IGRlZmF1bHRDYXJ0RGF0YSA9IHt9O1xyXG5cclxuXHRcdGNvbnN0IGRpc2FibGVkQWRkcmVzc0ZpZWxkcyA9XHJcblx0XHRcdFRodW5kZXIudXRpbC5wYXJzZUFycmF5U3RyaW5nKGNvbnRleHQub3B0aW9ucy5hZGRyZXNzRGlzYWJsZWQpXHJcblx0XHRcdFx0LnJlZHVjZSgobywgZmllbGQpID0+IHNldChvLCBmaWVsZCwgdHJ1ZSksIHt9KTtcclxuXHJcblx0XHRjb250ZXh0LmlzU3Vic2NyaXB0aW9uID0gY29udGV4dC5vcHRpb25zLnR5cGUgPT09ICdzdWJzY3JpcHRpb24nO1xyXG5cclxuXHRcdGNvbnRleHQudXNlU2VhcmNoQWRkcmVzcyA9ICEhVGh1bmRlci5wbHVnaW5zLnNlYXJjaEFkZHJlc3M7XHJcblxyXG5cdFx0Y29udGV4dC5kaXNhYmxlZCA9IGZpZWxkID0+IHtcclxuXHRcdFx0cmV0dXJuIGRpc2FibGVkQWRkcmVzc0ZpZWxkc1tmaWVsZF0gJiZcclxuXHRcdFx0XHRcdGNvbnRleHQudXNlU2VhcmNoQWRkcmVzcyA/ICdyZWFkb25seScgOiAnJztcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgdG9GaWVsZERldGFpbCA9IChwcmVmaXggPSAnJykgPT4gZmllbGQgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3QgW2tleSwgcmVxdWlyZWRdID0gZmllbGQuc3BsaXQoJzonKTtcclxuXHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0cmVxdWlyZWQ6ICAgICAgIHJlcXVpcmVkID09PSAncmVxdWlyZWQnLFxyXG5cdFx0XHRcdGtleTogICAgICAgICAgICBrZXksXHJcblx0XHRcdFx0dHJhbnNsYXRpb25LZXk6IGNhbWVsQ2FzZShbcHJlZml4LCB0cmFuc2xhdGlvbktleXNba2V5XSB8fCBrZXldKVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0Y29udGV4dC5jdXN0b21lckZpZWxkcyA9XHJcblx0XHRcdFRodW5kZXIudXRpbC5wYXJzZUFycmF5U3RyaW5nKGN1c3RvbWVyRmllbGRzKVxyXG5cdFx0XHRcdC5tYXAodG9GaWVsZERldGFpbCgnY3VzdG9tZXInKSk7XHJcblxyXG5cdFx0Y29udGV4dC5yZWNpcGllbnRGaWVsZHMgPVxyXG5cdFx0XHRUaHVuZGVyLnV0aWwucGFyc2VBcnJheVN0cmluZyhyZWNpcGllbnRGaWVsZHMpXHJcblx0XHRcdFx0Lm1hcCh0b0ZpZWxkRGV0YWlsKCdhZGRyZXNzJykpO1xyXG5cclxuXHRcdGNvbnN0IHJlcXVlc3RGYWlsZWQgPSBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdGVyci5yZXNwb25zZUpTT04sXHJcblx0XHRcdHtcclxuXHRcdFx0XHRkZWZhdWx0OiBjb250ZXh0Lm0oJ2NoZWNrb3V0UHJlcGFyYXRpb25GYWlsZWQnKVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRjYWxsYmFja1xyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gJC53aGVuKFRodW5kZXIuYXV0aGVudGljYXRlZCgpID8gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0bWV0aG9kOiAnR0VUJyxcclxuXHRcdFx0dXJsOiAgICAnL3YxL21lJyxcclxuXHRcdFx0cXVlcnk6ICB7XHJcblx0XHRcdFx0cmF3OiAgICB0cnVlLFxyXG5cdFx0XHRcdGZpZWxkczogW1xyXG5cdFx0XHRcdFx0J25hbWUnLFxyXG5cdFx0XHRcdFx0J2VtYWlsJyxcclxuXHRcdFx0XHRcdCdtb2JpbGUnLFxyXG5cdFx0XHRcdFx0J3Bob25lJyxcclxuXHRcdFx0XHRcdCdnZW5kZXInLFxyXG5cdFx0XHRcdFx0J2JpcnRoZGF0ZScsXHJcblx0XHRcdFx0XHQnY291bnRyeScsXHJcblx0XHRcdFx0XHQnbGFuZ3VhZ2UnLFxyXG5cdFx0XHRcdFx0J2N1cnJlbmN5JyxcclxuXHRcdFx0XHRcdCd0aW1lem9uZScsXHJcblx0XHRcdFx0XHQnYWRkcmVzcy5wcmltYXJ5JyxcclxuXHRcdFx0XHRdLmpvaW4oJywnKVxyXG5cdFx0XHR9XHJcblx0XHR9KSA6IG51bGwpLnRoZW4oY3VzdG9tZXIgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3QgcHJpbWFyeUFkZHJlc3MgPSBnZXQoY3VzdG9tZXIsICdhZGRyZXNzLnByaW1hcnknLCBudWxsKTtcclxuXHJcblx0XHRcdGlmIChwcmltYXJ5QWRkcmVzcykge1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0Q2FydERhdGEuYWRkcmVzcyA9IHtcclxuXHRcdFx0XHRcdHNoaXBwaW5nOiBwcmltYXJ5QWRkcmVzcyxcclxuXHRcdFx0XHRcdGJpbGxpbmc6ICBwcmltYXJ5QWRkcmVzc1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnRleHQuY3VzdG9tZXIgPSBjdXN0b21lciB8fCBudWxsO1xyXG5cdFx0XHRjb250ZXh0LmFkZHJlc3MgPSBwcmltYXJ5QWRkcmVzcyB8fCBBZGRyZXNzSGFuZGxlci5kZWZhdWx0QWRkcmVzcygpO1xyXG5cclxuXHRcdFx0cmV0dXJuICQud2hlbihcclxuXHRcdFx0XHRUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdFx0bWV0aG9kOiAnR0VUJyxcclxuXHRcdFx0XHRcdHVybDogICAgJy92MS9jb3VudHJpZXMnLFxyXG5cdFx0XHRcdFx0cXVlcnk6ICB7IGZpZWxkczogJ2NvZGUnLCBsaW1pdDogMTIwLCBwYWdlOiAxIH0sXHJcblx0XHRcdFx0fSksXHJcblx0XHRcdFx0VGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRcdG1ldGhvZDogJ0dFVCcsXHJcblx0XHRcdFx0XHR1cmw6ICAgICcvdjEvY291bnRyaWVzJyxcclxuXHRcdFx0XHRcdHF1ZXJ5OiAgeyBmaWVsZHM6ICdjb2RlJywgbGltaXQ6IDEyMCwgcGFnZTogMiB9LFxyXG5cdFx0XHRcdH0pLFxyXG5cdFx0XHRcdFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0XHRtZXRob2Q6ICdHRVQnLFxyXG5cdFx0XHRcdFx0dXJsOiAgICAnL3YxL2NvdW50cmllcycsXHJcblx0XHRcdFx0XHRxdWVyeTogIHsgZmllbGRzOiAnY29kZScsIGxpbWl0OiAxMjAsIHBhZ2U6IDMgfSxcclxuXHRcdFx0XHR9KSxcclxuXHRcdFx0XHRnZXRDYXJ0KHtcclxuXHRcdFx0XHRcdHF1ZXJ5OiBkZWZhdWx0Q2FydFF1ZXJ5LFxyXG5cdFx0XHRcdFx0ZGF0YTogIGRlZmF1bHRDYXJ0RGF0YSxcclxuXHRcdFx0XHR9KSxcclxuXHRcdFx0XHRUaHVuZGVyLmF1dGhlbnRpY2F0ZWQoKSA/IFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0XHRtZXRob2Q6ICdHRVQnLFxyXG5cdFx0XHRcdFx0dXJsOiAgICAnL3YxL21lL2NvdXBvbnMnLFxyXG5cdFx0XHRcdFx0cXVlcnk6ICB7XHJcblx0XHRcdFx0XHRcdGxpbWl0OiAxMjAsXHJcblx0XHRcdFx0XHRcdGZpZWxkczogW1xyXG5cdFx0XHRcdFx0XHRcdCduYW1lJyxcclxuXHRcdFx0XHRcdFx0XHQnYWN0aXZlJyxcclxuXHRcdFx0XHRcdFx0XHQnb25seScsXHJcblx0XHRcdFx0XHRcdFx0J3R5cGUnLFxyXG5cdFx0XHRcdFx0XHRcdCdkaXNjb3VudCcsXHJcblx0XHRcdFx0XHRcdFx0J2NhdGVnb3J5JyxcclxuXHRcdFx0XHRcdFx0XHQncHJpY2UnLFxyXG5cdFx0XHRcdFx0XHRcdCdzdWJzY3JpcHRpb24nLFxyXG5cdFx0XHRcdFx0XHRcdCdleHBpcmVzQXQnXHJcblx0XHRcdFx0XHRcdF0uam9pbignLCcpXHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdH0pIDogbnVsbCxcclxuXHRcdFx0XHRjb250ZXh0LmlzU3Vic2NyaXB0aW9uID8gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRcdG1ldGhvZDogJ0dFVCcsXHJcblx0XHRcdFx0XHR1cmw6ICAgICcvdjEvc3Vic2NyaXB0aW9ucy9wbGFucycsXHJcblx0XHRcdFx0XHRxdWVyeToge1xyXG5cdFx0XHRcdFx0XHRpZHM6ICAgIHN1YnNjcmlwdGlvblBsYW5zLm1hcCgoeyBpZCB9KSA9PiBpZCkuam9pbignLCcpLFxyXG5cdFx0XHRcdFx0XHRmaWVsZHM6IFsnbmFtZScsICdpbW1lZGlhdGUnLCAnaW50ZXJ2YWwnXS5qb2luKCcsJyksXHJcblx0XHRcdFx0XHRcdHNvcnQ6ICAgJ2lkcycsXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSkgOiBudWxsXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0fSwgcmVxdWVzdEZhaWxlZCkudGhlbigoXHJcblx0XHRcdGNvdW50cmllczEsXHJcblx0XHRcdGNvdW50cmllczIsXHJcblx0XHRcdGNvdW50cmllczMsXHJcblx0XHRcdGNhcnQsXHJcblx0XHRcdGNvdXBvbnMsXHJcblx0XHRcdHBsYW5zXHJcblx0XHQpID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IGhhc0NhcnRFcnJvciA9IGNhcnRbMF0uY2FydC5lcnJvcnNcclxuXHRcdFx0XHRcdFx0XHRcdFx0LnNvbWUoZXJyID0+IGVyci5jb2RlICE9PSAnc2hpcHBpbmctYWRkcmVzcy1yZXF1aXJlZCcpO1xyXG5cclxuXHRcdFx0aWYgKGhhc0NhcnRFcnJvcikge1xyXG5cdFx0XHRcdHJldHVybiBUaHVuZGVyLnJlbmRlcigkY29udGFpbmVyLCAnY2FydCcsIHtcclxuXHRcdFx0XHRcdG9yZGVyQWN0aW9uczogT2JqZWN0LmtleXMoVGh1bmRlci5vcHRpb25zLnBheW1lbnRNZXRob2RzKSxcclxuXHRcdFx0XHRcdGl0ZW1zOiAgICAgICAgY29udGV4dC5vcHRpb25zLml0ZW1zXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnRleHQuY291bnRyaWVzID0gW10uY29uY2F0KFxyXG5cdFx0XHRcdGNvdW50cmllczFbMF0sXHJcblx0XHRcdFx0Y291bnRyaWVzMlswXSxcclxuXHRcdFx0XHRjb3VudHJpZXMzWzBdXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRjb250ZXh0LmNhcnQgPSBjYXJ0WzBdLmNhcnQ7XHJcblx0XHRcdGNvbnRleHQuc3Vic2NyaXB0aW9uID0gY2FydFswXS5zdWJzY3JpcHRpb24gfHwgbnVsbDtcclxuXHRcdFx0Y29udGV4dC5zdWJzY3JpcHRpb25QbGFucyA9IChwbGFucyA/IHBsYW5zWzBdIDogW10pLm1hcChwbGFuID0+IHtcclxuXHRcdFx0XHRyZXR1cm4gJC5leHRlbmQocGxhbiwgc3Vic2NyaXB0aW9uUGxhbnMuZmluZChzID0+IHMuaWQgPT09IHBsYW4uX2lkKSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRjb250ZXh0LmNvdXBvbnMgPSBjb3Vwb25zID8gY291cG9uc1swXSA6IFtdO1xyXG5cclxuXHRcdFx0Q291cG9uSGFuZGxlci5zZXRBcHBsaWNhYmxlQ291cG9ucyhcclxuXHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMudHlwZSxcclxuXHRcdFx0XHRjb250ZXh0LmNhcnQsXHJcblx0XHRcdFx0Y29udGV4dC5jb3Vwb25zXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgY29udGV4dCk7XHJcblxyXG5cdFx0fSwgcmVxdWVzdEZhaWxlZCk7XHJcblxyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLmluaXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcblxyXG5cdFx0Y29uc3QgJHBheW1lbnRGb3JtQ29udGFpbmVyID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tcGF5bWVudC1mb3JtLWNvbnRhaW5lcicpO1xyXG5cclxuXHRcdFRodW5kZXIucmVuZGVyKCRwYXltZW50Rm9ybUNvbnRhaW5lciwgJ3BheW1lbnQtZm9ybScsIHtcclxuXHRcdFx0dHlwZTogY29udGV4dC5vcHRpb25zLnR5cGVcclxuXHRcdH0sIChlcnIsIHsgaW50ZXJmYWNlczogcGF5bWVudEhhbmRsZXIgfSkgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3QgJGNvbnRhaW5lciA9ICQodGhpcyk7XHJcblx0XHRcdGNvbnN0ICRiYWNrVG9DYXJ0ID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tYmFjay10by1jYXJ0Jyk7XHJcblx0XHRcdGNvbnN0ICRjYXJ0SXRlbXMgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1jYXJ0LWl0ZW1zIHRhYmxlJyk7XHJcblx0XHRcdGNvbnN0ICRnb1RvVXBkYXRlQ3VzdG9tZXIgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1nby10by11cGRhdGUtY3VzdG9tZXInKTtcclxuXHRcdFx0Y29uc3QgJHNhbWVGb3JSZWNpcGllbnQgPSAkKHRoaXMpLmZpbmQoJ1tuYW1lPVwic2FtZUZvclJlY2lwaWVudFwiXScpO1xyXG5cdFx0XHRjb25zdCAkc2F2ZUFzUHJpbWFyeUFkZHJlc3MgPSAkKHRoaXMpLmZpbmQoJyN0aHVuZGVyLS1zYXZlLXByaW1hcnktYWRkcmVzcy1hZ3JlZW1lbnQnKTtcclxuXHRcdFx0Y29uc3QgJHNlYXJjaEFkZHJlc3MgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1zZWFyY2gtYWRkcmVzcycpO1xyXG5cdFx0XHRjb25zdCAkZGlzYWJsZWRBZGRyZXNzSW5wdXRzID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tYWRkcmVzcy1sb2NhdGlvbiBkaXYgW3JlYWRvbmx5XScpLnBhcmVudCgpO1xyXG5cdFx0XHRjb25zdCAkYXBwbHlBZGRyZXNzID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tYXBwbHktYWRkcmVzcycpO1xyXG5cdFx0XHRjb25zdCAkb3JkZXJSZXF1ZXN0ID0gJCh0aGlzKS5maW5kKCdbbmFtZT1cInJlcXVlc3RcIl0nKTtcclxuXHRcdFx0Y29uc3QgJHRvdGFsRGV0YWlscyA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXRvdGFsLWRldGFpbHMnKTtcclxuXHRcdFx0Y29uc3QgJHByb2NlZWRDaGVja291dCA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXByb2NlZWQtY2hlY2tvdXQnKTtcclxuXHRcdFx0Y29uc3QgcHJvY2Vzc0NoZWNrb3V0U3Bpbm5lciA9IFRodW5kZXIudXRpbC5tYWtlQXN5bmNCdXR0b24oJHByb2NlZWRDaGVja291dCwgeyBiaW5kOiBmYWxzZSB9KTtcclxuXHJcblx0XHRcdGNvbnN0IGFyZVRlcm1zQWdyZWVkID0gVGh1bmRlci51dGlsLmJpbmRBZ3JlZW1lbnRzKHtcclxuXHRcdFx0XHQkdGVybXM6ICQodGhpcykuZmluZCgnW2RhdGEtYWdyZWVtZW50LXNjb3BlXScpLFxyXG5cdFx0XHRcdGFncmVlbWVudHM6IHtcclxuXHRcdFx0XHRcdHRlcm1zOiAgIHtcclxuXHRcdFx0XHRcdFx0dGV4dDogIGNvbnRleHQub3B0aW9ucy50ZXJtc1RleHQsXHJcblx0XHRcdFx0XHRcdGxpbms6ICBjb250ZXh0Lm9wdGlvbnMudGVybXNMaW5rLFxyXG5cdFx0XHRcdFx0XHRlcnJvcjogY29udGV4dC5tKCd0ZXJtc0FncmVlbWVudFJlcXVpcmVkJylcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRwcml2YWN5OiB7XHJcblx0XHRcdFx0XHRcdHRleHQ6ICBjb250ZXh0Lm9wdGlvbnMucHJpdmFjeVRleHQsXHJcblx0XHRcdFx0XHRcdGxpbms6ICBjb250ZXh0Lm9wdGlvbnMucHJpdmFjeUxpbmssXHJcblx0XHRcdFx0XHRcdGVycm9yOiBjb250ZXh0Lm0oJ3ByaXZhY3lBZ3JlZW1lbnRSZXF1aXJlZCcpXHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjb25zdCBjb3Vwb25IYW5kbGVyID0gQ291cG9uSGFuZGxlcih7XHJcblx0XHRcdFx0Zm9ybTogICAgJCh0aGlzKS5maW5kKCcudGh1bmRlci0tY2FydC1pdGVtcycpLFxyXG5cdFx0XHRcdGxhYmVsczogIHtcclxuXHRcdFx0XHRcdGFwcGx5Q291cG9uczogICAgICAgICAgY29udGV4dC5tKCdhcHBseUNvdXBvbnMnKSxcclxuXHRcdFx0XHRcdGZpbmlzaEFwcGx5aW5nQ291cG9uczogY29udGV4dC5tKCdmaW5pc2hBcHBseWluZ0NvdXBvbnMnKSxcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGNvdXBvbnM6ICAgICAgICAgICAgIGNvbnRleHQuY291cG9ucyxcclxuXHRcdFx0XHRjYXJ0OiAgICAgICAgICAgICAgICAoKSA9PiBjb250ZXh0LmNhcnQsXHJcblx0XHRcdFx0b25Db3Vwb25BcHBseTogICAgICAgdHlwZSA9PiBhcHBseUNvdXBvbnModHlwZSksXHJcblx0XHRcdFx0b25Db3Vwb25TZWxlY3RFcnJvcjogY29kZSA9PiBUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBjb250ZXh0Lm0oY29kZSkpXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29uc3QgY3VzdG9tZXJIYW5kbGVyID0gQ3VzdG9tZXJIYW5kbGVyKHtcclxuXHRcdFx0XHRjdXN0b21lckZpZWxkczogY29udGV4dC5jdXN0b21lckZpZWxkcy5tYXAoKHsga2V5LCByZXF1aXJlZCB9KSA9PiAoe1xyXG5cdFx0XHRcdFx0ZmllbGQ6ICAgIGtleSxcclxuXHRcdFx0XHRcdHJlcXVpcmVkOiByZXF1aXJlZFxyXG5cdFx0XHRcdH0pKVxyXG5cdFx0XHRcdC5tYXAoZGV0YWlsID0+ICQuZXh0ZW5kKGRldGFpbCwge1xyXG5cdFx0XHRcdFx0JGlucHV0OiAkKHRoaXMpLmZpbmQoYC50aHVuZGVyLS1jdXN0b21lciBbbmFtZT1cImN1c3RvbWVyLiR7ZGV0YWlsLmZpZWxkfVwiXWApXHJcblx0XHRcdFx0fSkpLFxyXG5cdFx0XHRcdHRyYW5zbGF0aW9uS2V5czogdHJhbnNsYXRpb25LZXlzLFxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGNvbnN0IGFkZHJlc3NIYW5kbGVyID0gQWRkcmVzc0hhbmRsZXIoe1xyXG5cdFx0XHRcdGFkZHJlc3NGaWVsZHM6IFtcclxuXHRcdFx0XHRcdC4uLmNvbnRleHQucmVjaXBpZW50RmllbGRzLm1hcCgoeyBrZXksIHJlcXVpcmVkIH0pID0+ICh7XHJcblx0XHRcdFx0XHRcdGZpZWxkOiAgICAga2V5LFxyXG5cdFx0XHRcdFx0XHRyZWNpcGllbnQ6IHRydWUsXHJcblx0XHRcdFx0XHRcdHJlcXVpcmVkOiAgcmVxdWlyZWRcclxuXHRcdFx0XHRcdH0pKSxcclxuXHRcdFx0XHRcdHsgZmllbGQ6ICdjb3VudHJ5JywgcmVxdWlyZWQ6IHRydWUgfSxcclxuXHRcdFx0XHRcdHsgZmllbGQ6ICdzdGF0ZScsIHJlcXVpcmVkOiBmYWxzZSB9LFxyXG5cdFx0XHRcdFx0eyBmaWVsZDogJ2NpdHknLCByZXF1aXJlZDogdHJ1ZSB9LFxyXG5cdFx0XHRcdFx0eyBmaWVsZDogJ2FkZHJlc3MxJywgcmVxdWlyZWQ6IHRydWUgfSxcclxuXHRcdFx0XHRcdHsgZmllbGQ6ICdhZGRyZXNzMicsIHJlcXVpcmVkOiBmYWxzZSB9LFxyXG5cdFx0XHRcdFx0eyBmaWVsZDogJ3Bvc3Rjb2RlJywgcmVxdWlyZWQ6IHRydWUgfSxcclxuXHRcdFx0XHRdLm1hcChkZXRhaWwgPT4gJC5leHRlbmQoZGV0YWlsLCB7XHJcblx0XHRcdFx0XHQkaW5wdXQ6ICQodGhpcykuZmluZChbXHJcblx0XHRcdFx0XHRcdCcudGh1bmRlci0tcmVjaXBpZW50LWluZm8nLFxyXG5cdFx0XHRcdFx0XHQnLnRodW5kZXItLWFkZHJlc3MnLFxyXG5cdFx0XHRcdFx0XS5qb2luKCcsJykpXHJcblx0XHRcdFx0XHQuZmluZChgW25hbWU9XCJhZGRyZXNzLiR7ZGV0YWlsLmZpZWxkfVwiXWApXHJcblx0XHRcdFx0fSkpLFxyXG5cdFx0XHRcdHRyYW5zbGF0aW9uS2V5czogICAgIHRyYW5zbGF0aW9uS2V5cyxcclxuXHRcdFx0XHRzZWFyY2hBZGRyZXNzUGx1Z2luOiBUaHVuZGVyLnBsdWdpbnMuc2VhcmNoQWRkcmVzc1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGNvbnN0IGRlYm91bmNlZEFwcGx5U3Vic2NyaXB0aW9uRGV0YWlsID0gVGh1bmRlci51dGlsLmRlYm91bmNlKFxyXG5cdFx0XHRcdGFwcGx5U3Vic2NyaXB0aW9uRGV0YWlsLFxyXG5cdFx0XHRcdDEwMCxcclxuXHRcdFx0XHR0cnVlXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRjb25zdCBzdWJzY3JpcHRpb25IYW5kbGVyID0gU3Vic2NyaXB0aW9uSGFuZGxlcih7XHJcblx0XHRcdFx0Zm9ybTogICAgICAgICAgICAgICQodGhpcykuZmluZCgnLnRodW5kZXItLXN1YnNjcmlwdGlvbi1kZXRhaWxzJyksXHJcblx0XHRcdFx0bGFiZWxzOiAgICAgICAgICAgIHtcclxuXHRcdFx0XHRcdGZpcnN0T3JkZXJTdGFydHNBdDogIGNvbnRleHQubSgnZmlyc3RPcmRlclN0YXJ0c0F0JyksXHJcblx0XHRcdFx0XHRzZWNvbmRPcmRlclN0YXJ0c0F0OiBjb250ZXh0Lm0oJ3NlY29uZE9yZGVyU3RhcnRzQXQnKSxcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHN1YnNjcmlwdGlvblBsYW5zOiBjb250ZXh0LnN1YnNjcmlwdGlvblBsYW5zLFxyXG5cdFx0XHRcdHRpbWV6b25lOiAgICAgICAgICAoKSA9PiBUaHVuZGVyLm9wdGlvbnMudGltZXpvbmUsXHJcblx0XHRcdFx0b25QbGFuQ2hhbmdlOiAgICAgICgpID0+IGRlYm91bmNlZEFwcGx5U3Vic2NyaXB0aW9uRGV0YWlsKCksXHJcblx0XHRcdFx0b25TdGFydHNBdENoYW5nZTogICgpID0+IGRlYm91bmNlZEFwcGx5U3Vic2NyaXB0aW9uRGV0YWlsKClcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRUaHVuZGVyLnV0aWwuYmluZEJhY2tCdXR0b24oJGJhY2tUb0NhcnQsIGNvbnRleHQpO1xyXG5cclxuXHRcdFx0Y3VzdG9tZXJIYW5kbGVyLnNldEN1c3RvbWVyKGNvbnRleHQuY3VzdG9tZXIpO1xyXG5cdFx0XHRhZGRyZXNzSGFuZGxlci5zZXRBZGRyZXNzKGNvbnRleHQuYWRkcmVzcyk7XHJcblxyXG5cdFx0XHQkc2FtZUZvclJlY2lwaWVudC5vbignY2hhbmdlJywgY29weVRvUmVjaXBpZW50KTtcclxuXHRcdFx0JGFwcGx5QWRkcmVzcy5vbignY2xpY2snLCBhcHBseUNoYW5nZXMpO1xyXG5cdFx0XHQkc2VhcmNoQWRkcmVzcy5vbignY2xpY2snLCBzZWFyY2hBZGRyZXNzKTtcclxuXHRcdFx0JGRpc2FibGVkQWRkcmVzc0lucHV0cy5vbignY2xpY2snLCBzZWFyY2hBZGRyZXNzKTtcclxuXHJcblx0XHRcdCRnb1RvVXBkYXRlQ3VzdG9tZXIub24oJ2NsaWNrJywgKCkgPT4ge1xyXG5cdFx0XHRcdHJldHVybiBUaHVuZGVyLnJlbmRlcigkY29udGFpbmVyLCAnY3VzdG9tZXItdXBkYXRlJywge1xyXG5cdFx0XHRcdFx0YmFjazogIHtcclxuXHRcdFx0XHRcdFx0JGNvbnRhaW5lcjogJGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdFx0Y29tcG9uZW50OiAgaW1wbGVtZW50YXRpb24ubmFtZSxcclxuXHRcdFx0XHRcdFx0b3B0aW9uczogICAgY29udGV4dC5vcHRpb25zXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gSXQncyBhIGJpdCBoYWNreSB3YXkgdG8gaGFuZGxlIHJlQ0FQVENIQSxcclxuXHRcdFx0Ly8gYnV0IGlmIGEgc3RvcmUgdXNlcyByZUNBVFBDSEEgZm9yIGNoZWNrb3V0IGFuZCBvcmRlci9zdWJzY3JpcHRpb24gYXV0aCxcclxuXHRcdFx0Ly8gYmluZCByZUNBVFBDSEEgdHdpY2UgZm9yIHRoZSBzYW1lIGJ1dHRvbiB0byBnZXQgdHdvIHJlQ0FQVENIQSByZXNwb25zZXMuXHJcblx0XHRcdGNvbnN0IHJlY2FwdGNoYUNvbXBvbmVudHMgPSBbXHJcblx0XHRcdFx0aW1wbGVtZW50YXRpb24ubmFtZSxcclxuXHRcdFx0XHQnc2VhcmNoLXB1cmNoYXNlJ1xyXG5cdFx0XHRdO1xyXG5cclxuXHRcdFx0Y29uc3QgcmVjYXB0Y2hhSGFuZGxlciA9IFJlY2FwdGNoYUhhbmRsZXIoXHJcblx0XHRcdFx0cmVjYXB0Y2hhQ29tcG9uZW50c1xyXG5cdFx0XHRcdFx0LmZpbHRlcihUaHVuZGVyLnV0aWwudXNlUmVjYXB0Y2hhKVxyXG5cdFx0XHRcdFx0LnJlZHVjZSgobywgYykgPT4gc2V0KG8sIGMsIHRydWUpLCB7fSlcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHJlY2FwdGNoYUNvbXBvbmVudHMuZm9yRWFjaChjb21wb25lbnROYW1lID0+IFRodW5kZXIudXRpbC5tYWtlUmVjYXB0Y2hhKHtcclxuXHRcdFx0XHRjb21wb25lbnROYW1lOiBjb21wb25lbnROYW1lLFxyXG5cdFx0XHRcdGJ1dHRvbjogICAgICAgICRwcm9jZWVkQ2hlY2tvdXQsXHJcblx0XHRcdFx0dmFsaWRhdGU6ICAgICAgdmFsaWRhdGVDaGVja291dERhdGEsXHJcblx0XHRcdFx0Y2FsbGJhY2s6ICAgICAgcHJvY2VlZENoZWNrb3V0XHJcblx0XHRcdH0pKTtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGNvcHlUb1JlY2lwaWVudCgpIHtcclxuXHRcdFx0XHRyZXR1cm4gJCh0aGlzKS5pcygnOmNoZWNrZWQnKSA/XHJcblx0XHRcdFx0XHRcdGFkZHJlc3NIYW5kbGVyLnNldEFkZHJlc3MoY3VzdG9tZXJIYW5kbGVyLmdldEN1c3RvbWVyKCkpIDpcclxuXHRcdFx0XHRcdFx0YWRkcmVzc0hhbmRsZXIucmVzZXQoJ3JlY2lwaWVudCcpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBhcHBseUNoYW5nZXMoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IG9wdGlvbnMgPSBidWlsZENhcnRPcHRpb25zKCk7XHJcblx0XHRcdFx0Y29uc3QgYWRkcmVzcyA9IG9wdGlvbnMuZGF0YS5hZGRyZXNzLnNoaXBwaW5nO1xyXG5cdFx0XHRcdGNvbnN0IGRpc2NvdW50ID0gb3B0aW9ucy5kYXRhLmRpc2NvdW50O1xyXG5cclxuXHRcdFx0XHRjb25zdCBhZGRyZXNzRXJyb3IgPSBhZGRyZXNzSGFuZGxlci52YWxpZGF0ZUFkZHJlc3MoYWRkcmVzcywgZmFsc2UpO1xyXG5cclxuXHRcdFx0XHQvLyBWYWxpZGF0ZSBzaGlwcGluZyBhZGRyZXNzXHJcblx0XHRcdFx0aWYgKGFkZHJlc3NFcnJvcikge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFRodW5kZXIubm90aWZ5KCdlcnJvcicsIGNvbnRleHQubShhZGRyZXNzRXJyb3IpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IG9sZENhcnRJdGVtcyA9ICRjYXJ0SXRlbXMuaHRtbCgpO1xyXG5cdFx0XHRcdGNvbnN0IG9sZFRvdGFsRGV0YWlscyA9ICR0b3RhbERldGFpbHMuaHRtbCgpO1xyXG5cdFx0XHRcdGNvbnN0IHNlY3Rpb25TcGlubmVyID0gVGh1bmRlci51aSgnc2VjdGlvbi1zcGlubmVyJykoKTtcclxuXHJcblx0XHRcdFx0JGNhcnRJdGVtcy5odG1sKGA8dHI+PHRkPiR7c2VjdGlvblNwaW5uZXJ9PC90ZD48L3RyPmApO1xyXG5cdFx0XHRcdCR0b3RhbERldGFpbHMuaHRtbChzZWN0aW9uU3Bpbm5lcik7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHRcdCdpbnZhbGlkLXBvc3Rjb2RlJzogICAgIGNvbnRleHQubSgnaW52YWxpZFBvc3Rjb2RlJyksXHJcblx0XHRcdFx0XHQnc3RhcnRzLXRvby1lYXJseSc6ICAgICBjb250ZXh0Lm0oJ3N0YXJ0c1Rvb0Vhcmx5JyksXHJcblx0XHRcdFx0XHQnY2FydC1jb3Vwb24tY2F0ZWdvcnknOiBjb250ZXh0Lm0oJ2NhcnRDb3Vwb25DYXRlZ29yeScpLFxyXG5cdFx0XHRcdFx0J2NhcnQtY291cG9uLXByaWNlJzogICAgY29udGV4dC5tKCdjYXJ0Q291cG9uUHJpY2UnKSxcclxuXHRcdFx0XHRcdGRlZmF1bHQ6ICAgICAgICAgICAgICAgIGNvbnRleHQubSgnY2FydFVwZGF0ZUZhaWxlZCcpLFxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdHJldHVybiBnZXRDYXJ0KG9wdGlvbnMpLnRoZW4oKHsgY2FydCwgc3Vic2NyaXB0aW9uIH0pID0+IHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBjYXJ0SGFzSXRlbUVycm9yID0gY2FydC5lcnJvcnMuc29tZShlcnJvciA9PiBlcnJvci5jb2RlID09PSAnaXRlbS1lcnJvcicpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChjYXJ0SGFzSXRlbUVycm9yKSB7XHJcblx0XHRcdFx0XHRcdFRodW5kZXIubm90aWZ5KCdlcnJvcicsIGNvbnRleHQubSgnaW52YWxpZENhcnRJdGVtSW5jbHVkZWQnKSk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBUaHVuZGVyLnJlbmRlcigkY29udGFpbmVyLCAnY2FydCcsIHtcclxuXHRcdFx0XHRcdFx0XHRvcmRlckFjdGlvbnM6IE9iamVjdC5rZXlzKFRodW5kZXIub3B0aW9ucy5wYXltZW50TWV0aG9kcyksXHJcblx0XHRcdFx0XHRcdFx0aXRlbXM6ICAgICAgICBjb250ZXh0Lm9wdGlvbnMuaXRlbXNcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y29udGV4dC5jYXJ0ID0gY2FydDtcclxuXHRcdFx0XHRcdGNvbnRleHQuc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uIHx8IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0Q291cG9uSGFuZGxlci5zZXRBcHBsaWNhYmxlQ291cG9ucyhcclxuXHRcdFx0XHRcdFx0Y29udGV4dC5vcHRpb25zLnR5cGUsXHJcblx0XHRcdFx0XHRcdGNvbnRleHQuY2FydCxcclxuXHRcdFx0XHRcdFx0Y29udGV4dC5jb3Vwb25zXHJcblx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChkaXNjb3VudCkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGRpc2NvdW50Lml0ZW1zKSB7XHJcblx0XHRcdFx0XHRcdFx0ZGlzY291bnQuaXRlbXMuZm9yRWFjaCgoeyBpdGVtLCBjb3Vwb24gfSkgPT4gc2V0KFxyXG5cdFx0XHRcdFx0XHRcdFx0Y29udGV4dC5jYXJ0Lml0ZW1zLmZpbmQoKHsgX2lkIH0pID0+IF9pZCA9PT0gaXRlbSksXHJcblx0XHRcdFx0XHRcdFx0XHQnYXBwbGllZENvdXBvbicsXHJcblx0XHRcdFx0XHRcdFx0XHRjb3Vwb25IYW5kbGVyLmdldENvdXBvbihjb3Vwb24pXHJcblx0XHRcdFx0XHRcdFx0KSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmIChkaXNjb3VudC5jYXJ0KSB7XHJcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5jYXJ0LmFwcGxpZWRDb3Vwb24gPSBjb3Vwb25IYW5kbGVyLmdldENvdXBvbihkaXNjb3VudC5jYXJ0LmNvdXBvbik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgJHRlbXBsYXRlID0gJChUaHVuZGVyLmNvbXBvbmVudChpbXBsZW1lbnRhdGlvbi5uYW1lKS50ZW1wbGF0ZShjb250ZXh0KSk7XHJcblxyXG5cdFx0XHRcdFx0JGNhcnRJdGVtcy5odG1sKCR0ZW1wbGF0ZS5maW5kKCcudGh1bmRlci0tY2FydC1pdGVtcyB0YWJsZScpLmh0bWwoKSk7XHJcblx0XHRcdFx0XHQkdG90YWxEZXRhaWxzLmh0bWwoJHRlbXBsYXRlLmZpbmQoJy50aHVuZGVyLS10b3RhbC1kZXRhaWxzJykuaHRtbCgpKTtcclxuXHJcblx0XHRcdFx0XHRjb3Vwb25IYW5kbGVyLmJpbmRDb3Vwb25WYWxpZGF0b3IoKTtcclxuXHJcblx0XHRcdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0XHRcdGVycm9ycyxcclxuXHRcdFx0XHRcdGVyciA9PiB7XHJcblx0XHRcdFx0XHRcdCRjYXJ0SXRlbXMuaHRtbChvbGRDYXJ0SXRlbXMpO1xyXG5cdFx0XHRcdFx0XHQkdG90YWxEZXRhaWxzLmh0bWwob2xkVG90YWxEZXRhaWxzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHQpKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIHZhbGlkYXRlQ2hlY2tvdXREYXRhKCkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBhZ3JlZWQgPSBhcmVUZXJtc0FncmVlZCgpO1xyXG5cclxuXHRcdFx0XHRpZiAoIWFncmVlZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3Qgb3B0aW9ucyA9IGJ1aWxkQ2FydE9wdGlvbnMoJ2NoZWNrb3V0Jyk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHtcclxuXHRcdFx0XHRcdGFkZHJlc3MsXHJcblx0XHRcdFx0XHRzdWJzY3JpcHRpb24sXHJcblx0XHRcdFx0fSA9IG9wdGlvbnMuZGF0YTtcclxuXHJcblx0XHRcdFx0Ly8gVmFsaWRhdGUgY3VzdG9tZXJcclxuXHRcdFx0XHRjb25zdCBjdXN0b21lciA9IGN1c3RvbWVySGFuZGxlci5nZXRDdXN0b21lcigpO1xyXG5cdFx0XHRcdGNvbnN0IGN1c3RvbWVyRXJyb3IgPSBjdXN0b21lckhhbmRsZXIudmFsaWRhdGVDdXN0b21lcihjdXN0b21lcik7XHJcblxyXG5cdFx0XHRcdGlmIChjdXN0b21lckVycm9yKSB7XHJcblx0XHRcdFx0XHRUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBjb250ZXh0Lm0oY3VzdG9tZXJFcnJvcikpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gVmFsaWRhdGUgYWRkcmVzc2VzXHJcblx0XHRcdFx0Y29uc3QgYWRkcmVzc0Vycm9ycyA9IFtcclxuXHRcdFx0XHRcdGFkZHJlc3Muc2hpcHBpbmcsXHJcblx0XHRcdFx0XHRhZGRyZXNzLmJpbGxpbmdcclxuXHRcdFx0XHRdXHJcblx0XHRcdFx0Lm1hcChhZGRyZXNzSGFuZGxlci52YWxpZGF0ZUFkZHJlc3MpXHJcblx0XHRcdFx0LmZpbHRlcih2ID0+IHYpO1xyXG5cclxuXHRcdFx0XHRpZiAoYWRkcmVzc0Vycm9yc1swXSkge1xyXG5cdFx0XHRcdFx0VGh1bmRlci5ub3RpZnkoJ2Vycm9yJywgY29udGV4dC5tKGFkZHJlc3NFcnJvcnNbMF0pKTtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IHBheW1lbnRFcnJvciA9IHBheW1lbnRIYW5kbGVyLnZhbGlkYXRlKCk7XHJcblxyXG5cdFx0XHRcdGlmIChwYXltZW50RXJyb3IpIHtcclxuXHRcdFx0XHRcdFRodW5kZXIubm90aWZ5KCdlcnJvcicsIHBheW1lbnRFcnJvci5tZXNzYWdlKTtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjb250ZXh0LmlzU3Vic2NyaXB0aW9uKSB7XHJcblx0XHRcdFx0XHQvLyBWYWxpZGF0ZSBvbmx5IGlmIGNoZWNrb3V0IHByb2Nlc3MgaXMgZm9yIGEgc3Vic2NyaXB0aW9uXHJcblx0XHRcdFx0XHRjb25zdCBzdWJzY3JpcHRpb25FcnJvciA9IHN1YnNjcmlwdGlvbkhhbmRsZXIudmFsaWRhdGVTdWJzY3JpcHRpb25EZXRhaWwoc3Vic2NyaXB0aW9uKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoc3Vic2NyaXB0aW9uRXJyb3IpIHtcclxuXHRcdFx0XHRcdFx0VGh1bmRlci5ub3RpZnkoJ2Vycm9yJywgY29udGV4dC5tKHN1YnNjcmlwdGlvbkVycm9yKSk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gcHJvY2VlZENoZWNrb3V0KHRva2VuLCByZXNldFJlY2FwdGNoYSkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBzaG91bGRFeGVjdXRlID0gcmVjYXB0Y2hhSGFuZGxlci5leGVjdXRlKHRva2VuKTtcclxuXHJcblx0XHRcdFx0aWYgKCFzaG91bGRFeGVjdXRlKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdGNvbnN0IHtcclxuXHRcdFx0XHRcdGNoZWNrb3V0OiAgICAgICAgICBjaGVja291dFJlcyxcclxuXHRcdFx0XHRcdCdzZWFyY2gtcHVyY2hhc2UnOiBzZWFyY2hQdXJjaGFzZVJlc1xyXG5cdFx0XHRcdH0gPSBzaG91bGRFeGVjdXRlO1xyXG5cclxuXHRcdFx0XHRwcm9jZXNzQ2hlY2tvdXRTcGlubmVyLnJ1bigpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBvcHRpb25zID0gYnVpbGRDYXJ0T3B0aW9ucygnY2hlY2tvdXQnKTtcclxuXHRcdFx0XHRjb25zdCBjdXN0b21lciA9IGN1c3RvbWVySGFuZGxlci5nZXRDdXN0b21lcigpO1xyXG5cdFx0XHRcdGNvbnN0IGNhcmQgPSBwYXltZW50SGFuZGxlci5nZXRDYXJkKCk7XHJcblx0XHRcdFx0Y29uc3QgW3BheW1lbnRNZXRob2RJZF0gPSBvcHRpb25zLmRhdGEucGF5bWVudE1ldGhvZC5zcGxpdCgnLicpO1xyXG5cclxuXHRcdFx0XHRpZiAoY2hlY2tvdXRSZXMpIHtcclxuXHRcdFx0XHRcdC8vIFNldCByZUNBUFRDSEEgcmVzcG9uc2VcclxuXHRcdFx0XHRcdG9wdGlvbnMucmVjYXB0Y2hhID0gY2hlY2tvdXRSZXM7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRvcHRpb25zLmRhdGEucGF5bWVudE1ldGhvZCA9IHBheW1lbnRNZXRob2RJZDtcclxuXHJcblx0XHRcdFx0aWYgKCFUaHVuZGVyLmF1dGhlbnRpY2F0ZWQoKSkge1xyXG5cdFx0XHRcdFx0Ly8gU2V0IGN1c3RvbWVyIGRldGFpbHMgb25seSBmb3Igbm9uLXJlZ2lzdGVyZWQgY3VzdG9tZXJzXHJcblx0XHRcdFx0XHRvcHRpb25zLmRhdGEuY3VzdG9tZXIgPSBjdXN0b21lcjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGNoZWNrb3V0RmluaXNoZWQgPSAoc3VjY2Vzc0RldGFpbCkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdHByb2Nlc3NDaGVja291dFNwaW5uZXIuZG9uZSgpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChyZXNldFJlY2FwdGNoYSkge1xyXG5cdFx0XHRcdFx0XHRyZXNldFJlY2FwdGNoYSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICghc3VjY2Vzc0RldGFpbCkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdGlmICghVGh1bmRlci5hdXRoZW50aWNhdGVkKCkpIHtcclxuXHRcdFx0XHRcdFx0Ly8gRGVsZXRlIG9yZGVyZWQgaXRlbXMgZnJvbSB0aGUgbG9jYWwgY2FydFxyXG5cdFx0XHRcdFx0XHRjb250ZXh0LmNhcnQuaXRlbXMuZm9yRWFjaChpdGVtID0+IFRodW5kZXIuQ2FydC5kZWxldGVJdGVtKGl0ZW0uX2lkLCAkLm5vb3ApKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gVGh1bmRlci5leGVjdXRlKFxyXG5cdFx0XHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25DaGVja291dFN1Y2Nlc3MsXHJcblx0XHRcdFx0XHRcdCRjb250YWluZXIsXHJcblx0XHRcdFx0XHRcdGNvbnRleHQsXHJcblx0XHRcdFx0XHRcdHN1Y2Nlc3NEZXRhaWxcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0bGV0IG9yZGVyO1xyXG5cdFx0XHRcdGxldCBzdWJzY3JpcHRpb247XHJcblxyXG5cdFx0XHRcdGNvbnN0IGF1dGhCeU9yZGVyT3JTdWJzY3JpcHRpb24gPSB7XHJcblx0XHRcdFx0XHRydW46ICh7IG9yZGVyOiBvLCBzdWJzY3JpcHRpb246IHMgfSkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCRzYXZlQXNQcmltYXJ5QWRkcmVzcy5pcygnOmNoZWNrZWQnKSkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIFVwZGF0ZSB0aGUgcHJpbWFyeSBhZGRyZXNzIChGaXJlICYgRm9yZ2V0KVxyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IG9wdGlvbnMgPSBidWlsZENhcnRPcHRpb25zKCdjaGVja291dCcpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdFx0XHRcdFx0bWV0aG9kOiAnUFVUJyxcclxuXHRcdFx0XHRcdFx0XHRcdHVybDogICAgYC92MS9tZWAsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhOiAgIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YWRkcmVzczoge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByaW1hcnk6IG9wdGlvbnMuZGF0YS5hZGRyZXNzLnNoaXBwaW5nXHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0b3JkZXIgPSBvO1xyXG5cdFx0XHRcdFx0XHRzdWJzY3JpcHRpb24gPSBzIHx8IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCB0eXBlID0gY29udGV4dC5vcHRpb25zLnR5cGU7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHN1YmplY3QgPSBjb250ZXh0LmlzU3Vic2NyaXB0aW9uID8gcyA6IG87XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBvcHRpb25zID0ge1xyXG5cdFx0XHRcdFx0XHRcdGRhdGE6IFRodW5kZXIub3B0aW9ucy5vcmRlckF1dGhGaWVsZHMucmVkdWNlKChvLCBmaWVsZCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHNldChvLCBmaWVsZCwgZ2V0KHN1YmplY3QuY3VzdG9tZXIsIGZpZWxkLCBudWxsKSk7XHJcblx0XHRcdFx0XHRcdFx0fSwge30pXHJcblx0XHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoc2VhcmNoUHVyY2hhc2VSZXMpIHtcclxuXHRcdFx0XHRcdFx0XHRvcHRpb25zLnJlY2FwdGNoYSA9IHNlYXJjaFB1cmNoYXNlUmVzO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBBdXRoZW50aWNhdGUgYnkgYW4gb3JkZXIgb3IgYSBzdWJzY3JpcHRpb25cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGF1dGgodHlwZSwgc3ViamVjdC5faWQsIG9wdGlvbnMpO1xyXG5cclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRmYWlsOiBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0XHRcdGVyci5yZXNwb25zZUpTT04sXHJcblx0XHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OiBjb250ZXh0Lm0oJ2NoZWNrb3V0UHJvY2Vzc0ZhaWxlZCcpXHJcblx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdGVyciA9PiBjaGVja291dEZpbmlzaGVkKClcclxuXHRcdFx0XHRcdClcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRjb25zdCBwZXJzaXN0VG9rZW5BbmRNYWtlUGF5bWVudCA9IHtcclxuXHRcdFx0XHRcdHJ1bjogYXV0aFJlc3VsdCA9PiB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoYXV0aFJlc3VsdCkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjb25zdCB0b2tlbiA9IGF1dGhSZXN1bHQudG9rZW47XHJcblx0XHRcdFx0XHRcdFx0Y29uc3Qgc3RvcmFnZSA9IFRodW5kZXIucGx1Z2lucy5jcmVkZW50aWFsU3RvcmFnZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gU2V0IGF1dGggdG9rZW4gaW4gdGhlIHN0b3JhZ2UsXHJcblx0XHRcdFx0XHRcdFx0Ly8gcHJlZmVyYWJseSBpbiBzZXNzaW9uU3RvcmFnZSB0byB0YWtlIGNhcmUgb2YgcmVkaXJlY3Rpb25zIGZyb20gcGF5bWVudCBzZXJ2aWNlcy5cclxuXHRcdFx0XHRcdFx0XHRzdG9yYWdlLnNldEl0ZW0oVGh1bmRlci5vcHRpb25zLmF1dGhTdG9yYWdlLm9yZGVyLCB0b2tlbik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiBwYXltZW50SGFuZGxlci5tYWtlUGF5bWVudCh7XHJcblx0XHRcdFx0XHRcdFx0Y2FydDogICAgICAgICAgY29udGV4dC5jYXJ0LFxyXG5cdFx0XHRcdFx0XHRcdG9yZGVyOiAgICAgICAgIG9yZGVyLFxyXG5cdFx0XHRcdFx0XHRcdHN1YnNjcmlwdGlvbjogIHN1YnNjcmlwdGlvbixcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21lcjogICAgICBjdXN0b21lcixcclxuXHRcdFx0XHRcdFx0fSwgZXJyID0+IHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKGVycikge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGNoZWNrb3V0RmluaXNoZWQoKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gVGh1bmRlci5leGVjdXRlKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25QYXltZW50RmFpbHVyZSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdFx0XHRcdFx0Y29udGV4dCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0eyBvcmRlciwgc3Vic2NyaXB0aW9uIH1cclxuXHRcdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIXN1YnNjcmlwdGlvbikge1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmVndWxhciBvcmRlciBjYXNlXHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gY2hlY2tvdXRGaW5pc2hlZCh7IG9yZGVyLCBzdWJzY3JpcHRpb24gfSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRjb25zdCBvcHRpb25zID0ge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YTogY2FyZCA/IHsgY2FyZCB9IDoge31cclxuXHRcdFx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBTdWJzY3JpcHRpb24gY2FzZSwgcG9zdCBzY2hlZHVsZXMgYW5kIGZpbmlzaC5cclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc2NoZWR1bGVTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLl9pZCwgb3B0aW9ucykudGhlbigoKSA9PiB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNoZWNrb3V0RmluaXNoZWQoeyBvcmRlciwgc3Vic2NyaXB0aW9uIH0pO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9LCBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0XHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OiBjb250ZXh0Lm0oJ3NjaGVkdWxlRmFpbGVkJylcclxuXHRcdFx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdFx0XHRlcnIgPT4gY2hlY2tvdXRGaW5pc2hlZCgpXHJcblx0XHRcdFx0XHRcdFx0KSk7XHJcblxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0Y29uc3QgY2hlY2tvdXRFcnJvckhhbmRsZXIgPSBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRkZWZhdWx0OiBjb250ZXh0Lm0oJ2NoZWNrb3V0RmFpbGVkJylcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRlcnIgPT4gY2hlY2tvdXRGaW5pc2hlZCgpXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0Ly8gQ2hlY2tvdXRcclxuXHRcdFx0XHRjaGVja291dChvcHRpb25zKS50aGVuKFxyXG5cdFx0XHRcdFx0YXV0aEJ5T3JkZXJPclN1YnNjcmlwdGlvbi5ydW4sXHJcblx0XHRcdFx0XHRjaGVja291dEVycm9ySGFuZGxlclxyXG5cdFx0XHRcdCkudGhlbihcclxuXHRcdFx0XHRcdHBlcnNpc3RUb2tlbkFuZE1ha2VQYXltZW50LnJ1bixcclxuXHRcdFx0XHRcdGF1dGhCeU9yZGVyT3JTdWJzY3JpcHRpb24uZmFpbFxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBidWlsZENhcnRPcHRpb25zKHR5cGUgPSAnY2FsY3VsYXRlJykge1xyXG5cclxuXHRcdFx0XHRjb25zdCBhZGRyZXNzID0gYWRkcmVzc0hhbmRsZXIuZ2V0QWRkcmVzcygpO1xyXG5cdFx0XHRcdGNvbnN0IGRpc2NvdW50ID0gY291cG9uSGFuZGxlci5nZXREaXNjb3VudERldGFpbHMoKTtcclxuXHJcblx0XHRcdFx0Y29uc3Qgb3B0aW9ucyA9IHtcclxuXHRcdFx0XHRcdHF1ZXJ5OiB7fSxcclxuXHRcdFx0XHRcdGRhdGE6ICB7fSxcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHQvLyBGaWx0ZXIgaXRlbXNcclxuXHRcdFx0XHRpZiAoY29udGV4dC5vcHRpb25zLml0ZW1zKSB7XHJcblx0XHRcdFx0XHRvcHRpb25zLnF1ZXJ5ID0geyBpdGVtczogY29udGV4dC5vcHRpb25zLml0ZW1zLnRvU3RyaW5nKCkgfTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIFNldCBhZGRyZXNzXHJcblx0XHRcdFx0aWYgKGFkZHJlc3MpIHtcclxuXHRcdFx0XHRcdG9wdGlvbnMuZGF0YS5hZGRyZXNzID0geyBzaGlwcGluZzogYWRkcmVzcywgYmlsbGluZzogYWRkcmVzcyB9O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gU2V0IHN1YnNjcmlwdGlvbiBkZXRhaWxzXHJcblx0XHRcdFx0aWYgKGNvbnRleHQuaXNTdWJzY3JpcHRpb24pIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBzdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb25IYW5kbGVyLmdldFN1YnNjcmlwdGlvbkRldGFpbCgpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChzdWJzY3JpcHRpb24gJiYgc3Vic2NyaXB0aW9uLnBsYW4pIHtcclxuXHRcdFx0XHRcdFx0b3B0aW9ucy5kYXRhLnN1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBBcHBseSBkaXNjb3VudCAoY291cG9ucylcclxuXHRcdFx0XHRpZiAoT2JqZWN0LmtleXMoZGlzY291bnQpLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0b3B0aW9ucy5kYXRhLmRpc2NvdW50ID0gZGlzY291bnQ7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBSZXF1ZXN0IG9wdGlvbnMgZm9yIGNoZWNrb3V0XHJcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjaGVja291dCcpIHtcclxuXHRcdFx0XHRcdG9wdGlvbnMuZGF0YS5jdXJyZW5jeSA9IGNvbnRleHQuY2FydC5jdXJyZW5jeS5wYXltZW50LmNvZGU7XHJcblx0XHRcdFx0XHRvcHRpb25zLmRhdGEucGF5bWVudE1ldGhvZCA9IHBheW1lbnRIYW5kbGVyLmdldFBheW1lbnRNZXRob2RJZCgpO1xyXG5cdFx0XHRcdFx0b3B0aW9ucy5kYXRhLnJlcXVlc3QgPSAkb3JkZXJSZXF1ZXN0LnZhbCgpIHx8IG51bGw7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gb3B0aW9ucztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIHNlYXJjaEFkZHJlc3MoKSB7XHJcblxyXG5cdFx0XHRcdGlmIChjb3Vwb25IYW5kbGVyLmlzQXBwbHlpbmcoKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFRodW5kZXIubm90aWZ5KCdlcnJvcicsIGNvbnRleHQubSgnYXBwbHlDb3Vwb25zRmlyc3QnKSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRhZGRyZXNzSGFuZGxlci5zZWFyY2hBZGRyZXNzKGVyciA9PiB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGVyciA/XHJcblx0XHRcdFx0XHRcdFx0VGh1bmRlci5ub3RpZnkoJ2Vycm9yJywgZXJyLm1lc3NhZ2UpIDpcclxuXHRcdFx0XHRcdFx0XHRhcHBseUNoYW5nZXMoKTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGFwcGx5Q291cG9ucyh0eXBlKSB7XHJcblxyXG5cdFx0XHRcdGlmIChjb250ZXh0LmlzU3Vic2NyaXB0aW9uKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgZGV0YWlsID0gc3Vic2NyaXB0aW9uSGFuZGxlci5nZXRTdWJzY3JpcHRpb25EZXRhaWwoKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIWRldGFpbCB8fCAhZGV0YWlsLnBsYW4pIHtcclxuXHRcdFx0XHRcdFx0VGh1bmRlci5ub3RpZnkoJ2Vycm9yJywgY29udGV4dC5tKCdzZWxlY3RTdWJzY3JpcHRpb25QbGFuRmlyc3QnKSk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTsgLy8gQmxvY2sgZnVydGhlciBleGVjdXRpb25zXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdlbmQnKSB7XHJcblx0XHRcdFx0XHRhcHBseUNoYW5nZXMoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gYXBwbHlTdWJzY3JpcHRpb25EZXRhaWwoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGRldGFpbCA9IHN1YnNjcmlwdGlvbkhhbmRsZXIuZ2V0U3Vic2NyaXB0aW9uRGV0YWlsKCk7XHJcblx0XHRcdFx0Y29uc3QgZXJyb3IgPSBzdWJzY3JpcHRpb25IYW5kbGVyLnZhbGlkYXRlU3Vic2NyaXB0aW9uRGV0YWlsKGRldGFpbCk7XHJcblxyXG5cdFx0XHRcdGlmIChlcnJvciA9PT0gJ3N1YnNjcmlwdGlvblBsYW5SZXF1aXJlZCcpIHtcclxuXHRcdFx0XHRcdHJldHVybiBUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBjb250ZXh0Lm0oZXJyb3IpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChlcnJvciA9PT0gJ3N1YnNjcmlwdGlvblN0YXJ0c0F0UmVxdWlyZWQnKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gYXBwbHlDaGFuZ2VzKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9KTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0Q2FydChvcHRpb25zID0ge30pIHtcclxuXHJcblx0XHRpZiAoIVRodW5kZXIuYXV0aGVudGljYXRlZCgpKSB7XHJcblx0XHRcdHNldChvcHRpb25zLCAnZGF0YS5pdGVtcycsIFRodW5kZXIuQ2FydC5pdGVtcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFRodW5kZXIucmVxdWVzdCgkLmV4dGVuZCh7XHJcblx0XHRcdG1ldGhvZDogJ1BPU1QnLFxyXG5cdFx0XHR1cmw6ICAgIFRodW5kZXIuYXV0aGVudGljYXRlZCgpID9cclxuXHRcdFx0XHRcdCcvdjEvbWUvY2FydCcgOlxyXG5cdFx0XHRcdFx0Jy92MS9tZS9ub24tcmVnaXN0ZXJlZC9jYXJ0J1xyXG5cdFx0fSwgb3B0aW9ucykpO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNoZWNrb3V0KG9wdGlvbnMgPSB7fSkge1xyXG5cclxuXHRcdGNvbnN0IHR5cGUgPSBvcHRpb25zLmRhdGEuc3Vic2NyaXB0aW9uID8gJ3N1YnNjcmlwdGlvbicgOiAnb3JkZXInO1xyXG5cclxuXHRcdGlmICghVGh1bmRlci5hdXRoZW50aWNhdGVkKCkpIHtcclxuXHRcdFx0c2V0KG9wdGlvbnMsICdkYXRhLml0ZW1zJywgVGh1bmRlci5DYXJ0Lml0ZW1zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KCQuZXh0ZW5kKHtcclxuXHRcdFx0bWV0aG9kOiAnUE9TVCcsXHJcblx0XHRcdHVybDogICAgVGh1bmRlci5hdXRoZW50aWNhdGVkKCkgP1xyXG5cdFx0XHRcdFx0YC92MS9tZS9jYXJ0L2NoZWNrb3V0LyR7dHlwZX1gIDpcclxuXHRcdFx0XHRcdGAvdjEvbWUvbm9uLXJlZ2lzdGVyZWQvY2FydC9jaGVja291dC8ke3R5cGV9YFxyXG5cdFx0fSwgb3B0aW9ucykpO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGF1dGgodHlwZSwgaWQsIG9wdGlvbnMgPSB7fSkge1xyXG5cclxuXHRcdGlmIChUaHVuZGVyLmF1dGhlbnRpY2F0ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KCQuZXh0ZW5kKHtcclxuXHRcdFx0bWV0aG9kOiAnUE9TVCcsXHJcblx0XHRcdHVybDogICAgdHlwZSA9PT0gJ29yZGVyJyA/XHJcblx0XHRcdFx0XHRgL3YxL29yZGVycy8ke2lkfS9hdXRoYCA6XHJcblx0XHRcdFx0XHRgL3YxL3N1YnNjcmlwdGlvbnMvJHtpZH0vYXV0aGBcclxuXHRcdH0sIG9wdGlvbnMpKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzY2hlZHVsZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb25JZCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3QoJC5leHRlbmQoe1xyXG5cdFx0XHRtZXRob2Q6ICdQT1NUJyxcclxuXHRcdFx0dXJsOiAgICBgL3YxL21lL3N1YnNjcmlwdGlvbnMvJHtzdWJzY3JpcHRpb25JZH0vc2NoZWR1bGVkYCxcclxuXHRcdH0sIG9wdGlvbnMpKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XHJcblxyXG59OyIsImNvbnN0IGdldCA9IHJlcXVpcmUoJ2xvZGFzaC5nZXQnKTtcclxuY29uc3Qgc2V0ID0gcmVxdWlyZSgnbG9kYXNoLnNldCcpO1xyXG5jb25zdCBjYW1lbENhc2UgPSByZXF1aXJlKCdsb2Rhc2guY2FtZWxjYXNlJyk7XHJcblxyXG5jb25zdCBBZGRyZXNzSGFuZGxlciA9ICh7XHJcblx0YWRkcmVzc0ZpZWxkcyxcclxuXHR0cmFuc2xhdGlvbktleXMsXHJcblx0c2VhcmNoQWRkcmVzc1BsdWdpblxyXG59KSA9PiB7XHJcblxyXG5cdGZ1bmN0aW9uIHJlc2V0KHR5cGUgPSAnYWxsJykge1xyXG5cclxuXHRcdGNvbnN0IGZpZWxkc1RvQ2xlYXIgPSB0eXBlID09PSAncmVjaXBpZW50JyA/XHJcblx0XHRcdFx0XHRcdFx0XHRhZGRyZXNzRmllbGRzLmZpbHRlcigoeyByZWNpcGllbnQgfSkgPT4gcmVjaXBpZW50KSA6XHJcblx0XHRcdFx0XHRcdFx0XHRhZGRyZXNzRmllbGRzO1xyXG5cclxuXHRcdGZpZWxkc1RvQ2xlYXIuZm9yRWFjaCgoeyAkaW5wdXQgfSkgPT4gJGlucHV0LnZhbChudWxsKSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRBZGRyZXNzKCkge1xyXG5cclxuXHRcdHJldHVybiBhZGRyZXNzRmllbGRzLnJlZHVjZSgobywgeyBmaWVsZCwgJGlucHV0IH0pID0+IHtcclxuXHJcblx0XHRcdHJldHVybiBzZXQobywgZmllbGQsICRpbnB1dC52YWwoKSB8fCBudWxsKTtcclxuXHJcblx0XHR9LCB7fSk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0QWRkcmVzcyhhZGRyZXNzKSB7XHJcblxyXG5cdFx0YWRkcmVzc0ZpZWxkcy5mb3JFYWNoKCh7IGZpZWxkLCAkaW5wdXQgfSkgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3QgdmFsdWUgPSBnZXQoYWRkcmVzcywgZmllbGQpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBudWxsIDogJGlucHV0LnZhbCh2YWx1ZSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzLCB2YWxpZGF0ZVJlY2lwaWVudCA9IGZhbHNlKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVxdWlyZWRzID0gYWRkcmVzc0ZpZWxkc1xyXG5cdFx0XHRcdFx0XHRcdC5maWx0ZXIoKHsgcmVxdWlyZWQgfSkgPT4gcmVxdWlyZWQpXHJcblx0XHRcdFx0XHRcdFx0LmZpbHRlcigoeyByZWNpcGllbnQgfSkgPT4gdmFsaWRhdGVSZWNpcGllbnQgPyB0cnVlIDogIXJlY2lwaWVudCk7XHJcblxyXG5cdFx0Zm9yIChjb25zdCB7IGZpZWxkIH0gb2YgcmVxdWlyZWRzKSB7XHJcblxyXG5cdFx0XHRpZiAoZ2V0KGFkZHJlc3MsIGZpZWxkKSkgY29udGludWU7XHJcblxyXG5cdFx0XHRjb25zdCBjb2RlID0gY2FtZWxDYXNlKFsnYWRkcmVzcycsIHRyYW5zbGF0aW9uS2V5c1tmaWVsZF0gfHwgZmllbGQsICdyZXF1aXJlZCddKTtcclxuXHJcblx0XHRcdHJldHVybiBjb2RlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2VhcmNoQWRkcmVzcyhjYWxsYmFjaykge1xyXG5cclxuXHRcdHNlYXJjaEFkZHJlc3NQbHVnaW4oKGVyciwgYWRkcmVzcykgPT4ge1xyXG5cclxuXHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzZXRBZGRyZXNzKGFkZHJlc3MpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIGFkZHJlc3MpO1xyXG5cdFx0fSk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHJlc2V0LFxyXG5cdFx0Z2V0QWRkcmVzcyxcclxuXHRcdHNldEFkZHJlc3MsXHJcblx0XHR2YWxpZGF0ZUFkZHJlc3MsXHJcblx0XHRzZWFyY2hBZGRyZXNzLFxyXG5cdH07XHJcblxyXG59O1xyXG5cclxuQWRkcmVzc0hhbmRsZXIuZGVmYXVsdEFkZHJlc3MgPSAoKSA9PiAoe1xyXG5cdG5hbWU6ICAgICB7XHJcblx0XHRmaXJzdDogbnVsbCxcclxuXHRcdGxhc3Q6ICBudWxsLFxyXG5cdFx0ZnVsbDogIG51bGwsXHJcblx0fSxcclxuXHRjb21wYW55OiAgbnVsbCxcclxuXHRwb3N0Y29kZTogbnVsbCxcclxuXHRjb3VudHJ5OiAgbnVsbCxcclxuXHRzdGF0ZTogICAgbnVsbCxcclxuXHRjaXR5OiAgICAgbnVsbCxcclxuXHRhZGRyZXNzMTogbnVsbCxcclxuXHRhZGRyZXNzMjogbnVsbCxcclxuXHRtb2JpbGU6ICAgbnVsbCxcclxuXHRwaG9uZTogICAgbnVsbCxcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkZHJlc3NIYW5kbGVyOyIsImNvbnN0IGdldCA9IHJlcXVpcmUoJ2xvZGFzaC5nZXQnKTtcclxuY29uc3Qgc2V0ID0gcmVxdWlyZSgnbG9kYXNoLnNldCcpO1xyXG5cclxuY29uc3QgQ291cG9uSGFuZGxlciA9ICh7XHJcblx0Zm9ybSxcclxuXHRsYWJlbHMgPSB7XHJcblx0XHRhcHBseUNvdXBvbnM6ICcnLFxyXG5cdFx0ZmluaXNoQXBwbHlpbmdDb3Vwb25zOiAnJyxcclxuXHR9LFxyXG5cdGNvdXBvbnMsXHJcblx0Y2FydCA9ICgpID0+IHt9LFxyXG5cdG9uQ291cG9uQXBwbHkgPSB0eXBlID0+IHRydWUsXHJcblx0b25Db3Vwb25TZWxlY3RFcnJvciA9IGNvZGUgPT4ge31cclxuXHJcbn0pID0+IHtcclxuXHJcblx0bGV0IGFwcGx5aW5nID0gZmFsc2U7XHJcblxyXG5cdGNvbnN0IGNvdXBvbk1hcCA9IGNvdXBvbnMucmVkdWNlKChvLCBjKSA9PiBzZXQobywgYy5faWQsIGMpLCB7fSk7XHJcblxyXG5cdGNvbnN0ICRhcHBseUNvdXBvbnMgPSBmb3JtLmZpbmQoJy50aHVuZGVyLS1hcHBseS1jb3Vwb25zJyk7XHJcblxyXG5cdCRhcHBseUNvdXBvbnMub24oJ2NsaWNrJywgYXBwbHlDb3Vwb25zKTtcclxuXHJcblx0YmluZENvdXBvblZhbGlkYXRvcigpO1xyXG5cclxuXHRmdW5jdGlvbiBpc0FwcGx5aW5nKCkge1xyXG5cdFx0cmV0dXJuIGFwcGx5aW5nO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0Q291cG9uKGNvdXBvbklkKSB7XHJcblx0XHRyZXR1cm4gY291cG9uTWFwW2NvdXBvbklkXTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldENvdXBvblNlbGVjdG9ycygpIHtcclxuXHJcblx0XHRyZXR1cm4gZm9ybS5maW5kKFtcclxuXHRcdFx0Jy50aHVuZGVyLS1jYXJ0LWl0ZW0tY291cG9uJyxcclxuXHRcdFx0Jy50aHVuZGVyLS1jYXJ0LWNvdXBvbidcclxuXHRcdF0uam9pbignLCcpKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGJpbmRDb3Vwb25WYWxpZGF0b3IoKSB7XHJcblxyXG5cdFx0Z2V0Q291cG9uU2VsZWN0b3JzKCkub24oJ2NoYW5nZScsIHZhbGlkYXRlQ291cG9ucyk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBhcHBseUNvdXBvbnMoKSB7XHJcblxyXG5cdFx0aWYgKGFwcGx5aW5nKSB7XHJcblx0XHRcdC8vIFN0b3AgY291cG9uIHNlbGVjdGlvbnNcclxuXHRcdFx0aWYgKCFvbkNvdXBvbkFwcGx5KCdlbmQnKSkgcmV0dXJuO1xyXG5cdFx0XHRhcHBseWluZyA9IGZhbHNlO1xyXG5cdFx0XHQkYXBwbHlDb3Vwb25zLnRleHQobGFiZWxzLmFwcGx5Q291cG9ucyk7XHJcblx0XHRcdGdldENvdXBvblNlbGVjdG9ycygpLmhpZGUoKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBJbml0aWFsaXplIGNvdXBvbiBzZWxlY3Rpb25zXHJcblx0XHRcdGlmICghb25Db3Vwb25BcHBseSgnc3RhcnQnKSkgcmV0dXJuO1xyXG5cdFx0XHRhcHBseWluZyA9IHRydWU7XHJcblx0XHRcdCRhcHBseUNvdXBvbnMudGV4dChsYWJlbHMuZmluaXNoQXBwbHlpbmdDb3Vwb25zKTtcclxuXHRcdFx0Z2V0Q291cG9uU2VsZWN0b3JzKCkuc2hvdygpO1xyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldERpc2NvdW50RGV0YWlscygpIHtcclxuXHJcblx0XHRyZXR1cm4gZ2V0Q291cG9uU2VsZWN0b3JzKCkubWFwKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0Y29uc3QgaXRlbSA9ICQodGhpcykuZGF0YSgnaXRlbScpIHx8IG51bGw7XHJcblx0XHRcdGNvbnN0IGNvdXBvbiA9ICQodGhpcykudmFsKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4geyBpdGVtLCBjb3Vwb24gfTtcclxuXHJcblx0XHR9KS5nZXQoKS5yZWR1Y2UoKG8sIHsgaXRlbSwgY291cG9uIH0pID0+IHtcclxuXHJcblx0XHRcdGlmICghY291cG9uKSByZXR1cm4gbztcclxuXHJcblx0XHRcdHJldHVybiBpdGVtID9cclxuXHRcdFx0XHRcdHNldChvLCAnaXRlbXMnLCBnZXQobywgJ2l0ZW1zJywgW10pLmNvbmNhdCh7IGl0ZW0sIGNvdXBvbiB9KSkgOlxyXG5cdFx0XHRcdFx0c2V0KG8sICdjYXJ0LmNvdXBvbicsIGNvdXBvbik7XHJcblx0XHR9LCB7fSk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdmFsaWRhdGVDb3Vwb25zKCkge1xyXG5cclxuXHRcdGNvbnN0ICRzZWxlY3RvciA9ICQodGhpcyk7XHJcblx0XHRjb25zdCBpdGVtSWQgPSAkKHRoaXMpLmRhdGEoJ2l0ZW0nKTtcclxuXHRcdGNvbnN0IGNvdXBvbiA9IGNvdXBvbk1hcFskKHRoaXMpLnZhbCgpXTtcclxuXHRcdGNvbnN0IGl0ZW0gPSBjYXJ0KCkuaXRlbXMuZmluZChpdGVtID0+IGl0ZW0uX2lkID09PSBpdGVtSWQpO1xyXG5cclxuXHRcdGlmICghY291cG9uIHx8ICFpdGVtKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRsZXQgY29kZSA9IG51bGw7XHJcblxyXG5cdFx0Ly8gRHVwbGljYXRlZCBkaXNjb3VudCBhcHBsaWNhdGlvbnNcclxuXHRcdGlmIChjb3Vwb24ub25seSAmJlxyXG5cdFx0XHRpdGVtLmRpc2NvdW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdGNvZGUgPSAnYWxyZWFkeURpc2NvdW50ZWQnO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEl0ZW0ncyBxdWFudGl0eSBtdXN0IGJlIDEgdG8gYXBwbHkgYSBjb3Vwb25cclxuXHRcdGlmIChpdGVtLnF1YW50aXR5LnJhdyAhPT0gMSkge1xyXG5cdFx0XHRjb2RlID0gJ211c3RCZU9uZVF1YW50aXR5JztcclxuXHRcdH1cclxuXHJcblx0XHQvLyBEdXBsaWNhdGVkIGNvdXBvbiB1c2FnZVxyXG5cdFx0Y29uc3Qgc2VsZWN0ZWQgPSBnZXRDb3Vwb25TZWxlY3RvcnMoKS5tYXAoZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiAkKHRoaXMpLmlzKCRzZWxlY3RvcikgPyBudWxsIDogJCh0aGlzKS52YWwoKTtcclxuXHRcdH0pLmdldCgpLmZpbHRlcih2ID0+IHYpO1xyXG5cclxuXHRcdGlmIChzZWxlY3RlZC5pbmRleE9mKGNvdXBvbi5faWQpID49IDApIHtcclxuXHRcdFx0Y29kZSA9ICdkdXBsaWNhdGVkQ291cG9uJztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29kZSkge1xyXG5cdFx0XHQkc2VsZWN0b3IudmFsKCcnKTtcclxuXHRcdFx0cmV0dXJuIG9uQ291cG9uU2VsZWN0RXJyb3IoY29kZSk7XHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGlzQXBwbHlpbmcsXHJcblx0XHRnZXRDb3Vwb24sXHJcblx0XHRiaW5kQ291cG9uVmFsaWRhdG9yLFxyXG5cdFx0Z2V0RGlzY291bnREZXRhaWxzLFxyXG5cdH07XHJcblxyXG59O1xyXG5cclxuQ291cG9uSGFuZGxlci5zZXRBcHBsaWNhYmxlQ291cG9ucyA9IChvcmRlclR5cGUsIGNhcnQsIGNvdXBvbnMpID0+IHtcclxuXHJcblx0Ly8gRmlsdGVyIG9ubHkgYXBwbGljYWJsZSBjb3Vwb25zXHJcblx0Y29uc3QgYXBwbGljYWJsZUNvdXBvbnMgPSBjb3Vwb25zLmZpbHRlcihjID0+IHtcclxuXHJcblx0XHRjb25zdCB7IGFjdGl2ZSwgZXhwaXJlc0F0LCBzdWJzY3JpcHRpb24gfSA9IGM7XHJcblxyXG5cdFx0Ly8gRmlsdGVyIGNvdXBvbnMgd2hlcmU6XHJcblx0XHQvLyAtIEEgY291cG9uIGlzIGFjdGl2ZVxyXG5cdFx0Ly8gLSBBIGNvdXBvbiBpcyBmb3IgYSBzdWJzY3JpcHRpb24gYW5kIHRoZSB2aWV3IGlzIGZvciBzdWJzY3JpcHRpb25zXHJcblx0XHQvLyAtIEEgY291cG9uIGlzIGZvciBhbiBvcmRlciBhbmQgdGhlIHZpZXcgaXMgZm9yIG9yZGVyc1xyXG5cdFx0Ly8gLSBBIGNvdXBvbiBoYXMgbm8gZXhwaXJhdGlvbiBkYXRlc1xyXG5cdFx0Ly8gLSBBIGNvdXBvbiBoYXMgYW4gZXhwaXJhdGlvbiBkYXRlIGFuZCBpdCBpcyBub3QgcGFzc2VkIHlldFxyXG5cdFx0cmV0dXJuIGFjdGl2ZSAmJiAoXHJcblx0XHRcdFx0XHQob3JkZXJUeXBlID09PSAnc3Vic2NyaXB0aW9uJyAmJiBzdWJzY3JpcHRpb24udHlwZSkgfHxcclxuXHRcdFx0XHRcdChvcmRlclR5cGUgPT09ICdvcmRlcicgJiYgIXN1YnNjcmlwdGlvbi50eXBlKVxyXG5cdFx0XHRcdCkgJiYgKFxyXG5cdFx0XHRcdFx0IWV4cGlyZXNBdCB8fFxyXG5cdFx0XHRcdFx0bmV3IERhdGUoZXhwaXJlc0F0LnJhdykudmFsdWVPZigpID4gbmV3IERhdGUoKS52YWx1ZU9mKClcclxuXHRcdFx0XHQpO1xyXG5cdH0pO1xyXG5cclxuXHRjb25zdCBwcm9kdWN0Q291cG9ucyA9IGFwcGxpY2FibGVDb3Vwb25zLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ3Byb2R1Y3QnKTtcclxuXHRjb25zdCBjYXJ0Q291cG9ucyA9IGFwcGxpY2FibGVDb3Vwb25zLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2NhcnQnKTtcclxuXHJcblx0Y2FydC5pdGVtcyA9IGNhcnQuaXRlbXMubWFwKGl0ZW0gPT4ge1xyXG5cclxuXHRcdGl0ZW0uYXBwbGljYWJsZUNvdXBvbnMgPSBwcm9kdWN0Q291cG9ucy5maWx0ZXIoY291cG9uID0+IHtcclxuXHJcblx0XHRcdHJldHVybiBhcHBsaWNhYmxlQnlDYXRlZ29yeShpdGVtLCBjb3Vwb24uY2F0ZWdvcnkpICYmXHJcblx0XHRcdFx0XHRhcHBsaWNhYmxlQnlQcmljZShpdGVtLCBjb3Vwb24ucHJpY2UpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGl0ZW07XHJcblx0fSk7XHJcblxyXG5cdGNhcnQuYXBwbGljYWJsZUNvdXBvbnMgPSBjYXJ0Q291cG9ucztcclxuXHJcblx0ZnVuY3Rpb24gYXBwbGljYWJsZUJ5Q2F0ZWdvcnkoaXRlbSwgY2F0ZWdvcnkpIHtcclxuXHJcblx0XHRjb25zdCB7IGJyYW5kLCBjb2xsZWN0aW9ucywgcHJvZHVjdCB9ID0gaXRlbTtcclxuXHJcblx0XHRpZiAoY2F0ZWdvcnkudHlwZSA9PT0gJ2FueScpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qgc3ViamVjdHNUb1Rlc3QgPSB7XHJcblx0XHRcdGJyYW5kczogICAgICBbXS5jb25jYXQoYnJhbmQgPyBicmFuZC5faWQgOiBbXSksXHJcblx0XHRcdGNvbGxlY3Rpb25zOiBbXS5jb25jYXQoLi4uY29sbGVjdGlvbnMubWFwKCh7IHBhdGggfSkgPT4gcGF0aCkpXHJcblx0XHRcdFx0XHRcdFx0Lm1hcCgoeyBfaWQgfSkgPT4gX2lkKSxcclxuXHRcdFx0cHJvZHVjdHM6ICAgIFtdLmNvbmNhdChwcm9kdWN0ID8gcHJvZHVjdC5faWQgOiBbXSksXHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IGNhdGVnb3J5VG9UZXN0ID0gW1xyXG5cdFx0XHQnYnJhbmRzJyxcclxuXHRcdFx0J2NvbGxlY3Rpb25zJyxcclxuXHRcdFx0J3Byb2R1Y3RzJ1xyXG5cdFx0XS5maW5kKGMgPT4gY2F0ZWdvcnlbY10pO1xyXG5cclxuXHRcdGNvbnN0IHRvVGVzdCA9IHN1YmplY3RzVG9UZXN0W2NhdGVnb3J5VG9UZXN0XTtcclxuXHRcdGNvbnN0IHBvb2wgPSBjYXRlZ29yeVtjYXRlZ29yeVRvVGVzdF0ubWFwKCh7IF9pZCB9KSA9PiBfaWQpO1xyXG5cclxuXHRcdGlmIChjYXRlZ29yeS50eXBlID09PSAnaW5jbHVkZScpIHtcclxuXHRcdFx0cmV0dXJuIHBvb2wuc29tZSh2ID0+IHRvVGVzdC5pbmRleE9mKHYpID49IDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjYXRlZ29yeS50eXBlID09PSAnZXhjbHVkZScpIHtcclxuXHRcdFx0cmV0dXJuIHBvb2wuZXZlcnkodiA9PiB0b1Rlc3QuaW5kZXhPZih2KSA9PT0gLTEpO1xyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFwcGxpY2FibGVCeVByaWNlKGl0ZW0sIHsgbWluLCBtYXggfSkge1xyXG5cclxuXHRcdGNvbnN0IHByaWNlID0gaXRlbS52YXJpYW50LnByaWNlLnNhbGUucmF3O1xyXG5cclxuXHRcdHJldHVybiAoXHJcblx0XHRcdChtaW4gPT09IG51bGwgfHwgbWluLnJhdyA8IHByaWNlKSAmJlxyXG5cdFx0XHQobWF4ID09PSBudWxsIHx8IG1heC5yYXcgPiBwcmljZSlcclxuXHRcdCk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvdXBvbkhhbmRsZXI7IiwiY29uc3QgZ2V0ID0gcmVxdWlyZSgnbG9kYXNoLmdldCcpO1xyXG5jb25zdCBzZXQgPSByZXF1aXJlKCdsb2Rhc2guc2V0Jyk7XHJcbmNvbnN0IGNhbWVsQ2FzZSA9IHJlcXVpcmUoJ2xvZGFzaC5jYW1lbGNhc2UnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKHtcclxuXHRjdXN0b21lckZpZWxkcyxcclxuXHR0cmFuc2xhdGlvbktleXMsXHJcbn0pID0+IHtcclxuXHJcblx0ZnVuY3Rpb24gc2V0Q3VzdG9tZXIoY3VzdG9tZXIpIHtcclxuXHJcblx0XHRpZiAoIWN1c3RvbWVyKSByZXR1cm47XHJcblxyXG5cdFx0Y3VzdG9tZXJGaWVsZHMuZm9yRWFjaCgoeyBmaWVsZCwgJGlucHV0IH0pID0+IHtcclxuXHJcblx0XHRcdCRpbnB1dC52YWwoZ2V0KGN1c3RvbWVyLCBmaWVsZCkgfHwgbnVsbCk7XHJcblx0XHR9KTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRDdXN0b21lcigpIHtcclxuXHJcblx0XHRyZXR1cm4gY3VzdG9tZXJGaWVsZHMucmVkdWNlKChvLCB7IGZpZWxkLCAkaW5wdXQgfSkgPT4ge1xyXG5cdFx0XHRyZXR1cm4gc2V0KG8sIGZpZWxkLCAkaW5wdXQudmFsKCkgfHwgbnVsbCk7XHJcblx0XHR9LCB7fSk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdmFsaWRhdGVDdXN0b21lcihjdXN0b21lcikge1xyXG5cclxuXHRcdGZvciAoY29uc3QgeyBmaWVsZCwgcmVxdWlyZWQgfSBvZiBjdXN0b21lckZpZWxkcykge1xyXG5cclxuXHRcdFx0aWYgKCFyZXF1aXJlZCkgY29udGludWU7XHJcblxyXG5cdFx0XHRjb25zdCB2YWx1ZSA9IGdldChjdXN0b21lciwgZmllbGQpO1xyXG5cclxuXHRcdFx0aWYgKCF2YWx1ZSkge1xyXG5cdFx0XHRcdHJldHVybiBjYW1lbENhc2UoWydjdXN0b21lcicsIHRyYW5zbGF0aW9uS2V5c1tmaWVsZF0gfHwgZmllbGQsICdyZXF1aXJlZCddKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0c2V0Q3VzdG9tZXIsXHJcblx0XHRnZXRDdXN0b21lcixcclxuXHRcdHZhbGlkYXRlQ3VzdG9tZXJcclxuXHR9O1xyXG5cclxufTsiLCJjb25zdCBzZXQgPSByZXF1aXJlKCdsb2Rhc2guc2V0Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVkUmVzcG9uc2UgPT4ge1xyXG5cclxuXHRjb25zdCBoYW5kbGVyID0ge1xyXG5cdFx0Y291bnRlcjogMCxcclxuXHRcdHRva2VuOiBbXSxcclxuXHRcdHJlcXVpcmVkUmVzcG9uc2VcclxuXHR9O1xyXG5cclxuXHRoYW5kbGVyLmV4ZWN1dGUgPSB0b2tlbiA9PiB7XHJcblxyXG5cdFx0Y29uc3QgcmVxdWlyZWRDb21wb25lbnRzID0gT2JqZWN0LmtleXMoaGFuZGxlci5yZXF1aXJlZFJlc3BvbnNlKTtcclxuXHRcdGNvbnN0IHJlcXVpcmVkTGVuZ3RoID0gcmVxdWlyZWRDb21wb25lbnRzLmxlbmd0aDtcclxuXHJcblx0XHRpZiAocmVxdWlyZWRMZW5ndGggPT09IDApIHtcclxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgb2YgcmVxdWlyZWQgcmVzcG9uc2VzIGlzIDAsXHJcblx0XHRcdC8vIHNpbXBseSByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxyXG5cdFx0XHRyZXR1cm4ge307XHJcblx0XHR9XHJcblxyXG5cdFx0aGFuZGxlci50b2tlbiA9IGhhbmRsZXIudG9rZW4uY29uY2F0KHRva2VuKS5maWx0ZXIodG9rZW4gPT4gdG9rZW4pO1xyXG5cclxuXHRcdGlmICgrK2hhbmRsZXIuY291bnRlciA9PT0gMiAmJlxyXG5cdFx0XHRyZXF1aXJlZExlbmd0aCA9PT0gaGFuZGxlci50b2tlbi5sZW5ndGgpIHtcclxuXHJcblx0XHRcdGNvbnN0IHJlc3VsdCA9IHJlcXVpcmVkQ29tcG9uZW50cy5yZWR1Y2UoKG8sIGMsIGkpID0+IHtcclxuXHRcdFx0XHRyZXR1cm4gc2V0KG8sIGMsIGhhbmRsZXIudG9rZW5baV0pO1xyXG5cdFx0XHR9LCB7fSk7XHJcblxyXG5cdFx0XHRoYW5kbGVyLnJlc2V0KCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0aGFuZGxlci5yZXNldCA9ICgpID0+IHtcclxuXHRcdGhhbmRsZXIuY291bnRlciA9IDA7XHJcblx0XHRoYW5kbGVyLnRva2VuID0gW107XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIGhhbmRsZXI7XHJcblxyXG59OyIsImNvbnN0IHNldCA9IHJlcXVpcmUoJ2xvZGFzaC5zZXQnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKHtcclxuXHRmb3JtLFxyXG5cdGxhYmVscyxcclxuXHRzdWJzY3JpcHRpb25QbGFucyxcclxuXHR0aW1lem9uZSA9ICgpID0+ICdVVEMnLFxyXG5cdG9uUGxhbkNoYW5nZSA9ICgpID0+IHt9LFxyXG5cdG9uU3RhcnRzQXRDaGFuZ2UgPSAoKSA9PiB7fVxyXG59KSA9PiB7XHJcblxyXG5cdGNvbnN0ICRwbGFuID0gZm9ybS5maW5kKCdbbmFtZT1cInN1YnNjcmlwdGlvblBsYW5cIl0nKTtcclxuXHRjb25zdCAkc3RhcnRzQXRTZWN0aW9uID0gZm9ybS5maW5kKCcudGh1bmRlci0tc3Vic2NyaXB0aW9uLXN0YXJ0cy1hdCcpO1xyXG5cdGNvbnN0ICRzdGFydHNBdExhYmVsID0gJHN0YXJ0c0F0U2VjdGlvbi5maW5kKCdsYWJlbCcpO1xyXG5cdGNvbnN0ICRzdGFydHNBdCA9ICRzdGFydHNBdFNlY3Rpb24uZmluZCgnW25hbWU9XCJzdWJzY3JpcHRpb25TdGFydHNBdFwiXScpO1xyXG5cdGNvbnN0ICRpbW1lZGlhdGVUaXAgPSAkKCcuZmlyc3Qtb3JkZXItaXMtaW1tZWRpYXRlJyk7XHJcblxyXG5cdGNvbnN0IGRhdGVwaWNrZXIgPSAkc3RhcnRzQXQuZGF0YSgncGlja2FkYXknKTtcclxuXHJcblx0Y29uc3Qgc3Vic2NyaXB0aW9uUGxhbk1hcCA9IHN1YnNjcmlwdGlvblBsYW5zLnJlZHVjZSgobywgcGxhbikgPT4ge1xyXG5cdFx0cmV0dXJuIHNldChvLCBwbGFuLl9pZCwgcGxhbik7XHJcblx0fSwge30pO1xyXG5cclxuXHRzdWJzY3JpcHRpb25QbGFuQ2hhbmdlZCgpO1xyXG5cclxuXHRpZiAoZGF0ZXBpY2tlcikge1xyXG5cdFx0Ly8gU2V0IGRhdGVwaWNrZXIncyBtaW4gZGF0ZSBhcyB0b21vcnJvdyAoMjQgaG91cnMgbGF0ZXIpXHJcblx0XHRkYXRlcGlja2VyLnNldE1pbkRhdGUoXHJcblx0XHRcdG5ldyBEYXRlKG5ldyBEYXRlKCkudmFsdWVPZigpICsgKDEwMDAgKiAzNjAwICogMjQpKVxyXG5cdFx0KTtcclxuXHR9XHJcblxyXG5cdCRwbGFuLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcclxuXHRcdHN1YnNjcmlwdGlvblBsYW5DaGFuZ2VkKCk7XHJcblx0XHRyZXR1cm4gb25QbGFuQ2hhbmdlKCk7XHJcblx0fSk7XHJcblxyXG5cdCRzdGFydHNBdC5vbignY2hhbmdlJywgZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gb25TdGFydHNBdENoYW5nZSgpO1xyXG5cdH0pO1xyXG5cclxuXHRmdW5jdGlvbiBnZXRTdWJzY3JpcHRpb25QbGFuKHN1YnNjcmlwdGlvblBsYW5JZCkge1xyXG5cdFx0cmV0dXJuIHN1YnNjcmlwdGlvblBsYW5NYXBbc3Vic2NyaXB0aW9uUGxhbklkXTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHZhbGlkYXRlU3Vic2NyaXB0aW9uRGV0YWlsKHN1YnNjcmlwdGlvbikge1xyXG5cclxuXHRcdGlmICghc3Vic2NyaXB0aW9uIHx8ICFzdWJzY3JpcHRpb24ucGxhbikge1xyXG5cdFx0XHRyZXR1cm4gJ3N1YnNjcmlwdGlvblBsYW5SZXF1aXJlZCc7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgcGxhbiA9IHN1YnNjcmlwdGlvblBsYW5NYXBbc3Vic2NyaXB0aW9uLnBsYW5dO1xyXG5cclxuXHRcdGlmIChwbGFuLnN0YXJ0c0F0ICYmICFzdWJzY3JpcHRpb24uc3RhcnRzQXQpIHtcclxuXHRcdFx0cmV0dXJuICdzdWJzY3JpcHRpb25TdGFydHNBdFJlcXVpcmVkJztcclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRTdWJzY3JpcHRpb25EZXRhaWwoKSB7XHJcblxyXG5cdFx0Y29uc3QgcGxhbiA9IHN1YnNjcmlwdGlvblBsYW5NYXBbJHBsYW4udmFsKCldO1xyXG5cclxuXHRcdGlmICghcGxhbikgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0Y29uc3QgZGV0YWlsID0ge1xyXG5cdFx0XHRwbGFuOiAgICAgcGxhbi5faWQsXHJcblx0XHRcdHRpbWV6b25lOiB0aW1lem9uZSgpLFxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBzdGFydHNBdCA9IChcclxuXHRcdFx0Ly8gSWYgYHBsYW4uc3RhcnRzQXRgIGlzIGEgZnVuY3Rpb24sIHNpbXBseSBpbnZva2UgYW5kIGdldCB0aGUgdGltZSB2YWx1ZS5cclxuXHRcdFx0KHR5cGVvZiBwbGFuLnN0YXJ0c0F0ID09PSAnZnVuY3Rpb24nICYmIHBsYW4uc3RhcnRzQXQocGxhbikpIHx8XHJcblx0XHRcdC8vIElmIGBwbGFuLnN0YXJ0c0F0YCBpcyBhICdkYXRlcGlja2VyJywgZ2V0IHRoZSB0aW1lIHZhbHVlIGZyb20gZGF0ZXBpY2tlci5cclxuXHRcdFx0KHBsYW4uc3RhcnRzQXQgPT09ICdkYXRlcGlja2VyJyAmJiAkc3RhcnRzQXQuZGF0YSgncGlja2FkYXknKS5nZXREYXRlKCkpXHJcblx0XHQpIHx8IG51bGw7XHJcblxyXG5cdFx0aWYgKHN0YXJ0c0F0KSB7XHJcblxyXG5cdFx0XHQvLyBTZXQgb3JkZXIgc2NoZWR1bGVzJyB0aW1lcyAoZGVmYXVsdCA9IDA5OjAwKVxyXG5cdFx0XHRzdGFydHNBdC5zZXRIb3VycyhcclxuXHRcdFx0XHQuLi4ocGxhbi50aW1lIHx8ICcwOTowMCcpXHJcblx0XHRcdFx0XHQuc3BsaXQoJzonKVxyXG5cdFx0XHRcdFx0Lm1hcCh2ID0+IHBhcnNlSW50KHYpKVxyXG5cdFx0XHRcdFx0LmNvbmNhdCgwLCAwLCAwKSAvLyBEZWZhdWx0IG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kc1xyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0ZGV0YWlsLnN0YXJ0c0F0ID0gc3RhcnRzQXQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRldGFpbDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzdWJzY3JpcHRpb25QbGFuQ2hhbmdlZCgpIHtcclxuXHJcblx0XHRjb25zdCBwbGFuID0gc3Vic2NyaXB0aW9uUGxhbk1hcFskcGxhbi52YWwoKV07XHJcblxyXG5cdFx0aWYgKCFwbGFuKSByZXR1cm47XHJcblxyXG5cdFx0aWYgKHBsYW4uc3RhcnRzQXQgPT09ICdkYXRlcGlja2VyJykge1xyXG5cdFx0XHQkc3RhcnRzQXRTZWN0aW9uLnNob3coKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdCRzdGFydHNBdFNlY3Rpb24uaGlkZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwbGFuLmltbWVkaWF0ZSkge1xyXG5cdFx0XHQkaW1tZWRpYXRlVGlwLnNob3coKTtcclxuXHRcdFx0JHN0YXJ0c0F0TGFiZWwudGV4dChsYWJlbHMuc2Vjb25kT3JkZXJTdGFydHNBdCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQkaW1tZWRpYXRlVGlwLmhpZGUoKTtcclxuXHRcdFx0JHN0YXJ0c0F0TGFiZWwudGV4dChsYWJlbHMuZmlyc3RPcmRlclN0YXJ0c0F0KTtcclxuXHRcdH1cclxuXHJcblx0XHQkc3RhcnRzQXQudmFsKCcnKTtcclxuXHRcdGRhdGVwaWNrZXIuc2V0RGF0ZShudWxsKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Z2V0U3Vic2NyaXB0aW9uUGxhbixcclxuXHRcdHZhbGlkYXRlU3Vic2NyaXB0aW9uRGV0YWlsLFxyXG5cdFx0Z2V0U3Vic2NyaXB0aW9uRGV0YWlsLFxyXG5cdFx0c3Vic2NyaXB0aW9uUGxhbkNoYW5nZWQsXHJcblx0fTtcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBUaHVuZGVyID0+IHtcclxuXHJcblx0Y29uc3QgaW1wbGVtZW50YXRpb24gPSB7XHJcblx0XHRuYW1lOiAnY3VzdG9tZXItY291cG9ucydcclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5vcHRpb25zID0gKCkgPT4gKHtcclxuXHRcdHBhZ2U6ICAgICAgICAgICAgMSxcclxuXHRcdGxpbWl0OiAgICAgICAgICAgMjQsXHJcblx0XHR1c2VQYWdpbmF0aW9uOiAgIHRydWUsXHJcblx0XHRjb25maXJtT25EZWxldGU6IFRodW5kZXIub3B0aW9ucy5jb25maXJtYXRpb24uY291cG9uRGVsZXRlLCAvLyBXaGV0aGVyIHRvIGNvbmZpcm0gYmVmb3JlIGRlbGV0aW5nIGEgY291cG9uXHJcblxyXG5cdFx0b25EZWxldGU6IGZ1bmN0aW9uKCRjb250YWluZXIsIGNvbnRleHQpIHtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLm5vdGlmeSgnc3VjY2VzcycsIGNvbnRleHQubSgnZGVsZXRlU3VjY2VzcycpKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ucHJlID0gZnVuY3Rpb24oY29udGV4dCwgY2FsbGJhY2spIHtcclxuXHJcblx0XHRjb250ZXh0LmNvdXBvbkxpc3RJZCA9IChNYXRoLnJhbmRvbSgpICsgJycpLnNsaWNlKDIpO1xyXG5cclxuXHRcdGNvbnRleHQuY2F0ZWdvcmllcyA9IGNvdXBvbiA9PiAoXHJcblx0XHRcdGNvdXBvbi5jYXRlZ29yeS5wcm9kdWN0cyB8fFxyXG5cdFx0XHRjb3Vwb24uY2F0ZWdvcnkuYnJhbmRzIHx8XHJcblx0XHRcdGNvdXBvbi5jYXRlZ29yeS5jb2xsZWN0aW9uc1xyXG5cdFx0KS5tYXAobSA9PiBtLm5hbWUpLmpvaW4oJywgJyk7XHJcblxyXG5cdFx0Y29uc3QgZXJyb3JzID0ge1xyXG5cdFx0XHRkZWZhdWx0OiBjb250ZXh0Lm0oJ2NvdXBvbkxpc3RGYWlsZWQnKVxyXG5cdFx0fTtcclxuXHJcblx0XHQkLndoZW4oXHJcblx0XHRcdFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0bWV0aG9kOiAnR0VUJyxcclxuXHRcdFx0XHR1cmw6ICAgICcvdjEvbWUvY291cG9ucycsXHJcblx0XHRcdFx0cXVlcnk6ICB7XHJcblx0XHRcdFx0XHRwYWdlOiAgY29udGV4dC5vcHRpb25zLnBhZ2UsXHJcblx0XHRcdFx0XHRsaW1pdDogY29udGV4dC5vcHRpb25zLmxpbWl0LFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSksXHJcblx0XHRcdGNvbnRleHQub3B0aW9ucy51c2VQYWdpbmF0aW9uID8gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRtZXRob2Q6ICdHRVQnLFxyXG5cdFx0XHRcdHVybDogICAgJy92MS9tZS9jb3Vwb25zL2NvdW50JyxcclxuXHRcdFx0XHRxdWVyeTogIHsgcmF3OiB0cnVlIH1cclxuXHRcdFx0fSkgOiBudWxsXHJcblx0XHQpLnRoZW4oKGNvdXBvbnMsIGNvdW50KSA9PiB7XHJcblxyXG5cdFx0XHRjb250ZXh0LmNvdXBvbnMgPSBjb3Vwb25zWzBdO1xyXG5cdFx0XHRjb250ZXh0LmNvdW50ID0gY291bnQgPyBjb3VudFswXS5jb3VudCA6IG51bGw7XHJcblxyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgY29udGV4dCk7XHJcblxyXG5cdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRlcnJvcnMsXHJcblx0XHRcdGNhbGxiYWNrXHJcblx0XHQpKTtcclxuXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24uaW5pdCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuXHJcblx0XHRjb25zdCAkY29udGFpbmVyID0gJCh0aGlzKTtcclxuXHRcdGNvbnN0ICRwYWdpbmF0aW9uID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tY3VzdG9tZXItY291cG9uLWxpc3QtcGFnaW5hdGlvbicpO1xyXG5cdFx0Y29uc3QgJGRlbGV0ZUNvdXBvbiA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWRlbGV0ZS1jb3Vwb24nKTtcclxuXHJcblx0XHQkZGVsZXRlQ291cG9uLm9uKCdjbGljaycsIGRlbGV0ZUNvdXBvbik7XHJcblxyXG5cdFx0aWYgKGNvbnRleHQub3B0aW9ucy51c2VQYWdpbmF0aW9uKSB7XHJcblxyXG5cdFx0XHRUaHVuZGVyLnBsdWdpbnMucGFnaW5hdGlvbih7XHJcblx0XHRcdFx0Y29udGFpbmVyOiAkcGFnaW5hdGlvbixcclxuXHRcdFx0XHRjdXJyZW50UGFnZTogY29udGV4dC5vcHRpb25zLnBhZ2UsXHJcblx0XHRcdFx0dG90YWxSZXN1bHQ6IGNvbnRleHQuY291bnQsXHJcblx0XHRcdFx0cmVzdWx0UGVyUGFnZTogY29udGV4dC5vcHRpb25zLmxpbWl0LFxyXG5cdFx0XHRcdG9uUGFnZUNoYW5nZTogKHsgcGFnZSB9KSA9PiBUaHVuZGVyLnJlbmRlcihcclxuXHRcdFx0XHRcdCRjb250YWluZXIsXHJcblx0XHRcdFx0XHQnY3VzdG9tZXItY291cG9ucycsXHJcblx0XHRcdFx0XHQkLmV4dGVuZChjb250ZXh0Lm9wdGlvbnMsIHsgcGFnZSB9KVxyXG5cdFx0XHRcdClcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZGVsZXRlQ291cG9uKCkge1xyXG5cclxuXHRcdFx0Y29uc3QgcmVtb3ZlQ291cG9uID0gKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRjb25zdCBzcGlubmVyID0gVGh1bmRlci51dGlsLm1ha2VBc3luY0J1dHRvbigkKHRoaXMpLCB7IGJpbmQ6IGZhbHNlIH0pO1xyXG5cclxuXHRcdFx0XHRzcGlubmVyLnJ1bigpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBjb3Vwb25JZCA9ICQodGhpcykuZGF0YSgnY291cG9uJyk7XHJcblx0XHRcdFx0Y29uc3QgJGNvdXBvbiA9ICRjb250YWluZXIuZmluZChgW2RhdGEtY291cG9uPVwiJHtjb3Vwb25JZH1cIl1gKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgZXJyb3JzID0ge1xyXG5cdFx0XHRcdFx0ZGVmYXVsdDogY29udGV4dC5tKCdjb3Vwb25EZWxldGVGYWlsZWQnKVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0XHRtZXRob2Q6ICdERUxFVEUnLFxyXG5cdFx0XHRcdFx0dXJsOiAgICBgL3YxL21lL2NvdXBvbnMvJHtjb3Vwb25JZH1gXHJcblx0XHRcdFx0fSkudGhlbigoKSA9PiB7XHJcblxyXG5cdFx0XHRcdFx0c3Bpbm5lci5kb25lKCk7XHJcblx0XHRcdFx0XHQkY291cG9uLnJlbW92ZSgpO1xyXG5cdFx0XHRcdFx0JGNvbnRhaW5lci5maW5kKCdbZGF0YS1taF0nKS5tYXRjaEhlaWdodCgpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdFx0XHRcdGNvbnRleHQub3B0aW9ucy5vbkRlbGV0ZSxcclxuXHRcdFx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdFx0Y29udGV4dFxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0XHRcdGVycm9ycyxcclxuXHRcdFx0XHRcdGVyciA9PiBzcGlubmVyLmRvbmUoKVxyXG5cdFx0XHRcdCkpO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGlmICghY29udGV4dC5vcHRpb25zLmNvbmZpcm1PbkRlbGV0ZSkge1xyXG5cdFx0XHRcdHJldHVybiByZW1vdmVDb3Vwb24oKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIucGx1Z2lucy5jb25maXJtYXRpb24oXHJcblx0XHRcdFx0Y29udGV4dC5tKCdkZWxldGVDb25maXJtJyksXHJcblx0XHRcdFx0KCkgPT4gcmVtb3ZlQ291cG9uKClcclxuXHRcdFx0KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcclxuXHJcbn07IiwiY29uc3Qgc2V0ID0gcmVxdWlyZSgnbG9kYXNoLnNldCcpO1xyXG5jb25zdCBjYW1lbENhc2UgPSByZXF1aXJlKCdsb2Rhc2guY2FtZWxjYXNlJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRodW5kZXIgPT4ge1xyXG5cclxuXHRjb25zdCBzdXBwb3J0ZWRDb21wb25lbnRzID0gKCkgPT4gW1xyXG5cdFx0J2N1c3RvbWVyLXVwZGF0ZScsXHJcblx0XHQnY3VzdG9tZXItdXBkYXRlLWFkZHJlc3MnLFxyXG5cdFx0J29yZGVyLWxpc3QnLFxyXG5cdFx0VGh1bmRlci5vcHRpb25zLnBheW1lbnRNZXRob2RzLnN1YnNjcmlwdGlvbiA/XHJcblx0XHRcdCdzdWJzY3JpcHRpb24tbGlzdCcgOlxyXG5cdFx0XHRudWxsLFxyXG5cdFx0J2N1c3RvbWVyLWNvdXBvbnMnLFxyXG5cdFx0VGh1bmRlci5vcHRpb25zLnByb2R1Y3RSZXZpZXcgP1xyXG5cdFx0XHQnY3VzdG9tZXItcmV2aWV3cycgOlxyXG5cdFx0XHRudWxsLFxyXG5cdFx0VGh1bmRlci5vcHRpb25zLnByb2R1Y3RSZXZpZXcgJiZcclxuXHRcdFRodW5kZXIub3B0aW9ucy5wcm9kdWN0UmV2aWV3Q29tbWVudCA/XHJcblx0XHRcdCdjdXN0b21lci1yZXZpZXctY29tbWVudHMnIDpcclxuXHRcdFx0bnVsbCxcclxuXHRcdCdjdXN0b21lci1kZWxldGUtYWNjb3VudCcsXHJcblx0XS5maWx0ZXIodiA9PiB2KTtcclxuXHJcblx0Ly8gSW1wbGVtZW50YXRpb25cclxuXHRjb25zdCBpbXBsZW1lbnRhdGlvbiA9IHtcclxuXHRcdG5hbWU6ICdjdXN0b21lci1kYXNoYm9hcmQnXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ub3B0aW9ucyA9ICgpID0+ICQuZXh0ZW5kKHtcclxuXHRcdG5hdjogICBzdXBwb3J0ZWRDb21wb25lbnRzKCksICAgIC8vIE5hdmlnYXRpb24gY29tcG9uZW50c1xyXG5cdFx0Zm9jdXM6IHN1cHBvcnRlZENvbXBvbmVudHMoKVswXSwgLy8gSW5pdGlhbCBjb21wb25lbnQgdG8gYmUgZm9jdXNlZFxyXG5cdFx0bG9nb3V0OiBUaHVuZGVyLm9wdGlvbnMuY3VzdG9tZXJEYXNoYm9hcmRMb2dvdXQsXHJcblxyXG5cdH0sIHN1cHBvcnRlZENvbXBvbmVudHMoKS5yZWR1Y2UoKG8sIGNvbXBvbmVudCkgPT4ge1xyXG5cclxuXHRcdHJldHVybiBzZXQobywgY2FtZWxDYXNlKFsnb25WaWV3JywgY29tcG9uZW50XSksIGZ1bmN0aW9uKCRjb250YWluZXIsIGNvbnRleHQsICR2aWV3Q29udGFpbmVyKSB7XHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlbmRlcigkdmlld0NvbnRhaW5lciwgY29tcG9uZW50KTtcclxuXHRcdH0pO1xyXG5cclxuXHR9LCB7fSkpO1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5wcmUgPSBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaykge1xyXG5cclxuXHRcdGNvbnN0IHRyYW5zbGF0aW9uS2V5cyA9IHtcclxuXHRcdFx0J2N1c3RvbWVyLXVwZGF0ZSc6ICAgICAgICAgICdjdXN0b21lckluZm8nLFxyXG5cdFx0XHQnY3VzdG9tZXItdXBkYXRlLWFkZHJlc3MnOiAgJ2N1c3RvbWVyQWRkcmVzcycsXHJcblx0XHRcdCdvcmRlci1saXN0JzogICAgICAgICAgICAgICAnb3JkZXJMaXN0JyxcclxuXHRcdFx0J3N1YnNjcmlwdGlvbi1saXN0JzogICAgICAgICdzdWJzY3JpcHRpb25MaXN0JyxcclxuXHRcdFx0J2N1c3RvbWVyLWNvdXBvbnMnOiAgICAgICAgICdjdXN0b21lckNvdXBvbnMnLFxyXG5cdFx0XHQnY3VzdG9tZXItcmV2aWV3cyc6ICAgICAgICAgJ2N1c3RvbWVyUmV2aWV3cycsXHJcblx0XHRcdCdjdXN0b21lci1yZXZpZXctY29tbWVudHMnOiAnY3VzdG9tZXJSZXZpZXdDb21tZW50cycsXHJcblx0XHRcdCdjdXN0b21lci1kZWxldGUtYWNjb3VudCc6ICAnY3VzdG9tZXJEZWxldGVBY2NvdW50J1xyXG5cdFx0fTtcclxuXHJcblx0XHRjb250ZXh0Lm5hdiA9IFRodW5kZXIudXRpbC5wYXJzZUFycmF5U3RyaW5nKGNvbnRleHQub3B0aW9ucy5uYXYpLm1hcChjb21wb25lbnQgPT4gKHtcclxuXHRcdFx0a2V5OiBjb21wb25lbnQsXHJcblx0XHRcdHRyYW5zbGF0aW9uS2V5OiB0cmFuc2xhdGlvbktleXNbY29tcG9uZW50XVxyXG5cdFx0fSkpO1xyXG5cclxuXHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBjb250ZXh0KTtcclxuXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24uaW5pdCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuXHJcblx0XHRjb25zdCAkY29udGFpbmVyID0gJCh0aGlzKTtcclxuXHRcdGNvbnN0ICRtZW51ID0gJCh0aGlzKS5maW5kKGBbZGF0YS1jb21wb25lbnRdYCk7XHJcblx0XHRjb25zdCAkdmlld0NvbnRhaW5lciA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWN1c3RvbWVyLWRhc2hib2FyZC12aWV3Jyk7XHJcblx0XHRjb25zdCAkbG9nb3V0V3JhcCA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWxvZ291dC13cmFwJyk7XHJcblx0XHRjb25zdCAkbG9nb3V0ID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tbG9nb3V0Jyk7XHJcblxyXG5cdFx0dmlld0NvbXBvbmVudChjb250ZXh0Lm9wdGlvbnMuZm9jdXMpO1xyXG5cclxuXHRcdCRtZW51Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdmlld0NvbXBvbmVudCgkKHRoaXMpLmRhdGEoJ2NvbXBvbmVudCcpKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHZpZXdDb21wb25lbnQoY29tcG9uZW50KSB7XHJcblxyXG5cdFx0XHQkbG9nb3V0V3JhcFtjb21wb25lbnQgPT09ICdjdXN0b21lci11cGRhdGUnID8gJ3JlbW92ZUNsYXNzJyA6ICdhZGRDbGFzcyddKCdoaWRkZW4nKTtcclxuXHJcblx0XHRcdCRtZW51LnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuXHRcdFx0JGNvbnRhaW5lci5maW5kKGBbZGF0YS1jb21wb25lbnQ9XCIke2NvbXBvbmVudH1cIl1gKS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5leGVjdXRlKFxyXG5cdFx0XHRcdGNvbnRleHQub3B0aW9uc1tjYW1lbENhc2UoWydvblZpZXcnLCBjb21wb25lbnRdKV0sXHJcblx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRjb250ZXh0LFxyXG5cdFx0XHRcdCR2aWV3Q29udGFpbmVyXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0JGxvZ291dC5vbignY2xpY2snLCAoKSA9PiB7XHJcblx0XHRcdFRodW5kZXIubG9nb3V0KCk7XHJcblx0XHRcdFRodW5kZXIuY2xvc2UoKTtcclxuXHRcdH0pO1xyXG5cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gVGh1bmRlciA9PiB7XHJcblxyXG5cdGNvbnN0IGltcGxlbWVudGF0aW9uID0ge1xyXG5cdFx0bmFtZTogJ2N1c3RvbWVyLWRlbGV0ZS1hY2NvdW50J1xyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLm9wdGlvbnMgPSAoKSA9PiAoe1xyXG5cclxuXHRcdGNvbmZpcm1PbkRlbGV0ZTogVGh1bmRlci5vcHRpb25zLmNvbmZpcm1hdGlvbi5jdXN0b21lckRlbGV0ZSwgLy8gV2hldGhlciB0byBjb25maXJtIGJlZm9yZSBkZWxldGluZ1xyXG5cclxuXHRcdG9uRGVsZXRlOiBmdW5jdGlvbigkY29udGFpbmVyLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0XHRUaHVuZGVyLm5vdGlmeSgnc3VjY2VzcycsIGNvbnRleHQubSgnZGVsZXRlU3VjY2VzcycpKTtcclxuXHJcblx0XHRcdFRodW5kZXIucGx1Z2lucy5yZWRpcmVjdChUaHVuZGVyLm9wdGlvbnMucm9vdCk7XHJcblx0XHR9XHJcblxyXG5cdH0pO1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5pbml0ID0gZnVuY3Rpb24oY29udGV4dCkge1xyXG5cclxuXHRcdGNvbnN0ICRjb250YWluZXIgPSAkKHRoaXMpO1xyXG5cdFx0Y29uc3QgJGZvcm0gPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1jdXN0b21lci1kZWxldGUtYWNjb3VudC1mb3JtJyk7XHJcblx0XHRjb25zdCAkYnV0dG9uID0gJGZvcm0uZmluZCgnLnRodW5kZXItLWRlbGV0ZS1hY2NvdW50Jyk7XHJcblx0XHRjb25zdCBidXR0b25TcGlubmVyID0gVGh1bmRlci51dGlsLm1ha2VBc3luY0J1dHRvbigkYnV0dG9uKTtcclxuXHJcblx0XHQkYnV0dG9uLm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblxyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0aWYgKCFjb250ZXh0Lm9wdGlvbnMuY29uZmlybU9uRGVsZXRlKSB7XHJcblx0XHRcdFx0cmV0dXJuIGRlbGV0ZUN1c3RvbWVyKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnBsdWdpbnMuY29uZmlybWF0aW9uKFxyXG5cdFx0XHRcdGNvbnRleHQubSgnZGVsZXRlQ29uZmlybScpLFxyXG5cdFx0XHRcdCgpID0+IGRlbGV0ZUN1c3RvbWVyKCksXHJcblx0XHRcdFx0KCkgPT4gYnV0dG9uU3Bpbm5lci5kb25lKClcclxuXHRcdFx0KTtcclxuXHJcblx0XHR9KTtcclxuXHJcblx0XHRmdW5jdGlvbiBkZWxldGVDdXN0b21lcigpIHtcclxuXHJcblx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHRkZWZhdWx0OiBjb250ZXh0Lm0oYGRlbGV0ZUZhaWxlZGApXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ0RFTEVURScsXHJcblx0XHRcdFx0dXJsOiAgICAnL3YxL21lJyxcclxuXHRcdFx0fSkudGhlbigoKSA9PiB7XHJcblxyXG5cdFx0XHRcdGJ1dHRvblNwaW5uZXIuZG9uZSgpO1xyXG5cclxuXHRcdFx0XHRUaHVuZGVyLmxvZ291dCgpO1xyXG5cclxuXHRcdFx0XHRUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25EZWxldGUsXHJcblx0XHRcdFx0XHQkY29udGFpbmVyLFxyXG5cdFx0XHRcdFx0Y29udGV4dFxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9LCBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0XHRlcnJvcnMsXHJcblx0XHRcdFx0ZXJyID0+IGJ1dHRvblNwaW5uZXIuZG9uZSgpXHJcblx0XHRcdCkpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IFRodW5kZXIgPT4ge1xyXG5cclxuXHRjb25zdCBpbXBsZW1lbnRhdGlvbiA9IHtcclxuXHRcdG5hbWU6ICdjdXN0b21lci1sb2dpbidcclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5vcHRpb25zID0gKCkgPT4gKHtcclxuXHJcblx0XHRzb2NpYWxBcHBzOiBUaHVuZGVyLm9wdGlvbnMuc29jaWFsQXBwcyxcclxuXHJcblx0XHRvbkxvZ2luOiBmdW5jdGlvbigkY29udGFpbmVyLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0XHRUaHVuZGVyLm5vdGlmeSgnc3VjY2VzcycsIGNvbnRleHQubSgnbG9naW5TdWNjZXNzJykpO1xyXG5cclxuXHRcdFx0VGh1bmRlci5wbHVnaW5zLnJlZGlyZWN0KFRodW5kZXIub3B0aW9ucy5yb290KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0b25Tb2NpYWxMb2dpbjogZnVuY3Rpb24oJGNvbnRhaW5lciwgY29udGV4dCwgZGF0YSkge1xyXG5cclxuXHRcdFx0VGh1bmRlci5ub3RpZnkoJ3N1Y2Nlc3MnLCBjb250ZXh0Lm0oJ2xvZ2luU3VjY2VzcycpKTtcclxuXHJcblx0XHRcdFRodW5kZXIucGx1Z2lucy5yZWRpcmVjdChUaHVuZGVyLm9wdGlvbnMucm9vdCk7XHJcblx0XHR9XHJcblxyXG5cdH0pO1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5wcmUgPSBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaykge1xyXG5cclxuXHRcdGNvbnRleHQuc29jaWFsID0gKCkgPT4gVGh1bmRlci51aXNbJ3NvY2lhbC1sb2dpbiddKHtcclxuXHRcdFx0dHlwZTogICAgJ2xvZ2luJyxcclxuXHRcdFx0dmVuZG9yczogY29udGV4dC5vcHRpb25zLnNvY2lhbEFwcHNcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBjb250ZXh0KTtcclxuXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24uaW5pdCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuXHJcblx0XHRjb25zdCAkY29udGFpbmVyID0gJCh0aGlzKTtcclxuXHRcdGNvbnN0ICRmb3JtID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tbG9naW4tZm9ybScpO1xyXG5cdFx0Y29uc3QgJGJ1dHRvbiA9ICRmb3JtLmZpbmQoJy50aHVuZGVyLS1sb2dpbi1jdXN0b21lcicpO1xyXG5cdFx0Y29uc3QgJGdvVG9SZXNldFBhc3N3b3JkID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tZ28tdG8tcmVzZXQtcGFzc3dvcmQnKTtcclxuXHRcdGNvbnN0IGJ1dHRvblNwaW5uZXIgPSBUaHVuZGVyLnV0aWwubWFrZUFzeW5jQnV0dG9uKCRidXR0b24pO1xyXG5cclxuXHRcdFRodW5kZXIudXRpbC5iaW5kU29jaWFsQXBwcygkY29udGFpbmVyKTtcclxuXHJcblx0XHRjb25zdCBzb2NpYWxEYXRhID0gVGh1bmRlci51dGlsLmhhbmRsZVNvY2lhbExvZ2luKCk7XHJcblxyXG5cdFx0aWYgKHNvY2lhbERhdGEpIHtcclxuXHJcblx0XHRcdFRodW5kZXIuZXhlY3V0ZShcclxuXHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25Tb2NpYWxMb2dpbixcclxuXHRcdFx0XHQkY29udGFpbmVyLFxyXG5cdFx0XHRcdGNvbnRleHQsXHJcblx0XHRcdFx0c29jaWFsRGF0YVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCRnb1RvUmVzZXRQYXNzd29yZC5vbignY2xpY2snLCAoKSA9PiB7XHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlbmRlcigkY29udGFpbmVyLCAnY3VzdG9tZXItcmVzZXQtcGFzc3dvcmQnLCB7XHJcblx0XHRcdFx0YmFjazoge1xyXG5cdFx0XHRcdFx0JGNvbnRhaW5lcjogJGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdGNvbXBvbmVudDogIGltcGxlbWVudGF0aW9uLm5hbWUsXHJcblx0XHRcdFx0XHRvcHRpb25zOiAgICBjb250ZXh0Lm9wdGlvbnNcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0VGh1bmRlci51dGlsLm1ha2VSZWNhcHRjaGEoaW1wbGVtZW50YXRpb24ubmFtZSwgJGJ1dHRvbiwgZnVuY3Rpb24odG9rZW4sIHJlc2V0UmVjYXB0Y2hhKSB7XHJcblxyXG5cdFx0XHRjb25zdCBkYXRhID0gVGh1bmRlci51dGlsLnVzZXJJZE9yRW1haWwoXHJcblx0XHRcdFx0VGh1bmRlci51dGlsLmZvcm1Ub0pTT04oJGZvcm0uc2VyaWFsaXplQXJyYXkoKSlcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGNvbnN0IHJlc2V0U3RhdGUgPSAoKSA9PiB7XHJcblx0XHRcdFx0YnV0dG9uU3Bpbm5lci5kb25lKCk7XHJcblx0XHRcdFx0cmV0dXJuIHJlc2V0UmVjYXB0Y2hhICYmIHJlc2V0UmVjYXB0Y2hhKCk7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdFx0J25vdC1leGlzdGluZy1jdXN0b21lcic6IGNvbnRleHQubSgnbm90RXhpc3RpbmdDdXN0b21lcicpLFxyXG5cdFx0XHRcdCdpbnZhbGlkLXBhc3N3b3JkJzogICAgICBjb250ZXh0Lm0oJ2ludmFsaWRQYXNzd29yZCcpLFxyXG5cdFx0XHRcdGRlZmF1bHQ6ICAgICAgICAgICAgICAgICBjb250ZXh0Lm0oJ2xvZ2luRmFpbGVkJylcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0bWV0aG9kOiAnUE9TVCcsXHJcblx0XHRcdFx0dXJsOiAgICAnL3YxL2N1c3RvbWVycy9hdXRoJyxcclxuXHRcdFx0XHRkYXRhOiAgIGRhdGEsXHJcblx0XHRcdH0pLnRoZW4oZGF0YSA9PiB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHN0b3JhZ2UgPSBUaHVuZGVyLnBsdWdpbnMuY3JlZGVudGlhbFN0b3JhZ2U7XHJcblxyXG5cdFx0XHRcdHN0b3JhZ2Uuc2V0SXRlbShUaHVuZGVyLm9wdGlvbnMuYXV0aFN0b3JhZ2UuY3VzdG9tZXIsIGRhdGEudG9rZW4pO1xyXG5cclxuXHRcdFx0XHRUaHVuZGVyLmhlYWRlcigpO1xyXG5cclxuXHRcdFx0XHRUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25Mb2dpbixcclxuXHRcdFx0XHRcdCRjb250YWluZXIsXHJcblx0XHRcdFx0XHRjb250ZXh0XHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHJlc2V0U3RhdGUoKTtcclxuXHJcblx0XHRcdH0sIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdGVycm9ycyxcclxuXHRcdFx0XHQoKSA9PiByZXNldFN0YXRlKClcclxuXHRcdFx0KSk7XHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdH07XHJcblxyXG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcclxuXHJcbn07IiwiY29uc3QgZ2V0ID0gcmVxdWlyZSgnbG9kYXNoLmdldCcpO1xyXG5jb25zdCBjYW1lbENhc2UgPSByZXF1aXJlKCdsb2Rhc2guY2FtZWxjYXNlJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRodW5kZXIgPT4ge1xyXG5cclxuXHRjb25zdCB0cmFuc2xhdGlvbktleSA9IHtcclxuXHRcdCduYW1lLmZpcnN0JzogJ2ZpcnN0TmFtZScsXHJcblx0XHQnbmFtZS5sYXN0JzogICdsYXN0TmFtZScsXHJcblx0XHQnbmFtZS5mdWxsJzogICdmdWxsTmFtZScsXHJcblx0fTtcclxuXHJcblx0Ly8gSW1wbGVtZW50YXRpb25cclxuXHRjb25zdCBpbXBsZW1lbnRhdGlvbiA9IHtcclxuXHRcdG5hbWU6ICdjdXN0b21lci1yZWdpc3RlcidcclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5vcHRpb25zID0gKCkgPT4gKHtcclxuXHJcblx0XHRmaWVsZHM6ICAgICAgICAgIFRodW5kZXIub3B0aW9ucy5jdXN0b21lclJlZ2lzdHJhdGlvbkZpZWxkcyxcclxuXHRcdGJpcnRoZGF0ZUZvcm1hdDogVGh1bmRlci5vcHRpb25zLmRhdGVJbnB1dEZvcm1hdCxcclxuXHRcdHNvY2lhbEFwcHM6ICAgICAgVGh1bmRlci5vcHRpb25zLnNvY2lhbEFwcHMsXHJcblx0XHR0ZXJtc0xpbms6ICAgICAgIFRodW5kZXIub3B0aW9ucy5sZWdhbC5yZWdpc3RyYXRpb25UZXJtcy5saW5rLFxyXG5cdFx0dGVybXNUZXh0OiAgICAgICBUaHVuZGVyLm9wdGlvbnMubGVnYWwucmVnaXN0cmF0aW9uVGVybXMudGV4dCxcclxuXHRcdHByaXZhY3lMaW5rOiAgICAgVGh1bmRlci5vcHRpb25zLmxlZ2FsLnJlZ2lzdHJhdGlvblByaXZhY3kubGluayxcclxuXHRcdHByaXZhY3lUZXh0OiAgICAgVGh1bmRlci5vcHRpb25zLmxlZ2FsLnJlZ2lzdHJhdGlvblByaXZhY3kudGV4dCxcclxuXHJcblx0XHRvblJlZ2lzdGVyOiBmdW5jdGlvbigkY29udGFpbmVyLCBjb250ZXh0LCBjdXN0b21lcikge1xyXG5cclxuXHRcdFx0VGh1bmRlci5ub3RpZnkoJ3N1Y2Nlc3MnLCBjb250ZXh0Lm0oJ3JlZ2lzdGVyU3VjY2VzcycpKTtcclxuXHJcblx0XHRcdFRodW5kZXIucmVuZGVyKCRjb250YWluZXIsICdjdXN0b21lci1sb2dpbicpO1xyXG5cdFx0fSxcclxuXHRcdG9uU29jaWFsUmVnaXN0ZXI6IGZ1bmN0aW9uKCRjb250YWluZXIsIGNvbnRleHQsIGRhdGEpIHtcclxuXHJcblx0XHRcdGlmIChkYXRhLmVycm9yKSB7XHJcblx0XHRcdFx0aWYgKGRhdGEuZXJyb3IgPT09ICdkdXBsaWNhdGVkLWVtYWlsJykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFRodW5kZXIubm90aWZ5KCdlcnJvcicsIGNvbnRleHQubSgnZHVwbGljYXRlZEVtYWlsJykpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0VGh1bmRlci5ub3RpZnkoJ3N1Y2Nlc3MnLCBjb250ZXh0Lm0oJ3JlZ2lzdGVyU3VjY2VzcycpKTtcclxuXHJcblx0XHRcdFRodW5kZXIucGx1Z2lucy5yZWRpcmVjdChUaHVuZGVyLm9wdGlvbnMucm9vdCk7XHJcblx0XHR9XHJcblxyXG5cdH0pO1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5wcmUgPSBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaykge1xyXG5cclxuXHRcdGNvbnN0IHtcclxuXHRcdFx0dGVybXNMaW5rLFxyXG5cdFx0XHR0ZXJtc1RleHQsXHJcblx0XHRcdHByaXZhY3lMaW5rLFxyXG5cdFx0XHRwcml2YWN5VGV4dCxcclxuXHRcdH0gPSBjb250ZXh0Lm9wdGlvbnM7XHJcblxyXG5cdFx0Y29udGV4dC5hZ3JlZW1lbnRzID0gW1xyXG5cdFx0XHQodGVybXNMaW5rIHx8IHRlcm1zVGV4dCkgPyAndGVybXMnIDogbnVsbCxcclxuXHRcdFx0KHByaXZhY3lMaW5rIHx8IHByaXZhY3lUZXh0KSA/ICdwcml2YWN5JyA6IG51bGwsXHJcblx0XHRdLmZpbHRlcih2ID0+IHYpO1xyXG5cclxuXHRcdGNvbnN0IGJpcnRoT3B0aW9ucyA9IHtcclxuXHRcdFx0WVlZWTogeyBrZXk6ICdiaXJ0aFllYXInLCB0cmFuc2xhdGlvbktleTogJ3llYXInLCB0ZXN0ZXI6IC9eXFxkezR9JC8gfSxcclxuXHRcdFx0TU06ICAgeyBrZXk6ICdiaXJ0aE1vbnRoJywgdHJhbnNsYXRpb25LZXk6ICdtb250aCcsIHRlc3RlcjogL15cXGR7MSwyfSQvIH0sXHJcblx0XHRcdEREOiAgIHsga2V5OiAnYmlydGhEYXRlJywgdHJhbnNsYXRpb25LZXk6ICdkYXRlJywgdGVzdGVyOiAvXlxcZHsxLDJ9JC8gfVxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBiaXJ0aGRhdGVGb3JtYXRzID0gY29udGV4dC5vcHRpb25zLmJpcnRoZGF0ZUZvcm1hdC5zcGxpdCgnLScpO1xyXG5cclxuXHRcdGNvbnRleHQuZmllbGRzID0gVGh1bmRlci51dGlsLnBhcnNlQXJyYXlTdHJpbmcoY29udGV4dC5vcHRpb25zLmZpZWxkcykubWFwKGZpZWxkID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IFtrZXksIHJlcXVpcmVkXSA9IGZpZWxkLnNwbGl0KCc6Jyk7XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHJlcXVpcmVkOiAgICAgICByZXF1aXJlZCA9PT0gJ3JlcXVpcmVkJyxcclxuXHRcdFx0XHRrZXk6ICAgICAgICAgICAga2V5LFxyXG5cdFx0XHRcdHRyYW5zbGF0aW9uS2V5OiB0cmFuc2xhdGlvbktleVtrZXldIHx8IGtleVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdGNvbnRleHQuYmlydGhkYXRlRmllbGRzID0gYmlydGhkYXRlRm9ybWF0cy5tYXAoKGZvcm1hdCwgaSkgPT4ge1xyXG5cclxuXHRcdFx0cmV0dXJuICQuZXh0ZW5kKHtcclxuXHRcdFx0XHRsYXN0OiBpID09PSBiaXJ0aGRhdGVGb3JtYXRzLmxlbmd0aCAtIDFcclxuXHRcdFx0fSwgYmlydGhPcHRpb25zW2Zvcm1hdF0pO1xyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdGNvbnRleHQuc29jaWFsID0gKCkgPT4gVGh1bmRlci51aXNbJ3NvY2lhbC1sb2dpbiddKHtcclxuXHRcdFx0dHlwZTogICAgJ3JlZ2lzdGVyJyxcclxuXHRcdFx0dmVuZG9yczogY29udGV4dC5vcHRpb25zLnNvY2lhbEFwcHNcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBjb250ZXh0KTtcclxuXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24uaW5pdCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuXHJcblx0XHRjb25zdCAkY29udGFpbmVyID0gJCh0aGlzKTtcclxuXHRcdGNvbnN0ICRmb3JtID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tcmVnaXN0ZXItZm9ybScpO1xyXG5cdFx0Y29uc3QgJGJ1dHRvbiA9ICRmb3JtLmZpbmQoJy50aHVuZGVyLS1yZWdpc3Rlci1jdXN0b21lcicpO1xyXG5cdFx0Y29uc3QgYnV0dG9uU3Bpbm5lciA9IFRodW5kZXIudXRpbC5tYWtlQXN5bmNCdXR0b24oJGJ1dHRvbiwgeyBiaW5kOiBmYWxzZSB9KTtcclxuXHJcblx0XHRjb25zdCBhcmVUZXJtc0FncmVlZCA9IFRodW5kZXIudXRpbC5iaW5kQWdyZWVtZW50cyh7XHJcblx0XHRcdCR0ZXJtczogJCh0aGlzKS5maW5kKCdbZGF0YS1hZ3JlZW1lbnQtc2NvcGVdJyksXHJcblx0XHRcdGFncmVlbWVudHM6IHtcclxuXHRcdFx0XHR0ZXJtczogICB7XHJcblx0XHRcdFx0XHR0ZXh0OiAgY29udGV4dC5vcHRpb25zLnRlcm1zVGV4dCxcclxuXHRcdFx0XHRcdGxpbms6ICBjb250ZXh0Lm9wdGlvbnMudGVybXNMaW5rLFxyXG5cdFx0XHRcdFx0ZXJyb3I6IGNvbnRleHQubSgndGVybXNBZ3JlZW1lbnRSZXF1aXJlZCcpXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRwcml2YWN5OiB7XHJcblx0XHRcdFx0XHR0ZXh0OiAgY29udGV4dC5vcHRpb25zLnByaXZhY3lUZXh0LFxyXG5cdFx0XHRcdFx0bGluazogIGNvbnRleHQub3B0aW9ucy5wcml2YWN5TGluayxcclxuXHRcdFx0XHRcdGVycm9yOiBjb250ZXh0Lm0oJ3ByaXZhY3lBZ3JlZW1lbnRSZXF1aXJlZCcpXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0VGh1bmRlci51dGlsLmJpbmRTb2NpYWxBcHBzKCRjb250YWluZXIsIGFyZVRlcm1zQWdyZWVkKTtcclxuXHJcblx0XHRjb25zdCBzb2NpYWxEYXRhID0gVGh1bmRlci51dGlsLmhhbmRsZVNvY2lhbExvZ2luKCk7XHJcblxyXG5cdFx0aWYgKHNvY2lhbERhdGEpIHtcclxuXHJcblx0XHRcdFRodW5kZXIuZXhlY3V0ZShcclxuXHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25Tb2NpYWxSZWdpc3RlcixcclxuXHRcdFx0XHQkY29udGFpbmVyLFxyXG5cdFx0XHRcdGNvbnRleHQsXHJcblx0XHRcdFx0c29jaWFsRGF0YVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdFRodW5kZXIudXRpbC5tYWtlUmVjYXB0Y2hhKHtcclxuXHRcdFx0Y29tcG9uZW50TmFtZTogaW1wbGVtZW50YXRpb24ubmFtZSxcclxuXHRcdFx0YnV0dG9uOiAgICAgICAgJGJ1dHRvbixcclxuXHRcdFx0dmFsaWRhdGU6ICAgICAgdmFsaWRhdGVEYXRhLFxyXG5cdFx0XHRjYWxsYmFjazogICAgICBmdW5jdGlvbih0b2tlbiwgcmVzZXRSZWNhcHRjaGEpIHtcclxuXHJcblx0XHRcdFx0YnV0dG9uU3Bpbm5lci5ydW4oKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgcmVzZXRTdGF0ZSA9ICgpID0+IHtcclxuXHRcdFx0XHRcdGJ1dHRvblNwaW5uZXIuZG9uZSgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHJlc2V0UmVjYXB0Y2hhICYmIHJlc2V0UmVjYXB0Y2hhKCk7XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0Y29uc3Qgc3VjY2VzcyA9IGN1c3RvbWVyID0+IHtcclxuXHJcblx0XHRcdFx0XHRUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdFx0XHRcdGNvbnRleHQub3B0aW9ucy5vblJlZ2lzdGVyLFxyXG5cdFx0XHRcdFx0XHQkY29udGFpbmVyLFxyXG5cdFx0XHRcdFx0XHRjb250ZXh0LFxyXG5cdFx0XHRcdFx0XHRjdXN0b21lclxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gcmVzZXRTdGF0ZSgpO1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGNvbnN0IGZhaWwgPSBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoZXJyLnJlc3BvbnNlSlNPTiwge1xyXG5cdFx0XHRcdFx0J2R1cGxpY2F0ZWQtZW1haWwnOiAgIGNvbnRleHQubSgnZHVwbGljYXRlZEVtYWlsJyksXHJcblx0XHRcdFx0XHQnZHVwbGljYXRlZC11c2VyLWlkJzogY29udGV4dC5tKCdkdXBsaWNhdGVkVXNlcklkJyksXHJcblx0XHRcdFx0XHRkZWZhdWx0OiAgICAgICAgICAgICAgY29udGV4dC5tKCdyZWdpc3RlckZhaWxlZCcpLFxyXG5cdFx0XHRcdFx0dmFsaWRhdGlvbjogZXJyID0+IHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IFssIC4uLnBhdGhdID0gZXJyLnZhbGlkYXRpb24uc291cmNlLnNwbGl0KCcuJyk7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGZpZWxkID0gcGF0aC5qb2luKCcuJyk7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gY29udGV4dC5tKGNhbWVsQ2FzZShbJ2ludmFsaWQnLCB0cmFuc2xhdGlvbktleVtmaWVsZF0gfHwgZmllbGRdKSk7XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdH0sIGVyciA9PiB7XHJcblx0XHRcdFx0XHRyZXR1cm4gcmVzZXRTdGF0ZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRcdG1ldGhvZDogJ1BPU1QnLFxyXG5cdFx0XHRcdFx0dXJsOiAgICAnL3YxL21lJyxcclxuXHRcdFx0XHRcdGRhdGE6ICAgZ2V0Q3VzdG9tZXIoKSxcclxuXHRcdFx0XHR9KS50aGVuKHN1Y2Nlc3MsIGZhaWwpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGdldEN1c3RvbWVyKCkge1xyXG5cclxuXHRcdFx0Y29uc3QgYmlydGhGaWVsZHMgPSBbXHJcblx0XHRcdFx0J2JpcnRoWWVhcicsXHJcblx0XHRcdFx0J2JpcnRoTW9udGgnLFxyXG5cdFx0XHRcdCdiaXJ0aERhdGUnLFxyXG5cdFx0XHRdO1xyXG5cclxuXHRcdFx0Y29uc3QgZGF0YSA9IFRodW5kZXIudXRpbC5mb3JtVG9KU09OKCRmb3JtLnNlcmlhbGl6ZUFycmF5KCkpO1xyXG5cclxuXHRcdFx0aWYgKGJpcnRoRmllbGRzLmV2ZXJ5KGZpZWxkID0+IGRhdGFbZmllbGRdKSkge1xyXG5cclxuXHRcdFx0XHRkYXRhLmJpcnRoZGF0ZSA9IG5ldyBEYXRlKFxyXG5cdFx0XHRcdFx0ZGF0YS5iaXJ0aFllYXIsXHJcblx0XHRcdFx0XHRkYXRhLmJpcnRoTW9udGggLSAxLFxyXG5cdFx0XHRcdFx0ZGF0YS5iaXJ0aERhdGVcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRiaXJ0aEZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IGRlbGV0ZSBkYXRhW2ZpZWxkXSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gdmFsaWRhdGVEYXRhKCkge1xyXG5cclxuXHRcdFx0Y29uc3QgY3VzdG9tZXIgPSBnZXRDdXN0b21lcigpO1xyXG5cclxuXHRcdFx0Y29uc3QgcmVxdWlyZWRGaWVsZHMgPSBjb250ZXh0LmZpZWxkcy5maWx0ZXIoKHsgcmVxdWlyZWQgfSkgPT4gcmVxdWlyZWQpO1xyXG5cclxuXHRcdFx0Zm9yIChjb25zdCB7IGtleSwgdHJhbnNsYXRpb25LZXkgfSBvZiByZXF1aXJlZEZpZWxkcykge1xyXG5cclxuXHRcdFx0XHRpZiAoIWdldChjdXN0b21lciwga2V5LCBudWxsKSkge1xyXG5cdFx0XHRcdFx0VGh1bmRlci5ub3RpZnkoJ2Vycm9yJywgY29udGV4dC5tKGAke3RyYW5zbGF0aW9uS2V5fVJlcXVpcmVkYCkpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBhcmVUZXJtc0FncmVlZCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IFRodW5kZXIgPT4ge1xyXG5cclxuXHRjb25zdCBpbXBsZW1lbnRhdGlvbiA9IHtcclxuXHRcdG5hbWU6ICdjdXN0b21lci1yZXNldC1wYXNzd29yZCdcclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5vcHRpb25zID0gKCkgPT4gKHtcclxuXHRcdGN1c3RvbWVyOiAgJ2N1c3RvbWVyJyxcclxuXHRcdHNlY3JldDogICAgJ3NlY3JldCcsXHJcblx0XHRpbnB1dDogICAgICdxdWVyeScsICAgICAgLy8gJ3F1ZXJ5JyBvciAnYXR0cmlidXRlJ1xyXG5cdFx0ZXhwaXJlc0luOiA2MCAqIDYwICogMjQsIC8vIDI0IGhvdXJzXHJcblx0XHRvbkVtYWlsUmVxdWVzdDogZnVuY3Rpb24oJGNvbnRhaW5lciwgY29udGV4dCkge1xyXG5cclxuXHRcdFx0VGh1bmRlci5ub3RpZnkoJ3N1Y2Nlc3MnLCBjb250ZXh0Lm0oJ3JlcXVlc3RFbWFpbFN1Y2Nlc3MnKSk7XHJcblx0XHR9LFxyXG5cdFx0b25QYXNzd29yZFJlc2V0OiBmdW5jdGlvbigkY29udGFpbmVyLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0XHRUaHVuZGVyLm5vdGlmeSgnc3VjY2VzcycsIGNvbnRleHQubSgnc2V0UGFzc3dvcmRTdWNjZXNzJykpO1xyXG5cclxuXHRcdFx0VGh1bmRlci5yZW5kZXIoJGNvbnRhaW5lciwgJ2N1c3RvbWVyLWxvZ2luJyk7XHJcblx0XHR9LFxyXG5cdH0pO1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5wcmUgPSBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaykge1xyXG5cclxuXHRcdGlmIChjb250ZXh0Lm9wdGlvbnMuaW5wdXQgPT09ICdxdWVyeScpIHtcclxuXHJcblx0XHRcdGNvbnN0IHF1ZXJ5ID0gVGh1bmRlci51dGlsLnVybFF1ZXJ5KCk7XHJcblx0XHRcdGNvbnN0IGN1c3RvbWVyRmllbGQgPSBjb250ZXh0Lm9wdGlvbnMuY3VzdG9tZXI7XHJcblx0XHRcdGNvbnN0IHNlY3JldEZpZWxkID0gY29udGV4dC5vcHRpb25zLnNlY3JldDtcclxuXHJcblx0XHRcdGlmIChxdWVyeVtjdXN0b21lckZpZWxkXSAmJlxyXG5cdFx0XHRcdHF1ZXJ5W3NlY3JldEZpZWxkXSkge1xyXG5cclxuXHRcdFx0XHRjb250ZXh0LmN1c3RvbWVyID0gcXVlcnlbY3VzdG9tZXJGaWVsZF07XHJcblx0XHRcdFx0Y29udGV4dC5zZWNyZXQgPSBxdWVyeVtzZWNyZXRGaWVsZF07XHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQub3B0aW9ucy5pbnB1dCA9PT0gJ2F0dHJpYnV0ZScpIHtcclxuXHJcblx0XHRcdGNvbnRleHQuY3VzdG9tZXIgPSBjb250ZXh0Lm9wdGlvbnMuY3VzdG9tZXI7XHJcblx0XHRcdGNvbnRleHQuc2VjcmV0ID0gY29udGV4dC5vcHRpb25zLnNlY3JldDtcclxuXHRcdH1cclxuXHJcblx0XHRjb250ZXh0LnR5cGUgPSBjb250ZXh0LmN1c3RvbWVyICYmXHJcblx0XHRcdFx0XHRcdGNvbnRleHQuc2VjcmV0ID9cclxuXHRcdFx0XHRcdFx0XHQncmVzZXQtcGFzc3dvcmQnIDpcclxuXHRcdFx0XHRcdFx0XHQncmVxdWVzdC1lbWFpbCc7XHJcblxyXG5cdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIGNvbnRleHQpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5pbml0ID0gZnVuY3Rpb24oY29udGV4dCkge1xyXG5cclxuXHRcdGNvbnN0ICRjb250YWluZXIgPSAkKHRoaXMpO1xyXG5cdFx0Y29uc3QgJGZvcm0gPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1yZXNldC1wYXNzd29yZC1mb3JtJyk7XHJcblxyXG5cdFx0aWYgKGNvbnRleHQudHlwZSA9PT0gJ3JlcXVlc3QtZW1haWwnKSB7XHJcblxyXG5cdFx0XHRjb25zdCAkcmVxdWVzdEVtYWlsID0gJGZvcm0uZmluZCgnLnRodW5kZXItLXJlcXVlc3QtZW1haWwnKTtcclxuXHRcdFx0Y29uc3QgJGdvVG9DdXN0b21lckxvZ2luID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tZ28tdG8tY3VzdG9tZXItbG9naW4nKTtcclxuXHRcdFx0Y29uc3QgcmVxdWVzdEVtYWlsU3Bpbm5lciA9IFRodW5kZXIudXRpbC5tYWtlQXN5bmNCdXR0b24oJHJlcXVlc3RFbWFpbCk7XHJcblxyXG5cdFx0XHRUaHVuZGVyLnV0aWwuYmluZEJhY2tCdXR0b24oJGdvVG9DdXN0b21lckxvZ2luLCBjb250ZXh0KTtcclxuXHJcblx0XHRcdFRodW5kZXIudXRpbC5tYWtlUmVjYXB0Y2hhKGltcGxlbWVudGF0aW9uLm5hbWUsICRyZXF1ZXN0RW1haWwsIGZ1bmN0aW9uKHRva2VuLCByZXNldFJlY2FwdGNoYSkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBkYXRhID0gJC5leHRlbmQoVGh1bmRlci51dGlsLnVzZXJJZE9yRW1haWwoXHJcblx0XHRcdFx0XHRUaHVuZGVyLnV0aWwuZm9ybVRvSlNPTigkZm9ybS5zZXJpYWxpemVBcnJheSgpKVxyXG5cdFx0XHRcdCksIHtcclxuXHRcdFx0XHRcdGV4cGlyZXNJbjogY29udGV4dC5vcHRpb25zLmV4cGlyZXNJbixcclxuXHRcdFx0XHRcdHNjb3BlOiAgICAgJ3Jlc2V0LXBhc3N3b3JkJ1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRjb25zdCByZXNldFN0YXRlID0gKCkgPT4ge1xyXG5cdFx0XHRcdFx0cmVxdWVzdEVtYWlsU3Bpbm5lci5kb25lKCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gcmVzZXRSZWNhcHRjaGEgJiYgcmVzZXRSZWNhcHRjaGEoKTtcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdFx0XHQnbm90LWV4aXN0aW5nLWN1c3RvbWVyJzogY29udGV4dC5tKCdub3RFeGlzdGluZ0N1c3RvbWVyJyksXHJcblx0XHRcdFx0XHQnZW1haWwtcmVxdWlyZWQnOiAgICAgICAgY29udGV4dC5tKCdjdXN0b21lcldpdGhvdXRFbWFpbCcpLFxyXG5cdFx0XHRcdFx0ZGVmYXVsdDogICAgICAgICAgICAgICAgIGNvbnRleHQubSgncmVxdWVzdEVtYWlsRmFpbGVkJylcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdFx0bWV0aG9kOiAgJ1BPU1QnLFxyXG5cdFx0XHRcdFx0dXJsOiAgICAgJy92MS9jdXN0b21lcnMvdmVyaWZpY2F0aW9ucy9lbWFpbHMnLFxyXG5cdFx0XHRcdFx0ZGF0YTogICAgZGF0YSxcclxuXHRcdFx0XHR9KS50aGVuKCgpID0+IHtcclxuXHJcblx0XHRcdFx0XHRUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdFx0XHRcdGNvbnRleHQub3B0aW9ucy5vbkVtYWlsUmVxdWVzdCxcclxuXHRcdFx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdFx0Y29udGV4dFxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gcmVzZXRTdGF0ZSgpO1xyXG5cclxuXHRcdFx0XHR9LCBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdFx0ZXJyb3JzLFxyXG5cdFx0XHRcdFx0ZXJyID0+IHJlc2V0U3RhdGUoKVxyXG5cdFx0XHRcdCkpO1xyXG5cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZXh0LnR5cGUgPT09ICdyZXNldC1wYXNzd29yZCcpIHtcclxuXHJcblx0XHRcdGNvbnN0ICRyZXNldFBhc3N3b3JkID0gJGZvcm0uZmluZCgnLnRodW5kZXItLXJlc2V0LXBhc3N3b3JkJyk7XHJcblx0XHRcdGNvbnN0IHJlc2V0UGFzc3dvcmRTcGlubmVyID0gVGh1bmRlci51dGlsLm1ha2VBc3luY0J1dHRvbigkcmVzZXRQYXNzd29yZCk7XHJcblxyXG5cdFx0XHRUaHVuZGVyLnV0aWwubWFrZVJlY2FwdGNoYShpbXBsZW1lbnRhdGlvbi5uYW1lLCAkcmVzZXRQYXNzd29yZCwgZnVuY3Rpb24odG9rZW4sIHJlc2V0UmVjYXB0Y2hhKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGRhdGEgPSAkLmV4dGVuZChUaHVuZGVyLnV0aWwuZm9ybVRvSlNPTigkZm9ybS5zZXJpYWxpemVBcnJheSgpKSwge1xyXG5cdFx0XHRcdFx0c2VjcmV0OiBjb250ZXh0LnNlY3JldFxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRjb25zdCByZXNldFN0YXRlID0gKCkgPT4ge1xyXG5cdFx0XHRcdFx0cmVzZXRQYXNzd29yZFNwaW5uZXIuZG9uZSgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHJlc2V0UmVjYXB0Y2hhICYmIHJlc2V0UmVjYXB0Y2hhKCk7XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0Y29uc3QgZXJyb3JzID0ge1xyXG5cdFx0XHRcdFx0ZGVmYXVsdDogY29udGV4dC5tKCdzZXRQYXNzd29yZEZhaWxlZCcpXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0VGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRcdG1ldGhvZDogICAgJ1BVVCcsXHJcblx0XHRcdFx0XHR1cmw6ICAgICAgIGAvdjEvY3VzdG9tZXJzLyR7Y29udGV4dC5jdXN0b21lcn0vcGFzc3dvcmRgLFxyXG5cdFx0XHRcdFx0ZGF0YTogICAgICBkYXRhLFxyXG5cdFx0XHRcdFx0cmVjYXB0Y2hhOiB0b2tlbixcclxuXHRcdFx0XHR9KS50aGVuKCgpID0+IHtcclxuXHJcblx0XHRcdFx0XHRUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdFx0XHRcdGNvbnRleHQub3B0aW9ucy5vblBhc3N3b3JkUmVzZXQsXHJcblx0XHRcdFx0XHRcdCRjb250YWluZXIsXHJcblx0XHRcdFx0XHRcdGNvbnRleHRcclxuXHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHJlc2V0U3RhdGUoKTtcclxuXHJcblx0XHRcdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0XHRcdGVycm9ycyxcclxuXHRcdFx0XHRcdGVyciA9PiByZXNldFN0YXRlKClcclxuXHRcdFx0XHQpKTtcclxuXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xyXG5cclxufTsiLCJjb25zdCBwcm9kdWN0UmV2aWV3ID0gcmVxdWlyZSgnLi4vcHJvZHVjdC1yZXZpZXcnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGh1bmRlciA9PiB7XHJcblxyXG5cdGNvbnN0IHByb2R1Y3RSZXZpZXdJbnN0YW5jZSA9IHByb2R1Y3RSZXZpZXcoVGh1bmRlcik7XHJcblxyXG5cdGNvbnN0IGltcGxlbWVudGF0aW9uID0ge1xyXG5cdFx0bmFtZTogJ2N1c3RvbWVyLXJldmlldy1jb21tZW50J1xyXG5cdH07XHJcblxyXG5cdC8vIE90aGVyIG9wdGlvbnMgd2lsbCBiZSBleGFjdGx5IHNhbWUgYXMgYHByb2R1Y3QtcmV2aWV3YCBjb21wb25lbnRcclxuXHRpbXBsZW1lbnRhdGlvbi5vcHRpb25zID0gKCkgPT4gJC5leHRlbmQoXHJcblx0XHRwcm9kdWN0UmV2aWV3SW5zdGFuY2Uub3B0aW9ucygpLFxyXG5cdFx0e1xyXG5cdFx0XHRjb21tZW50OiAgICAgIG51bGwsIC8vIENvbW1lbnQgSURcclxuXHRcdFx0c2hvd1Byb2R1Y3Q6ICB0cnVlLFxyXG5cdFx0XHRzaG93Q29tbWVudHM6IHtcclxuXHRcdFx0XHRmaWx0ZXI6ICAgICAgICAgbnVsbCxcclxuXHRcdFx0XHR1c2VCb2R5RXhjZXJwdDogZmFsc2UsXHJcblx0XHRcdFx0dXNlRmxhZzogICAgICAgIGZhbHNlLFxyXG5cdFx0XHRcdHVzZVBhZ2luYXRpb246ICBmYWxzZSxcclxuXHRcdFx0fSxcclxuXHRcdH1cclxuXHQpO1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5wcmUgPSBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaykge1xyXG5cclxuXHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBjb250ZXh0KTtcclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5pbml0ID0gZnVuY3Rpb24oY29udGV4dCkge1xyXG5cclxuXHRcdGNvbnN0ICRjb250YWluZXIgPSAkKHRoaXMpO1xyXG5cdFx0Y29uc3QgJGJhY2tUb0NvbW1lbnRzID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tYmFjay10by1jb21tZW50cycpO1xyXG5cdFx0Y29uc3QgJHJldmlld0NvbnRhaW5lciA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWN1c3RvbWVyLXJldmlldy1jb21tZW50LWNvbnRhaW5lcicpO1xyXG5cclxuXHRcdFRodW5kZXIudXRpbC5iaW5kQmFja0J1dHRvbigkYmFja1RvQ29tbWVudHMsIGNvbnRleHQpO1xyXG5cclxuXHRcdGlmIChjb250ZXh0Lm9wdGlvbnMuc2hvd0NvbW1lbnRzKSB7XHJcblx0XHRcdGNvbnRleHQub3B0aW9ucy5zaG93Q29tbWVudHMuZmlsdGVyID0geyBpZHM6IGNvbnRleHQub3B0aW9ucy5jb21tZW50IH07XHJcblx0XHR9XHJcblxyXG5cdFx0VGh1bmRlci5yZW5kZXIoJHJldmlld0NvbnRhaW5lciwgJ3Byb2R1Y3QtcmV2aWV3JywgY29udGV4dC5vcHRpb25zKTtcclxuXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xyXG5cclxufTsiLCJjb25zdCBzZXQgPSByZXF1aXJlKCdsb2Rhc2guc2V0Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRodW5kZXIgPT4ge1xyXG5cclxuXHRjb25zdCBpbXBsZW1lbnRhdGlvbiA9IHtcclxuXHRcdG5hbWU6ICdjdXN0b21lci1yZXZpZXctY29tbWVudHMnXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ub3B0aW9ucyA9ICgpID0+ICh7XHJcblx0XHRwYWdlOiAgICAgICAgICAgIDEsICAgICAgICAgICAgLy8gV2hpY2ggcGFnZSBvZiBjb21tZW50cz9cclxuXHRcdGxpbWl0OiAgICAgICAgICAgMTAsICAgICAgICAgICAvLyBIb3cgbWFueSBjb21tZW50cyBhdCBvbmNlP1xyXG5cdFx0c29ydDogICAgICAgICAgICAnLWNyZWF0ZWRBdCcsIC8vIERlZmF1bHQgc29ydCB2YWx1ZVxyXG5cdFx0dXNlUGFnaW5hdGlvbjogICB0cnVlLCAgICAgICAgIC8vIFVzZSBQYWdpbmF0aW9uP1xyXG5cclxuXHRcdG9uVmlld0NvbW1lbnQ6IGZ1bmN0aW9uKCRjb250YWluZXIsIGNvbnRleHQsIHJldmlld0lkLCBjb21tZW50SWQpIHtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlbmRlcigkY29udGFpbmVyLCAnY3VzdG9tZXItcmV2aWV3LWNvbW1lbnQnLCB7XHJcblx0XHRcdFx0cmV2aWV3OiAgcmV2aWV3SWQsXHJcblx0XHRcdFx0Y29tbWVudDogY29tbWVudElkLFxyXG5cdFx0XHRcdGJhY2s6ICAgIHtcclxuXHRcdFx0XHRcdCRjb250YWluZXI6ICRjb250YWluZXIsXHJcblx0XHRcdFx0XHRjb21wb25lbnQ6ICBpbXBsZW1lbnRhdGlvbi5uYW1lLFxyXG5cdFx0XHRcdFx0b3B0aW9uczogICAgY29udGV4dC5vcHRpb25zXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLnByZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcblxyXG5cdFx0Y29uc3QgY3VzdG9tZXIgPSBUaHVuZGVyLmF1dGhlbnRpY2F0ZWQoJ2N1c3RvbWVyJykuc3ViO1xyXG5cclxuXHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0ZGVmYXVsdDogY29udGV4dC5tKCdjb21tZW50TGlzdEZhaWxlZCcpXHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiAkLndoZW4oXHJcblx0XHRcdGZldGNoQ29tbWVudHMoKSxcclxuXHRcdFx0Y291bnRDb21tZW50cygpXHJcblx0XHQpLnRoZW4oKGNvbW1lbnRzLCBjb3VudCkgPT4gY2FsbGJhY2sobnVsbCwgJC5leHRlbmQoY29udGV4dCwge1xyXG5cdFx0XHRjb21tZW50czogY29tbWVudHNbMF0gfHwgW10sXHJcblx0XHRcdGNvdW50OiAgICBjb3VudCA/IGNvdW50WzBdLmNvdW50IDogbnVsbCxcclxuXHRcdH0pKSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRlcnJvcnMsXHJcblx0XHRcdGNhbGxiYWNrXHJcblx0XHQpKTtcclxuXHJcblx0XHRmdW5jdGlvbiBmZXRjaENvbW1lbnRzKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0bWV0aG9kOiAnR0VUJyxcclxuXHRcdFx0XHR1cmw6ICcvdjEvcHJvZHVjdHMvcmV2aWV3cy9jb21tZW50cycsXHJcblx0XHRcdFx0cXVlcnk6IHtcclxuXHRcdFx0XHRcdGN1c3RvbWVyOiBjdXN0b21lcixcclxuXHRcdFx0XHRcdHBhZ2U6ICAgICBjb250ZXh0Lm9wdGlvbnMucGFnZSxcclxuXHRcdFx0XHRcdGxpbWl0OiAgICBjb250ZXh0Lm9wdGlvbnMubGltaXQsXHJcblx0XHRcdFx0XHRzb3J0OiAgICAgY29udGV4dC5vcHRpb25zLnNvcnQsXHJcblx0XHRcdFx0XHRmaWVsZHM6ICAgW1xyXG5cdFx0XHRcdFx0XHQncmV2aWV3JyxcclxuXHRcdFx0XHRcdFx0J2N1c3RvbWVyJyxcclxuXHRcdFx0XHRcdFx0J2JvZHknLFxyXG5cdFx0XHRcdFx0XHQnY3JlYXRlZEF0JyxcclxuXHRcdFx0XHRcdF0uam9pbignLCcpLFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNvdW50Q29tbWVudHMoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRtZXRob2Q6ICdHRVQnLFxyXG5cdFx0XHRcdHVybDogJy92MS9wcm9kdWN0cy9yZXZpZXdzL2NvbW1lbnRzL2NvdW50JyxcclxuXHRcdFx0XHRxdWVyeToge1xyXG5cdFx0XHRcdFx0Y3VzdG9tZXI6IGN1c3RvbWVyLFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5pbml0ID0gZnVuY3Rpb24oY29udGV4dCkge1xyXG5cclxuXHRcdGNvbnN0IGNvbW1lbnRNYXAgPSBjb250ZXh0LmNvbW1lbnRzLnJlZHVjZSgobywgY29tbWVudCkgPT4ge1xyXG5cdFx0XHRyZXR1cm4gc2V0KG8sIGNvbW1lbnQuX2lkLCBjb21tZW50KTtcclxuXHRcdH0sIHt9KTtcclxuXHJcblx0XHRjb25zdCAkY29udGFpbmVyID0gJCh0aGlzKTtcclxuXHRcdGNvbnN0ICR2aWV3Q29tbWVudCA9ICQodGhpcykuZmluZChbXHJcblx0XHRcdCcudGh1bmRlci0tY3VzdG9tZXItcmV2aWV3LWNvbW1lbnQtYm9keScsXHJcblx0XHRcdCcudGh1bmRlci0tdmlldy1jb21tZW50JyxcclxuXHRcdF0uam9pbignLCcpKTtcclxuXHRcdGNvbnN0ICRwYWdpbmF0aW9uID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tY3VzdG9tZXItcmV2aWV3LWNvbW1lbnQtbGlzdC1wYWdpbmF0aW9uJyk7XHJcblxyXG5cdFx0JHZpZXdDb21tZW50Lm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblxyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgY29tbWVudElkID0gJCh0aGlzKS5wYXJlbnRzKCdbZGF0YS1jb21tZW50XScpLmRhdGEoJ2NvbW1lbnQnKTtcclxuXHRcdFx0Y29uc3QgY29tbWVudCA9IGNvbW1lbnRNYXBbY29tbWVudElkXTtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdFx0Y29udGV4dC5vcHRpb25zLm9uVmlld0NvbW1lbnQsXHJcblx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRjb250ZXh0LFxyXG5cdFx0XHRcdGNvbW1lbnQucmV2aWV3Ll9pZCxcclxuXHRcdFx0XHRjb21tZW50Ll9pZFxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChjb250ZXh0Lm9wdGlvbnMudXNlUGFnaW5hdGlvbikge1xyXG5cclxuXHRcdFx0VGh1bmRlci5wbHVnaW5zLnBhZ2luYXRpb24oe1xyXG5cdFx0XHRcdGNvbnRhaW5lcjogICAgICRwYWdpbmF0aW9uLFxyXG5cdFx0XHRcdGN1cnJlbnRQYWdlOiAgIGNvbnRleHQub3B0aW9ucy5wYWdlLFxyXG5cdFx0XHRcdHRvdGFsUmVzdWx0OiAgIGNvbnRleHQuY291bnQucmF3LFxyXG5cdFx0XHRcdHJlc3VsdFBlclBhZ2U6IGNvbnRleHQub3B0aW9ucy5saW1pdCxcclxuXHRcdFx0XHRvblBhZ2VDaGFuZ2U6ICAoeyBwYWdlIH0pID0+IFRodW5kZXIucmVuZGVyKFxyXG5cdFx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdGltcGxlbWVudGF0aW9uLm5hbWUsXHJcblx0XHRcdFx0XHQkLmV4dGVuZChjb250ZXh0Lm9wdGlvbnMsIHsgcGFnZSB9KVxyXG5cdFx0XHRcdClcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcclxuXHJcbn07IiwiY29uc3QgcHJvZHVjdFJldmlldyA9IHJlcXVpcmUoJy4uL3Byb2R1Y3QtcmV2aWV3Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRodW5kZXIgPT4ge1xyXG5cclxuXHRjb25zdCBpbXBsZW1lbnRhdGlvbiA9IHtcclxuXHRcdG5hbWU6ICdjdXN0b21lci1yZXZpZXcnXHJcblx0fTtcclxuXHJcblx0Ly8gQWxsIG9wdGlvbnMgYXJlIGV4YWN0bHkgc2FtZSBhcyBgcHJvZHVjdC1yZXZpZXdgIGNvbXBvbmVudFxyXG5cdGltcGxlbWVudGF0aW9uLm9wdGlvbnMgPSAoKSA9PiAkLmV4dGVuZChcclxuXHRcdHByb2R1Y3RSZXZpZXcoVGh1bmRlcikub3B0aW9ucygpLFxyXG5cdFx0e1xyXG5cdFx0XHR1c2VCb2R5RXhjZXJwdDogZmFsc2UsXHJcblx0XHRcdHVzZUZsYWc6ICAgICAgICBmYWxzZSxcclxuXHRcdFx0c2hvd1Byb2R1Y3Q6ICAgIHRydWUsXHJcblx0XHRcdHNob3dDb21tZW50czogICB0cnVlLFxyXG5cdFx0fVxyXG5cdCk7XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLnByZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcblxyXG5cdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIGNvbnRleHQpO1xyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLmluaXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcblxyXG5cdFx0Y29uc3QgJGNvbnRhaW5lciA9ICQodGhpcyk7XHJcblx0XHRjb25zdCAkYmFja1RvUmV2aWV3cyA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWJhY2stdG8tcmV2aWV3cycpO1xyXG5cdFx0Y29uc3QgJHJldmlld0NvbnRhaW5lciA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWN1c3RvbWVyLXJldmlldy1jb250YWluZXInKTtcclxuXHJcblx0XHRUaHVuZGVyLnV0aWwuYmluZEJhY2tCdXR0b24oJGJhY2tUb1Jldmlld3MsIGNvbnRleHQpO1xyXG5cclxuXHRcdFRodW5kZXIucmVuZGVyKCRyZXZpZXdDb250YWluZXIsICdwcm9kdWN0LXJldmlldycsIGNvbnRleHQub3B0aW9ucyk7XHJcblxyXG5cdH07XHJcblxyXG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBUaHVuZGVyID0+IHtcclxuXHJcblx0Y29uc3QgaW1wbGVtZW50YXRpb24gPSB7XHJcblx0XHRuYW1lOiAnY3VzdG9tZXItcmV2aWV3cydcclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5vcHRpb25zID0gKCkgPT4gKHtcclxuXHRcdHBhZ2U6ICAgICAgICAgICAgMSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGljaCBwYWdlIG9mIHJldmlld3M/XHJcblx0XHRsaW1pdDogICAgICAgICAgIDEyLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG93IG1hbnkgcmV2aWV3cyBhdCBvbmNlP1xyXG5cdFx0c29ydDogICAgICAgICAgICAnLWNyZWF0ZWRBdCcsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgc29ydCB2YWx1ZVxyXG5cdFx0dXNlUmF0aW5nOiAgICAgICBUaHVuZGVyLm9wdGlvbnMucHJvZHVjdFJldmlld1JhdGluZywgIC8vIFVzZSByYXRpbmc/XHJcblx0XHR1c2VDb21tZW50czogICAgIFRodW5kZXIub3B0aW9ucy5wcm9kdWN0UmV2aWV3Q29tbWVudCwgLy8gVXNlIHJldmlldyBjb21tZW50cz9cclxuXHRcdHVzZUhlbHBWb3RlOiAgICAgdHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgaGVscGZ1bCB2b3Rlcz9cclxuXHRcdHVzZVBhZ2luYXRpb246ICAgdHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgUGFnaW5hdGlvbj9cclxuXHJcblx0XHRvblZpZXdSZXZpZXc6IGZ1bmN0aW9uKCRjb250YWluZXIsIGNvbnRleHQsIHJldmlld0lkKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZW5kZXIoJGNvbnRhaW5lciwgJ2N1c3RvbWVyLXJldmlldycsIHtcclxuXHRcdFx0XHRyZXZpZXc6ICAgICAgICByZXZpZXdJZCxcclxuXHRcdFx0XHR1c2VSYXRpbmc6ICAgICBjb250ZXh0Lm9wdGlvbnMudXNlUmF0aW5nLFxyXG5cdFx0XHRcdHVzZUhlbHBWb3RlOiAgIGNvbnRleHQub3B0aW9ucy51c2VIZWxwVm90ZSxcclxuXHRcdFx0XHR1c2VDb21tZW50czogICBjb250ZXh0Lm9wdGlvbnMudXNlQ29tbWVudHMsXHJcblx0XHRcdFx0YmFjazogICAgICAgICAge1xyXG5cdFx0XHRcdFx0JGNvbnRhaW5lcjogJGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdGNvbXBvbmVudDogIGltcGxlbWVudGF0aW9uLm5hbWUsXHJcblx0XHRcdFx0XHRvcHRpb25zOiAgICBjb250ZXh0Lm9wdGlvbnNcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ucHJlID0gZnVuY3Rpb24oY29udGV4dCwgY2FsbGJhY2spIHtcclxuXHJcblx0XHRjb25zdCBjdXN0b21lciA9IFRodW5kZXIuYXV0aGVudGljYXRlZCgnY3VzdG9tZXInKS5zdWI7XHJcblxyXG5cdFx0Y29uc3QgZXJyb3JzID0ge1xyXG5cdFx0XHRkZWZhdWx0OiBjb250ZXh0Lm0oJ3Jldmlld0xpc3RGYWlsZWQnKVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gJC53aGVuKFxyXG5cdFx0XHRmZXRjaFJldmlld3MoKSxcclxuXHRcdFx0Y291bnRSZXZpZXdzKClcclxuXHRcdCkudGhlbigocmV2aWV3cywgY291bnQpID0+IGNhbGxiYWNrKG51bGwsICQuZXh0ZW5kKGNvbnRleHQsIHtcclxuXHRcdFx0cmV2aWV3czogcmV2aWV3c1swXSB8fCBbXSxcclxuXHRcdFx0Y291bnQ6ICAgY291bnQgPyBjb3VudFswXS5jb3VudCA6IG51bGwsXHJcblx0XHR9KSksIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0ZXJyb3JzLFxyXG5cdFx0XHRjYWxsYmFja1xyXG5cdFx0KSk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZmV0Y2hSZXZpZXdzKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0bWV0aG9kOiAnR0VUJyxcclxuXHRcdFx0XHR1cmw6ICcvdjEvcHJvZHVjdHMvcmV2aWV3cy9wdWJsaXNoZWQnLFxyXG5cdFx0XHRcdHF1ZXJ5OiB7XHJcblx0XHRcdFx0XHRjdXN0b21lcjogY3VzdG9tZXIsXHJcblx0XHRcdFx0XHRwYWdlOiAgICAgY29udGV4dC5vcHRpb25zLnBhZ2UsXHJcblx0XHRcdFx0XHRsaW1pdDogICAgY29udGV4dC5vcHRpb25zLmxpbWl0LFxyXG5cdFx0XHRcdFx0c29ydDogICAgIGNvbnRleHQub3B0aW9ucy5zb3J0LFxyXG5cdFx0XHRcdFx0ZmllbGRzOiAgIFtcclxuXHRcdFx0XHRcdFx0J3Byb2R1Y3QnLFxyXG5cdFx0XHRcdFx0XHQndGl0bGUnLFxyXG5cdFx0XHRcdFx0XHQnaW1hZ2VzJyxcclxuXHRcdFx0XHRcdFx0J3JhdGluZycsXHJcblx0XHRcdFx0XHRcdCdoZWxwZWQnLFxyXG5cdFx0XHRcdFx0XHQndG90YWxDb21tZW50JyxcclxuXHRcdFx0XHRcdFx0J2NyZWF0ZWRBdCcsXHJcblx0XHRcdFx0XHRdLmpvaW4oJywnKSxcclxuXHRcdFx0XHRcdGVtYmVkOiAnK3Byb2R1Y3QudGh1bWJuYWlsJ1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNvdW50UmV2aWV3cygpIHtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ0dFVCcsXHJcblx0XHRcdFx0dXJsOiAnL3YxL3Byb2R1Y3RzL3Jldmlld3MvcHVibGlzaGVkL2NvdW50JyxcclxuXHRcdFx0XHRxdWVyeToge1xyXG5cdFx0XHRcdFx0Y3VzdG9tZXI6IGN1c3RvbWVyLFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5pbml0ID0gZnVuY3Rpb24oY29udGV4dCkge1xyXG5cclxuXHRcdGNvbnN0ICRjb250YWluZXIgPSAkKHRoaXMpO1xyXG5cdFx0Y29uc3QgJHZpZXdSZXZpZXcgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS12aWV3LXJldmlldycpO1xyXG5cdFx0Y29uc3QgJHBhZ2luYXRpb24gPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1jdXN0b21lci1yZXZpZXctbGlzdC1wYWdpbmF0aW9uJyk7XHJcblxyXG5cdFx0JHZpZXdSZXZpZXcub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuXHJcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0XHRjb25zdCByZXZpZXdJZCA9ICQodGhpcykucGFyZW50cygnW2RhdGEtcmV2aWV3XScpLmRhdGEoJ3JldmlldycpO1xyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIuZXhlY3V0ZShcclxuXHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25WaWV3UmV2aWV3LFxyXG5cdFx0XHRcdCRjb250YWluZXIsXHJcblx0XHRcdFx0Y29udGV4dCxcclxuXHRcdFx0XHRyZXZpZXdJZFxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChjb250ZXh0Lm9wdGlvbnMudXNlUGFnaW5hdGlvbikge1xyXG5cclxuXHRcdFx0VGh1bmRlci5wbHVnaW5zLnBhZ2luYXRpb24oe1xyXG5cdFx0XHRcdGNvbnRhaW5lcjogICAgICRwYWdpbmF0aW9uLFxyXG5cdFx0XHRcdGN1cnJlbnRQYWdlOiAgIGNvbnRleHQub3B0aW9ucy5wYWdlLFxyXG5cdFx0XHRcdHRvdGFsUmVzdWx0OiAgIGNvbnRleHQuY291bnQucmF3LFxyXG5cdFx0XHRcdHJlc3VsdFBlclBhZ2U6IGNvbnRleHQub3B0aW9ucy5saW1pdCxcclxuXHRcdFx0XHRvblBhZ2VDaGFuZ2U6ICAoeyBwYWdlIH0pID0+IFRodW5kZXIucmVuZGVyKFxyXG5cdFx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdGltcGxlbWVudGF0aW9uLm5hbWUsXHJcblx0XHRcdFx0XHQkLmV4dGVuZChjb250ZXh0Lm9wdGlvbnMsIHsgcGFnZSB9KVxyXG5cdFx0XHRcdClcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcclxuXHJcbn07IiwiY29uc3QgZ2V0ID0gcmVxdWlyZSgnbG9kYXNoLmdldCcpO1xyXG5jb25zdCBzZXQgPSByZXF1aXJlKCdsb2Rhc2guc2V0Jyk7XHJcbmNvbnN0IGNhbWVsQ2FzZSA9IHJlcXVpcmUoJ2xvZGFzaC5jYW1lbGNhc2UnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGh1bmRlciA9PiB7XHJcblxyXG5cdGNvbnN0IHRyYW5zbGF0aW9uS2V5ID0ge1xyXG5cdFx0J25hbWUuZmlyc3QnOiAnZmlyc3ROYW1lJyxcclxuXHRcdCduYW1lLmxhc3QnOiAgJ2xhc3ROYW1lJyxcclxuXHRcdCduYW1lLmZ1bGwnOiAgJ2Z1bGxOYW1lJyxcclxuXHR9O1xyXG5cclxuXHQvLyBJbXBsZW1lbnRhdGlvblxyXG5cdGNvbnN0IGltcGxlbWVudGF0aW9uID0ge1xyXG5cdFx0bmFtZTogJ2N1c3RvbWVyLXVwZGF0ZS1hZGRyZXNzJ1xyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLm9wdGlvbnMgPSAoKSA9PiAoe1xyXG5cclxuXHRcdHJlY2lwaWVudEZpZWxkczogVGh1bmRlci5vcHRpb25zLnJlY2lwaWVudEZpZWxkcyxcclxuXHRcdGFkZHJlc3NEaXNhYmxlZDogVGh1bmRlci5vcHRpb25zLmFkZHJlc3NEaXNhYmxlZCxcclxuXHJcblx0XHRvblVwZGF0ZTogZnVuY3Rpb24oJGNvbnRhaW5lciwgY29udGV4dCkge1xyXG5cclxuXHRcdFx0VGh1bmRlci5ub3RpZnkoJ3N1Y2Nlc3MnLCBjb250ZXh0Lm0oJ3VwZGF0ZVN1Y2Nlc3MnKSk7XHJcblx0XHR9LFxyXG5cclxuXHR9KTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ucHJlID0gZnVuY3Rpb24oY29udGV4dCwgY2FsbGJhY2spIHtcclxuXHJcblx0XHRjb25zdCBkaXNhYmxlZEFkZHJlc3NGaWVsZHMgPVxyXG5cdFx0XHRUaHVuZGVyLnV0aWwucGFyc2VBcnJheVN0cmluZyhjb250ZXh0Lm9wdGlvbnMuYWRkcmVzc0Rpc2FibGVkKVxyXG5cdFx0XHRcdFx0LnJlZHVjZSgobywgZmllbGQpID0+IHNldChvLCBmaWVsZCwgdHJ1ZSksIHt9KTtcclxuXHJcblx0XHRjb250ZXh0LnVzZVNlYXJjaEFkZHJlc3MgPSAhIVRodW5kZXIucGx1Z2lucy5zZWFyY2hBZGRyZXNzO1xyXG5cclxuXHRcdGNvbnRleHQuZGlzYWJsZWQgPSBmaWVsZCA9PlxyXG5cdFx0XHRkaXNhYmxlZEFkZHJlc3NGaWVsZHNbZmllbGRdICYmXHJcblx0XHRcdGNvbnRleHQudXNlU2VhcmNoQWRkcmVzcyA/ICdyZWFkb25seScgOiAnJztcclxuXHJcblx0XHRjb250ZXh0LnJlY2lwaWVudEZpZWxkcyA9IFRodW5kZXIudXRpbC5wYXJzZUFycmF5U3RyaW5nKGNvbnRleHQub3B0aW9ucy5yZWNpcGllbnRGaWVsZHMpLm1hcChmaWVsZCA9PiB7XHJcblxyXG5cdFx0XHRjb25zdCBba2V5LCByZXF1aXJlZF0gPSBmaWVsZC5zcGxpdCgnOicpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRyZXF1aXJlZDogICAgICAgcmVxdWlyZWQgPT09ICdyZXF1aXJlZCcsXHJcblx0XHRcdFx0a2V5OiAgICAgICAgICAgIGtleSxcclxuXHRcdFx0XHR0cmFuc2xhdGlvbktleTogdHJhbnNsYXRpb25LZXlba2V5XSB8fCBrZXlcclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KTtcclxuXHJcblx0XHRjb250ZXh0LmFkZHJlc3NGaWVsZHMgPSBbXHJcblx0XHRcdHsgcmVxdWlyZWQ6IHRydWUsIGtleTogJ2NvdW50cnknLCB0cmFuc2xhdGlvbktleTogJ2NvdW50cnknLCB9LFxyXG5cdFx0XHR7IHJlcXVpcmVkOiBmYWxzZSwga2V5OiAnc3RhdGUnLCB0cmFuc2xhdGlvbktleTogJ3N0YXRlJywgfSxcclxuXHRcdFx0eyByZXF1aXJlZDogdHJ1ZSwga2V5OiAnY2l0eScsIHRyYW5zbGF0aW9uS2V5OiAnY2l0eScsIH0sXHJcblx0XHRcdHsgcmVxdWlyZWQ6IHRydWUsIGtleTogJ2FkZHJlc3MxJywgdHJhbnNsYXRpb25LZXk6ICdhZGRyZXNzMScsIH0sXHJcblx0XHRcdHsgcmVxdWlyZWQ6IGZhbHNlLCBrZXk6ICdhZGRyZXNzMicsIHRyYW5zbGF0aW9uS2V5OiAnYWRkcmVzczInLCB9LFxyXG5cdFx0XHR7IHJlcXVpcmVkOiB0cnVlLCBrZXk6ICdwb3N0Y29kZScsIHRyYW5zbGF0aW9uS2V5OiAncG9zdGNvZGUnLCB9LFxyXG5cdFx0XTtcclxuXHJcblx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgnY3VzdG9tZXJSZWFkRmFpbGVkJylcclxuXHRcdH07XHJcblxyXG5cdFx0JC53aGVuKFxyXG5cdFx0XHRUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ0dFVCcsXHJcblx0XHRcdFx0dXJsOiAgICAnL3YxL2NvdW50cmllcycsXHJcblx0XHRcdFx0cXVlcnk6ICB7IGZpZWxkczogJ2NvZGUnLCBsaW1pdDogMTIwLCBwYWdlOiAxIH0sXHJcblx0XHRcdH0pLFxyXG5cdFx0XHRUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ0dFVCcsXHJcblx0XHRcdFx0dXJsOiAgICAnL3YxL2NvdW50cmllcycsXHJcblx0XHRcdFx0cXVlcnk6ICB7IGZpZWxkczogJ2NvZGUnLCBsaW1pdDogMTIwLCBwYWdlOiAyIH0sXHJcblx0XHRcdH0pLFxyXG5cdFx0XHRUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ0dFVCcsXHJcblx0XHRcdFx0dXJsOiAgICAnL3YxL2NvdW50cmllcycsXHJcblx0XHRcdFx0cXVlcnk6ICB7IGZpZWxkczogJ2NvZGUnLCBsaW1pdDogMTIwLCBwYWdlOiAzIH0sXHJcblx0XHRcdH0pLFxyXG5cdFx0XHRUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ0dFVCcsXHJcblx0XHRcdFx0dXJsOiAgICAnL3YxL21lJyxcclxuXHRcdFx0XHRxdWVyeTogIHsgZmllbGRzOiAnYWRkcmVzcycgfVxyXG5cdFx0XHR9KVxyXG5cdFx0KS50aGVuKChcclxuXHRcdFx0Y291bnRyaWVzMSxcclxuXHRcdFx0Y291bnRyaWVzMixcclxuXHRcdFx0Y291bnRyaWVzMyxcclxuXHRcdFx0Y3VzdG9tZXJcclxuXHRcdCkgPT4ge1xyXG5cclxuXHRcdFx0Y29udGV4dC5jb3VudHJpZXMgPSBbXS5jb25jYXQoXHJcblx0XHRcdFx0Y291bnRyaWVzMVswXSxcclxuXHRcdFx0XHRjb3VudHJpZXMyWzBdLFxyXG5cdFx0XHRcdGNvdW50cmllczNbMF1cclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGNvbnRleHQuYWRkcmVzcyA9IGN1c3RvbWVyWzBdLmFkZHJlc3MucHJpbWFyeSB8fCB7IG5hbWU6IHt9IH07XHJcblxyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgY29udGV4dCk7XHJcblxyXG5cdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRlcnJvcnMsXHJcblx0XHRcdGNhbGxiYWNrXHJcblx0XHQpKTtcclxuXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24uaW5pdCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuXHJcblx0XHRjb25zdCAkY29udGFpbmVyID0gJCh0aGlzKTtcclxuXHRcdGNvbnN0ICRmb3JtID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tY3VzdG9tZXItYWRkcmVzcy11cGRhdGUtZm9ybScpO1xyXG5cdFx0Y29uc3QgJGJ1dHRvbiA9ICRmb3JtLmZpbmQoJy50aHVuZGVyLS11cGRhdGUtYWRkcmVzcycpO1xyXG5cdFx0Y29uc3QgJHNlYXJjaEFkZHJlc3MgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1zZWFyY2gtYWRkcmVzcycpO1xyXG5cdFx0Y29uc3QgJGRpc2FibGVkQWRkcmVzc0lucHV0cyA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWFkZHJlc3MtbG9jYXRpb24gZGl2IFtyZWFkb25seV0nKS5wYXJlbnQoKTtcclxuXHJcblx0XHRjb25zdCBidXR0b25TcGlubmVyID0gVGh1bmRlci51dGlsLm1ha2VBc3luY0J1dHRvbigkYnV0dG9uLCB7IGJpbmQ6IGZhbHNlIH0pO1xyXG5cclxuXHRcdGNvbnN0IHJlY2lwaWVudEZpZWxkcyA9IGNvbnRleHQucmVjaXBpZW50RmllbGRzLm1hcChmID0+IGYua2V5KTtcclxuXHRcdGNvbnN0IGFkZHJlc3NGaWVsZHMgPSBjb250ZXh0LmFkZHJlc3NGaWVsZHMubWFwKGYgPT4gZi5rZXkpO1xyXG5cdFx0Y29uc3QgYWxsRmllbGRzTWFwID0gW1xyXG5cdFx0XHQuLi5yZWNpcGllbnRGaWVsZHMsXHJcblx0XHRcdC4uLmFkZHJlc3NGaWVsZHNcclxuXHRcdF0ucmVkdWNlKChvLCBmaWVsZCkgPT4gc2V0KG8sIFtmaWVsZF0sIHRydWUpLCB7fSk7XHJcblxyXG5cdFx0Y29uc3QgJGZpZWxkcyA9IFtdLmNvbmNhdChyZWNpcGllbnRGaWVsZHMsIGFkZHJlc3NGaWVsZHMpXHJcblx0XHRcdFx0XHRcdC5yZWR1Y2UoKG8sIGtleSkgPT4gc2V0KG8sIFtrZXldLCAkZm9ybS5maW5kKGBbbmFtZT1cIiR7a2V5fVwiXWApKSwge30pO1xyXG5cclxuXHRcdGFkZHJlc3NUb0Zvcm0oY29udGV4dC5hZGRyZXNzKTtcclxuXHJcblx0XHQkc2VhcmNoQWRkcmVzcy5vbignY2xpY2snLCBzZWFyY2hBZGRyZXNzKTtcclxuXHRcdCRkaXNhYmxlZEFkZHJlc3NJbnB1dHMub24oJ2NsaWNrJywgc2VhcmNoQWRkcmVzcyk7XHJcblxyXG5cdFx0VGh1bmRlci51dGlsLm1ha2VSZWNhcHRjaGEoe1xyXG5cdFx0XHRjb21wb25lbnROYW1lOiBpbXBsZW1lbnRhdGlvbi5uYW1lLFxyXG5cdFx0XHRidXR0b246ICAgICAgICAkYnV0dG9uLFxyXG5cdFx0XHR2YWxpZGF0ZTogICAgICB2YWxpZGF0ZUFkZHJlc3MsXHJcblx0XHRcdGNhbGxiYWNrOiAgICAgIGZ1bmN0aW9uKHRva2VuLCByZXNldFJlY2FwdGNoYSkge1xyXG5cclxuXHRcdFx0XHRidXR0b25TcGlubmVyLnJ1bigpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBwcmltYXJ5QWRkcmVzcyA9IFRodW5kZXIudXRpbC5mb3JtVG9KU09OKCRmb3JtLnNlcmlhbGl6ZUFycmF5KCkpO1xyXG5cdFx0XHRcdGNvbnN0IHJlY2FwdGNoYSA9IFRodW5kZXIudXRpbC51bnNldFJlY2FwdGNoYShwcmltYXJ5QWRkcmVzcyk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGRhdGEgPSB7IGFkZHJlc3M6IHsgcHJpbWFyeTogcHJpbWFyeUFkZHJlc3MgfSB9O1xyXG5cclxuXHRcdFx0XHRjb25zdCByZXNldFN0YXRlID0gKCkgPT4ge1xyXG5cdFx0XHRcdFx0YnV0dG9uU3Bpbm5lci5kb25lKCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gcmVzZXRSZWNhcHRjaGEgJiYgcmVzZXRSZWNhcHRjaGEoKTtcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdFx0XHQnaW52YWxpZC1wb3N0Y29kZSc6ICBjb250ZXh0Lm0oJ2ludmFsaWRQb3N0Y29kZScpLFxyXG5cdFx0XHRcdFx0J3Bvc3Rjb2RlLXJlcXVpcmVkJzogY29udGV4dC5tKCdwb3N0Y29kZVJlcXVpcmVkJyksXHJcblx0XHRcdFx0XHRkZWZhdWx0OiAgICAgICAgICAgICBjb250ZXh0Lm0oJ3VwZGF0ZUZhaWxlZCcpLFxyXG5cdFx0XHRcdFx0dmFsaWRhdGlvbjogZXJyID0+IHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IFssIGZpZWxkXSA9IGVyci52YWxpZGF0aW9uLnNvdXJjZS5zcGxpdCgnYWRkcmVzcy5wcmltYXJ5LicpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCFmaWVsZCB8fCAhYWxsRmllbGRzTWFwW2ZpZWxkXSkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGNvbnRleHQubShjYW1lbENhc2UoWydpbnZhbGlkJywgdHJhbnNsYXRpb25LZXlbZmllbGRdIHx8IGZpZWxkXSkpO1xyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRcdG1ldGhvZDogICAgJ1BVVCcsXHJcblx0XHRcdFx0XHR1cmw6ICAgICAgICcvdjEvbWUnLFxyXG5cdFx0XHRcdFx0ZGF0YTogICAgICBkYXRhLFxyXG5cdFx0XHRcdFx0cmVjYXB0Y2hhOiByZWNhcHRjaGFcclxuXHRcdFx0XHR9KS50aGVuKGRhdGEgPT4ge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGFkZHJlc3MgPSBnZXQoZGF0YSwgJ2FkZHJlc3MucHJpbWFyeScpO1xyXG5cclxuXHRcdFx0XHRcdGFkZHJlc3NUb0Zvcm0oYWRkcmVzcyk7XHJcblxyXG5cdFx0XHRcdFx0VGh1bmRlci5leGVjdXRlKFxyXG5cdFx0XHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25VcGRhdGUsXHJcblx0XHRcdFx0XHRcdCRjb250YWluZXIsXHJcblx0XHRcdFx0XHRcdGNvbnRleHQsXHJcblx0XHRcdFx0XHRcdGFkZHJlc3NcclxuXHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHJlc2V0U3RhdGUoKTtcclxuXHJcblx0XHRcdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0XHRcdGVycm9ycyxcclxuXHRcdFx0XHRcdGVyciA9PiByZXNldFN0YXRlKClcclxuXHRcdFx0XHQpKTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHZhbGlkYXRlQWRkcmVzcygpIHtcclxuXHJcblx0XHRcdGNvbnN0IGFkZHJlc3MgPSBUaHVuZGVyLnV0aWwuZm9ybVRvSlNPTigkZm9ybS5zZXJpYWxpemVBcnJheSgpKTtcclxuXHJcblx0XHRcdGNvbnN0IHJlcXVpcmVkRmllbGRzID0gW10uY29uY2F0KFxyXG5cdFx0XHRcdGNvbnRleHQucmVjaXBpZW50RmllbGRzLFxyXG5cdFx0XHRcdGNvbnRleHQuYWRkcmVzc0ZpZWxkc1xyXG5cdFx0XHQpLmZpbHRlcihmID0+IGYucmVxdWlyZWQpLm1hcChmID0+IGYua2V5KTtcclxuXHJcblx0XHRcdGZvciAoY29uc3QgZmllbGQgb2YgcmVxdWlyZWRGaWVsZHMpIHtcclxuXHJcblx0XHRcdFx0aWYgKCFnZXQoYWRkcmVzcywgZmllbGQsIG51bGwpKSB7XHJcblx0XHRcdFx0XHRUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBjb250ZXh0Lm0oYCR7dHJhbnNsYXRpb25LZXlbZmllbGRdIHx8IGZpZWxkfVJlcXVpcmVkYCkpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBhZGRyZXNzVG9Gb3JtKGFkZHJlc3MsIG9ubHlBZGRyZXNzRmllbGRzID0gZmFsc2UpIHtcclxuXHJcblx0XHRcdGlmICghYWRkcmVzcykgcmV0dXJuO1xyXG5cclxuXHRcdFx0Y29uc3QgZmllbGRzID0gb25seUFkZHJlc3NGaWVsZHMgP1xyXG5cdFx0XHRcdFx0XHRcdGFkZHJlc3NGaWVsZHMgOlxyXG5cdFx0XHRcdFx0XHRcdFtdLmNvbmNhdChyZWNpcGllbnRGaWVsZHMsIGFkZHJlc3NGaWVsZHMpO1xyXG5cclxuXHRcdFx0ZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xyXG5cclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGZpZWxkID09PSAnY291bnRyeScgP1xyXG5cdFx0XHRcdFx0XHRcdFx0Z2V0KGFkZHJlc3MsIGAke2ZpZWxkfS5jb2RlYCwgZ2V0KGFkZHJlc3MsIGZpZWxkLCBudWxsKSkgOlxyXG5cdFx0XHRcdFx0XHRcdFx0Z2V0KGFkZHJlc3MsIGZpZWxkLCBudWxsKTtcclxuXHJcblx0XHRcdFx0JGZpZWxkc1tmaWVsZF0udmFsKHZhbHVlKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2VhcmNoQWRkcmVzcyhldmVudCkge1xyXG5cclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcblx0XHRcdFRodW5kZXIucGx1Z2lucy5zZWFyY2hBZGRyZXNzKChlcnIsIGFkZHJlc3MpID0+IHtcclxuXHJcblx0XHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFRodW5kZXIubm90aWZ5KCdlcnJvcicsIGVyci5tZXNzYWdlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGFkZHJlc3NUb0Zvcm0oYWRkcmVzcywgdHJ1ZSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xyXG5cclxufTsiLCJjb25zdCBjYW1lbENhc2UgPSByZXF1aXJlKCdsb2Rhc2guY2FtZWxjYXNlJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRodW5kZXIgPT4ge1xyXG5cclxuXHRjb25zdCBpbXBsZW1lbnRhdGlvbiA9IHtcclxuXHRcdG5hbWU6ICdjdXN0b21lci11cGRhdGUtY3JlZGVudGlhbCdcclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5vcHRpb25zID0gKCkgPT4gKHtcclxuXHJcblx0XHRmaWVsZDogbnVsbCwgLy8gJ3VzZXJJZCcsICdlbWFpbCcsICdwYXNzd29yZCdcclxuXHJcblx0XHRvblVwZGF0ZTogZnVuY3Rpb24oJGNvbnRhaW5lciwgY29udGV4dCkge1xyXG5cclxuXHRcdFx0VGh1bmRlci5ub3RpZnkoJ3N1Y2Nlc3MnLCBjb250ZXh0Lm0oJ3VwZGF0ZVN1Y2Nlc3MnKSk7XHJcblx0XHR9LFxyXG5cdFx0b25VcGRhdGVDdXN0b21lcjogZnVuY3Rpb24oJGNvbnRhaW5lciwgY29udGV4dCwgZmllbGQpIHtcclxuXHJcblx0XHRcdFRodW5kZXIucmVuZGVyKCRjb250YWluZXIsICdjdXN0b21lci11cGRhdGUnKTtcclxuXHRcdH1cclxuXHJcblx0fSk7XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLmluaXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcblxyXG5cdFx0Y29uc3QgJGNvbnRhaW5lciA9ICQodGhpcyk7XHJcblx0XHRjb25zdCAkdXBkYXRlQ3VzdG9tZXIgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS11cGRhdGUtY3VzdG9tZXInKTtcclxuXHRcdGNvbnN0ICRmb3JtID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tY3JlZGVudGlhbC1mb3JtJyk7XHJcblx0XHRjb25zdCAkYnV0dG9uID0gJGZvcm0uZmluZCgnLnRodW5kZXItLXVwZGF0ZS1jcmVkZW50aWFsJyk7XHJcblx0XHRjb25zdCBidXR0b25TcGlubmVyID0gVGh1bmRlci51dGlsLm1ha2VBc3luY0J1dHRvbigkYnV0dG9uKTtcclxuXHJcblx0XHQkdXBkYXRlQ3VzdG9tZXIub24oJ2NsaWNrJywgKCkgPT4gVGh1bmRlci5leGVjdXRlKFxyXG5cdFx0XHRjb250ZXh0Lm9wdGlvbnMub25VcGRhdGVDdXN0b21lcixcclxuXHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0Y29udGV4dFxyXG5cdFx0KSk7XHJcblxyXG5cdFx0VGh1bmRlci51dGlsLm1ha2VSZWNhcHRjaGEoaW1wbGVtZW50YXRpb24ubmFtZSwgJGJ1dHRvbiwgZnVuY3Rpb24odG9rZW4sIHJlc2V0UmVjYXB0Y2hhKSB7XHJcblxyXG5cdFx0XHRjb25zdCBkYXRhID0gVGh1bmRlci51dGlsLmZvcm1Ub0pTT04oJGZvcm0uc2VyaWFsaXplQXJyYXkoKSk7XHJcblxyXG5cdFx0XHQvLyBGb3IgY3VzdG9tZXJzIHdpdGggc29jaWFsIHJlZ2lzdHJhdGlvbnNcclxuXHRcdFx0ZGF0YS5wYXNzd29yZCA9IGRhdGEucGFzc3dvcmQgfHwgJyc7XHJcblxyXG5cdFx0XHRjb25zdCByZXNldFN0YXRlID0gKCkgPT4ge1xyXG5cdFx0XHRcdGJ1dHRvblNwaW5uZXIuZG9uZSgpO1xyXG5cdFx0XHRcdHJldHVybiByZXNldFJlY2FwdGNoYSAmJiByZXNldFJlY2FwdGNoYSgpO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Y29uc3QgZXJyb3JzID0ge1xyXG5cdFx0XHRcdCdpbnZhbGlkLXBhc3N3b3JkJzogICBjb250ZXh0Lm0oJ2ludmFsaWRQYXNzd29yZCcpLFxyXG5cdFx0XHRcdCdkdXBsaWNhdGVkLXVzZXItaWQnOiBjb250ZXh0Lm0oJ2R1cGxpY2F0ZWRVc2VySWQnKSxcclxuXHRcdFx0XHQnZHVwbGljYXRlZC1lbWFpbCc6ICAgY29udGV4dC5tKCdkdXBsaWNhdGVkRW1haWwnKSxcclxuXHRcdFx0XHRkZWZhdWx0OiAgICAgICAgICAgICAgY29udGV4dC5tKCd1cGRhdGVGYWlsZWQnKSxcclxuXHRcdFx0XHR2YWxpZGF0aW9uOiBlcnIgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgcGF0aCA9IGVyci52YWxpZGF0aW9uLnNvdXJjZS5zcGxpdCgnLicpO1xyXG5cdFx0XHRcdFx0Y29uc3QgZmllbGQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGNvbnRleHQubShjYW1lbENhc2UoWydpbnZhbGlkTmV3JywgZmllbGRdKSk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ1BVVCcsXHJcblx0XHRcdFx0dXJsOiAgICAnL3YxL21lL2NyZWRlbnRpYWxzJyxcclxuXHRcdFx0XHRkYXRhOiAgIGRhdGEsXHJcblx0XHRcdH0pLnRoZW4oKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25VcGRhdGUsXHJcblx0XHRcdFx0XHQkY29udGFpbmVyLFxyXG5cdFx0XHRcdFx0Y29udGV4dFxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdHJldHVybiByZXNldFN0YXRlKCk7XHJcblxyXG5cdFx0XHR9LCBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0XHRlcnJvcnMsXHJcblx0XHRcdFx0ZXJyID0+IHJlc2V0U3RhdGUoKVxyXG5cdFx0XHQpKTtcclxuXHJcblx0XHR9KTtcclxuXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xyXG5cclxufTsiLCJjb25zdCBnZXQgPSByZXF1aXJlKCdsb2Rhc2guZ2V0Jyk7XHJcbmNvbnN0IHNldCA9IHJlcXVpcmUoJ2xvZGFzaC5zZXQnKTtcclxuY29uc3QgY2FtZWxDYXNlID0gcmVxdWlyZSgnbG9kYXNoLmNhbWVsY2FzZScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaHVuZGVyID0+IHtcclxuXHJcblx0Y29uc3QgdHJhbnNsYXRpb25LZXkgPSB7XHJcblx0XHQnbmFtZS5maXJzdCc6ICdmaXJzdE5hbWUnLFxyXG5cdFx0J25hbWUubGFzdCc6ICAnbGFzdE5hbWUnLFxyXG5cdFx0J25hbWUuZnVsbCc6ICAnZnVsbE5hbWUnLFxyXG5cdH07XHJcblxyXG5cdC8vIEltcGxlbWVudGF0aW9uXHJcblx0Y29uc3QgaW1wbGVtZW50YXRpb24gPSB7XHJcblx0XHRuYW1lOiAnY3VzdG9tZXItdXBkYXRlJ1xyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLm9wdGlvbnMgPSAoKSA9PiAoe1xyXG5cclxuXHRcdGZpZWxkczogICAgICAgICAgVGh1bmRlci5vcHRpb25zLmN1c3RvbWVyVXBkYXRlRmllbGRzLFxyXG5cdFx0YmlydGhkYXRlRm9ybWF0OiBUaHVuZGVyLm9wdGlvbnMuZGF0ZUlucHV0Rm9ybWF0LFxyXG5cclxuXHRcdG9uVXBkYXRlOiBmdW5jdGlvbigkY29udGFpbmVyLCBjb250ZXh0LCBjdXN0b21lcikge1xyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIubm90aWZ5KCdzdWNjZXNzJywgY29udGV4dC5tKCd1cGRhdGVTdWNjZXNzJykpO1xyXG5cdFx0fSxcclxuXHRcdG9uQ2hhbmdlQ3JlZGVudGlhbDogZnVuY3Rpb24oJGNvbnRhaW5lciwgY29udGV4dCwgZmllbGQpIHtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlbmRlcigkY29udGFpbmVyLCAnY3VzdG9tZXItdXBkYXRlLWNyZWRlbnRpYWwnLCB7IGZpZWxkIH0pO1xyXG5cdFx0fVxyXG5cclxuXHR9KTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ucHJlID0gZnVuY3Rpb24oY29udGV4dCwgY2FsbGJhY2spIHtcclxuXHJcblx0XHRjb25zdCBiaXJ0aE9wdGlvbnMgPSB7XHJcblx0XHRcdFlZWVk6IHsga2V5OiAnYmlydGhZZWFyJywgdHJhbnNsYXRpb25LZXk6ICd5ZWFyJywgdGVzdGVyOiAvXlxcZHs0fSQvIH0sXHJcblx0XHRcdE1NOiAgIHsga2V5OiAnYmlydGhNb250aCcsIHRyYW5zbGF0aW9uS2V5OiAnbW9udGgnLCB0ZXN0ZXI6IC9eXFxkezEsMn0kLyB9LFxyXG5cdFx0XHRERDogICB7IGtleTogJ2JpcnRoRGF0ZScsIHRyYW5zbGF0aW9uS2V5OiAnZGF0ZScsIHRlc3RlcjogL15cXGR7MSwyfSQvIH1cclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgaGFzQmlydGhEYXRlID0gY29udGV4dC5vcHRpb25zLmZpZWxkcy5pbmRleE9mKCdiaXJ0aGRhdGUnKSA+PSAwO1xyXG5cdFx0Y29uc3QgYmlydGhkYXRlRm9ybWF0cyA9IGNvbnRleHQub3B0aW9ucy5iaXJ0aGRhdGVGb3JtYXQuc3BsaXQoJy0nKTtcclxuXHJcblx0XHRjb250ZXh0LmZpZWxkcyA9IFRodW5kZXIudXRpbC5wYXJzZUFycmF5U3RyaW5nKGNvbnRleHQub3B0aW9ucy5maWVsZHMpLm1hcChmaWVsZCA9PiB7XHJcblxyXG5cdFx0XHRjb25zdCBba2V5LCByZXF1aXJlZF0gPSBmaWVsZC5zcGxpdCgnOicpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRyZXF1aXJlZDogICAgICAgcmVxdWlyZWQgPT09ICdyZXF1aXJlZCcsXHJcblx0XHRcdFx0a2V5OiAgICAgICAgICAgIGtleSxcclxuXHRcdFx0XHR0cmFuc2xhdGlvbktleTogdHJhbnNsYXRpb25LZXlba2V5XSB8fCBrZXlcclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KTtcclxuXHJcblx0XHRjb250ZXh0LmJpcnRoZGF0ZUZpZWxkcyA9IGhhc0JpcnRoRGF0ZSA/IGJpcnRoZGF0ZUZvcm1hdHMubWFwKChmb3JtYXQsIGkpID0+ICQuZXh0ZW5kKHtcclxuXHRcdFx0bGFzdDogaSA9PT0gYmlydGhkYXRlRm9ybWF0cy5sZW5ndGggLSAxXHJcblx0XHR9LCBiaXJ0aE9wdGlvbnNbZm9ybWF0XSkpIDogW107XHJcblxyXG5cdFx0Y29uc3QgZXJyb3JzID0ge1xyXG5cdFx0XHRkZWZhdWx0OiBjb250ZXh0Lm0oJ2N1c3RvbWVyUmVhZEZhaWxlZCcpXHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRtZXRob2Q6ICdHRVQnLFxyXG5cdFx0XHR1cmw6ICAgICcvdjEvbWUnLFxyXG5cdFx0XHRxdWVyeTogIHtcclxuXHRcdFx0XHRmaWVsZHM6IFtcclxuXHRcdFx0XHRcdCdhdmF0YXInLFxyXG5cdFx0XHRcdFx0J3VzZXJJZCcsXHJcblx0XHRcdFx0XHQnZW1haWwnLFxyXG5cdFx0XHRcdFx0J2FsaWFzJyxcclxuXHRcdFx0XHRcdCduYW1lLmZpcnN0JyxcclxuXHRcdFx0XHRcdCduYW1lLmxhc3QnLFxyXG5cdFx0XHRcdFx0J25hbWUuZnVsbCcsXHJcblx0XHRcdFx0XHQnbW9iaWxlJyxcclxuXHRcdFx0XHRcdCdwaG9uZScsXHJcblx0XHRcdFx0XHQnZ2VuZGVyJyxcclxuXHRcdFx0XHRcdCdiaXJ0aGRhdGUnLFxyXG5cdFx0XHRcdFx0J2NvdW50cnknLFxyXG5cdFx0XHRcdF0uam9pbignLCcpXHJcblx0XHRcdH1cclxuXHRcdH0pLnRoZW4oZGF0YSA9PiB7XHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBzZXQoY29udGV4dCwgJ2N1c3RvbWVyJywgZGF0YSkpO1xyXG5cdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRlcnJvcnMsXHJcblx0XHRcdGNhbGxiYWNrXHJcblx0XHQpKTtcclxuXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24uaW5pdCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuXHJcblx0XHRjb25zdCAkY29udGFpbmVyID0gJCh0aGlzKTtcclxuXHRcdGNvbnN0ICRiYWNrVG9DaGVja291dCA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWJhY2stdG8tY2hlY2tvdXQnKTtcclxuXHRcdGNvbnN0ICRjaGFuZ2VDcmVkZW50aWFsID0gJCh0aGlzKS5maW5kKCdbZGF0YS1jaGFuZ2UtY3JlZGVudGlhbF0nKTtcclxuXHRcdGNvbnN0ICRhdmF0YXJGb3JtID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tY3VzdG9tZXItYXZhdGFyLWZvcm0nKTtcclxuXHRcdGNvbnN0ICRhdmF0YXIgPSAkYXZhdGFyRm9ybS5maW5kKCcudGh1bmRlci0tY3VzdG9tZXItYXZhdGFyJyk7XHJcblx0XHRjb25zdCAkdXBkYXRlRm9ybSA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWN1c3RvbWVyLXVwZGF0ZS1mb3JtJyk7XHJcblx0XHRjb25zdCAkYnV0dG9uID0gJHVwZGF0ZUZvcm0uZmluZCgnLnRodW5kZXItLXVwZGF0ZS1jdXN0b21lcicpO1xyXG5cdFx0Y29uc3QgYnV0dG9uU3Bpbm5lciA9IFRodW5kZXIudXRpbC5tYWtlQXN5bmNCdXR0b24oJGJ1dHRvbiwgeyBiaW5kOiBmYWxzZSB9KTtcclxuXHJcblx0XHRjb25zdCBmaWVsZHMgPSBbXHJcblx0XHRcdC4uLmNvbnRleHQuZmllbGRzLFxyXG5cdFx0XHQuLi5jb250ZXh0LmJpcnRoZGF0ZUZpZWxkc1xyXG5cdFx0XVxyXG5cdFx0LmZpbHRlcigoeyBrZXkgfSkgPT4ga2V5ICE9PSAnYmlydGhkYXRlJylcclxuXHRcdC5tYXAoKHsga2V5IH0pID0+ICh7XHJcblx0XHRcdGtleTogICBrZXksXHJcblx0XHRcdCRpbnB1dDogJHVwZGF0ZUZvcm0uZmluZChgW25hbWU9XCIke2tleX1cIl1gKSxcclxuXHRcdH0pKTtcclxuXHJcblx0XHRjdXN0b21lclRvRm9ybShjb250ZXh0LmN1c3RvbWVyKTtcclxuXHJcblx0XHRUaHVuZGVyLnV0aWwuaW1hZ2VVcGxvYWRlcihcclxuXHRcdFx0JGF2YXRhckZvcm0sXHJcblx0XHRcdGltYWdlID0+IFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0bWV0aG9kOiAnUFVUJyxcclxuXHRcdFx0XHR1cmw6ICAgICcvdjEvbWUnLFxyXG5cdFx0XHRcdGRhdGE6ICAgeyBhdmF0YXI6IGltYWdlLl9pZCB9XHJcblx0XHRcdH0pLnRoZW4oKCkgPT4ge1xyXG5cdFx0XHRcdCRhdmF0YXIuYXR0cignc3JjJywgVGh1bmRlci51dGlsLmltYWdlVVJMKGltYWdlLCAxMjAsIDEyMCkpO1xyXG5cdFx0XHRcdHJldHVybiBUaHVuZGVyLm5vdGlmeSgnc3VjY2VzcycsIGNvbnRleHQubSgnYXZhdGFyVXBsb2FkU3VjY2VzcycpKTtcclxuXHRcdFx0fSwgZXJyID0+IHtcclxuXHRcdFx0XHRyZXR1cm4gVGh1bmRlci5ub3RpZnkoJ2Vycm9yJywgY29udGV4dC5tKCdhdmF0YXJVcGxvYWRGYWlsZWQnKSk7XHJcblx0XHRcdH0pLFxyXG5cdFx0XHQoKSA9PiBUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBjb250ZXh0Lm0oJ2F2YXRhclVwbG9hZEZhaWxlZCcpKVxyXG5cdFx0KTtcclxuXHJcblx0XHRUaHVuZGVyLnV0aWwuYmluZEJhY2tCdXR0b24oJGJhY2tUb0NoZWNrb3V0LCBjb250ZXh0KTtcclxuXHJcblx0XHQkY2hhbmdlQ3JlZGVudGlhbC5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdFRodW5kZXIuZXhlY3V0ZShcclxuXHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25DaGFuZ2VDcmVkZW50aWFsLFxyXG5cdFx0XHRcdCRjb250YWluZXIsXHJcblx0XHRcdFx0Y29udGV4dCxcclxuXHRcdFx0XHQkKHRoaXMpLmRhdGEoJ2NoYW5nZUNyZWRlbnRpYWwnKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdFRodW5kZXIudXRpbC5tYWtlUmVjYXB0Y2hhKHtcclxuXHRcdFx0Y29tcG9uZW50TmFtZTogaW1wbGVtZW50YXRpb24ubmFtZSxcclxuXHRcdFx0YnV0dG9uOiAgICAgICAgJGJ1dHRvbixcclxuXHRcdFx0dmFsaWRhdGU6ICAgICAgdmFsaWRhdGVDdXN0b21lcixcclxuXHRcdFx0Y2FsbGJhY2s6ICAgICAgZnVuY3Rpb24odG9rZW4sIHJlc2V0UmVjYXB0Y2hhKSB7XHJcblxyXG5cdFx0XHRcdGJ1dHRvblNwaW5uZXIucnVuKCk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHJlc2V0U3RhdGUgPSAoKSA9PiB7XHJcblx0XHRcdFx0XHRidXR0b25TcGlubmVyLmRvbmUoKTtcclxuXHRcdFx0XHRcdHJldHVybiByZXNldFJlY2FwdGNoYSAmJiByZXNldFJlY2FwdGNoYSgpO1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgndXBkYXRlRmFpbGVkJyksXHJcblxyXG5cdFx0XHRcdFx0dmFsaWRhdGlvbjogZXJyID0+IHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IFssIC4uLnBhdGhdID0gZXJyLnZhbGlkYXRpb24uc291cmNlLnNwbGl0KCcuJyk7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGZpZWxkID0gcGF0aC5qb2luKCcuJyk7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gY29udGV4dC5tKGNhbWVsQ2FzZShbJ2ludmFsaWQnLCB0cmFuc2xhdGlvbktleVtmaWVsZF0gfHwgZmllbGRdKSk7XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdFx0bWV0aG9kOiAnUFVUJyxcclxuXHRcdFx0XHRcdHVybDogICAgJy92MS9tZScsXHJcblx0XHRcdFx0XHRkYXRhOiAgIGZvcm1Ub0N1c3RvbWVyKCksXHJcblx0XHRcdFx0fSkudGhlbihjdXN0b21lciA9PiB7XHJcblxyXG5cdFx0XHRcdFx0Y3VzdG9tZXJUb0Zvcm0oY3VzdG9tZXIpO1xyXG5cclxuXHRcdFx0XHRcdFRodW5kZXIuZXhlY3V0ZShcclxuXHRcdFx0XHRcdFx0Y29udGV4dC5vcHRpb25zLm9uVXBkYXRlLFxyXG5cdFx0XHRcdFx0XHQkY29udGFpbmVyLFxyXG5cdFx0XHRcdFx0XHRjb250ZXh0LFxyXG5cdFx0XHRcdFx0XHRjdXN0b21lclxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gcmVzZXRTdGF0ZSgpO1xyXG5cclxuXHRcdFx0XHR9LCBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdFx0ZXJyb3JzLFxyXG5cdFx0XHRcdFx0ZXJyID0+IHJlc2V0U3RhdGUoKVxyXG5cdFx0XHRcdCkpO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gbm9ybWFsaXplQmlydGhkYXRlKGRhdGEpIHtcclxuXHJcblx0XHRcdGNvbnN0IGJpcnRoRmllbGRzID0gW1xyXG5cdFx0XHRcdCdiaXJ0aFllYXInLFxyXG5cdFx0XHRcdCdiaXJ0aE1vbnRoJyxcclxuXHRcdFx0XHQnYmlydGhEYXRlJyxcclxuXHRcdFx0XTtcclxuXHJcblx0XHRcdGlmIChiaXJ0aEZpZWxkcy5ldmVyeShmaWVsZCA9PiBkYXRhW2ZpZWxkXSkpIHtcclxuXHJcblx0XHRcdFx0ZGF0YS5iaXJ0aGRhdGUgPSBuZXcgRGF0ZShcclxuXHRcdFx0XHRcdGRhdGEuYmlydGhZZWFyLFxyXG5cdFx0XHRcdFx0ZGF0YS5iaXJ0aE1vbnRoIC0gMSxcclxuXHRcdFx0XHRcdGRhdGEuYmlydGhEYXRlXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZGF0YS5iaXJ0aGRhdGUgPSBudWxsO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRiaXJ0aEZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IGRlbGV0ZSBkYXRhW2ZpZWxkXSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZm9ybVRvQ3VzdG9tZXIoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbm9ybWFsaXplQmlydGhkYXRlKFRodW5kZXIudXRpbC5mb3JtVG9KU09OKCR1cGRhdGVGb3JtLnNlcmlhbGl6ZUFycmF5KCkpKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjdXN0b21lclRvRm9ybShjdXN0b21lcikge1xyXG5cclxuXHRcdFx0Y29uc3QgYmlydGhkYXRlID0gY3VzdG9tZXIuYmlydGhkYXRlID9cclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBEYXRlKGN1c3RvbWVyLmJpcnRoZGF0ZS5yYXcgfHwgY3VzdG9tZXIuYmlydGhkYXRlKSA6XHJcblx0XHRcdFx0XHRcdFx0XHRudWxsO1xyXG5cclxuXHRcdFx0ZGVsZXRlIGN1c3RvbWVyLmJpcnRoZGF0ZTtcclxuXHJcblx0XHRcdGlmIChiaXJ0aGRhdGUpIHtcclxuXHRcdFx0XHQkLmV4dGVuZChjdXN0b21lciwge1xyXG5cdFx0XHRcdFx0YmlydGhZZWFyOiAgYmlydGhkYXRlLmdldEZ1bGxZZWFyKCksXHJcblx0XHRcdFx0XHRiaXJ0aE1vbnRoOiBiaXJ0aGRhdGUuZ2V0TW9udGgoKSArIDEsXHJcblx0XHRcdFx0XHRiaXJ0aERhdGU6ICBiaXJ0aGRhdGUuZ2V0RGF0ZSgpLFxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmaWVsZHMuZm9yRWFjaCgoeyBrZXksICRpbnB1dCB9KSA9PiB7XHJcblxyXG5cdFx0XHRcdCRpbnB1dC52YWwoZ2V0KGN1c3RvbWVyLCBrZXkpIHx8IG51bGwpO1xyXG5cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHZhbGlkYXRlQ3VzdG9tZXIoKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjdXN0b21lciA9IGZvcm1Ub0N1c3RvbWVyKCk7XHJcblxyXG5cdFx0XHRjb25zdCByZXF1aXJlZEZpZWxkcyA9IGNvbnRleHQuZmllbGRzLmZpbHRlcihmaWVsZCA9PiBmaWVsZC5yZXF1aXJlZCk7XHJcblxyXG5cdFx0XHRmb3IgKGNvbnN0IHsga2V5LCB0cmFuc2xhdGlvbktleSB9IG9mIHJlcXVpcmVkRmllbGRzKSB7XHJcblxyXG5cdFx0XHRcdGlmICghZ2V0KGN1c3RvbWVyLCBrZXksIG51bGwpKSB7XHJcblx0XHRcdFx0XHRUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBjb250ZXh0Lm0oYCR7dHJhbnNsYXRpb25LZXl9UmVxdWlyZWRgKSk7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gVGh1bmRlciA9PiB7XHJcblxyXG5cdGNvbnN0IGltcGxlbWVudGF0aW9uID0ge1xyXG5cdFx0bmFtZTogJ2N1c3RvbWVyLXZlcmlmaWNhdGlvbidcclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5vcHRpb25zID0gKCkgPT4gKHtcclxuXHRcdGN1c3RvbWVyOiAgJ2N1c3RvbWVyJyxcclxuXHRcdHNlY3JldDogICAgJ3NlY3JldCcsXHJcblx0XHRpbnB1dDogICAgICdxdWVyeScsICAgICAgLy8gJ3F1ZXJ5JyBvciAnYXR0cmlidXRlJ1xyXG5cdFx0ZXhwaXJlc0luOiA2MCAqIDYwICogMjQsIC8vIDI0IGhvdXJzXHJcblxyXG5cdFx0b25FbWFpbFJlcXVlc3Q6IGZ1bmN0aW9uKCRjb250YWluZXIsIGNvbnRleHQpIHtcclxuXHJcblx0XHRcdFRodW5kZXIubm90aWZ5KCdzdWNjZXNzJywgY29udGV4dC5tKCdyZXF1ZXN0RW1haWxTdWNjZXNzJykpO1xyXG5cdFx0fSxcclxuXHRcdG9uVmVyaWZpY2F0aW9uOiBmdW5jdGlvbigkY29udGFpbmVyLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0XHRUaHVuZGVyLm5vdGlmeSgnc3VjY2VzcycsIGNvbnRleHQubSgndmVyaWZpY2F0aW9uU3VjY2VzcycpKTtcclxuXHRcdH0sXHJcblx0fSk7XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLnByZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcblxyXG5cdFx0aWYgKGNvbnRleHQub3B0aW9ucy5pbnB1dCA9PT0gJ3F1ZXJ5Jykge1xyXG5cclxuXHRcdFx0Y29uc3QgcXVlcnkgPSBUaHVuZGVyLnV0aWwudXJsUXVlcnkoKTtcclxuXHRcdFx0Y29uc3QgY3VzdG9tZXJGaWVsZCA9IGNvbnRleHQub3B0aW9ucy5jdXN0b21lcjtcclxuXHRcdFx0Y29uc3Qgc2VjcmV0RmllbGQgPSBjb250ZXh0Lm9wdGlvbnMuc2VjcmV0O1xyXG5cclxuXHRcdFx0aWYgKHF1ZXJ5W2N1c3RvbWVyRmllbGRdICYmXHJcblx0XHRcdFx0cXVlcnlbc2VjcmV0RmllbGRdKSB7XHJcblxyXG5cdFx0XHRcdGNvbnRleHQuY3VzdG9tZXIgPSBxdWVyeVtjdXN0b21lckZpZWxkXTtcclxuXHRcdFx0XHRjb250ZXh0LnNlY3JldCA9IHF1ZXJ5W3NlY3JldEZpZWxkXTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dC5vcHRpb25zLmlucHV0ID09PSAnYXR0cmlidXRlJykge1xyXG5cclxuXHRcdFx0Y29udGV4dC5jdXN0b21lciA9IGNvbnRleHQub3B0aW9ucy5jdXN0b21lcjtcclxuXHRcdFx0Y29udGV4dC5zZWNyZXQgPSBjb250ZXh0Lm9wdGlvbnMuc2VjcmV0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnRleHQudHlwZSA9IGNvbnRleHQuY3VzdG9tZXIgJiZcclxuXHRcdFx0XHRcdFx0Y29udGV4dC5zZWNyZXQgP1xyXG5cdFx0XHRcdFx0XHRcdCd2ZXJpZmljYXRpb24nIDpcclxuXHRcdFx0XHRcdFx0XHQncmVxdWVzdC1lbWFpbCc7XHJcblxyXG5cdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIGNvbnRleHQpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5pbml0ID0gZnVuY3Rpb24oY29udGV4dCkge1xyXG5cclxuXHRcdGNvbnN0ICRjb250YWluZXIgPSAkKHRoaXMpO1xyXG5cdFx0Y29uc3QgJGZvcm0gPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1yZXNldC1wYXNzd29yZC1mb3JtJyk7XHJcblxyXG5cdFx0aWYgKGNvbnRleHQudHlwZSA9PT0gJ3JlcXVlc3QtZW1haWwnKSB7XHJcblxyXG5cdFx0XHRjb25zdCAkcmVxdWVzdEVtYWlsID0gJGZvcm0uZmluZCgnLnRodW5kZXItLXJlcXVlc3QtZW1haWwnKTtcclxuXHRcdFx0Y29uc3QgcmVxdWVzdEVtYWlsU3Bpbm5lciA9IFRodW5kZXIudXRpbC5tYWtlQXN5bmNCdXR0b24oJHJlcXVlc3RFbWFpbCk7XHJcblxyXG5cdFx0XHRUaHVuZGVyLnV0aWwubWFrZVJlY2FwdGNoYShpbXBsZW1lbnRhdGlvbi5uYW1lLCAkcmVxdWVzdEVtYWlsLCBmdW5jdGlvbih0b2tlbiwgcmVzZXRSZWNhcHRjaGEpIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgZGF0YSA9ICQuZXh0ZW5kKFRodW5kZXIudXRpbC51c2VySWRPckVtYWlsKFxyXG5cdFx0XHRcdFx0VGh1bmRlci51dGlsLmZvcm1Ub0pTT04oJGZvcm0uc2VyaWFsaXplQXJyYXkoKSlcclxuXHRcdFx0XHQpLCB7XHJcblx0XHRcdFx0XHRleHBpcmVzSW46IGNvbnRleHQub3B0aW9ucy5leHBpcmVzSW4sXHJcblx0XHRcdFx0XHRzY29wZTogICAgICd2ZXJpZmljYXRpb24nXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHJlc2V0U3RhdGUgPSAoKSA9PiB7XHJcblx0XHRcdFx0XHRyZXF1ZXN0RW1haWxTcGlubmVyLmRvbmUoKTtcclxuXHRcdFx0XHRcdHJldHVybiByZXNldFJlY2FwdGNoYSAmJiByZXNldFJlY2FwdGNoYSgpO1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHRcdCdub3QtZXhpc3RpbmctY3VzdG9tZXInOiBjb250ZXh0Lm0oJ25vdEV4aXN0aW5nQ3VzdG9tZXInKSxcclxuXHRcdFx0XHRcdCdlbWFpbC1yZXF1aXJlZCc6ICAgICAgICBjb250ZXh0Lm0oJ2N1c3RvbWVyV2l0aG91dEVtYWlsJyksXHJcblx0XHRcdFx0XHRkZWZhdWx0OiAgICAgICAgICAgICAgICAgY29udGV4dC5tKCdyZXF1ZXN0RW1haWxGYWlsZWQnKVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0XHRtZXRob2Q6ICAnUE9TVCcsXHJcblx0XHRcdFx0XHR1cmw6ICAgICAnL3YxL2N1c3RvbWVycy92ZXJpZmljYXRpb25zL2VtYWlscycsXHJcblx0XHRcdFx0XHRkYXRhOiAgICBkYXRhLFxyXG5cdFx0XHRcdH0pLnRoZW4oKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdFRodW5kZXIuZXhlY3V0ZShcclxuXHRcdFx0XHRcdFx0Y29udGV4dC5vcHRpb25zLm9uRW1haWxSZXF1ZXN0LFxyXG5cdFx0XHRcdFx0XHQkY29udGFpbmVyLFxyXG5cdFx0XHRcdFx0XHRjb250ZXh0XHJcblx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiByZXNldFN0YXRlKCk7XHJcblxyXG5cdFx0XHRcdH0sIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0XHRcdGVyci5yZXNwb25zZUpTT04sXHJcblx0XHRcdFx0XHRlcnJvcnMsXHJcblx0XHRcdFx0XHRlcnIgPT4gcmVzZXRTdGF0ZSgpXHJcblx0XHRcdFx0KSk7XHJcblxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQudHlwZSA9PT0gJ3ZlcmlmaWNhdGlvbicpIHtcclxuXHJcblx0XHRcdGNvbnN0ICRmaW5pc2hWZXJpZmljYXRpb24gPSAkZm9ybS5maW5kKCcudGh1bmRlci0tZmluaXNoLXZlcmlmaWNhdGlvbicpO1xyXG5cdFx0XHRjb25zdCBmaW5pc2hWZXJpZmljYXRpb25TcGlubmVyID0gVGh1bmRlci51dGlsLm1ha2VBc3luY0J1dHRvbigkZmluaXNoVmVyaWZpY2F0aW9uKTtcclxuXHJcblx0XHRcdFRodW5kZXIudXRpbC5tYWtlUmVjYXB0Y2hhKGltcGxlbWVudGF0aW9uLm5hbWUsICRmaW5pc2hWZXJpZmljYXRpb24sIGZ1bmN0aW9uKHRva2VuLCByZXNldFJlY2FwdGNoYSkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBkYXRhID0ge1xyXG5cdFx0XHRcdFx0c2VjcmV0OiBjb250ZXh0LnNlY3JldFxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGNvbnN0IHJlc2V0U3RhdGUgPSAoKSA9PiB7XHJcblx0XHRcdFx0XHRmaW5pc2hWZXJpZmljYXRpb25TcGlubmVyLmRvbmUoKTtcclxuXHRcdFx0XHRcdHJldHVybiByZXNldFJlY2FwdGNoYSAmJiByZXNldFJlY2FwdGNoYSgpO1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgndmVyaWZpY2F0aW9uRmFpbGVkJylcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdFx0bWV0aG9kOiAgICAnUE9TVCcsXHJcblx0XHRcdFx0XHR1cmw6ICAgICAgIGAvdjEvY3VzdG9tZXJzLyR7Y29udGV4dC5jdXN0b21lcn0vdmVyaWZpZWRgLFxyXG5cdFx0XHRcdFx0ZGF0YTogICAgICBkYXRhLFxyXG5cdFx0XHRcdFx0cmVjYXB0Y2hhOiB0b2tlbixcclxuXHRcdFx0XHR9KS50aGVuKCgpID0+IHtcclxuXHJcblx0XHRcdFx0XHRUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdFx0XHRcdGNvbnRleHQub3B0aW9ucy5vblZlcmlmaWNhdGlvbixcclxuXHRcdFx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdFx0Y29udGV4dFxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gcmVzZXRTdGF0ZSgpO1xyXG5cclxuXHRcdFx0XHR9LCBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdFx0ZXJyb3JzLFxyXG5cdFx0XHRcdFx0ZXJyID0+IHJlc2V0U3RhdGUoKVxyXG5cdFx0XHRcdCkpO1xyXG5cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XHJcblxyXG59OyIsImNvbnN0IF9zZXQgPSByZXF1aXJlKCdsb2Rhc2guc2V0Jyk7XHJcbmNvbnN0IF9nZXQgPSByZXF1aXJlKCdsb2Rhc2guZ2V0Jyk7XHJcbmNvbnN0IGNhbWVsQ2FzZSA9IHJlcXVpcmUoJ2xvZGFzaC5jYW1lbGNhc2UnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGh1bmRlciA9PiB7XHJcblxyXG5cdGNvbnN0IGltcGxlbWVudGF0aW9uID0ge1xyXG5cdFx0bmFtZTogJ29yZGVyLWRldGFpbCdcclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5vcHRpb25zID0gKCkgPT4gKHtcclxuXHRcdG9yZGVyOiAgICAgICAgICAgICAgJycsICAgLy8gT3JkZXIgSUQgdG8gcmVuZGVyXHJcblx0XHR1cGRhdGVUcmFuc2FjdGlvbnM6IHRydWUsIC8vIFVwZGF0ZSB0cmFuc2FjdGlvbnMgYmVmb3JlIGdldHRpbmcgYW4gb3JkZXJcclxuXHRcdGN1c3RvbWVyRmllbGRzOiAgICAgVGh1bmRlci5vcHRpb25zLmN1c3RvbWVyT3JkZXJGaWVsZHMubWFwKGZpZWxkID0+IGZpZWxkLnNwbGl0KCc6JylbMF0pLFxyXG5cdFx0cmVjaXBpZW50RmllbGRzOiAgICBUaHVuZGVyLm9wdGlvbnMucmVjaXBpZW50RmllbGRzLm1hcChmaWVsZCA9PiBmaWVsZC5zcGxpdCgnOicpWzBdKSxcclxuXHJcblx0XHRvblJlcXVlc3RSZWZ1bmQ6ICAgIGZ1bmN0aW9uKCRjb250YWluZXIsIGNvbnRleHQsIG9yZGVyKSB7XHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlbmRlcigkY29udGFpbmVyLCAnb3JkZXItcmVxdWVzdC1yZWZ1bmQnLCB7XHJcblx0XHRcdFx0b3JkZXI6IG9yZGVyLl9pZCxcclxuXHRcdFx0XHRiYWNrOiAge1xyXG5cdFx0XHRcdFx0JGNvbnRhaW5lcjogJGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdGNvbXBvbmVudDogIGltcGxlbWVudGF0aW9uLm5hbWUsXHJcblx0XHRcdFx0XHRvcHRpb25zOiAgICBjb250ZXh0Lm9wdGlvbnNcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5wcmUgPSBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaykge1xyXG5cclxuXHRcdGNvbnN0IHsgb3JkZXIgfSA9IGNvbnRleHQub3B0aW9ucztcclxuXHJcblx0XHRjb250ZXh0LmNvdXBvbkRldGFpbCA9IGNvdXBvbiA9PiB7XHJcblx0XHRcdHJldHVybiBjb3Vwb24gP1xyXG5cdFx0XHRcdFx0Y29udGV4dC5tKCdkaXNjb3VudGVkQnknLCB7IHZhbHVlOiBjb3Vwb24uZGlzY291bnQudmFsdWUuY29udmVydGVkIH0pIDpcclxuXHRcdFx0XHRcdCcnO1xyXG5cdFx0fTtcclxuXHJcblx0XHRjb250ZXh0LmZ1bGZpbGxtZW50VHJhY2tlciA9ICh7IHRyYWNraW5nIH0pID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IG1lc3NhZ2UgPSBbXHJcblx0XHRcdFx0dHJhY2tpbmcuY29tcGFueSxcclxuXHRcdFx0XHR0cmFja2luZy51aWQgPyBgKCR7dHJhY2tpbmcudWlkfSlgIDogbnVsbCxcclxuXHRcdFx0XS5maWx0ZXIodiA9PiB2KS5qb2luKCcgJyk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJhY2tpbmcudXJsID9cclxuXHRcdFx0XHRcdGA8YSBocmVmPVwiJHt0cmFja2luZy51cmx9XCI+JHttZXNzYWdlIHx8IGNvbnRleHQubSgndmlld1RyYWNrZXInKX08L2E+YCA6XHJcblx0XHRcdFx0XHRgPHNwYW4+JHttZXNzYWdlfTwvc3Bhbj5gO1xyXG5cdFx0fTtcclxuXHJcblx0XHRjb250ZXh0LnJlZnVuZFRvdGFsRGV0YWlsID0gdG90YWwgPT4gW1xyXG5cdFx0XHR0eXBlb2YgdG90YWwuaXRlbXMucHJpY2Uud2l0aFRheC5yYXcgPT09ICdudW1iZXInID9cclxuXHRcdFx0XHRjb250ZXh0Lm0oJ3JlZnVuZEl0ZW1Ub3RhbCcsIHsgdG90YWw6IHRvdGFsLml0ZW1zLnByaWNlLndpdGhUYXguY29udmVydGVkIH0pIDpcclxuXHRcdFx0XHRudWxsLFxyXG5cdFx0XHR0eXBlb2YgdG90YWwuc2hpcHBpbmcuZmVlLndpdGhUYXgucmF3ID09PSAnbnVtYmVyJyA/XHJcblx0XHRcdFx0Y29udGV4dC5tKCdyZWZ1bmRTaGlwcGluZ1RvdGFsJywgeyB0b3RhbDogdG90YWwuc2hpcHBpbmcuZmVlLndpdGhUYXguY29udmVydGVkIH0pIDpcclxuXHRcdFx0XHRudWxsLFxyXG5cdFx0XS5maWx0ZXIodiA9PiB2KS5qb2luKCcgKyAnKTtcclxuXHJcblx0XHRjb250ZXh0LmNhbGN1bGF0ZUV4cGlyZXNBdCA9IChvcmRlciwgaXRlbSkgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gaXRlbS5kb3dubG9hZC5wb2xpY3kuZXhwaXJlcztcclxuXHJcblx0XHRcdGlmICghdHlwZSkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHlwZSA9PT0gJ2F0JyA/XHJcblx0XHRcdFx0bmV3IERhdGUodmFsdWUucmF3KSA6XHJcblx0XHRcdFx0VGh1bmRlci51dGlsLmFkZFRpbWUob3JkZXIuY3JlYXRlZEF0LnJhdywgdHlwZSwgdmFsdWUucmF3KTtcclxuXHRcdH07XHJcblxyXG5cdFx0Y29udGV4dC50b0RhdGVWYWx1ZXMgPSBkYXRlID0+ICh7XHJcblx0XHRcdHllYXI6ICBkYXRlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSxcclxuXHRcdFx0bW9udGg6IChkYXRlLmdldE1vbnRoKCkgKyAxKS50b1N0cmluZygpLFxyXG5cdFx0XHRkYXRlOiAgZGF0ZS5nZXREYXRlKCkudG9TdHJpbmcoKSxcclxuXHRcdFx0aG91cnM6IGRhdGUuZ2V0SG91cnMoKS50b1N0cmluZygpLFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y29uc3QgdHJhbnNsYXRpb25LZXlzID0ge1xyXG5cdFx0XHQnbmFtZS5maXJzdCc6ICdmaXJzdE5hbWUnLFxyXG5cdFx0XHQnbmFtZS5sYXN0JzogICdsYXN0TmFtZScsXHJcblx0XHRcdCduYW1lLmZ1bGwnOiAgJ2Z1bGxOYW1lJyxcclxuXHRcdH07XHJcblxyXG5cdFx0Y29udGV4dC5jdXN0b21lckZpZWxkcyA9IFRodW5kZXIudXRpbC5wYXJzZUFycmF5U3RyaW5nKFxyXG5cdFx0XHRjb250ZXh0Lm9wdGlvbnMuY3VzdG9tZXJGaWVsZHNcclxuXHRcdCkubWFwKGtleSA9PiAoe1xyXG5cdFx0XHRrZXk6IGtleSxcclxuXHRcdFx0dHJhbnNsYXRpb25LZXk6IGNhbWVsQ2FzZShbJ2N1c3RvbWVyJywgdHJhbnNsYXRpb25LZXlzW2tleV0gfHwga2V5XSksXHJcblx0XHR9KSk7XHJcblxyXG5cdFx0Y29udGV4dC5yZWNpcGllbnRGaWVsZHMgPSBUaHVuZGVyLnV0aWwucGFyc2VBcnJheVN0cmluZyhcclxuXHRcdFx0Y29udGV4dC5vcHRpb25zLnJlY2lwaWVudEZpZWxkc1xyXG5cdFx0KS5tYXAoa2V5ID0+ICh7XHJcblx0XHRcdGtleToga2V5LFxyXG5cdFx0XHR0cmFuc2xhdGlvbktleTogY2FtZWxDYXNlKFsnYWRkcmVzcycsIHRyYW5zbGF0aW9uS2V5c1trZXldIHx8IGtleV0pLFxyXG5cdFx0fSkpO1xyXG5cclxuXHRcdGNvbnRleHQudW5kb3dubG9hZGFibGVTdGF0dXNlcyA9IHtcclxuXHRcdFx0cGxhY2VkOiAgICAgICB0cnVlLFxyXG5cdFx0XHRjYW5jZWxsZWQ6ICAgIHRydWUsXHJcblx0XHRcdCd1bmRlci1wYWlkJzogdHJ1ZSxcclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRleHQub3B0aW9ucy51cGRhdGVUcmFuc2FjdGlvbnMgP1xyXG5cdFx0XHRcdC8vIFNpbmNlIHdlIGFyZSB0cnlpbmcgdG8gbWFrZSB0aGUgb3JkZXIgdXAtdG8tZGF0ZSB3aXRoIHRoZSBiZXN0IGVmZm9ydCxcclxuXHRcdFx0XHQvLyBwcm9jZWVkIGZvbGxvd2luZyBwcm9jZXNzZXMgZXZlbiBpZiBgdXBkYXRlVHJhbnNhY3Rpb25zYCBleGVjdXRpb24gZmFpbHMuXHJcblx0XHRcdFx0dXBkYXRlVHJhbnNhY3Rpb25zKCkudGhlbihcclxuXHRcdFx0XHRcdCgpID0+IGZldGNoT3JkZXIoKS50aGVuKG9yZGVyID0+IHN1Y2Nlc3Mob3JkZXIpKSxcclxuXHRcdFx0XHRcdCgpID0+IGZldGNoT3JkZXIoKS50aGVuKG9yZGVyID0+IHN1Y2Nlc3Mob3JkZXIpKVxyXG5cdFx0XHRcdCkgOlxyXG5cdFx0XHRcdGZldGNoT3JkZXIoKS50aGVuKG9yZGVyID0+IHN1Y2Nlc3Mob3JkZXIpKTtcclxuXHJcblx0XHRmdW5jdGlvbiBzdWNjZXNzKG9yZGVyKSB7XHJcblxyXG5cdFx0XHQvLyBNYWtlIGB1cGRhdGVUcmFuc2FjdGlvbnNgIG9wdGlvbiBhcyBgdHJ1ZWAsXHJcblx0XHRcdC8vIGV2ZW50IGlmIGl0IHdhcyBwYXNzZWQgYXMgYGZhbHNlYC5cclxuXHRcdFx0Y29udGV4dC5vcHRpb25zLnVwZGF0ZVRyYW5zYWN0aW9ucyA9IHRydWU7XHJcblxyXG5cdFx0XHRjb25zdCBmaW5kRGlzY291bnQgPSB0eXBlID0+IGRpc2NvdW50ID0+IHtcclxuXHRcdFx0XHRyZXR1cm4gZGlzY291bnQuY291cG9uICYmIGRpc2NvdW50LmNvdXBvbi50eXBlID09PSB0eXBlO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHRjb25zdCBmaW5kQ2FydERpc2NvdW50ID0gZmluZERpc2NvdW50KCdjYXJ0Jyk7XHJcblx0XHRcdGNvbnN0IGZpbmRQcm9kdWN0RGlzY291bnQgPSBmaW5kRGlzY291bnQoJ3Byb2R1Y3QnKTtcclxuXHJcblx0XHRcdGNvbnN0IGFsbEl0ZW1zID0gb3JkZXIuaXRlbXMucmVkdWNlKChpdGVtcywgaXRlbSkgPT4ge1xyXG5cdFx0XHRcdHJldHVybiBpdGVtcy5jb25jYXQoaXRlbSwgaXRlbS5idW5kbGVJdGVtcyB8fCBbXSk7XHJcblx0XHRcdH0sIFtdKTtcclxuXHRcdFx0Y29uc3QgaXRlbXNBbmRTaGlwbWVudHMgPSBbXS5jb25jYXQoYWxsSXRlbXMsIG9yZGVyLnNoaXBtZW50cyk7XHJcblxyXG5cdFx0XHRhbGxJdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG5cdFx0XHRcdC8vIO2ZmOu2iCDsl6zrtoAg7ZSM656Y6re4XHJcblx0XHRcdFx0aXRlbS5yZWZ1bmRlZCA9IFRodW5kZXIudXRpbC5jaGVja0l0ZW1SZWZ1bmRlZChvcmRlciwgaXRlbS5faWQpO1xyXG5cclxuXHRcdFx0XHQvLyDri6TsmrTroZzrk5wg6rCA64qlIOyXrOu2gCDtlIzrnpjqt7hcclxuXHRcdFx0XHRpdGVtLmRvd25sb2FkYWJsZSA9IChcclxuXHRcdFx0XHRcdGl0ZW0udHlwZSA9PT0gJ2Rvd25sb2FkYWJsZScgJiYgLy8g64uk7Jq066Gc65OcIOyDge2SiOydtOuptOyEnFxyXG5cdFx0XHRcdFx0IWl0ZW0ucmVmdW5kZWQgJiYgICAgICAgICAgICAgICAvLyDtmZjrtojrkJjsp4Ag7JWK7JWY6rOgXHJcblx0XHRcdFx0XHQoXHJcblx0XHRcdFx0XHRcdC8vIOuLpOyatOuhnOuTnCDqsIDriqUg7Zqf7IiYIOygnO2VnOydtCDsl4bqsbDrgpgsIOygnO2VnOufieydhCDrhJjquLDsp4Ag7JWK7JWY6rOgXHJcblx0XHRcdFx0XHRcdCFpdGVtLmRvd25sb2FkLnBvbGljeS5jb3VudCB8fFxyXG5cdFx0XHRcdFx0XHRpdGVtLmRvd25sb2FkLmRvd25sb2FkZWQucmF3IDwgaXRlbS5kb3dubG9hZC5wb2xpY3kuY291bnQucmF3XHJcblx0XHRcdFx0XHQpICYmXHJcblx0XHRcdFx0XHQoXHJcblx0XHRcdFx0XHRcdC8vIOunjOujjCDrgqDsp5wg7KCc7ZWc7J20IOyXhuqxsOuCmCwg66eM66OM7J287J20IOyngOuCmOyngCDslYrsnYAg7IOB7ZKIXHJcblx0XHRcdFx0XHRcdCFpdGVtLmRvd25sb2FkLnBvbGljeS5leHBpcmVzLnR5cGUgfHxcclxuXHRcdFx0XHRcdFx0Y29udGV4dC5jYWxjdWxhdGVFeHBpcmVzQXQob3JkZXIsIGl0ZW0pLnZhbHVlT2YoKSA+IERhdGUubm93KClcclxuXHRcdFx0XHRcdClcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRpdGVtc0FuZFNoaXBtZW50cy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG5cclxuXHRcdFx0XHRpdGVtLmFwcGxpZWRDb3Vwb24gPSAoXHJcblx0XHRcdFx0XHRpdGVtLmRpc2NvdW50cy5maW5kKGZpbmRQcm9kdWN0RGlzY291bnQpIHx8IHsgY291cG9uOiBudWxsIH1cclxuXHRcdFx0XHQpLmNvdXBvbjtcclxuXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0b3JkZXIuc2hpcHBpbmdTdGF0dXMgPSBUaHVuZGVyLnV0aWwub3JkZXJTaGlwcGluZ1N0YXR1cyhvcmRlcik7XHJcblxyXG5cdFx0XHRvcmRlci5hcHBsaWVkQ291cG9uID0gKFxyXG5cdFx0XHRcdChcclxuXHRcdFx0XHRcdGl0ZW1zQW5kU2hpcG1lbnRzLmZpbmQoaXRlbSA9PiB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBpdGVtLmRpc2NvdW50cy5maW5kKGZpbmRDYXJ0RGlzY291bnQpO1xyXG5cdFx0XHRcdFx0fSkgfHwgeyBkaXNjb3VudHM6IFtdIH1cclxuXHRcdFx0XHQpLmRpc2NvdW50cy5maW5kKGZpbmRDYXJ0RGlzY291bnQpIHx8IHsgY291cG9uOiBudWxsIH1cclxuXHRcdFx0KS5jb3Vwb247XHJcblxyXG5cdFx0XHRvcmRlci5oYXNUYW5naWJsZUl0ZW0gPSBhbGxJdGVtcy5zb21lKGl0ZW0gPT4gaXRlbS50eXBlID09PSAndGFuZ2libGUnKTtcclxuXHJcblx0XHRcdGNvbnRleHQub3JkZXIgPSBvcmRlcjtcclxuXHJcblx0XHRcdGNvbnRleHQudmJhbmtzID0gb3JkZXIudHJhbnNhY3Rpb25zLnJlZHVjZSgodmJhbmtzLCB0cmFuc2FjdGlvbikgPT4ge1xyXG5cdFx0XHRcdHJldHVybiB2YmFua3MuY29uY2F0KHRyYW5zYWN0aW9uLnZiYW5rcyB8fCBbXSk7XHJcblx0XHRcdH0sIFtdKS5maWx0ZXIodmJhbmsgPT4ge1xyXG5cclxuXHRcdFx0XHRjb25zdCBleHBpcmVzQXQgPSBfZ2V0KHZiYW5rLCAnZXhwaXJlc0F0LnJhdycpO1xyXG5cclxuXHRcdFx0XHQvLyDrp4zro4wg6riw6rCE7J20IOyXhuycvOuptCDrp4zro4wg65CY7KeAIOyViuydgCDqsoPsnLzroZwg6rCE7KO8XHJcblx0XHRcdFx0aWYgKCFleHBpcmVzQXQpIHJldHVybiB0cnVlO1xyXG5cclxuXHRcdFx0XHQvLyBGaWx0ZXIgb3V0IGV4cGlyZWQgdmlydHVhbCBiYW5rIGRldGFpbHNcclxuXHRcdFx0XHRyZXR1cm4gIVRodW5kZXIudXRpbC5pc0V4cGlyZWQoZXhwaXJlc0F0KTtcclxuXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gU2V0IHBheW1lbnQgZGV0YWlscy5cclxuXHRcdFx0Y29uc3QgdGh1bmRlclBheW1lbnRNZXRob2RNYXAgPVxyXG5cdFx0XHRcdChUaHVuZGVyLm9wdGlvbnMucGF5bWVudE1ldGhvZHMub3JkZXIgfHwgW10pXHJcblx0XHRcdFx0XHQucmVkdWNlKChvLCBwKSA9PiBfc2V0KG8sIHAuaWQsIHApLCB7fSk7XHJcblxyXG5cdFx0XHQvLyBGaWx0ZXIgdmlhYmxlIHBheW1lbnQgbWV0aG9kcyB3aGVyZS4uXHJcblx0XHRcdGNvbnN0IHBheW1lbnRNZXRob2RzID0gb3JkZXIudHJhbnNhY3Rpb25zLm1hcCgoeyBwYXltZW50TWV0aG9kLCB2YmFua3MgfSkgPT4ge1xyXG5cclxuXHRcdFx0XHRjb25zdCB0aHVuZGVyUGF5bWVudE1ldGhvZCA9XHJcblx0XHRcdFx0XHR0aHVuZGVyUGF5bWVudE1ldGhvZE1hcFtwYXltZW50TWV0aG9kLl9pZF0gfHxcclxuXHRcdFx0XHRcdHRodW5kZXJQYXltZW50TWV0aG9kTWFwW3BheW1lbnRNZXRob2Quc2x1Z107XHJcblxyXG5cdFx0XHRcdGNvbnN0IHNob3VsZERpc3BsYXkgPSAoXHJcblx0XHRcdFx0XHQvLyB0aGUgcGF5bWVudCBtZXRob2QgaXMgY29uZmlndXJlZCBmb3IgVGh1bmRlciBhbmQuLlxyXG5cdFx0XHRcdFx0dGh1bmRlclBheW1lbnRNZXRob2QgJiZcclxuXHRcdFx0XHRcdC8vIHRoZSBwYXltZW50IChieSB0aGUgbWV0aG9kKSBpcyBub3QgZm9yIGxhdGVyXHJcblx0XHRcdFx0XHQhdGh1bmRlclBheW1lbnRNZXRob2QucGF5TGF0ZXIgJiZcclxuXHRcdFx0XHRcdChcclxuXHRcdFx0XHRcdFx0IXZiYW5rcy5sZW5ndGggfHwgICAgICAvLyB0aGUgcGF5bWVudCBtZXRob2QgaXMgbm90IGZvciB2aXJ0dWFsIGJhbmtzXHJcblx0XHRcdFx0XHRcdHZiYW5rcy5zb21lKHZiYW5rID0+IHsgLy8gb3Igb25lIG9yIG1vcmUgdmlydHVhbCBiYW5rcyBhcmUgZXhwaXJlZFxyXG5cclxuXHRcdFx0XHRcdFx0XHRjb25zdCBleHBpcmVzQXQgPSBfZ2V0KHZiYW5rLCAnZXhwaXJlc0F0LnJhdycpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyDrp4zro4wg6riw6rCE7J20IOyXhuycvOuptCDrp4zro4wg65CY7KeAIOyViuydgCDqsoPsnLzroZwg6rCE7KO8XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFleHBpcmVzQXQpIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFRodW5kZXIudXRpbC5pc0V4cGlyZWQoZXhwaXJlc0F0KTtcclxuXHJcblx0XHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQpXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHNob3VsZERpc3BsYXkgPyB0aHVuZGVyUGF5bWVudE1ldGhvZCA6IG51bGw7XHJcblxyXG5cdFx0XHR9KS5maWx0ZXIodiA9PiB2KTtcclxuXHJcblx0XHRcdC8vIFNob3VsZCBkaXNwbGF5IGEgcGF5bWVudCBmb3JtIHdoZW4sXHJcblx0XHRcdC8vIC0gVGhlIG9yZGVyJ3Mgc3RhdHVzIGlzICdwbGFjZWQnXHJcblx0XHRcdC8vIC0gT25lIG9yIG1vcmUgdmlhYmxlIHBheW1lbnQgbWV0aG9kcyBleGlzdFxyXG5cdFx0XHRjb25zdCBzaG91bGRQYXkgPVxyXG5cdFx0XHRcdG9yZGVyLnN0YXR1cyA9PT0gJ3BsYWNlZCcgJiZcclxuXHRcdFx0XHRwYXltZW50TWV0aG9kcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRjb250ZXh0LnBheW1lbnRNZXRob2RzID0gcGF5bWVudE1ldGhvZHM7XHJcblx0XHRcdGNvbnRleHQuc2hvdWxkUGF5ID0gc2hvdWxkUGF5O1xyXG5cclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHVwZGF0ZVRyYW5zYWN0aW9ucygpIHtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ1BVVCcsXHJcblx0XHRcdFx0dXJsOiAgICBgL3YxL21lL29yZGVycy8ke29yZGVyfS90cmFuc2FjdGlvbnNgLFxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZmV0Y2hPcmRlcigpIHtcclxuXHJcblx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHRkZWZhdWx0OiBjb250ZXh0Lm0oJ29yZGVyUmVhZEZhaWxlZCcpXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRtZXRob2Q6ICdHRVQnLFxyXG5cdFx0XHRcdHVybDogICAgYC92MS9tZS9vcmRlcnMvJHtvcmRlcn1gLFxyXG5cdFx0XHR9KS50aGVuKG51bGwsIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdGVycm9ycyxcclxuXHRcdFx0XHRjYWxsYmFja1xyXG5cdFx0XHQpKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLmluaXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcblxyXG5cdFx0Y29uc3Qge1xyXG5cdFx0XHRvcmRlcixcclxuXHRcdFx0cGF5bWVudE1ldGhvZHMsXHJcblx0XHRcdHNob3VsZFBheSxcclxuXHRcdH0gPSBjb250ZXh0O1xyXG5cclxuXHRcdGNvbnN0ICRjb250YWluZXIgPSAkKHRoaXMpO1xyXG5cdFx0Y29uc3QgJGJhY2tUb09yZGVycyA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWJhY2stdG8tb3JkZXJzJyk7XHJcblx0XHRjb25zdCAkc3Vic2NyaXB0aW9uaWQgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1zdWJzY3JpcHRpb24taWQgYScpO1xyXG5cdFx0Y29uc3QgJG1hcmtBc1JlY2VpdmVkID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tbWFyay1vcmRlci1hcy1yZWNlaXZlZCcpO1xyXG5cdFx0Y29uc3QgJG1hcmtBc05vdFJlY2VpdmVkID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tbWFyay1vcmRlci1hcy1ub3QtcmVjZWl2ZWQnKTtcclxuXHRcdGNvbnN0ICRjYW5jZWxPcmRlciA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWNhbmNlbC1vcmRlcicpO1xyXG5cdFx0Y29uc3QgJGNhbmNlbGxhdGlvbkZvcm0gPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1vcmRlci1jYW5jZWxsYXRpb24tZm9ybScpO1xyXG5cdFx0Y29uc3QgJGNhbmNlbGxhdGlvblJlYXNvbiA9ICRjYW5jZWxsYXRpb25Gb3JtLmZpbmQoJ3RleHRhcmVhJyk7XHJcblx0XHRjb25zdCAkY2FuY2VsQnV0dG9uID0gJGNhbmNlbGxhdGlvbkZvcm0uZmluZCgnYnV0dG9uJyk7XHJcblx0XHRjb25zdCAkcmVxdWVzdFJlZnVuZCA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXJlcXVlc3QtcmVmdW5kJyk7XHJcblx0XHRjb25zdCAkZG93bmxvYWRCdXR0b24gPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1kb3dubG9hZC1idXR0b24nKTtcclxuXHJcblx0XHRjb25zdCBjYW5jZWxCdXR0b25TcGlubmVyID0gVGh1bmRlci51dGlsLm1ha2VBc3luY0J1dHRvbigkY2FuY2VsQnV0dG9uKTtcclxuXHJcblx0XHQkZG93bmxvYWRCdXR0b24ub24oJ2NsaWNrJywgZ2V0RG93bmxvYWRMaW5rKTtcclxuXHRcdCRzdWJzY3JpcHRpb25pZC5vbignY2xpY2snLCB2aWV3U3Vic2NyaXB0aW9uKTtcclxuXHRcdCRtYXJrQXNSZWNlaXZlZC5vbignY2xpY2snLCBtYXJrQXNSZWNlaXZlZCk7XHJcblx0XHQkbWFya0FzTm90UmVjZWl2ZWQub24oJ2NsaWNrJywgbWFya0FzTm90UmVjZWl2ZWQpO1xyXG5cdFx0JGNhbmNlbE9yZGVyLm9uKCdjbGljaycsIHN0YXJ0Q2FuY2VsbGF0aW9uKTtcclxuXHRcdCRjYW5jZWxCdXR0b24ub24oJ2NsaWNrJywgY2FuY2VsT3JkZXIpO1xyXG5cdFx0JHJlcXVlc3RSZWZ1bmQub24oJ2NsaWNrJywgcmVxdWVzdFJlZnVuZCk7XHJcblx0XHQkKHRoaXMpLm9uKCdjbGljaycsICcudGh1bmRlci0tY2FuY2VsLXJlZnVuZCcsIHN0YXJ0UmVmdW5kQ2FuY2VsbGF0aW9uKTtcclxuXHRcdCQodGhpcykub24oJ2NsaWNrJywgJy50aHVuZGVyLS1yZWZ1bmQtY2FuY2VsbGF0aW9uLWZvcm0gYnV0dG9uJywgY2FuY2VsUmVmdW5kKTtcclxuXHJcblx0XHRUaHVuZGVyLnV0aWwuYmluZEJhY2tCdXR0b24oJGJhY2tUb09yZGVycywgY29udGV4dCk7XHJcblxyXG5cdFx0Ly8gUmVuZGVyIGEgcGF5bWVudCBmb3JtIGlmIGl0J3MgbmVlZGVkLlxyXG5cdFx0aWYgKHNob3VsZFBheSkge1xyXG5cclxuXHRcdFx0Y29uc3QgJHBheW1lbnRGb3JtQ29udGFpbmVyID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tcGF5bWVudC1mb3JtLWNvbnRhaW5lcicpO1xyXG5cdFx0XHRjb25zdCAkbWFrZVBheW1lbnQgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1tYWtlLXBheW1lbnQnKTtcclxuXHRcdFx0Y29uc3QgbWFrZVBheW1lbnRTcGlubmVyID0gVGh1bmRlci51dGlsLm1ha2VBc3luY0J1dHRvbigkbWFrZVBheW1lbnQsIHsgYmluZDogZmFsc2UgfSk7XHJcblxyXG5cdFx0XHRUaHVuZGVyLnJlbmRlcigkcGF5bWVudEZvcm1Db250YWluZXIsICdwYXltZW50LWZvcm0nLCB7XHJcblx0XHRcdFx0dHlwZTogJ29yZGVyJyxcclxuXHRcdFx0XHRwYXltZW50TWV0aG9kczogcGF5bWVudE1ldGhvZHMubWFwKHAgPT4gcC5pZClcclxuXHRcdFx0fSwgKGVyciwgeyBpbnRlcmZhY2VzOiBwYXltZW50SGFuZGxlciB9KSA9PiAkbWFrZVBheW1lbnQub24oJ2NsaWNrJywgKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBwYXltZW50SGFuZGxlci52YWxpZGF0ZSgpO1xyXG5cclxuXHRcdFx0XHRpZiAodmFsaWRhdGlvbkVycm9yKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gVGh1bmRlci5ub3RpZnkoJ2Vycm9yJywgdmFsaWRhdGlvbkVycm9yLm1lc3NhZ2UpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bWFrZVBheW1lbnRTcGlubmVyLnJ1bigpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gcGF5bWVudEhhbmRsZXIubWFrZVBheW1lbnQoe1xyXG5cdFx0XHRcdFx0Y2FydDogICAgIG9yZGVyLFxyXG5cdFx0XHRcdFx0b3JkZXI6ICAgIG9yZGVyLFxyXG5cdFx0XHRcdFx0Y3VzdG9tZXI6IG9yZGVyLmN1c3RvbWVyXHJcblx0XHRcdFx0fSwgZXJyID0+IHtcclxuXHJcblx0XHRcdFx0XHRpZiAoZXJyKSB7XHJcblx0XHRcdFx0XHRcdFRodW5kZXIubm90aWZ5KCdlcnJvcicsIGNvbnRleHQubSgncGF5bWVudEZhaWxlZCcpKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIG1ha2VQYXltZW50U3Bpbm5lci5kb25lKCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0VGh1bmRlci5ub3RpZnkoJ3N1Y2Nlc3MnLCBjb250ZXh0Lm0oJ3BheW1lbnRTdWNjZXNzJykpO1xyXG5cdFx0XHRcdFx0bWFrZVBheW1lbnRTcGlubmVyLmRvbmUoKTtcclxuXHRcdFx0XHRcdHJldHVybiBUaHVuZGVyLnJlbmRlcigkY29udGFpbmVyLCBpbXBsZW1lbnRhdGlvbi5uYW1lLCAkLmV4dGVuZChjb250ZXh0Lm9wdGlvbnMsIHtcclxuXHRcdFx0XHRcdFx0dXBkYXRlVHJhbnNhY3Rpb25zOiB0cnVlXHJcblx0XHRcdFx0XHR9KSk7XHJcblxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0fSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldERvd25sb2FkTGluaygpIHtcclxuXHJcblx0XHRcdGNvbnN0ICRpdGVtID0gJCh0aGlzKS5wYXJlbnRzKCdbZGF0YS1pdGVtXScpLmVxKDApO1xyXG5cdFx0XHRjb25zdCBpdGVtSWQgPSAkaXRlbS5kYXRhKCdidW5kbGVJdGVtJykgfHwgJGl0ZW0uZGF0YSgnaXRlbScpO1xyXG5cdFx0XHRjb25zdCBvcmRlcklkID0gY29udGV4dC5vcmRlci5faWQ7XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRtZXRob2Q6ICdQT1NUJyxcclxuXHRcdFx0XHR1cmw6ICAgIGAvdjEvbWUvb3JkZXJzLyR7b3JkZXJJZH0vaXRlbXMvJHtpdGVtSWR9L2Rvd25sb2FkL3VybGAsXHJcblx0XHRcdH0pLnRoZW4ocmVzID0+IHtcclxuXHRcdFx0XHRpZiAoIXJlcy51cmwpIHJldHVybjtcclxuXHJcblx0XHRcdFx0Y29uc3QgJGNvdW50VmlldyA9ICRpdGVtLmZpbmQoJy50aHVuZGVyLS1kb3dubG9hZC1jb3VudC12aWV3JykuZXEoMCk7XHJcblxyXG5cdFx0XHRcdGlmICgkY291bnRWaWV3Lmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0JGNvdW50Vmlldy5kYXRhKCdjdXJyZW50JywgJGNvdW50Vmlldy5kYXRhKCdjdXJyZW50JykgKyAxKTtcclxuXHRcdFx0XHRcdCRjb3VudFZpZXcudGV4dChjb250ZXh0Lm0oJ25UaW1lc0Rvd25sb2FkZWQnLCAkY291bnRWaWV3LmRhdGEoKSkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0d2luZG93Lm9wZW4ocmVzLnVybCk7XHJcblxyXG5cdFx0XHR9LCBlcnIgPT4ge1xyXG5cdFx0XHRcdGlmIChlcnIucmVzcG9uc2VKU09OLmVycm9yQ29kZSA9PT0gJ2Z1bGx5LXVzZWQtaXRlbScpIHtcclxuXHRcdFx0XHRcdHJldHVybiBUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBjb250ZXh0Lm0oJ2Z1bGx5VXNlZERvd25sb2FkYWJsZScpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGVyci5yZXNwb25zZUpTT04uZXJyb3JDb2RlID09PSAnZXhwaXJlZC1pdGVtJykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFRodW5kZXIubm90aWZ5KCdlcnJvcicsIGNvbnRleHQubSgnZXhwaXJlZERvd25sb2FkYWJsZScpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGVyci5yZXNwb25zZUpTT04uZXJyb3JDb2RlID09PSAncmVmdW5kZWQtaXRlbScpIHtcclxuXHRcdFx0XHRcdHJldHVybiBUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBjb250ZXh0Lm0oJ3JlZnVuZGVkSXRlbScpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHZpZXdTdWJzY3JpcHRpb24oKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZW5kZXIoJGNvbnRhaW5lciwgJ3N1YnNjcmlwdGlvbi1kZXRhaWwnLCB7XHJcblx0XHRcdFx0c3Vic2NyaXB0aW9uOiBvcmRlci5zdWJzY3JpcHRpb24uX2lkLFxyXG5cdFx0XHRcdGJhY2s6IHtcclxuXHRcdFx0XHRcdCRjb250YWluZXI6ICRjb250YWluZXIsXHJcblx0XHRcdFx0XHRjb21wb25lbnQ6ICBpbXBsZW1lbnRhdGlvbi5uYW1lLFxyXG5cdFx0XHRcdFx0b3B0aW9uczogICAgY29udGV4dC5vcHRpb25zXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gbWFya0FzUmVjZWl2ZWQoKSB7XHJcblxyXG5cdFx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdFx0J2ludmFsaWQtb3JkZXItc3RhdHVzJzogY29udGV4dC5tKCdpbnZhbGlkT3JkZXJTdGF0dXMnKSxcclxuXHRcdFx0XHRkZWZhdWx0OiBjb250ZXh0Lm0oJ21hcmtBc1JlY2VpdmVkRmFpbGVkJyksXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRtZXRob2Q6ICdQT1NUJyxcclxuXHRcdFx0XHR1cmw6ICAgIGAvdjEvbWUvb3JkZXJzLyR7b3JkZXIuX2lkfS9yZWNlaXZlZGAsXHJcblx0XHRcdH0pLnRoZW4oKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRUaHVuZGVyLm5vdGlmeSgnc3VjY2VzcycsIGNvbnRleHQubSgnbWFya0FzUmVjZWl2ZWRTdWNjZXNzJykpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gVGh1bmRlci5yZW5kZXIoJGNvbnRhaW5lciwgaW1wbGVtZW50YXRpb24ubmFtZSwgJC5leHRlbmQoY29udGV4dC5vcHRpb25zLCB7XHJcblx0XHRcdFx0XHR1cGRhdGVUcmFuc2FjdGlvbnM6IGZhbHNlXHJcblx0XHRcdFx0fSkpO1xyXG5cclxuXHRcdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRcdGVyci5yZXNwb25zZUpTT04sXHJcblx0XHRcdFx0ZXJyb3JzXHJcblx0XHRcdCkpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBtYXJrQXNOb3RSZWNlaXZlZCgpIHtcclxuXHJcblx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHQnaW52YWxpZC1vcmRlci1zdGF0dXMnOiBjb250ZXh0Lm0oJ2ludmFsaWRPcmRlclN0YXR1cycpLFxyXG5cdFx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgnbWFya0FzTm90UmVjZWl2ZWRGYWlsZWQnKSxcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ0RFTEVURScsXHJcblx0XHRcdFx0dXJsOiAgICBgL3YxL21lL29yZGVycy8ke29yZGVyLl9pZH0vcmVjZWl2ZWRgLFxyXG5cdFx0XHR9KS50aGVuKCgpID0+IHtcclxuXHJcblx0XHRcdFx0VGh1bmRlci5ub3RpZnkoJ3N1Y2Nlc3MnLCBjb250ZXh0Lm0oJ21hcmtBc05vdFJlY2VpdmVkU3VjY2VzcycpKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRodW5kZXIucmVuZGVyKCRjb250YWluZXIsIGltcGxlbWVudGF0aW9uLm5hbWUsICQuZXh0ZW5kKGNvbnRleHQub3B0aW9ucywge1xyXG5cdFx0XHRcdFx0dXBkYXRlVHJhbnNhY3Rpb25zOiBmYWxzZVxyXG5cdFx0XHRcdH0pKTtcclxuXHJcblx0XHRcdH0sIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdGVycm9yc1xyXG5cdFx0XHQpKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc3RhcnRDYW5jZWxsYXRpb24oKSB7XHJcblx0XHRcdCQodGhpcykuYWRkQ2xhc3MoJ2hpZGRlbicpO1xyXG5cdFx0XHQkY2FuY2VsbGF0aW9uRm9ybS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XHJcblx0XHRcdCRjYW5jZWxsYXRpb25SZWFzb24uZm9jdXMoKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjYW5jZWxPcmRlcihldmVudCkge1xyXG5cclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcblx0XHRcdGNvbnN0IGRhdGEgPSBUaHVuZGVyLnV0aWwuZm9ybVRvSlNPTigkY2FuY2VsbGF0aW9uRm9ybS5zZXJpYWxpemVBcnJheSgpKTtcclxuXHJcblx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHQnaW52YWxpZC1vcmRlci1zdGF0dXMnOiBjb250ZXh0Lm0oJ2ludmFsaWRPcmRlclN0YXR1cycpLFxyXG5cdFx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgnY2FuY2VsbGF0aW9uRmFpbGVkJyksXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRjb25zdCByZXNldFN0YXRlID0gKCkgPT4ge1xyXG5cdFx0XHRcdGNhbmNlbEJ1dHRvblNwaW5uZXIuZG9uZSgpO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0bWV0aG9kOiAnUE9TVCcsXHJcblx0XHRcdFx0dXJsOiAgICBgL3YxL21lL29yZGVycy8ke29yZGVyLl9pZH0vY2FuY2VsbGF0aW9uYCxcclxuXHRcdFx0XHRkYXRhOiAgIGRhdGEsXHJcblx0XHRcdH0pLnRoZW4oKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRyZXNldFN0YXRlKCk7XHJcblxyXG5cdFx0XHRcdFRodW5kZXIubm90aWZ5KCdzdWNjZXNzJywgY29udGV4dC5tKCdjYW5jZWxsYXRpb25TdWNjZXNzJykpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gVGh1bmRlci5yZW5kZXIoJGNvbnRhaW5lciwgaW1wbGVtZW50YXRpb24ubmFtZSwgJC5leHRlbmQoY29udGV4dC5vcHRpb25zLCB7XHJcblx0XHRcdFx0XHR1cGRhdGVUcmFuc2FjdGlvbnM6IGZhbHNlXHJcblx0XHRcdFx0fSkpO1xyXG5cclxuXHRcdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRcdGVyci5yZXNwb25zZUpTT04sXHJcblx0XHRcdFx0ZXJyb3JzLFxyXG5cdFx0XHRcdHJlc2V0U3RhdGVcclxuXHRcdFx0KSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlcXVlc3RSZWZ1bmQoKSB7XHJcblx0XHRcdFRodW5kZXIuZXhlY3V0ZShcclxuXHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25SZXF1ZXN0UmVmdW5kLFxyXG5cdFx0XHRcdCRjb250YWluZXIsXHJcblx0XHRcdFx0Y29udGV4dCxcclxuXHRcdFx0XHRvcmRlclxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHN0YXJ0UmVmdW5kQ2FuY2VsbGF0aW9uKGV2ZW50KSB7XHJcblxyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgJHJlZnVuZCA9ICQodGhpcykucGFyZW50cygnW2RhdGEtcmVmdW5kXScpO1xyXG5cdFx0XHRjb25zdCAkY2FuY2VsbGF0aW9uRm9ybSA9ICRyZWZ1bmQuZmluZCgnLnRodW5kZXItLXJlZnVuZC1jYW5jZWxsYXRpb24tZm9ybScpO1xyXG5cclxuXHRcdFx0JCh0aGlzKS5hZGRDbGFzcygnaGlkZGVuJyk7XHJcblx0XHRcdCRjYW5jZWxsYXRpb25Gb3JtLnJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY2FuY2VsUmVmdW5kKGV2ZW50KSB7XHJcblxyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgJHJlZnVuZCA9ICQodGhpcykucGFyZW50cygnW2RhdGEtcmVmdW5kXScpO1xyXG5cdFx0XHRjb25zdCAkY2FuY2VsbGF0aW9uRm9ybSA9ICRyZWZ1bmQuZmluZCgnLnRodW5kZXItLXJlZnVuZC1jYW5jZWxsYXRpb24tZm9ybScpO1xyXG5cdFx0XHRjb25zdCByZWZ1bmRJZCA9ICRyZWZ1bmQuZGF0YSgncmVmdW5kJyk7XHJcblxyXG5cdFx0XHRjb25zdCBkYXRhID0gVGh1bmRlci51dGlsLmZvcm1Ub0pTT04oJGNhbmNlbGxhdGlvbkZvcm0uc2VyaWFsaXplQXJyYXkoKSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gY2FuY2VsKCkudGhlbigoKSA9PiB7XHJcblx0XHRcdFx0VGh1bmRlci5ub3RpZnkoJ3N1Y2Nlc3MnLCBjb250ZXh0Lm0oJ3JlZnVuZENhbmNlbGxhdGlvblN1Y2Nlc3MnKSk7XHJcblx0XHRcdFx0cmV0dXJuIFRodW5kZXIucmVuZGVyKCRjb250YWluZXIsIGltcGxlbWVudGF0aW9uLm5hbWUsICQuZXh0ZW5kKGNvbnRleHQub3B0aW9ucywge1xyXG5cdFx0XHRcdFx0dXBkYXRlVHJhbnNhY3Rpb25zOiBmYWxzZVxyXG5cdFx0XHRcdH0pKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBjYW5jZWwoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHRcdCdpbnZhbGlkLXJlZnVuZC1zdGF0dXMnOiBjb250ZXh0Lm0oJ2ludmFsaWRSZWZ1bmRTdGF0dXMnKSxcclxuXHRcdFx0XHRcdGRlZmF1bHQ6ICAgICAgICAgICAgICAgICBjb250ZXh0Lm0oJ3JlZnVuZENhbmNlbGxhdGlvbkZhaWxlZCcpXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0XHRtZXRob2Q6ICdQT1NUJyxcclxuXHRcdFx0XHRcdHVybDogICAgYC92MS9tZS9vcmRlcnMvJHtvcmRlci5faWR9L3JlZnVuZHMvJHtyZWZ1bmRJZH0vY2FuY2VsbGF0aW9uYCxcclxuXHRcdFx0XHRcdGRhdGE6ICAgZGF0YVxyXG5cdFx0XHRcdH0pLnRoZW4obnVsbCwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0XHRcdGVycm9yc1xyXG5cdFx0XHRcdCkpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IFRodW5kZXIgPT4ge1xyXG5cclxuXHRjb25zdCBpbXBsZW1lbnRhdGlvbiA9IHtcclxuXHRcdG5hbWU6ICdvcmRlci1saXN0J1xyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLm9wdGlvbnMgPSAoKSA9PiAoe1xyXG5cdFx0cGFnZTogICAgICAgICAgMSwgICAgLy8gV2hpY2ggcGFnZSBvZiBvcmRlcnM/XHJcblx0XHRsaW1pdDogICAgICAgICAxMCwgICAvLyBIb3cgbWFueSBvcmRlcnMgYXQgb25jZT9cclxuXHRcdHVzZVBhZ2luYXRpb246IHRydWUsIC8vIFVzZSBwYWdpbmF0aW9uP1xyXG5cdFx0b25WaWV3T3JkZXI6ICAgZnVuY3Rpb24oJGNvbnRhaW5lciwgY29udGV4dCwgb3JkZXJJZCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIucmVuZGVyKCRjb250YWluZXIsICdvcmRlci1kZXRhaWwnLCB7XHJcblx0XHRcdFx0b3JkZXI6IG9yZGVySWQsXHJcblx0XHRcdFx0YmFjazogIHtcclxuXHRcdFx0XHRcdCRjb250YWluZXI6ICRjb250YWluZXIsXHJcblx0XHRcdFx0XHRjb21wb25lbnQ6ICBpbXBsZW1lbnRhdGlvbi5uYW1lLFxyXG5cdFx0XHRcdFx0b3B0aW9uczogICAgY29udGV4dC5vcHRpb25zXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLnByZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcblxyXG5cdFx0Y29uc3QgZXJyb3JzID0ge1xyXG5cdFx0XHRkZWZhdWx0OiBjb250ZXh0Lm0oJ29yZGVyTGlzdEZhaWxlZCcpXHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiAkLndoZW4oXHJcblx0XHRcdFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0bWV0aG9kOiAnR0VUJyxcclxuXHRcdFx0XHR1cmw6ICAgICcvdjEvbWUvb3JkZXJzJyxcclxuXHRcdFx0XHRxdWVyeTogIHtcclxuXHRcdFx0XHRcdHBhZ2U6ICAgY29udGV4dC5vcHRpb25zLnBhZ2UsXHJcblx0XHRcdFx0XHRsaW1pdDogIGNvbnRleHQub3B0aW9ucy5saW1pdCxcclxuXHRcdFx0XHRcdHNvcnQ6ICAgJy1jcmVhdGVkQXQnLFxyXG5cdFx0XHRcdFx0ZmllbGRzOiBbXHJcblx0XHRcdFx0XHRcdCdzdWJzY3JpcHRpb24nLFxyXG5cdFx0XHRcdFx0XHQnc3RhdHVzJyxcclxuXHRcdFx0XHRcdFx0J2l0ZW1zLnR5cGUnLFxyXG5cdFx0XHRcdFx0XHQnaXRlbXMucHJvZHVjdCcsXHJcblx0XHRcdFx0XHRcdCdpdGVtcy5idW5kbGVJdGVtcy50eXBlJyxcclxuXHRcdFx0XHRcdFx0J2Z1bGZpbGxtZW50cy5zdGF0dXMnLFxyXG5cdFx0XHRcdFx0XHQndG90YWwucHJpY2Uud2l0aFRheCcsXHJcblx0XHRcdFx0XHRcdCdjYW5jZWxsYXRpb24nLFxyXG5cdFx0XHRcdFx0XHQncmVjZWl2ZWRBdCcsXHJcblx0XHRcdFx0XHRcdCdjcmVhdGVkQXQnLFxyXG5cdFx0XHRcdFx0XS5qb2luKCcsJylcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pLFxyXG5cdFx0XHRjb250ZXh0Lm9wdGlvbnMudXNlUGFnaW5hdGlvbiA/IFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0bWV0aG9kOiAnR0VUJyxcclxuXHRcdFx0XHR1cmw6ICAgICcvdjEvbWUvb3JkZXJzL2NvdW50JyxcclxuXHRcdFx0XHRxdWVyeTogIHtcclxuXHRcdFx0XHRcdHJhdzogdHJ1ZVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSkgOiBudWxsXHJcblx0XHQpLnRoZW4oKG9yZGVycywgY291bnQpID0+IHtcclxuXHJcblx0XHRcdGNvbnRleHQub3JkZXJzID0gKG9yZGVyc1swXSB8fCBbXSkubWFwKG9yZGVyID0+IHtcclxuXHRcdFx0XHRvcmRlci5zaGlwcGluZ1N0YXR1cyA9IFRodW5kZXIudXRpbC5vcmRlclNoaXBwaW5nU3RhdHVzKG9yZGVyKTtcclxuXHRcdFx0XHRyZXR1cm4gb3JkZXI7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29udGV4dC5jb3VudCA9IGNvdW50ID8gY291bnRbMF0uY291bnQgOiBudWxsO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIGNvbnRleHQpO1xyXG5cclxuXHRcdH0sIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0ZXJyb3JzLFxyXG5cdFx0XHRjYWxsYmFja1xyXG5cdFx0KSk7XHJcblxyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLmluaXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcblxyXG5cdFx0Y29uc3QgJGNvbnRhaW5lciA9ICQodGhpcyk7XHJcblx0XHRjb25zdCAkb3JkZXIgPSAkKHRoaXMpLmZpbmQoJ1tkYXRhLW9yZGVyXScpO1xyXG5cdFx0Y29uc3QgJHBhZ2luYXRpb24gPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1vcmRlci1saXN0LXBhZ2luYXRpb24nKTtcclxuXHJcblx0XHQkb3JkZXIub24oJ2NsaWNrJywgW1xyXG5cdFx0XHQnLnRodW5kZXItLW9yZGVyLWlkJyxcclxuXHRcdFx0Jy50aHVuZGVyLS1vcmRlci10aHVtYm5haWwnLFxyXG5cdFx0XHQnLnRodW5kZXItLW9yZGVyLWZpcnN0LWl0ZW0nLFxyXG5cdFx0XHQnLnRodW5kZXItLW9yZGVyLXJlc3QtaXRlbXMnLFxyXG5cdFx0XS5qb2luKCcsJyksIGV2ZW50ID0+IFRodW5kZXIuZXhlY3V0ZShcclxuXHRcdFx0Y29udGV4dC5vcHRpb25zLm9uVmlld09yZGVyLFxyXG5cdFx0XHQkY29udGFpbmVyLFxyXG5cdFx0XHRjb250ZXh0LFxyXG5cdFx0XHQkKGV2ZW50LmRlbGVnYXRlVGFyZ2V0KS5kYXRhKCdvcmRlcicpXHJcblx0XHQpKTtcclxuXHJcblx0XHRpZiAoY29udGV4dC5vcHRpb25zLnVzZVBhZ2luYXRpb24pIHtcclxuXHJcblx0XHRcdFRodW5kZXIucGx1Z2lucy5wYWdpbmF0aW9uKHtcclxuXHRcdFx0XHRjb250YWluZXI6ICAgICAkcGFnaW5hdGlvbixcclxuXHRcdFx0XHRjdXJyZW50UGFnZTogICBjb250ZXh0Lm9wdGlvbnMucGFnZSxcclxuXHRcdFx0XHR0b3RhbFJlc3VsdDogICBjb250ZXh0LmNvdW50LFxyXG5cdFx0XHRcdHJlc3VsdFBlclBhZ2U6IGNvbnRleHQub3B0aW9ucy5saW1pdCxcclxuXHRcdFx0XHRvblBhZ2VDaGFuZ2U6ICAoeyBwYWdlIH0pID0+IFRodW5kZXIucmVuZGVyKFxyXG5cdFx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdGltcGxlbWVudGF0aW9uLm5hbWUsXHJcblx0XHRcdFx0XHQkLmV4dGVuZChjb250ZXh0Lm9wdGlvbnMsIHsgcGFnZSB9KVxyXG5cdFx0XHRcdClcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcclxuXHJcbn07IiwiY29uc3Qgc2V0ID0gcmVxdWlyZSgnbG9kYXNoLnNldCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaHVuZGVyID0+IHtcclxuXHJcblx0Y29uc3QgaW1wbGVtZW50YXRpb24gPSB7XHJcblx0XHRuYW1lOiAnb3JkZXItcmVxdWVzdC1yZWZ1bmQnXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ub3B0aW9ucyA9ICgpID0+ICh7XHJcblx0XHRvcmRlcjogICAgICAgICAgICAnJywgLy8gT3JkZXIgSUQgdG8gcmVmdW5kXHJcblx0XHRyZWFzb25DYXRlZ29yaWVzOiBUaHVuZGVyLm9wdGlvbnMucmVmdW5kUmVhc29uQ2F0ZWdvcmllcyxcclxuXHJcblx0XHRvblJlcXVlc3RSZWZ1bmRTdWNjZXNzOiBmdW5jdGlvbigkY29udGFpbmVyLCBjb250ZXh0LCByZWZ1bmQpIHtcclxuXHJcblx0XHRcdFRodW5kZXIubm90aWZ5KCdzdWNjZXNzJywgY29udGV4dC5tKCdyZXF1ZXN0UmVmdW5kU3VjY2VzcycpKTtcclxuXHJcblx0XHRcdGNvbnN0IGJhY2sgPSBjb250ZXh0Lm9wdGlvbnMuYmFjaztcclxuXHJcblx0XHRcdGlmICghYmFjaykgcmV0dXJuO1xyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIucmVuZGVyKGJhY2suJGNvbnRhaW5lciwgYmFjay5jb21wb25lbnQsIGJhY2sub3B0aW9ucyk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLnByZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcblxyXG5cdFx0bGV0IG9yZGVyID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gZmV0Y2hPcmRlcihjb250ZXh0Lm9wdGlvbnMub3JkZXIpXHJcblx0XHRcdFx0LnRoZW4obyA9PiB7XHJcblx0XHRcdFx0XHRvcmRlciA9IG87XHJcblx0XHRcdFx0XHRyZXR1cm4gZmV0Y2hDdXJyZW5jeShvcmRlci5jdXJyZW5jeS5wYXltZW50LmNvZGUpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0LnRoZW4oKFtjdXJyZW5jeV0pID0+IHN1Y2Nlc3Mob3JkZXIsIGN1cnJlbmN5KSk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gc3VjY2VzcyhvcmRlciwgY3VycmVuY3kpIHtcclxuXHJcblx0XHRcdGNvbnRleHQuY3VycmVuY3kgPSAkLmV4dGVuZChjdXJyZW5jeSwge1xyXG5cdFx0XHRcdC8vIE92ZXJyaWRlIHByZWNpc2lvbiB3aXRoIGEgc25hcHNob3QgdmVyc2lvblxyXG5cdFx0XHRcdHByZWNpc2lvbjogb3JkZXIuY3VycmVuY3kucGF5bWVudC5wcmVjaXNpb25cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjb25zdCByZWZ1bmRzSW5Qcm9jZXNzID1cclxuXHRcdFx0XHRvcmRlci5yZWZ1bmRzXHJcblx0XHRcdFx0XHQuZmlsdGVyKCh7IHN0YXR1cyB9KSA9PiBzdGF0dXMgIT09ICdjYW5jZWxsZWQnKTtcclxuXHJcblx0XHRcdC8vIHsgW2l0ZW1JZF06IHNoaXBtZW50LCAuLi4gfVxyXG5cdFx0XHRjb25zdCBpdGVtVG9TaGlwbWVudE1hcCA9IG9yZGVyLnNoaXBtZW50cy5yZWR1Y2UoKG8sIHNoaXBtZW50KSA9PiB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBzaGlwbWVudC5pdGVtcy5yZWR1Y2UoKG8sIGl0ZW0pID0+IHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gc2V0KG8sIGl0ZW0uX2lkLCBzaGlwbWVudCk7XHJcblxyXG5cdFx0XHRcdH0sIG8pO1xyXG5cclxuXHRcdFx0fSwge30pO1xyXG5cclxuXHRcdFx0Ly8geyBbaXRlbUlkXTogcXVhbnRpdHksIC4uLiB9XHJcblx0XHRcdGNvbnN0IHJlZnVuZGVkSXRlbVF1YW50aXR5TWFwID0gcmVmdW5kc0luUHJvY2Vzcy5yZWR1Y2UoKG8sIHJlZnVuZCkgPT4ge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gcmVmdW5kLml0ZW1zLnJlZHVjZSgobywgeyBpdGVtLCBxdWFudGl0eSB9KSA9PiB7XHJcblx0XHRcdFx0XHRvW2l0ZW0uX2lkXSA9IG9baXRlbS5faWRdIHx8IDA7XHJcblx0XHRcdFx0XHRvW2l0ZW0uX2lkXSArPSBxdWFudGl0eS5yYXc7XHJcblx0XHRcdFx0XHRyZXR1cm4gbztcclxuXHRcdFx0XHR9LCBvKTtcclxuXHJcblx0XHRcdH0sIHt9KTtcclxuXHJcblx0XHRcdC8vIHsgW3NoaXBtZW50SWRdOiBhbW91bnQsIC4uLiB9XHJcblx0XHRcdGNvbnN0IHJlZnVuZGVkU2hpcG1lbnRBbW91bnRNYXAgPSByZWZ1bmRzSW5Qcm9jZXNzLnJlZHVjZSgobywgcmVmdW5kKSA9PiB7XHJcblxyXG5cdFx0XHRcdHJldHVybiByZWZ1bmQuc2hpcG1lbnRzLnJlZHVjZSgobywgeyBzaGlwbWVudCwgZmVlIH0pID0+IHtcclxuXHRcdFx0XHRcdG9bc2hpcG1lbnQuX2lkXSA9IG9bc2hpcG1lbnQuX2lkXSB8fCAwO1xyXG5cdFx0XHRcdFx0b1tzaGlwbWVudC5faWRdID0gVGh1bmRlci51dGlsLnRvUHJlY2lzaW9uKFxyXG5cdFx0XHRcdFx0XHRvW3NoaXBtZW50Ll9pZF0gKyBmZWUud2l0aFRheC5yYXcsXHJcblx0XHRcdFx0XHRcdGNvbnRleHQuY3VycmVuY3kucHJlY2lzaW9uXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIG87XHJcblx0XHRcdFx0fSwgbyk7XHJcblxyXG5cdFx0XHR9LCB7fSk7XHJcblxyXG5cdFx0XHRvcmRlci5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4gW10uY29uY2F0KGl0ZW0sIGl0ZW0uYnVuZGxlSXRlbXMgfHwgW10pLmZvckVhY2goaXRlbSA9PiB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHNoaXBtZW50ID0gaXRlbVRvU2hpcG1lbnRNYXBbaXRlbS5faWRdO1xyXG5cdFx0XHRcdGNvbnN0IHJlZnVuZGVkSXRlbVF1YW50aXR5ID0gcmVmdW5kZWRJdGVtUXVhbnRpdHlNYXBbaXRlbS5faWRdIHx8IDA7XHJcblxyXG5cdFx0XHRcdGl0ZW0uc2hpcG1lbnQgPSBzaGlwbWVudDtcclxuXHRcdFx0XHRpdGVtLnJlZnVuZGFibGVRdWFudGl0eSA9IGl0ZW0ucXVhbnRpdHkucmF3IC0gcmVmdW5kZWRJdGVtUXVhbnRpdHk7XHJcblxyXG5cdFx0XHR9KSk7XHJcblxyXG5cdFx0XHRvcmRlci5zaGlwbWVudHMuZm9yRWFjaChzaGlwbWVudCA9PiB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHJlZnVuZGVkU2hpcG1lbnRBbW91bnQgPSByZWZ1bmRlZFNoaXBtZW50QW1vdW50TWFwW3NoaXBtZW50Ll9pZF0gfHwgMDtcclxuXHJcblx0XHRcdFx0c2hpcG1lbnQucmVmdW5kYWJsZUZlZSA9IFRodW5kZXIudXRpbC50b1ByZWNpc2lvbihcclxuXHRcdFx0XHRcdHNoaXBtZW50LmZlZS53aXRoVGF4LnJhdyAtIHJlZnVuZGVkU2hpcG1lbnRBbW91bnQsXHJcblx0XHRcdFx0XHRjb250ZXh0LmN1cnJlbmN5LnByZWNpc2lvblxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdG9yZGVyLmhhc1JlZnVuZGFibGVJdGVtID0gb3JkZXIuaXRlbXMuc29tZShpdGVtID0+IHtcclxuXHRcdFx0XHRyZXR1cm4gW10uY29uY2F0KGl0ZW0sIGl0ZW0uYnVuZGxlSXRlbXMgfHwgW10pLnNvbWUoaXRlbSA9PiB7XHJcblx0XHRcdFx0XHRyZXR1cm4gaXRlbS5yZWZ1bmRhYmxlUXVhbnRpdHkgPiAwO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBzZXQoY29udGV4dCwgJ29yZGVyJywgb3JkZXIpKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBmZXRjaE9yZGVyKG9yZGVyKSB7XHJcblxyXG5cdFx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdFx0ZGVmYXVsdDogY29udGV4dC5tKCdvcmRlclJlYWRGYWlsZWQnKVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0bWV0aG9kOiAnR0VUJyxcclxuXHRcdFx0XHR1cmw6ICAgIGAvdjEvbWUvb3JkZXJzLyR7b3JkZXJ9YCxcclxuXHRcdFx0XHRmaWVsZHM6IFtcclxuXHRcdFx0XHRcdCdpdGVtcycsXHJcblx0XHRcdFx0XHQnc2hpcG1lbnRzJyxcclxuXHRcdFx0XHRcdCdyZWZ1bmRzJyxcclxuXHRcdFx0XHRcdCd0cmFuc2FjdGlvbnMnLFxyXG5cdFx0XHRcdFx0J3RvdGFsJyxcclxuXHRcdFx0XHRdLmpvaW4oJywnKVxyXG5cdFx0XHR9KS50aGVuKG51bGwsIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdGVycm9ycyxcclxuXHRcdFx0XHRjYWxsYmFja1xyXG5cdFx0XHQpKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZmV0Y2hDdXJyZW5jeShjb2RlKSB7XHJcblxyXG5cdFx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdFx0ZGVmYXVsdDogY29udGV4dC5tKCdjdXJyZW5jeVJlYWRGYWlsZWQnKVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0bWV0aG9kOiAnR0VUJyxcclxuXHRcdFx0XHR1cmw6ICAgIGAvdjEvY3VycmVuY2llc2AsXHJcblx0XHRcdFx0cXVlcnk6IHsgY29kZSB9XHJcblx0XHRcdH0pLnRoZW4obnVsbCwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRcdGVyci5yZXNwb25zZUpTT04sXHJcblx0XHRcdFx0ZXJyb3JzLFxyXG5cdFx0XHRcdGNhbGxiYWNrXHJcblx0XHRcdCkpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24uaW5pdCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuXHJcblx0XHRjb25zdCB7XHJcblx0XHRcdG9yZGVyLFxyXG5cdFx0XHRjdXJyZW5jeVxyXG5cdFx0fSA9IGNvbnRleHQ7XHJcblxyXG5cdFx0Y29uc3QgY2F0ZWdvcnlNYXAgPSBjb250ZXh0Lm9wdGlvbnMucmVhc29uQ2F0ZWdvcmllcy5yZWR1Y2UoKG8sIGNhdGVnb3J5KSA9PiB7XHJcblx0XHRcdHJldHVybiBzZXQobywgY2F0ZWdvcnkubGFiZWwsIGNhdGVnb3J5KTtcclxuXHRcdH0sIHt9KTtcclxuXHJcblx0XHRjb25zdCBpdGVtTWFwID0gb3JkZXIuaXRlbXMucmVkdWNlKChvLCBpdGVtKSA9PiB7XHJcblx0XHRcdHJldHVybiBbXS5jb25jYXQoaXRlbSwgaXRlbS5idW5kbGVJdGVtcyB8fCBbXSkucmVkdWNlKChvLCBpdGVtKSA9PiB7XHJcblx0XHRcdFx0cmV0dXJuIHNldChvLCBpdGVtLl9pZCwgaXRlbSk7XHJcblx0XHRcdH0sIG8pO1xyXG5cdFx0fSwge30pO1xyXG5cclxuXHRcdGNvbnN0IHNoaXBtZW50TWFwID0gb3JkZXIuc2hpcG1lbnRzLnJlZHVjZSgobywgc2hpcG1lbnQpID0+IHtcclxuXHRcdFx0cmV0dXJuIHNldChvLCBzaGlwbWVudC5faWQsIHNoaXBtZW50KTtcclxuXHRcdH0sIHt9KTtcclxuXHJcblx0XHRjb25zdCBzaGlwbWVudEl0ZW1RdWFudGl0eU1hcCA9IG9yZGVyLnNoaXBtZW50cy5yZWR1Y2UoKG8sIHNoaXBtZW50KSA9PiB7XHJcblx0XHRcdHJldHVybiBzaGlwbWVudC5pdGVtcy5yZWR1Y2UoKG8sIGl0ZW0pID0+IHtcclxuXHRcdFx0XHRyZXR1cm4gc2V0KG8sIFtzaGlwbWVudC5faWQsIGl0ZW0uX2lkXSwgaXRlbS5xdWFudGl0eS5yYXcpO1xyXG5cdFx0XHR9LCBvKTtcclxuXHRcdH0sIHt9KTtcclxuXHJcblx0XHRjb25zdCAkY29udGFpbmVyID0gJCh0aGlzKTtcclxuXHRcdGNvbnN0ICRiYWNrVG9PcmRlciA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWJhY2stdG8tb3JkZXInKTtcclxuXHRcdGNvbnN0ICRjYXJ0SXRlbXMgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1jYXJ0LWl0ZW0nKTtcclxuXHRcdGNvbnN0ICR0b2dnbGVJdGVtU2VsZWN0aW9uID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tdG9nZ2xlLWl0ZW0tc2VsZWN0aW9uJyk7XHJcblx0XHRjb25zdCAkcmVmdW5kUXVhbnRpdHkgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1jYXJ0LWl0ZW0gaW5wdXRbbmFtZT1cInJlZnVuZFF1YW50aXR5XCJdJyk7XHJcblx0XHRjb25zdCAkcmVmdW5kQ2F0ZWdvcnkgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1yZWZ1bmQtY2F0ZWdvcnknKTtcclxuXHRcdGNvbnN0ICRyZWZ1bmRSZWFzb24gPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1yZWZ1bmQtcmVhc29uJyk7XHJcblx0XHRjb25zdCAkcmVxdWlyZXNSZWFzb24gPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1yZXF1aXJlcy1yZWZ1bmQtcmVhc29uJyk7XHJcblx0XHRjb25zdCAkdG90YWxEZXRhaWwgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1yZWZ1bmQtdG90YWwtZGV0YWlsJyk7XHJcblx0XHRjb25zdCAkcmVmdW5kSXRlbXNUb3RhbCA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXJlZnVuZC1pdGVtcy10b3RhbCB0ZCcpO1xyXG5cdFx0Y29uc3QgJHJlZnVuZFNoaXBwaW5nVG90YWwgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1yZWZ1bmQtc2hpcHBpbmctdG90YWwgdGQnKTtcclxuXHRcdGNvbnN0ICRyZWZ1bmRUb3RhbCA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXJlZnVuZC10b3RhbCB0ZCcpO1xyXG5cdFx0Y29uc3QgJHJlcXVlc3RSZWZ1bmQgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1yZXF1ZXN0LXJlZnVuZCcpO1xyXG5cdFx0Y29uc3QgcmVxdWVzdEJ1dHRvblNwaW5uZXIgPSBUaHVuZGVyLnV0aWwubWFrZUFzeW5jQnV0dG9uKCRyZXF1ZXN0UmVmdW5kLCB7IGJpbmQ6IGZhbHNlIH0pO1xyXG5cclxuXHRcdCR0b2dnbGVJdGVtU2VsZWN0aW9uLm9uKCdjbGljaycsIHRvZ2dsZUl0ZW1TZWxlY3Rpb24pO1xyXG5cdFx0JHJlZnVuZFF1YW50aXR5Lm9uKCdjaGFuZ2UnLCByZWZ1bmRRdWFudGl0eUNoYW5nZWQpO1xyXG5cdFx0JHJlZnVuZENhdGVnb3J5Lm9uKCdjaGFuZ2UnLCB1cGRhdGVSZWZ1bmRUb3RhbCk7XHJcblxyXG5cdFx0VGh1bmRlci51dGlsLmJpbmRCYWNrQnV0dG9uKCRiYWNrVG9PcmRlciwgY29udGV4dCk7XHJcblxyXG5cdFx0VGh1bmRlci51dGlsLm1ha2VSZWNhcHRjaGEoe1xyXG5cdFx0XHRjb21wb25lbnROYW1lOiBpbXBsZW1lbnRhdGlvbi5uYW1lLFxyXG5cdFx0XHRidXR0b246ICAgICAgICAkcmVxdWVzdFJlZnVuZCxcclxuXHRcdFx0dmFsaWRhdGU6ICAgICAgdmFsaWRhdGVSZXF1ZXN0LFxyXG5cdFx0XHRjYWxsYmFjazogICAgICByZXF1ZXN0UmVmdW5kXHJcblx0XHR9KTtcclxuXHJcblx0XHR1cGRhdGVSZWZ1bmRUb3RhbCgpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGdldE9uZUl0ZW1QcmljZShpdGVtKSB7XHJcblx0XHRcdHJldHVybiBpdGVtLnByaWNlLndpdGhUYXgucmF3IC8gaXRlbS5xdWFudGl0eS5yYXc7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gbWFya0l0ZW1BY3RpdmUoJGNhcnRJdGVtLCBhY3RpdmUsIHF1YW50aXR5KSB7XHJcblxyXG5cdFx0XHRjb25zdCAkdG9nZ2xlQnV0dG9uID0gJGNhcnRJdGVtLmZpbmQoJy50aHVuZGVyLS10b2dnbGUtaXRlbS1zZWxlY3Rpb24nKTtcclxuXHRcdFx0Y29uc3QgJHJlZnVuZFF1YW50aXR5ID0gJGNhcnRJdGVtLmZpbmQoJ2lucHV0W25hbWU9XCJyZWZ1bmRRdWFudGl0eVwiXScpO1xyXG5cdFx0XHRjb25zdCBpdGVtID0gaXRlbU1hcFskY2FydEl0ZW0uZGF0YSgnaXRlbScpXTtcclxuXHJcblx0XHRcdGlmIChhY3RpdmUpIHtcclxuXHRcdFx0XHQkY2FydEl0ZW0uZGF0YSgnYWN0aXZlJywgdHJ1ZSkucmVtb3ZlQ2xhc3MoJ2luYWN0aXZlJyk7XHJcblx0XHRcdFx0JHRvZ2dsZUJ1dHRvbi50ZXh0KGNvbnRleHQubSgncmVtb3ZlRnJvbVJlZnVuZCcpKTtcclxuXHRcdFx0XHQkcmVmdW5kUXVhbnRpdHkudmFsKFxyXG5cdFx0XHRcdFx0cXVhbnRpdHkgPT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdFx0XHRcdGl0ZW0ucmVmdW5kYWJsZVF1YW50aXR5IDpcclxuXHRcdFx0XHRcdFx0cXVhbnRpdHlcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdCRjYXJ0SXRlbS5kYXRhKCdhY3RpdmUnLCBmYWxzZSkuYWRkQ2xhc3MoJ2luYWN0aXZlJyk7XHJcblx0XHRcdFx0JHRvZ2dsZUJ1dHRvbi50ZXh0KGNvbnRleHQubSgnYWRkVG9SZWZ1bmQnKSk7XHJcblx0XHRcdFx0JHJlZnVuZFF1YW50aXR5LnZhbCgwKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiB0b2dnbGVJdGVtU2VsZWN0aW9uKGV2ZW50KSB7XHJcblxyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgJGNhcnRJdGVtID0gJCh0aGlzKS5wYXJlbnRzKCcudGh1bmRlci0tY2FydC1pdGVtJyk7XHJcblxyXG5cdFx0XHRtYXJrSXRlbUFjdGl2ZSgkY2FydEl0ZW0sICEkY2FydEl0ZW0uZGF0YSgnYWN0aXZlJykpO1xyXG5cdFx0XHR1cGRhdGVSZWZ1bmRUb3RhbCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlZnVuZFF1YW50aXR5Q2hhbmdlZCgpIHtcclxuXHJcblx0XHRcdGNvbnN0ICRjYXJ0SXRlbSA9ICQodGhpcykucGFyZW50cygnLnRodW5kZXItLWNhcnQtaXRlbScpO1xyXG5cdFx0XHRjb25zdCBxdWFudGl0eSA9IHBhcnNlSW50KCQodGhpcykudmFsKCkpO1xyXG5cclxuXHRcdFx0bWFya0l0ZW1BY3RpdmUoJGNhcnRJdGVtLCAhIXF1YW50aXR5LCBxdWFudGl0eSk7XHJcblx0XHRcdHVwZGF0ZVJlZnVuZFRvdGFsKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gdXBkYXRlUmVmdW5kVG90YWwoKSB7XHJcblxyXG5cdFx0XHQkY2FydEl0ZW1zLmVhY2goZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0ICRjYXJ0SXRlbSA9ICQodGhpcyk7XHJcblx0XHRcdFx0Y29uc3QgJHJlZnVuZEFtb3VudCA9ICRjYXJ0SXRlbS5maW5kKCcudGh1bmRlci0tY2FydC1pdGVtLXJlZnVuZC1hbW91bnQnKTtcclxuXHRcdFx0XHRjb25zdCBpdGVtID0gaXRlbU1hcFskY2FydEl0ZW0uZGF0YSgnaXRlbScpXTtcclxuXHRcdFx0XHRjb25zdCBxdWFudGl0eSA9IHBhcnNlSW50KCRjYXJ0SXRlbS5maW5kKCdpbnB1dFtuYW1lPVwicmVmdW5kUXVhbnRpdHlcIl0nKS52YWwoKSk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHJlZnVuZEFtb3VudCA9IFRodW5kZXIudXRpbC5mb3JtYXRQcmljZShcclxuXHRcdFx0XHRcdGdldE9uZUl0ZW1QcmljZShpdGVtKSAqIHF1YW50aXR5LFxyXG5cdFx0XHRcdFx0Y3VycmVuY3lcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHQkcmVmdW5kQW1vdW50LnRleHQocmVmdW5kQW1vdW50KTtcclxuXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29uc3QgY2F0ZWdvcnkgPSBjYXRlZ29yeU1hcFskcmVmdW5kQ2F0ZWdvcnkudmFsKCldO1xyXG5cclxuXHRcdFx0aWYgKCFjYXRlZ29yeSkge1xyXG5cdFx0XHRcdCRyZXF1aXJlc1JlYXNvbi5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XHJcblx0XHRcdFx0JHRvdGFsRGV0YWlsLmFkZENsYXNzKCdoaWRkZW4nKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHJlZnVuZEl0ZW1zID0gZ2V0UmVmdW5kSXRlbXMoKTtcclxuXHRcdFx0Y29uc3QgcmVmdW5kU2hpcG1lbnRzID0gZ2V0UmVmdW5kU2hpcG1lbnRzKGNhdGVnb3J5LCByZWZ1bmRJdGVtcyk7XHJcblxyXG5cdFx0XHRjb25zdCBpdGVtc1RvdGFsID0gcmVmdW5kSXRlbXMucmVkdWNlKChzdW0sIHsgaXRlbSwgcXVhbnRpdHkgfSkgPT4ge1xyXG5cdFx0XHRcdHJldHVybiBzdW0gKyAoZ2V0T25lSXRlbVByaWNlKGl0ZW0pICogcXVhbnRpdHkpO1xyXG5cdFx0XHR9LCAwKTtcclxuXHJcblx0XHRcdGNvbnN0IHNoaXBwaW5nVG90YWwgPSByZWZ1bmRTaGlwbWVudHMucmVkdWNlKChzdW0sIHNoaXBtZW50KSA9PiB7XHJcblx0XHRcdFx0cmV0dXJuIHN1bSArIHNoaXBtZW50LnJlZnVuZGFibGVGZWU7XHJcblx0XHRcdH0sIDApO1xyXG5cclxuXHRcdFx0Y29uc3QgdG90YWwgPSBpdGVtc1RvdGFsICsgc2hpcHBpbmdUb3RhbDtcclxuXHJcblx0XHRcdCRyZWZ1bmRJdGVtc1RvdGFsLnRleHQoVGh1bmRlci51dGlsLmZvcm1hdFByaWNlKGl0ZW1zVG90YWwsIGN1cnJlbmN5KSk7XHJcblx0XHRcdCRyZWZ1bmRTaGlwcGluZ1RvdGFsLnRleHQoVGh1bmRlci51dGlsLmZvcm1hdFByaWNlKHNoaXBwaW5nVG90YWwsIGN1cnJlbmN5KSk7XHJcblx0XHRcdCRyZWZ1bmRUb3RhbC50ZXh0KFRodW5kZXIudXRpbC5mb3JtYXRQcmljZSh0b3RhbCwgY3VycmVuY3kpKTtcclxuXHJcblx0XHRcdCRyZXF1aXJlc1JlYXNvbi5hZGRDbGFzcygnaGlkZGVuJyk7XHJcblx0XHRcdCR0b3RhbERldGFpbC5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldFJlZnVuZEl0ZW1zKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuICRyZWZ1bmRRdWFudGl0eS5tYXAoZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRpdGVtOiAgICAgaXRlbU1hcFskKHRoaXMpLnBhcmVudHMoJ1tkYXRhLWl0ZW1dJykuZGF0YSgnaXRlbScpXSxcclxuXHRcdFx0XHRcdHF1YW50aXR5OiBwYXJzZUludCgkKHRoaXMpLnZhbCgpKSxcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0fSkuZ2V0KCkuZmlsdGVyKCh7IHF1YW50aXR5IH0pID0+IHF1YW50aXR5KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0UmVmdW5kU2hpcG1lbnRzKGNhdGVnb3J5LCByZWZ1bmRJdGVtcykge1xyXG5cclxuXHRcdFx0aWYgKCFjYXRlZ29yeSkge1xyXG5cdFx0XHRcdHJldHVybiBbXTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3Qgc2hpcG1lbnRUb1JlZnVuZEl0ZW1zID0ge307XHJcblxyXG5cdFx0XHRyZWZ1bmRJdGVtcy5mb3JFYWNoKHJlZnVuZEl0ZW0gPT4ge1xyXG5cclxuXHRcdFx0XHRjb25zdCBzaGlwbWVudCA9IHJlZnVuZEl0ZW0uaXRlbS5zaGlwbWVudDtcclxuXHJcblx0XHRcdFx0aWYgKCFzaGlwbWVudCkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRzaGlwbWVudFRvUmVmdW5kSXRlbXNbc2hpcG1lbnQuX2lkXSA9XHJcblx0XHRcdFx0XHQoc2hpcG1lbnRUb1JlZnVuZEl0ZW1zW3NoaXBtZW50Ll9pZF0gfHwgW10pLmNvbmNhdChyZWZ1bmRJdGVtKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjb25zdCBzaGlwbWVudElkc1RvUmVmdW5kID0gT2JqZWN0LmtleXMoc2hpcG1lbnRUb1JlZnVuZEl0ZW1zKTtcclxuXHJcblx0XHRcdHJldHVybiBzaGlwbWVudElkc1RvUmVmdW5kLm1hcChzaGlwbWVudElkID0+IHtcclxuXHJcblx0XHRcdFx0Ly8gQ2xvbmUgZmlyc3QgdG8gYXZvaWQgc2lkZSBlZmZlY3RzXHJcblx0XHRcdFx0Y29uc3Qgc2hpcG1lbnRJdGVtUXVhbnRpdHkgPSAkLmV4dGVuZCh7fSwgc2hpcG1lbnRJdGVtUXVhbnRpdHlNYXBbc2hpcG1lbnRJZF0pO1xyXG5cdFx0XHRcdGNvbnN0IHJlZnVuZEl0ZW1zID0gc2hpcG1lbnRUb1JlZnVuZEl0ZW1zW3NoaXBtZW50SWRdO1xyXG5cclxuXHRcdFx0XHRyZWZ1bmRJdGVtcy5mb3JFYWNoKCh7IGl0ZW0sIHF1YW50aXR5IH0pID0+IHtcclxuXHRcdFx0XHRcdHNoaXBtZW50SXRlbVF1YW50aXR5W2l0ZW0uX2lkXSAtPSBxdWFudGl0eTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0Y29uc3QgYXJlQWxsSXRlbXNSZWZ1bmRlZCA9XHJcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhzaGlwbWVudEl0ZW1RdWFudGl0eSlcclxuXHRcdFx0XHRcdFx0LmV2ZXJ5KGl0ZW1JZCA9PiBzaGlwbWVudEl0ZW1RdWFudGl0eVtpdGVtSWRdID09PSAwKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdHNoaXBtZW50OiBzaGlwbWVudE1hcFtzaGlwbWVudElkXSxcclxuXHRcdFx0XHRcdHNob3VsZFJlZnVuZDogYXJlQWxsSXRlbXNSZWZ1bmRlZCA/XHJcblx0XHRcdFx0XHRcdFx0XHRjYXRlZ29yeS5zaGlwcGluZ0ZlZS5hbGxJdGVtcyA6XHJcblx0XHRcdFx0XHRcdFx0XHRjYXRlZ29yeS5zaGlwcGluZ0ZlZS5zb21lSXRlbXNcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0fSkuZmlsdGVyKCh7IHNoaXBtZW50LCBzaG91bGRSZWZ1bmQgfSkgPT4ge1xyXG5cclxuXHRcdFx0XHQvLyBXaGVuIHRoZSBzaGlwbWVudCBzaG91bGQgYmUgcmVmdW5kZWRcclxuXHRcdFx0XHQvLyBhbmQgaXRzIHJlZnVuZGFibGUgZmVlIGlzIGdyZWF0ZXIgdGhhbiAwXHJcblx0XHRcdFx0cmV0dXJuIHNob3VsZFJlZnVuZCAmJlxyXG5cdFx0XHRcdFx0XHRzaGlwbWVudC5yZWZ1bmRhYmxlRmVlID4gMDtcclxuXHJcblx0XHRcdH0pLm1hcCgoeyBzaGlwbWVudCB9KSA9PiBzaGlwbWVudCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldFJlcXVlc3REZXRhaWwoKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjYXRlZ29yeSA9IGNhdGVnb3J5TWFwWyRyZWZ1bmRDYXRlZ29yeS52YWwoKV07XHJcblx0XHRcdGNvbnN0IGl0ZW1zID0gZ2V0UmVmdW5kSXRlbXMoKTtcclxuXHRcdFx0Y29uc3Qgc2hpcG1lbnRzID0gZ2V0UmVmdW5kU2hpcG1lbnRzKGNhdGVnb3J5LCBpdGVtcykubWFwKHMgPT4gcy5faWQpO1xyXG5cclxuXHRcdFx0aXRlbXMuZm9yRWFjaChkZXRhaWwgPT4gZGV0YWlsLml0ZW0gPSBkZXRhaWwuaXRlbS5faWQpO1xyXG5cclxuXHRcdFx0Y29uc3QgcmVhc29uID0ge1xyXG5cdFx0XHRcdGNhdGVnb3J5OiBjYXRlZ29yeSA/XHJcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5tKGNhdGVnb3J5LmxhYmVsKSA6XHJcblx0XHRcdFx0XHRcdFx0bnVsbCxcclxuXHRcdFx0XHRib2R5OiAgICAgJHJlZnVuZFJlYXNvbi52YWwoKSxcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHJldHVybiB7IGl0ZW1zLCBzaGlwbWVudHMsIHJlYXNvbiB9O1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHZhbGlkYXRlUmVxdWVzdCgpIHtcclxuXHJcblx0XHRcdGNvbnN0IHtcclxuXHRcdFx0XHRpdGVtcyxcclxuXHRcdFx0XHRyZWFzb246IHtcclxuXHRcdFx0XHRcdGNhdGVnb3J5XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ID0gZ2V0UmVxdWVzdERldGFpbCgpO1xyXG5cclxuXHRcdFx0aWYgKCFpdGVtcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBjb250ZXh0Lm0oJ2F0TGVhc3RPbmVJdGVtUmVxdWlyZWQnKSk7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIWNhdGVnb3J5KSB7XHJcblx0XHRcdFx0VGh1bmRlci5ub3RpZnkoJ2Vycm9yJywgY29udGV4dC5tKCdyZWFzb25DYXRlZ29yeVJlcXVpcmVkJykpO1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlcXVlc3RSZWZ1bmQodG9rZW4sIHJlc2V0UmVjYXB0Y2hhKSB7XHJcblxyXG5cdFx0XHRyZXF1ZXN0QnV0dG9uU3Bpbm5lci5ydW4oKTtcclxuXHJcblx0XHRcdGNvbnN0IGRldGFpbCA9IGdldFJlcXVlc3REZXRhaWwoKTtcclxuXHJcblx0XHRcdGRldGFpbC5yZWFzb24gPSBgWyR7ZGV0YWlsLnJlYXNvbi5jYXRlZ29yeX1dICR7ZGV0YWlsLnJlYXNvbi5ib2R5IHx8ICcnfWAudHJpbSgpO1xyXG5cclxuXHRcdFx0Y29uc3QgcmVzZXRTdGF0ZSA9ICgpID0+IHtcclxuXHRcdFx0XHRyZXF1ZXN0QnV0dG9uU3Bpbm5lci5kb25lKCk7XHJcblx0XHRcdFx0cmV0dXJuIHJlc2V0UmVjYXB0Y2hhICYmIHJlc2V0UmVjYXB0Y2hhKCk7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdFx0J2ludmFsaWQtb3JkZXItc3RhdHVzJzogY29udGV4dC5tKCdpbnZhbGlkT3JkZXJTdGF0dXMnKSxcclxuXHRcdFx0XHRkZWZhdWx0OiAgICAgICAgICAgICAgICBjb250ZXh0Lm0oJ3JlcXVlc3RSZWZ1bmRGYWlsZWQnKSxcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogICAgJ1BPU1QnLFxyXG5cdFx0XHRcdHVybDogICAgICAgYC92MS9tZS9vcmRlcnMvJHtvcmRlci5faWR9L3JlZnVuZHNgLFxyXG5cdFx0XHRcdGRhdGE6ICAgICAgZGV0YWlsLFxyXG5cdFx0XHRcdHJlY2FwdGNoYTogdG9rZW4sXHJcblx0XHRcdH0pLnRoZW4ocmVmdW5kID0+IHtcclxuXHJcblx0XHRcdFx0cmVzZXRTdGF0ZSgpO1xyXG5cclxuXHRcdFx0XHRUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25SZXF1ZXN0UmVmdW5kU3VjY2VzcyxcclxuXHRcdFx0XHRcdCRjb250YWluZXIsXHJcblx0XHRcdFx0XHRjb250ZXh0LFxyXG5cdFx0XHRcdFx0cmVmdW5kXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdH0sIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdGVycm9ycyxcclxuXHRcdFx0XHRyZXNldFN0YXRlXHJcblx0XHRcdCkpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xyXG5cclxufTsiLCJjb25zdCBnZXQgPSByZXF1aXJlKCdsb2Rhc2guZ2V0Jyk7XHJcbmNvbnN0IHNldCA9IHJlcXVpcmUoJ2xvZGFzaC5zZXQnKTtcclxuY29uc3QgY2FtZWxDYXNlID0gcmVxdWlyZSgnbG9kYXNoLmNhbWVsY2FzZScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaHVuZGVyID0+IHtcclxuXHJcblx0Y29uc3QgaW1wbGVtZW50YXRpb24gPSB7XHJcblx0XHRuYW1lOiAncGF5bWVudC1mb3JtJ1xyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLm9wdGlvbnMgPSAoKSA9PiAoe1xyXG5cdFx0dHlwZTogJ29yZGVyJywgLy8gJ29yZGVyJyBvciAnc3Vic2NyaXB0aW9uJ1xyXG5cdFx0cGF5bWVudE1ldGhvZHM6IG51bGwsXHJcblx0fSk7XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLnByZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcblxyXG5cdFx0Y29uc3Qge1xyXG5cdFx0XHR0eXBlXHJcblx0XHR9ID0gY29udGV4dC5vcHRpb25zO1xyXG5cclxuXHRcdGNvbnN0IHBheW1lbnRNZXRob2RGaWx0ZXIgPSBjb250ZXh0Lm9wdGlvbnMucGF5bWVudE1ldGhvZHM7XHJcblx0XHRjb25zdCBkZWZhdWx0UGF5bWVudE1ldGhvZHMgPSBUaHVuZGVyLm9wdGlvbnMucGF5bWVudE1ldGhvZHNbdHlwZV0gfHwgW107XHJcblxyXG5cdFx0Y29udGV4dC5wYXltZW50TWV0aG9kcyA9XHJcblx0XHRcdGNvbnRleHQub3B0aW9ucy5wYXltZW50TWV0aG9kcyA/XHJcblx0XHRcdGRlZmF1bHRQYXltZW50TWV0aG9kcy5maWx0ZXIocGF5bWVudE1ldGhvZCA9PiB7XHJcblx0XHRcdFx0cmV0dXJuIHBheW1lbnRNZXRob2RGaWx0ZXIuc29tZShwID0+IHBheW1lbnRNZXRob2QuaWQgPT09IHApO1xyXG5cdFx0XHR9KSA6XHJcblx0XHRcdGRlZmF1bHRQYXltZW50TWV0aG9kcztcclxuXHJcblx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgY29udGV4dCk7XHJcblxyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLmluaXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcblxyXG5cdFx0Y29uc3Qgb3duZXIgPSB7XHJcblx0XHRcdHBlcnNvbjogIHsgbGFiZWw6IGNvbnRleHQubSgnY2FyZE93bmVyQmlydGhkYXRlJyksIGZvcm1hdDogJ1lZTU1ERCcgfSxcclxuXHRcdFx0Y29tcGFueTogeyBsYWJlbDogY29udGV4dC5tKCdjYXJkT3duZXJDb21wYW55TnVtYmVyJyksIGZvcm1hdDogJ1hYWFhYWFhYWFgnIH1cclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgcGF5bWVudE1ldGhvZE1hcCA9XHJcblx0XHRcdFx0Y29udGV4dC5wYXltZW50TWV0aG9kc1xyXG5cdFx0XHRcdFx0LnJlZHVjZSgobywgcCkgPT4gc2V0KG8sIFtgJHtwLmlkfS4ke3AubGFiZWx9YF0sIHApLCB7fSk7XHJcblxyXG5cdFx0Y29uc3QgJGNhcmRGb3JtID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tcGF5bWVudC1jYXJkLWRldGFpbCcpO1xyXG5cdFx0Y29uc3QgJHBheW1lbnRNZXRob2QgPSAkKHRoaXMpLmZpbmQoJ1tuYW1lPVwicGF5bWVudE1ldGhvZFwiXScpO1xyXG5cdFx0Y29uc3QgJGNhcmROdW1iZXIgPSAkKHRoaXMpLmZpbmQoJ1tuYW1lPVwiY2FyZC5udW1iZXJcIl0nKTtcclxuXHRcdGNvbnN0ICRpc0NvbXBhbnlDYXJkID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0taXMtY29tcGFueS1jYXJkIGlucHV0W3R5cGU9XCJjaGVja2JveFwiXScpO1xyXG5cdFx0Y29uc3QgJGNhcmRPd25lckxhYmVsID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tY2FyZC1vd25lciBsYWJlbCcpO1xyXG5cdFx0Y29uc3QgJGNhcmRPd25lcklucHV0ID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tY2FyZC1vd25lciBpbnB1dFt0eXBlPVwidGV4dFwiXScpO1xyXG5cclxuXHRcdCRwYXltZW50TWV0aG9kLm9uKCdjaGFuZ2UnLCBkaXNwbGF5Q2FyZEZvcm0pO1xyXG5cdFx0JGNhcmROdW1iZXIub24oJ2tleXVwJywgbm9ybWFsaXplQ2FyZE51bWJlcik7XHJcblx0XHQkaXNDb21wYW55Q2FyZC5vbignY2hhbmdlJywgZGVjaWRlQ2FyZE93bmVyKTtcclxuXHJcblx0XHRkZWNpZGVDYXJkT3duZXIoKTtcclxuXHJcblx0XHRmdW5jdGlvbiBnZXRQYXltZW50TWV0aG9kSWQoKSB7XHJcblx0XHRcdHJldHVybiAkcGF5bWVudE1ldGhvZC52YWwoKSB8fCBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldFBheW1lbnRNZXRob2QoKSB7XHJcblx0XHRcdHJldHVybiBwYXltZW50TWV0aG9kTWFwW2dldFBheW1lbnRNZXRob2RJZCgpXSB8fCBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldENhcmQoKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwYXltZW50TWV0aG9kID0gZ2V0UGF5bWVudE1ldGhvZCgpO1xyXG5cclxuXHRcdFx0aWYgKCFwYXltZW50TWV0aG9kIHx8ICFwYXltZW50TWV0aG9kLmNhcmRGaWVsZHMpIHtcclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgZGF0YSA9IHt9O1xyXG5cclxuXHRcdFx0JGNhcmRGb3JtLmZpbmQoJ1tuYW1lXScpLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0c2V0KGRhdGEsICQodGhpcykucHJvcCgnbmFtZScpLCAkKHRoaXMpLnZhbCgpIHx8IG51bGwpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGNvbnN0IGNhcmQgPSBkYXRhLmNhcmQ7XHJcblxyXG5cdFx0XHRpZiAoY2FyZCkge1xyXG5cdFx0XHRcdGlmIChjYXJkLm51bWJlcikge1xyXG5cdFx0XHRcdFx0Y2FyZC5udW1iZXIgPSBjYXJkLm51bWJlci5yZXBsYWNlKC9cXHMvZywgJy0nKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBjYXJkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xyXG5cclxuXHRcdFx0Y29uc3QgY2FyZCA9IGdldENhcmQoKTtcclxuXHRcdFx0Y29uc3QgcGF5bWVudE1ldGhvZCA9IGdldFBheW1lbnRNZXRob2QoKTtcclxuXHJcblx0XHRcdGlmICghcGF5bWVudE1ldGhvZCkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBjb2RlID0gJ3BheW1lbnRNZXRob2RSZXF1aXJlZCc7XHJcblx0XHRcdFx0Y29uc3QgZXJyID0gbmV3IEVycm9yKGNvbnRleHQubShjb2RlKSk7XHJcblxyXG5cdFx0XHRcdGVyci5jb2RlID0gY29kZTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGVycjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCFwYXltZW50TWV0aG9kLmNhcmRGaWVsZHMpIHtcclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVmFsaWRhdGUgaWYgdGhlIHBheW1lbnQgbWV0aG9kIHJlcXVpcmVzIG1hbnVhbCBjYXJkIGlucHV0c1xyXG5cclxuXHRcdFx0Y29uc3QgZmllbGRzID0gJGNhcmRGb3JtLmZpbmQoJ1tuYW1lXScpLm1hcChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gJCh0aGlzKS5wcm9wKCduYW1lJyk7XHJcblx0XHRcdH0pLmdldCgpO1xyXG5cclxuXHRcdFx0Zm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBnZXQoY2FyZCwgZmllbGQucmVwbGFjZSgnY2FyZC4nLCAnJykpO1xyXG5cclxuXHRcdFx0XHRpZiAodmFsdWUpIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRjb25zdCBjb2RlID0gY2FtZWxDYXNlKFtmaWVsZCwgJ3JlcXVpcmVkJ10pO1xyXG5cdFx0XHRcdGNvbnN0IGVyciA9IG5ldyBFcnJvcihjb250ZXh0Lm0oY29kZSkpO1xyXG5cclxuXHRcdFx0XHRlcnIuY29kZSA9IGNvZGU7XHJcblxyXG5cdFx0XHRcdHJldHVybiBlcnI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBub3JtYWxpemVDYXJkTnVtYmVyKCkge1xyXG5cclxuXHRcdFx0Y29uc3QgdmFsdWUgPSAoJCh0aGlzKS52YWwoKSB8fCAnJylcclxuXHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvW15cXGRdL2csICcnKTtcclxuXHJcblx0XHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBbMCwgMSwgMiwgM10ucmVkdWNlKChudW1iZXJzLCBpKSA9PiB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBudW1iZXJzLmNvbmNhdCh2YWx1ZS5zbGljZShpICogNCwgKGkgKyAxKSAqIDQpKTtcclxuXHJcblx0XHRcdH0sIFtdKTtcclxuXHJcblx0XHRcdCQodGhpcykudmFsKG5vcm1hbGl6ZWQuZmlsdGVyKHYgPT4gdikuam9pbignICcpKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZGVjaWRlQ2FyZE93bmVyKCkge1xyXG5cclxuXHRcdFx0Y29uc3QgaXNDb21wYW55Q2FyZCA9ICRpc0NvbXBhbnlDYXJkLmlzKCc6Y2hlY2tlZCcpO1xyXG5cdFx0XHRjb25zdCB7XHJcblx0XHRcdFx0bGFiZWwsXHJcblx0XHRcdFx0Zm9ybWF0XHJcblx0XHRcdH0gPSBpc0NvbXBhbnlDYXJkID8gb3duZXIuY29tcGFueSA6IG93bmVyLnBlcnNvbjtcclxuXHJcblx0XHRcdCRjYXJkT3duZXJMYWJlbC50ZXh0KGxhYmVsKTtcclxuXHRcdFx0JGNhcmRPd25lcklucHV0LnByb3AoJ3BsYWNlaG9sZGVyJywgZm9ybWF0KTtcclxuXHJcblx0XHRcdC8vIFJlc2V0IGNhcmQgb3duZXIgaW5wdXQncyB2YWx1ZVxyXG5cdFx0XHQkY2FyZE93bmVySW5wdXQudmFsKCcnKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVzZXRDYXJkKCkge1xyXG5cclxuXHRcdFx0Ly8gUmVzZXQgYWxsIGlucHV0IHZhbHVlc1xyXG5cdFx0XHQkY2FyZEZvcm0uZmluZCgnaW5wdXQnKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gJCh0aGlzKS5pcygnW3R5cGU9XCJjaGVja2JveFwiXScpID9cclxuXHRcdFx0XHRcdFx0JCh0aGlzKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpIDpcclxuXHRcdFx0XHRcdFx0JCh0aGlzKS52YWwoJycpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGRlY2lkZUNhcmRPd25lcigpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBkaXNwbGF5Q2FyZEZvcm0oKSB7XHJcblxyXG5cdFx0XHQvLyBSZXNldCBhbGwgaW5wdXQgdmFsdWVzXHJcblx0XHRcdHJlc2V0Q2FyZCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgcGF5bWVudE1ldGhvZCA9IGdldFBheW1lbnRNZXRob2QoKTtcclxuXHJcblx0XHRcdHJldHVybiBwYXltZW50TWV0aG9kLmNhcmRGaWVsZHMgP1xyXG5cdFx0XHRcdFx0JGNhcmRGb3JtLnNob3coKSA6XHJcblx0XHRcdFx0XHQkY2FyZEZvcm0uaGlkZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIG1ha2VQYXltZW50KHsgY2FydCwgb3JkZXIsIHN1YnNjcmlwdGlvbiwgY3VzdG9tZXIgfSwgY2FsbGJhY2spIHtcclxuXHJcblx0XHRcdGNvbnN0IHBheW1lbnRNZXRob2QgPSBnZXRQYXltZW50TWV0aG9kKCk7XHJcblxyXG5cdFx0XHRpZiAoIXBheW1lbnRNZXRob2QpIHtcclxuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKGNvbnRleHQubSgncGF5bWVudE1ldGhvZFJlcXVpcmVkJykpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHBheW1lbnRNZXRob2QucGF5TGF0ZXIpIHtcclxuXHRcdFx0XHQvLyBJZiBhIHBheW1lbnQgaXMgdG8gYmUgbWFkZSBhZnRlciBhbGwgY2hlY2tvdXQgcHJvY2Vzc2VzLFxyXG5cdFx0XHRcdC8vIHNpbXBseSBmaW5pc2ggY2hlY2tvdXQgcHJvY2Vzc2VzLlxyXG5cdFx0XHRcdHJldHVybiBjYWxsYmFjaygpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5wbHVnaW5zLm1ha2VQYXltZW50KHtcclxuXHRcdFx0XHRwYXltZW50TWV0aG9kLFxyXG5cdFx0XHRcdGNhcnQsXHJcblx0XHRcdFx0b3JkZXIsXHJcblx0XHRcdFx0c3Vic2NyaXB0aW9uLFxyXG5cdFx0XHRcdGN1c3RvbWVyLFxyXG5cdFx0XHR9LCBlcnIgPT4gY2FsbGJhY2soZXJyKSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJldHVybiBpbnRlcmZhY2VzXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRnZXRQYXltZW50TWV0aG9kSWQsXHJcblx0XHRcdGdldFBheW1lbnRNZXRob2QsXHJcblx0XHRcdGdldENhcmQsXHJcblx0XHRcdHJlc2V0Q2FyZCxcclxuXHRcdFx0dmFsaWRhdGUsXHJcblx0XHRcdG1ha2VQYXltZW50XHJcblx0XHR9O1xyXG5cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XHJcblxyXG59OyIsImNvbnN0IHNldCA9IHJlcXVpcmUoJ2xvZGFzaC5zZXQnKTtcclxuY29uc3QgcHJvZHVjdENhdGFsb2cgPSByZXF1aXJlKCcuL2xpYi9wcm9kdWN0Q2F0YWxvZy5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaHVuZGVyID0+IHtcclxuXHJcblx0Y29uc3QgaW1wbGVtZW50YXRpb24gPSB7XHJcblx0XHRuYW1lOiAncHJvZHVjdC1kZXRhaWwnXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ub3B0aW9ucyA9ICgpID0+ICh7XHJcblx0XHRwcm9kdWN0OiAgICAgICAgICAnJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9kdWN0IElEIHRvIHJlbmRlclxyXG5cdFx0cHJvZHVjdEFjdGlvbnM6ICAgVGh1bmRlci5vcHRpb25zLnByb2R1Y3RBY3Rpb25zLCAgICAgICAgLy8gWydhZGQtdG8tY2FydCcsICdidXktbm93J10sXHJcblx0XHRvcHRpb25TZWxlY3RvcjogICBUaHVuZGVyLm9wdGlvbnMucHJvZHVjdE9wdGlvblNlbGVjdG9yLCAvLyAnY29tYmluZWQnIHx8ICdzZXBhcmF0ZWQnXHJcblx0XHRkZXNjcmlwdGlvblN0eWxlOiAnZGV0YWlsZWQnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnc2ltcGxlJyB8fCAnZGV0YWlsZWQnXHJcblx0XHR1c2VGb2xsb3dpbmdOYXY6ICB0cnVlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgZm9sbG93aW5nIG5hdmlnYXRpb24/XHJcblx0XHR1c2VSZXZpZXdzOiAgICAgICBUaHVuZGVyLm9wdGlvbnMucHJvZHVjdFJldmlldywgICAgICAgICAvLyBVc2UgcmV2aWV3cz9cclxuXHRcdHVzZVJhdGluZzogICAgICAgICggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSByZXZpZXcgcmF0aW5nP1xyXG5cdFx0XHRUaHVuZGVyLm9wdGlvbnMucHJvZHVjdFJldmlldyAmJlxyXG5cdFx0XHRUaHVuZGVyLm9wdGlvbnMucHJvZHVjdFJldmlld1JhdGluZ1xyXG5cdFx0KSxcclxuXHJcblx0XHRvbkJ1eU5vdzogZnVuY3Rpb24oJGNvbnRhaW5lciwgY29udGV4dCwgaXRlbSkge1xyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZW5kZXIoJGNvbnRhaW5lciwgJ2NhcnQnLCB7IGl0ZW1zOiBbaXRlbS5faWRdIH0pO1xyXG5cdFx0fSxcclxuXHRcdG9uSXRlbUFkZDogZnVuY3Rpb24oJGNvbnRhaW5lciwgY29udGV4dCkge1xyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5ub3RpZnkoJ3N1Y2Nlc3MnLCBjb250ZXh0Lm0oJ2l0ZW1BZGRTdWNjZXNzJykpO1xyXG5cdFx0fSxcclxuXHRcdG9uR29Ub0NhcnQ6IGZ1bmN0aW9uKCRjb250YWluZXIsIGNvbnRleHQpIHtcclxuXHRcdFx0cmV0dXJuIFRodW5kZXIucmVuZGVyKCRjb250YWluZXIsICdjYXJ0Jyk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLnByZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcblxyXG5cdFx0Y29udGV4dC5vcHRpb25zLnByb2R1Y3RBY3Rpb25zID0gVGh1bmRlci51dGlsLnBhcnNlQXJyYXlTdHJpbmcoY29udGV4dC5vcHRpb25zLnByb2R1Y3RBY3Rpb25zKTtcclxuXHJcblx0XHRjb25zdCB7IHByb2R1Y3QgfSA9IGNvbnRleHQub3B0aW9ucztcclxuXHJcblx0XHRjb250ZXh0LmlzVW5hdmFpbGFibGVQcm9kdWN0ID0gcHJvZHVjdCA9PiB7XHJcblxyXG5cdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdC8vIEEgcHJvZHVjdCBpcyB1bmF2YWlsYWJsZVxyXG5cdFx0XHRcdCFwcm9kdWN0LmF2YWlsYWJsZSB8fFxyXG5cdFx0XHRcdChcclxuXHRcdFx0XHRcdHByb2R1Y3QudmFyaWFudHMgJiYgLy8gV2hpbGUgYSBwcm9kdWN0IGhhcyB2YXJpYW50cyBhcnJheVxyXG5cdFx0XHRcdFx0KFxyXG5cdFx0XHRcdFx0XHQvLyBBIHByb2R1Y3QgZG9lc24ndCBoYXZlIGFueSB2YXJpYW50c1xyXG5cdFx0XHRcdFx0XHQhcHJvZHVjdC52YXJpYW50cy5sZW5ndGggfHxcclxuXHRcdFx0XHRcdFx0Ly8gQWxsIHZhcmlhbnRzIGFyZSB1bmF2YWlsYWJsZVxyXG5cdFx0XHRcdFx0XHRwcm9kdWN0LnZhcmlhbnRzLmV2ZXJ5KHYgPT4gIXYuYXZhaWxhYmxlKVxyXG5cdFx0XHRcdFx0KVxyXG5cdFx0XHRcdCkgfHxcclxuXHRcdFx0XHQvLyBBIHRhbmdpYmxlIHByb2R1Y3QgZG9lc24ndCBzdXBwb3J0IGFueSBzaGlwcGluZyBtZXRob2RzXHJcblx0XHRcdFx0KFxyXG5cdFx0XHRcdFx0cHJvZHVjdC50eXBlID09PSAndGFuZ2libGUnICYmXHJcblx0XHRcdFx0XHRwcm9kdWN0LnNoaXBwaW5nLm1ldGhvZHMubGVuZ3RoID09PSAwXHJcblx0XHRcdFx0KVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0Y29udGV4dC5pc1NvbGRPdXRQcm9kdWN0ID0gcHJvZHVjdCA9PiB7XHJcblx0XHRcdHJldHVybiBwcm9kdWN0LnZhcmlhbnRzLmV2ZXJ5KHYgPT4gdi5xdWFudGl0eSAmJiB2LnF1YW50aXR5LnJhdyA9PT0gMCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnRleHQuaXNVbmF2YWlsYWJsZVZhcmlhbnQgPSAocHJvZHVjdCwgdmFyaWFudCkgPT4ge1xyXG5cclxuXHRcdFx0aWYgKGNvbnRleHQuaXNVbmF2YWlsYWJsZVByb2R1Y3QocHJvZHVjdCkgfHxcclxuXHRcdFx0XHQhdmFyaWFudC5hdmFpbGFibGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gJ25vdEF2YWlsYWJsZVZhcmlhbnQnO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodmFyaWFudC5xdWFudGl0eSAmJlxyXG5cdFx0XHRcdHZhcmlhbnQucXVhbnRpdHkucmF3ID09PSAwKSB7XHJcblx0XHRcdFx0cmV0dXJuICdzb2xkT3V0VmFyaWFudCc7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnRleHQuc2hvd09wdGlvblNlbGVjdG9yID0gKCkgPT4ge1xyXG5cdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdGNvbnRleHQub3B0aW9ucy5vcHRpb25TZWxlY3RvciA9PT0gJ3NlcGFyYXRlZCcgJiZcclxuXHRcdFx0XHRjb250ZXh0LnByb2R1Y3Qub3B0aW9ucy5sZW5ndGggPj0gMiAmJlxyXG5cdFx0XHRcdGNvbnRleHQucHJvZHVjdC52YXJpYW50cy5sZW5ndGggPj0gMlxyXG5cdFx0XHQpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdCdub3QtZXhpc3RpbmctcHJvZHVjdCc6IGNvbnRleHQubSgnbm90RXhpc3RpbmdQcm9kdWN0JyksXHJcblx0XHRcdGRlZmF1bHQ6ICAgICAgICAgICAgICAgIGNvbnRleHQubSgncHJvZHVjdFJlYWRGYWlsZWQnKVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0bWV0aG9kOiAnR0VUJyxcclxuXHRcdFx0dXJsOiAgICBgL3YxL3Byb2R1Y3RzLyR7cHJvZHVjdH1gLFxyXG5cdFx0XHRxdWVyeTogIHtcclxuXHRcdFx0XHRlbWJlZDogJytidW5kbGVzLml0ZW1zLnByb2R1Y3Quc2hpcHBpbmcnXHJcblx0XHRcdH1cclxuXHRcdH0pLnRoZW4oKHByb2R1Y3QsIHRleHRTdGF0dXMsIGpxWEhSKSA9PiB7XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci51dGlsLmdldEN1cnJlbmN5KGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LWN1cnJlbmN5JykpLnRoZW4oY3VycmVuY3kgPT4ge1xyXG5cclxuXHRcdFx0XHRjb250ZXh0LmN1cnJlbmN5ID0gY3VycmVuY3k7XHJcblx0XHRcdFx0Y29udGV4dC5wcm9kdWN0ID0gbW92ZVVuYXZhaWxhYmxlc1RvRW5kKHByb2R1Y3QpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgY29udGV4dCk7XHJcblxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIG1vdmVVbmF2YWlsYWJsZXNUb0VuZChwcm9kdWN0KSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IG9rVmFyaWFudHMgPSBbXTtcclxuXHRcdFx0XHRjb25zdCBub3RPa1ZhcmlhbnRzID0gW107XHJcblxyXG5cdFx0XHRcdHByb2R1Y3QudmFyaWFudHMuZm9yRWFjaCh2YXJpYW50ID0+IHtcclxuXHRcdFx0XHRcdHJldHVybiBjb250ZXh0LmlzVW5hdmFpbGFibGVWYXJpYW50KHByb2R1Y3QsIHZhcmlhbnQpID9cclxuXHRcdFx0XHRcdFx0XHRub3RPa1ZhcmlhbnRzLnB1c2godmFyaWFudCkgOlxyXG5cdFx0XHRcdFx0XHRcdG9rVmFyaWFudHMucHVzaCh2YXJpYW50KTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0cHJvZHVjdC52YXJpYW50cyA9IFtdLmNvbmNhdChva1ZhcmlhbnRzLCBub3RPa1ZhcmlhbnRzKTtcclxuXHJcblx0XHRcdFx0cHJvZHVjdC5idW5kbGVzLmZvckVhY2goYnVuZGxlID0+IHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBva0l0ZW1zID0gW107XHJcblx0XHRcdFx0XHRjb25zdCBub3RPa0l0ZW1zID0gW107XHJcblxyXG5cdFx0XHRcdFx0YnVuZGxlLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBjb250ZXh0LmlzVW5hdmFpbGFibGVWYXJpYW50KGl0ZW0ucHJvZHVjdCwgaXRlbS52YXJpYW50KSA/XHJcblx0XHRcdFx0XHRcdFx0XHRub3RPa0l0ZW1zLnB1c2goaXRlbSkgOlxyXG5cdFx0XHRcdFx0XHRcdFx0b2tJdGVtcy5wdXNoKGl0ZW0pO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdFx0YnVuZGxlLml0ZW1zID0gW10uY29uY2F0KG9rSXRlbXMsIG5vdE9rSXRlbXMpO1xyXG5cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHByb2R1Y3Q7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRlcnJvcnMsXHJcblx0XHRcdGNhbGxiYWNrXHJcblx0XHQpKTtcclxuXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24uYmluZCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuXHJcblx0XHRjb25zdCAkY29udGFpbmVyID0gJCh0aGlzKTtcclxuXHRcdGNvbnN0ICRmb2xsb3dpbmdOYXYgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1mb2xsb3dpbmctbmF2LWNvbnRhaW5lcicpO1xyXG5cclxuXHRcdFRodW5kZXIudXRpbC5mb2xsb3dpbmdOYXZpZ2F0aW9uKCRmb2xsb3dpbmdOYXYsIGNvbnRleHQub3B0aW9ucy51c2VGb2xsb3dpbmdOYXYsIFtcclxuXHRcdFx0e1xyXG5cdFx0XHRcdG5hbWU6IGNvbnRleHQubSgncHJvZHVjdEluZm8nKSxcclxuXHRcdFx0XHQkZWw6ICAkY29udGFpbmVyLmZpbmQoJy50aHVuZGVyLS1wcm9kdWN0LWRldGFpbCcpXHJcblx0XHRcdH0sXHJcblx0XHRcdGNvbnRleHQub3B0aW9ucy51c2VSZXZpZXdzID8ge1xyXG5cdFx0XHRcdG5hbWU6IFtcclxuXHRcdFx0XHRcdGNvbnRleHQubSgncHJvZHVjdFJldmlld3MnKSxcclxuXHRcdFx0XHRcdGA8c3BhbiBjbGFzcz1cInRodW5kZXItLXByb2R1Y3QtdG90YWwtY29tbWVudHNcIj4oJHtjb250ZXh0LnByb2R1Y3QudG90YWxSZXZpZXcuY29udmVydGVkfSk8L3NwYW4+YCxcclxuXHRcdFx0XHRdLmpvaW4oJyAnKSxcclxuXHRcdFx0XHQkZWw6ICAkY29udGFpbmVyLmZpbmQoJy50aHVuZGVyLS1wcm9kdWN0LXJldmlld3Mtd3JhcHBlcicpXHJcblx0XHRcdH0gOiBudWxsLFxyXG5cdFx0XS5maWx0ZXIodiA9PiB2KSk7XHJcblxyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLmluaXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcblxyXG5cdFx0Y29uc3QgcHJvZHVjdCA9IGNvbnRleHQucHJvZHVjdDtcclxuXHJcblx0XHRjb25zdCB2YXJpYW50TWFwID0gW10uY29uY2F0KFxyXG5cdFx0XHRjb250ZXh0LnByb2R1Y3QudmFyaWFudHMsXHJcblx0XHRcdGNvbnRleHQucHJvZHVjdC5idW5kbGVzLnJlZHVjZSgodmFyaWFudHMsIGJ1bmRsZSkgPT4ge1xyXG5cdFx0XHRcdHJldHVybiBidW5kbGUuaXRlbXMucmVkdWNlKCh2YXJpYW50cywgaXRlbSkgPT4ge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHZhcmlhbnRzLmNvbmNhdChpdGVtLnZhcmlhbnQpO1xyXG5cdFx0XHRcdH0sIHZhcmlhbnRzKTtcclxuXHRcdFx0fSwgW10pXHJcblx0XHQpLnJlZHVjZSgobywgdmFyaWFudCkgPT4ge1xyXG5cdFx0XHRyZXR1cm4gc2V0KG8sIHZhcmlhbnQuX2lkLCB2YXJpYW50KTtcclxuXHRcdH0sIHt9KTtcclxuXHJcblx0XHRjb25zdCBidW5kbGVQcm9kdWN0TWFwID0gY29udGV4dC5wcm9kdWN0LmJ1bmRsZXMucmVkdWNlKChvLCBidW5kbGUpID0+IHtcclxuXHRcdFx0cmV0dXJuIGJ1bmRsZS5pdGVtcy5yZWR1Y2UoKG8sIGl0ZW0pID0+IHNldChvLCBpdGVtLnByb2R1Y3QuX2lkLCBpdGVtLnByb2R1Y3QpLCBvKTtcclxuXHRcdH0sIHt9KTtcclxuXHJcblx0XHRjb25zdCB2YXJpYW50VG9CdW5kbGVNYXAgPSBjb250ZXh0LnByb2R1Y3QuYnVuZGxlcy5yZWR1Y2UoKG8sIGJ1bmRsZSkgPT4ge1xyXG5cdFx0XHRyZXR1cm4gYnVuZGxlLml0ZW1zLnJlZHVjZSgobywgaXRlbSkgPT4ge1xyXG5cdFx0XHRcdHJldHVybiBzZXQobywgaXRlbS52YXJpYW50Ll9pZCwgYnVuZGxlKTtcclxuXHRcdFx0fSwgbyk7XHJcblx0XHR9LCB7fSk7XHJcblxyXG5cdFx0Y29uc3QgJGNvbnRhaW5lciA9ICQodGhpcyk7XHJcblx0XHRjb25zdCAkb3B0aW9uU2VsZWN0ID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tcHJvZHVjdC1vcHRpb24td3JhcCBzZWxlY3QnKTtcclxuXHRcdGNvbnN0ICR2YXJpYW50U2VsZWN0b3IgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1wcm9kdWN0LWluZm8gLnRodW5kZXItLXByb2R1Y3Qtb3B0aW9uIC50aHVuZGVyLS1wcm9kdWN0LXZhcmlhbnQgc2VsZWN0Jyk7XHJcblx0XHRjb25zdCAkc2hpcHBpbmdNZXRob2RTZWxlY3RvciA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXNoaXBwaW5nLW1ldGhvZCBzZWxlY3QnKTtcclxuXHRcdGNvbnN0ICRpdGVtUXVhbnRpdHlJbnB1dCA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWl0ZW0tcXVhbnRpdHkgaW5wdXQnKTtcclxuXHRcdGNvbnN0ICRidW5kbGVJdGVtcyA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXByb2R1Y3QtYnVuZGxlLWl0ZW0nKTtcclxuXHRcdGNvbnN0ICRidW5kbGVJdGVtU2VsZWN0b3JzID0gJGJ1bmRsZUl0ZW1zLmZpbmQoJ3NlbGVjdCcpO1xyXG5cdFx0Y29uc3QgJHRvdGFsV3JhcCA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXByaWNlLXRvdGFsLXdyYXAnKTtcclxuXHRcdGNvbnN0ICR0b3RhbFZhbHVlID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tcHJpY2UtdG90YWwtdmFsdWUnKTtcclxuXHRcdGNvbnN0ICRhZGRUb0NhcnQgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1hZGQtdG8tY2FydCcpO1xyXG5cdFx0Y29uc3QgJGJ1eU5vdyA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWJ1eS1ub3cnKTtcclxuXHRcdGNvbnN0ICRnb1RvQ2FydCA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWdvLXRvLWNhcnQnKTtcclxuXHJcblx0XHRjb25zdCB2YXJpYXRpb25Ub1ZhcmlhbnRzID0gY29udGV4dC5wcm9kdWN0LnZhcmlhbnRzLnJlZHVjZSgobywgdikgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3Qga2V5ID0gdi50eXBlcy5tYXAodHlwZSA9PiB0eXBlLnZhcmlhdGlvbi5faWQpLnNvcnQoKS5qb2luKCcuJyk7XHJcblxyXG5cdFx0XHRyZXR1cm4gc2V0KG8sIFtrZXldLCB2Ll9pZCk7XHJcblxyXG5cdFx0fSwge30pO1xyXG5cclxuXHRcdGNvbnN0IGFkZFRvQ2FydFNwaW5uZXIgPSBUaHVuZGVyLnV0aWwubWFrZUFzeW5jQnV0dG9uKCRhZGRUb0NhcnQpO1xyXG5cclxuXHRcdHByb2R1Y3RDYXRhbG9nKCRjb250YWluZXIpO1xyXG5cclxuXHRcdCRidW5kbGVJdGVtU2VsZWN0b3JzLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdGNvbnN0IHZhbHVlID0gJCh0aGlzKS52YWwoKTtcclxuXHRcdFx0Y29uc3QgJHF1YW50aXR5ID0gJCh0aGlzKS5jbG9zZXN0KCcudGh1bmRlci0tcHJvZHVjdC1idW5kbGUtaXRlbScpLmZpbmQoJ2lucHV0W3R5cGU9XCJudW1iZXJcIl0nKTtcclxuXHJcblx0XHRcdCRxdWFudGl0eS52YWwodmFsdWUgPyAxIDogMCk7XHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y29uc3QgY2FsY3VsYXRlUHJpY2UgPSAoKSA9PiB7XHJcblxyXG5cdFx0XHRjb25zdCBpdGVtID0gYnVpbGRJdGVtRGF0YSgpO1xyXG5cclxuXHRcdFx0aWYgKCFpdGVtIHx8ICFpdGVtLnZhcmlhbnQgfHwgIWl0ZW0ucXVhbnRpdHkpIHtcclxuXHRcdFx0XHRyZXR1cm4gJHRvdGFsV3JhcC5oaWRlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHByaWNlID0gW10uY29uY2F0KGl0ZW0sIGl0ZW0uYnVuZGxlSXRlbXMgfHwgW10pLm1hcChpdGVtID0+IHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdmFyaWFudCA9IHZhcmlhbnRNYXBbaXRlbS52YXJpYW50XTtcclxuXHRcdFx0XHRjb25zdCBxdWFudGl0eSA9IGl0ZW0ucXVhbnRpdHk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB2YXJpYW50ICYmIHF1YW50aXR5ID8gdmFyaWFudC5wcmljZS5zYWxlLnJhdyAqIHF1YW50aXR5IDogMDtcclxuXHJcblx0XHRcdH0pLnJlZHVjZSgoc3VtLCBwcmljZSkgPT4gc3VtICsgcHJpY2UsIDApO1xyXG5cclxuXHRcdFx0JHRvdGFsVmFsdWUudGV4dChUaHVuZGVyLnV0aWwuZm9ybWF0UHJpY2UocHJpY2UsIGNvbnRleHQuY3VycmVuY3kpKTtcclxuXHJcblx0XHRcdHJldHVybiBwcmljZSA/ICR0b3RhbFdyYXAuZmFkZUluKDQwMCkgOiAkdG90YWxXcmFwLmhpZGUoKTtcclxuXHRcdH07XHJcblxyXG5cdFx0JHZhcmlhbnRTZWxlY3Rvci5vbignY2hhbmdlJywgZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHRjb25zdCB2YXJpYW50ID0gdmFyaWFudE1hcFskKHRoaXMpLnZhbCgpXTtcclxuXHJcblx0XHRcdGlmICghdmFyaWFudCkgcmV0dXJuO1xyXG5cclxuXHRcdFx0dmFyaWFudC50eXBlcy5mb3JFYWNoKCh7IG9wdGlvbiwgdmFyaWF0aW9uIH0pID0+IHtcclxuXHRcdFx0XHQkb3B0aW9uU2VsZWN0LmZpbHRlcihgW25hbWU9XCIke29wdGlvbi5faWR9XCJdYCkudmFsKHZhcmlhdGlvbi5faWQpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyDsmLXshZgg7ISg7YOdIOydtOuypO2KuCAoJ3NlcGFyYXRlZCcpXHJcblx0XHQkb3B0aW9uU2VsZWN0Lm9uKCdjaGFuZ2UnLCAoKSA9PiB7XHJcblxyXG5cdFx0XHRjb25zdCB2YXJpYXRpb25zID0gJG9wdGlvblNlbGVjdC5tYXAoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuICQodGhpcykudmFsKCk7XHJcblx0XHRcdH0pLmdldCgpLnNvcnQoKTtcclxuXHJcblx0XHRcdGNvbnN0IGtleSA9IHZhcmlhdGlvbnMuam9pbignLicpO1xyXG5cclxuXHRcdFx0Y29uc3QgdmFsdWUgPSB2YXJpYXRpb25Ub1ZhcmlhbnRzW2tleV0gfHwgbnVsbDtcclxuXHJcblx0XHRcdGlmICghdmFsdWUgJiYgdmFyaWF0aW9ucy5sZW5ndGggPT09ICRvcHRpb25TZWxlY3QubGVuZ3RoKSB7XHJcblx0XHRcdFx0JHRvdGFsV3JhcC5oaWRlKCk7XHJcblx0XHRcdFx0JHRvdGFsVmFsdWUudGV4dCgnJyk7XHJcblx0XHRcdFx0VGh1bmRlci5ub3RpZnkoJ2Vycm9yJywgY29udGV4dC5tKCdub3RFeGlzdGluZ1ZhcmlhbnQnKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiAkdmFyaWFudFNlbGVjdG9yLnZhbCgpID09PSB2YWx1ZSA/IG51bGwgOiAkdmFyaWFudFNlbGVjdG9yLnZhbCh2YWx1ZSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQkY29udGFpbmVyLmZpbmQoJ2lucHV0LHNlbGVjdCcpLm9uKCdjaGFuZ2UnLCBjYWxjdWxhdGVQcmljZSk7XHJcblxyXG5cdFx0JGFkZFRvQ2FydC5vbignY2xpY2snLCAoKSA9PiBhZGRUb0NhcnQoKSk7XHJcblxyXG5cdFx0JGJ1eU5vdy5vbignY2xpY2snLCAoKSA9PiBhZGRUb0NhcnQoaXRlbSA9PiBUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdGNvbnRleHQub3B0aW9ucy5vbkJ1eU5vdyxcclxuXHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0Y29udGV4dCxcclxuXHRcdFx0aXRlbVxyXG5cdFx0KSkpO1xyXG5cclxuXHRcdCRnb1RvQ2FydC5vbignY2xpY2snLCAoKSA9PiBUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdGNvbnRleHQub3B0aW9ucy5vbkdvVG9DYXJ0LFxyXG5cdFx0XHQkY29udGFpbmVyLFxyXG5cdFx0XHRjb250ZXh0XHJcblx0XHQpKTtcclxuXHJcblx0XHRpZiAoY29udGV4dC5vcHRpb25zLnVzZVJldmlld3MpIHtcclxuXHJcblx0XHRcdGNvbnN0ICRyZXZpZXdzQ29udGFpbmVyID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tcHJvZHVjdC1yZXZpZXdzLXdyYXBwZXInKTtcclxuXHJcblx0XHRcdFRodW5kZXIucmVuZGVyKCRyZXZpZXdzQ29udGFpbmVyLCAncHJvZHVjdC1yZXZpZXdzJywge1xyXG5cdFx0XHRcdHByb2R1Y3Q6ICAgICAgIGNvbnRleHQucHJvZHVjdC5faWQsXHJcblx0XHRcdFx0cHJvZHVjdFJhdGluZzogY29udGV4dC5vcHRpb25zLnVzZVJhdGluZyA/XHJcblx0XHRcdFx0XHRcdFx0XHRwcm9kdWN0LnJhdGluZyA6XHJcblx0XHRcdFx0XHRcdFx0XHRudWxsLFxyXG5cdFx0XHRcdHVzZVJhdGluZzogICAgIGNvbnRleHQub3B0aW9ucy51c2VSYXRpbmcsXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjbGVhckFsbE9wdGlvbnMoKSB7XHJcblx0XHRcdCR0b3RhbFdyYXAuaGlkZSgpO1xyXG5cdFx0XHQkdG90YWxWYWx1ZS50ZXh0KCcnKTtcclxuXHRcdFx0JGNvbnRhaW5lci5maW5kKCcudGh1bmRlci0tcHJvZHVjdC1vcHRpb24gc2VsZWN0JykudmFsKCcnKTtcclxuXHRcdFx0JGNvbnRhaW5lci5maW5kKCcudGh1bmRlci0tcHJvZHVjdC1vcHRpb24gaW5wdXRbdHlwZT1cIm51bWJlclwiXScpLnZhbCgxKTtcclxuXHRcdFx0JGNvbnRhaW5lci5maW5kKCcudGh1bmRlci0tcHJvZHVjdC1idW5kbGVzIHNlbGVjdCcpLnZhbCgnJyk7XHJcblx0XHRcdCRjb250YWluZXIuZmluZCgnLnRodW5kZXItLXByb2R1Y3QtYnVuZGxlcyBpbnB1dFt0eXBlPVwibnVtYmVyXCJdJykudmFsKDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGFkZFRvQ2FydChzdWNjZXNzKSB7XHJcblx0XHRcdGNvbnN0IGl0ZW0gPSBidWlsZEl0ZW1EYXRhKCk7XHJcblxyXG5cdFx0XHRzdWNjZXNzID0gc3VjY2VzcyB8fCAoKCkgPT4ge1xyXG5cclxuXHRcdFx0XHQkZ29Ub0NhcnQuc2hvdygpO1xyXG5cclxuXHRcdFx0XHRUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25JdGVtQWRkLFxyXG5cdFx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdGNvbnRleHRcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRpZiAoIXZhbGlkYXRlSXRlbURhdGEoaXRlbSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gYWRkVG9DYXJ0U3Bpbm5lci5kb25lKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHQnaXRlbXMtZXhjZWVkZWQnOiBjb250ZXh0Lm0oJ2l0ZW1zRXhjZWVkZWQnKSxcclxuXHRcdFx0XHRkZWZhdWx0OiAgICAgICAgICBjb250ZXh0Lm0oJ2l0ZW1BZGRGYWlsZWQnKSxcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGlmIChUaHVuZGVyLmF1dGhlbnRpY2F0ZWQoKSkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRcdG1ldGhvZDogJ1BPU1QnLFxyXG5cdFx0XHRcdFx0dXJsOiAgICAnL3YxL21lL2NhcnQvaXRlbXMnLFxyXG5cdFx0XHRcdFx0ZGF0YTogICBpdGVtXHJcblx0XHRcdFx0fSkudGhlbihpdGVtID0+IHtcclxuXHRcdFx0XHRcdGFkZFRvQ2FydFNwaW5uZXIuZG9uZSgpO1xyXG5cdFx0XHRcdFx0Y2xlYXJBbGxPcHRpb25zKCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gc3VjY2VzcyhpdGVtKTtcclxuXHRcdFx0XHR9LCBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdFx0ZXJyb3JzLFxyXG5cdFx0XHRcdFx0ZXJyID0+IGFkZFRvQ2FydFNwaW5uZXIuZG9uZSgpXHJcblx0XHRcdFx0KSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRUaHVuZGVyLkNhcnQuYWRkSXRlbShpdGVtLCBlcnIgPT4ge1xyXG5cclxuXHRcdFx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRcdFx0YWRkVG9DYXJ0U3Bpbm5lci5kb25lKCk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBlcnJvcnNbZXJyLmNvZGUgfHwgJ2RlZmF1bHQnXSB8fCBlcnJvcnMuZGVmYXVsdCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YWRkVG9DYXJ0U3Bpbm5lci5kb25lKCk7XHJcblx0XHRcdFx0XHRjbGVhckFsbE9wdGlvbnMoKTtcclxuXHRcdFx0XHRcdHJldHVybiBzdWNjZXNzKGl0ZW0pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHZhbGlkYXRlSXRlbURhdGEoaXRlbURhdGEpIHtcclxuXHRcdFx0aWYgKCFpdGVtRGF0YS52YXJpYW50KSB7XHJcblx0XHRcdFx0VGh1bmRlci5ub3RpZnkoJ2Vycm9yJywgY29udGV4dC5tKCd2YXJpYW50UmVxdWlyZWQnKSk7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIXZhbGlkYXRlUXVhbnRpdHkocHJvZHVjdC5uYW1lLCBpdGVtRGF0YSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHNlbGVjdGVkQnVuZGxlcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yIChjb25zdCBpdGVtIG9mIGl0ZW1EYXRhLmJ1bmRsZUl0ZW1zIHx8IFtdKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGJ1bmRsZSA9IHZhcmlhbnRUb0J1bmRsZU1hcFtpdGVtLnZhcmlhbnRdO1xyXG5cclxuXHRcdFx0XHRzZWxlY3RlZEJ1bmRsZXMucHVzaChidW5kbGUpO1xyXG5cclxuXHRcdFx0XHRpZiAoIXZhbGlkYXRlUXVhbnRpdHkoYnVuZGxlLm5hbWUsIGl0ZW0pKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoYnVuZGxlLnJlcXVpcmVkICYmXHJcblx0XHRcdFx0XHRpdGVtLnF1YW50aXR5ICE9PSBpdGVtRGF0YS5xdWFudGl0eSkge1xyXG5cdFx0XHRcdFx0VGh1bmRlci5ub3RpZnkoJ2Vycm9yJywgY29udGV4dC5tKCdpbnZhbGlkUmVxdWlyZWRCdW5kbGVJdGVtUXVhbnRpdHknLCB7IGJ1bmRsZTogYnVuZGxlLm5hbWUgfSkpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHJlcXVpcmVkQnVuZGxlcyA9IHByb2R1Y3QuYnVuZGxlcy5maWx0ZXIoYiA9PiBiLnJlcXVpcmVkKTtcclxuXHJcblx0XHRcdGZvciAoY29uc3QgYnVuZGxlIG9mIHJlcXVpcmVkQnVuZGxlcykge1xyXG5cclxuXHRcdFx0XHRpZiAoc2VsZWN0ZWRCdW5kbGVzLmluZGV4T2YoYnVuZGxlKSA9PT0gLTEpIHtcclxuXHRcdFx0XHRcdFRodW5kZXIubm90aWZ5KCdlcnJvcicsIGNvbnRleHQubSgncmVxdWlyZWRCdW5kbGVJdGVtUmVxdWlyZWQnLCB7IGJ1bmRsZTogYnVuZGxlLm5hbWUgfSkpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gdmFsaWRhdGVRdWFudGl0eShzY29wZSwgaXRlbSkge1xyXG5cclxuXHRcdFx0XHRpZiAoIWl0ZW0ucXVhbnRpdHkpIHtcclxuXHRcdFx0XHRcdFRodW5kZXIubm90aWZ5KCdlcnJvcicsIGNvbnRleHQubSgnaXRlbVF1YW50aXR5UmVxdWlyZWQnLCB7IHNjb3BlIH0pKTtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IHZhcmlhbnQgPSB2YXJpYW50TWFwW2l0ZW0udmFyaWFudF07XHJcblxyXG5cdFx0XHRcdGlmICh2YXJpYW50LnF1YW50aXR5ICYmXHJcblx0XHRcdFx0XHR2YXJpYW50LnF1YW50aXR5LnJhdyA8IGl0ZW0ucXVhbnRpdHkpIHtcclxuXHRcdFx0XHRcdFRodW5kZXIubm90aWZ5KCdlcnJvcicsIGNvbnRleHQubSgnZXhjZWVkZWRJdGVtUXVhbnRpdHknLCB7IHNjb3BlIH0pKTtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBidWlsZEl0ZW1EYXRhKCkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc2hpcHBpbmdNZXRob2QgPSAkc2hpcHBpbmdNZXRob2RTZWxlY3Rvci52YWwoKTtcclxuXHRcdFx0Y29uc3QgYnVuZGxlSXRlbXMgPSBbXTtcclxuXHJcblx0XHRcdCRidW5kbGVJdGVtcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBbcHJvZHVjdCwgdmFyaWFudF0gPSAoJCh0aGlzKS5maW5kKCdzZWxlY3QnKS52YWwoKSB8fCAnJykuc3BsaXQoJy4nKTtcclxuXHRcdFx0XHRjb25zdCBidW5kbGVJdGVtUXVhbnRpdHkgPSAkKHRoaXMpLmZpbmQoJ2lucHV0W3R5cGU9XCJudW1iZXJcIl0nKS52YWwoKSB8fCAwO1xyXG5cclxuXHRcdFx0XHRpZiAoIXByb2R1Y3QgfHwgIXZhcmlhbnQpIHJldHVybjtcclxuXHJcblx0XHRcdFx0YnVuZGxlSXRlbXMucHVzaCh7XHJcblx0XHRcdFx0XHRwcm9kdWN0OiAgICAgICAgcHJvZHVjdCxcclxuXHRcdFx0XHRcdHZhcmlhbnQ6ICAgICAgICB2YXJpYW50LFxyXG5cdFx0XHRcdFx0c2hpcHBpbmdNZXRob2Q6IGJ1bmRsZVByb2R1Y3RNYXBbcHJvZHVjdF0udHlwZSA9PT0gJ3RhbmdpYmxlJyA/XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0c2hpcHBpbmdNZXRob2QgOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG51bGwsXHJcblx0XHRcdFx0XHRxdWFudGl0eTogICAgICAgYnVuZGxlSXRlbVF1YW50aXR5ID8gcGFyc2VJbnQoYnVuZGxlSXRlbVF1YW50aXR5KSA6IG51bGwsXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGNvbnN0IGl0ZW1RdWFudGl0eSA9ICRpdGVtUXVhbnRpdHlJbnB1dC52YWwoKSB8fCAwO1xyXG5cdFx0XHRjb25zdCB2YXJpYW50ID0gJHZhcmlhbnRTZWxlY3Rvci52YWwoKSB8fCAoXHJcblx0XHRcdFx0cHJvZHVjdC52YXJpYW50cy5sZW5ndGggPT09IDEgP1xyXG5cdFx0XHRcdFx0cHJvZHVjdC52YXJpYW50c1swXS5faWQgOlxyXG5cdFx0XHRcdFx0bnVsbFxyXG5cdFx0XHQpIHx8IG51bGw7XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHByb2R1Y3Q6ICAgICAgICBwcm9kdWN0Ll9pZCxcclxuXHRcdFx0XHR2YXJpYW50OiAgICAgICAgdmFyaWFudCxcclxuXHRcdFx0XHRzaGlwcGluZ01ldGhvZDogc2hpcHBpbmdNZXRob2QsXHJcblx0XHRcdFx0cXVhbnRpdHk6ICAgICAgIGl0ZW1RdWFudGl0eSA/IHBhcnNlSW50KGl0ZW1RdWFudGl0eSkgOiBudWxsLFxyXG5cdFx0XHRcdGJ1bmRsZUl0ZW1zOiAgICBidW5kbGVJdGVtc1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gKCRjb250YWluZXIpID0+IHtcclxuXHJcblx0Y29uc3QgY2F0YWxvZ01hcCA9IHt9O1xyXG5cclxuXHRjb25zdCAkZGV0YWlscyA9ICRjb250YWluZXIuZmluZCgnLnRodW5kZXItLXByb2R1Y3QtY2F0YWxvZy1kZXRhaWwnKTtcclxuXHRjb25zdCAkdGh1bWJuYWlscyA9ICRjb250YWluZXIuZmluZCgnLnRodW5kZXItLXByb2R1Y3QtY2F0YWxvZy10aHVtYm5haWxzIGltZycpO1xyXG5cclxuXHQkZGV0YWlscy5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0Y2F0YWxvZ01hcFtnZXRJbWFnZUlkKCQodGhpcykpXSA9ICQodGhpcyk7XHJcblx0fSk7XHJcblxyXG5cdHNldEN1cnJlbnRJbWFnZShnZXRJbWFnZUlkKCRkZXRhaWxzLmVxKDApKSk7XHJcblxyXG5cdC8vIENsaWNrIGV2ZW50cyBmb3IgbW9iaWxlIGRldmljZXMuLlxyXG5cdCR0aHVtYm5haWxzLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG5cdFx0c2V0Q3VycmVudEltYWdlKGdldEltYWdlSWQoJCh0aGlzKSkpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBIb3ZlciBldmVudHMgZm9yIGxhcHRvcHNcclxuXHQkdGh1bWJuYWlscy5ob3ZlcihcclxuXHRcdGZ1bmN0aW9uKCkgeyBjYXRhbG9nTWFwW2dldEltYWdlSWQoJCh0aGlzKSldLmFkZENsYXNzKCdhY3RpdmUnKSB9LFxyXG5cdFx0ZnVuY3Rpb24oKSB7IGNhdGFsb2dNYXBbZ2V0SW1hZ2VJZCgkKHRoaXMpKV0ucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpIH1cclxuXHQpO1xyXG5cclxuXHRmdW5jdGlvbiBzZXRDdXJyZW50SW1hZ2UoaW1hZ2VJZCkge1xyXG5cdFx0c2V0QW5jaG9yKCRkZXRhaWxzLCBpbWFnZUlkKTtcclxuXHRcdHNldEFuY2hvcigkdGh1bWJuYWlscywgaW1hZ2VJZCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRBbmNob3IoaW1hZ2VzLCBpbWFnZUlkKSB7XHJcblxyXG5cdFx0aW1hZ2VzXHJcblx0XHRcdC5yZW1vdmVDbGFzcygnYW5jaG9yZWQnKVxyXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiAkKHRoaXMpLmRhdGEoKS5jYXRhbG9nSW1hZ2UgPT09IGltYWdlSWQ7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5hZGRDbGFzcygnYW5jaG9yZWQnKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldEltYWdlSWQoc2VsZWN0b3IpIHtcclxuXHJcblx0XHRyZXR1cm4gc2VsZWN0b3IuZGF0YSgnY2F0YWxvZ0ltYWdlJykgfHwgbnVsbDtcclxuXHR9XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gVGh1bmRlciA9PiB7XHJcblxyXG5cdGNvbnN0IGltcGxlbWVudGF0aW9uID0ge1xyXG5cdFx0bmFtZTogJ3Byb2R1Y3QtbGlzdCdcclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5vcHRpb25zID0gKCkgPT4gKHtcclxuXHRcdHBhZ2U6ICAgICAgICAxLCAgICAgICAgICAgIC8vIFdoaWNoIHBhZ2Ugb2YgcHJvZHVjdHM/XHJcblx0XHRsaW1pdDogICAgICAgMjQsICAgICAgICAgICAvLyBIb3cgbWFueSBwcm9kdWN0cyBhdCBvbmNlP1xyXG5cdFx0c29ydDogICAgICAgICctY3JlYXRlZEF0JywgLy8gRGVmYXVsdCBzb3J0IG9yZGVyXHJcblx0XHRmaWVsZHM6ICAgICAgJycsICAgICAgICAgICAvLyBBZGRpdGlvbmFsIGZpZWxkc1xyXG5cdFx0Y29sdW1uczogICAgIDQsICAgICAgICAgICAgLy8gSG93IG1hbnkgY29sdW1ucz8gKGNzcyBzdXBwb3J0cyBmb3IgMS0xMilcclxuXHRcdGZpbHRlcjogICAgICAnJywgICAgICAgICAgIC8vIEV4dHJhIGZpbHRlcnMuIGUuZy4sIGJyYW5kPWFiY2RcclxuXHRcdGxhYmVsczogICAgICBUaHVuZGVyLm9wdGlvbnMucHJvZHVjdExhYmVscywgLy8gUHJvZHVjdCBsYWJlbHMgKHVuYXZhaWxhYmxlLCBzb2xkLW91dCwgZGlzY291bnRlZClcclxuXHRcdGltYWdlV2lkdGg6ICAyNDAsICAgICAgICAgIC8vIEltYWdlIHdpZHRoXHJcblx0XHRpbWFnZUhlaWdodDogMjQwLCAgICAgICAgICAvLyBJbWFnZSBoZWlnaHRcclxuXHRcdHNob3dTdW1tYXJ5OiB0cnVlLCAgICAgICAgIC8vIFNob3cgYHByb2R1Y3Quc3VtbWFyeWBcclxuXHRcdHNob3dSYXRpbmc6ICAoICAgICAgICAgICAgIC8vIFNob3cgYHByb2R1Y3QucmF0aW5nYFxyXG5cdFx0XHRUaHVuZGVyLm9wdGlvbnMucHJvZHVjdFJldmlldyAmJlxyXG5cdFx0XHRUaHVuZGVyLm9wdGlvbnMucHJvZHVjdFJldmlld1JhdGluZ1xyXG5cdFx0KSxcclxuXHRcdHNob3dDb21wYXJlUHJpY2U6IHRydWUsICAvLyBTaG93IGBwcm9kdWN0LnByaWNlLm9yaWdpbmFsYFxyXG5cdFx0dXNlUGFnaW5hdGlvbjogICAgdHJ1ZSwgIC8vIFVzZSBwYWdpbmF0aW9uP1xyXG5cdFx0b25WaWV3UHJvZHVjdDogZnVuY3Rpb24oJGNvbnRhaW5lciwgY29udGV4dCwgcHJvZHVjdElkKSB7XHJcblx0XHRcdHJldHVybiBUaHVuZGVyLm9wZW4oJ3Byb2R1Y3QtZGV0YWlsJywge1xyXG5cdFx0XHRcdHByb2R1Y3Q6IHByb2R1Y3RJZFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ucHJlID0gZnVuY3Rpb24oY29udGV4dCwgY2FsbGJhY2spIHtcclxuXHJcblx0XHRjb25zdCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xyXG5cclxuXHRcdGNvbnN0IHF1ZXJ5ID0gJC5leHRlbmQoe1xyXG5cdFx0XHRidW5kbGVkOiBmYWxzZSAvLyBPbmx5IGRpc3BsYXkgcm9vdCBwcm9kdWN0c1xyXG5cdFx0fSwgVGh1bmRlci51dGlsLnBhcnNlUXVlcnlTdHJpbmcob3B0aW9ucy5maWx0ZXIpKTtcclxuXHJcblx0XHRjb25zdCBsaXN0UXVlcnkgPSAkLmV4dGVuZCh7XHJcblx0XHRcdGZpZWxkczogW1xyXG5cdFx0XHRcdCd0aHVtYm5haWwnLFxyXG5cdFx0XHRcdCdzbHVnJyxcclxuXHRcdFx0XHQnbmFtZScsXHJcblx0XHRcdFx0J3N1bW1hcnknLFxyXG5cdFx0XHRcdCdwcmljZScsXHJcblx0XHRcdFx0J2Rpc2NvdW50JyxcclxuXHRcdFx0XHQncmF0aW5nJyxcclxuXHRcdFx0XHQnYXZhaWxhYmxlJyxcclxuXHRcdFx0XHQndmFyaWFudHMuYXZhaWxhYmxlJyxcclxuXHRcdFx0XHQndmFyaWFudHMucXVhbnRpdHknXHJcblx0XHRcdF1cclxuXHRcdFx0LmNvbmNhdChUaHVuZGVyLnV0aWwucGFyc2VBcnJheVN0cmluZyhvcHRpb25zLmZpZWxkcykpXHJcblx0XHRcdC5qb2luKCcsJyksXHJcblx0XHRcdHBhZ2U6ICAgb3B0aW9ucy5wYWdlLCAgIC8vIFBhZ2Ugb3B0aW9uXHJcblx0XHRcdGxpbWl0OiAgb3B0aW9ucy5saW1pdCwgIC8vIExpbWl0IG9wdGlvblxyXG5cdFx0XHRzb3J0OiAgIG9wdGlvbnMuc29ydCwgICAvLyBTb3J0IG9wdGlvblxyXG5cdFx0fSwgcXVlcnkpO1xyXG5cclxuXHRcdGNvbnN0IGNvdW50UXVlcnkgPSAkLmV4dGVuZCh7XHJcblx0XHRcdHJhdzogdHJ1ZSxcclxuXHRcdH0sIHF1ZXJ5KTtcclxuXHJcblx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgncHJvZHVjdExpc3RGYWlsZWQnKVxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBsYWJlbHMgPSBUaHVuZGVyLnV0aWwucGFyc2VBcnJheVN0cmluZyhvcHRpb25zLmxhYmVscykubWFwKGxhYmVsID0+IHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRsYWJlbDogbGFiZWwsXHJcblx0XHRcdFx0Y2hlY2s6ICh7XHJcblx0XHRcdFx0XHR1bmF2YWlsYWJsZTogcHJvZHVjdCA9PiAoXHJcblx0XHRcdFx0XHRcdCFwcm9kdWN0LmF2YWlsYWJsZSB8fFxyXG5cdFx0XHRcdFx0XHRwcm9kdWN0LnZhcmlhbnRzLmV2ZXJ5KHYgPT4gIXYuYXZhaWxhYmxlKVxyXG5cdFx0XHRcdFx0KSxcclxuXHRcdFx0XHRcdCdzb2xkLW91dCc6IHByb2R1Y3QgPT4gcHJvZHVjdC52YXJpYW50cy5ldmVyeSh2ID0+IHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHYucXVhbnRpdHkgJiYgdi5xdWFudGl0eS5yYXcgPT09IDA7XHJcblx0XHRcdFx0XHR9KSxcclxuXHRcdFx0XHRcdGRpc2NvdW50ZWQ6IHByb2R1Y3QgPT4gISFwcm9kdWN0LmRpc2NvdW50LnR5cGUsXHJcblx0XHRcdFx0fSlbbGFiZWxdXHJcblx0XHRcdH07XHJcblx0XHR9LCB7fSk7XHJcblxyXG5cdFx0cmV0dXJuICQud2hlbiguLi5bXHJcblx0XHRcdFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0bWV0aG9kOiAnR0VUJyxcclxuXHRcdFx0XHR1cmw6ICAgICcvdjEvcHJvZHVjdHMnLFxyXG5cdFx0XHRcdHF1ZXJ5OiAgbGlzdFF1ZXJ5LFxyXG5cdFx0XHR9KSxcclxuXHRcdFx0Y29udGV4dC5vcHRpb25zLnVzZVBhZ2luYXRpb24gPyBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ0dFVCcsXHJcblx0XHRcdFx0dXJsOiAgICAnL3YxL3Byb2R1Y3RzL2NvdW50JyxcclxuXHRcdFx0XHRxdWVyeTogIGNvdW50UXVlcnksXHJcblx0XHRcdH0pIDogbnVsbFxyXG5cdFx0XSkudGhlbigocHJvZHVjdHMsIGNvdW50KSA9PiB7XHJcblxyXG5cdFx0XHRjb250ZXh0LmNvdW50ID0gY291bnQgPyBjb3VudFswXS5jb3VudCA6IG51bGw7XHJcblx0XHRcdGNvbnRleHQucHJvZHVjdHMgPSBwcm9kdWN0c1swXS5tYXAocHJvZHVjdCA9PiB7XHJcblxyXG5cdFx0XHRcdHByb2R1Y3QubGFiZWwgPSAoXHJcblx0XHRcdFx0XHRsYWJlbHMuZmluZCgoeyBjaGVjayB9KSA9PiBjaGVjayhwcm9kdWN0KSkgfHxcclxuXHRcdFx0XHRcdHsgbGFiZWw6IG51bGwgfVxyXG5cdFx0XHRcdCkubGFiZWw7XHJcblxyXG5cdFx0XHRcdHJldHVybiBwcm9kdWN0O1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBjb250ZXh0KTtcclxuXHJcblx0XHR9LCBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdGVyci5yZXNwb25zZUpTT04sXHJcblx0XHRcdGVycm9ycyxcclxuXHRcdFx0Y2FsbGJhY2tcclxuXHRcdCkpO1xyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLmluaXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcblxyXG5cdFx0Y29uc3QgJGNvbnRhaW5lciA9ICQodGhpcyk7XHJcblx0XHRjb25zdCAkcHJvZHVjdCA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXByb2R1Y3QnKTtcclxuXHRcdGNvbnN0ICRwYWdpbmF0aW9uID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tcHJvZHVjdC1saXN0LXBhZ2luYXRpb24nKTtcclxuXHJcblx0XHQkcHJvZHVjdC5vbignY2xpY2snLCBbXHJcblx0XHRcdCcudGh1bmRlci0tcHJvZHVjdC10aHVtYm5haWwtd3JhcHBlcicsXHJcblx0XHRcdCcudGh1bmRlci0tcHJvZHVjdC1uYW1lJyxcclxuXHRcdFx0Jy50aHVuZGVyLS1wcm9kdWN0LXN1bW1hcnknLFxyXG5cdFx0XS5qb2luKCcsJyksIGV2ZW50ID0+IFRodW5kZXIuZXhlY3V0ZShcclxuXHRcdFx0Y29udGV4dC5vcHRpb25zLm9uVmlld1Byb2R1Y3QsXHJcblx0XHRcdCRjb250YWluZXIsXHJcblx0XHRcdGNvbnRleHQsXHJcblx0XHRcdCQoZXZlbnQuZGVsZWdhdGVUYXJnZXQpLmRhdGEoJ3Byb2R1Y3QnKVxyXG5cdFx0KSk7XHJcblxyXG5cdFx0aWYgKGNvbnRleHQub3B0aW9ucy51c2VQYWdpbmF0aW9uKSB7XHJcblxyXG5cdFx0XHRUaHVuZGVyLnBsdWdpbnMucGFnaW5hdGlvbih7XHJcblx0XHRcdFx0Y29udGFpbmVyOiAgICAgJHBhZ2luYXRpb24sXHJcblx0XHRcdFx0Y3VycmVudFBhZ2U6ICAgY29udGV4dC5vcHRpb25zLnBhZ2UsXHJcblx0XHRcdFx0dG90YWxSZXN1bHQ6ICAgY29udGV4dC5jb3VudCxcclxuXHRcdFx0XHRyZXN1bHRQZXJQYWdlOiBjb250ZXh0Lm9wdGlvbnMubGltaXQsXHJcblx0XHRcdFx0b25QYWdlQ2hhbmdlOiAgKHsgcGFnZSB9KSA9PiBUaHVuZGVyLnJlbmRlcihcclxuXHRcdFx0XHRcdCRjb250YWluZXIsXHJcblx0XHRcdFx0XHRpbXBsZW1lbnRhdGlvbi5uYW1lLFxyXG5cdFx0XHRcdFx0JC5leHRlbmQoY29udGV4dC5vcHRpb25zLCB7IHBhZ2UgfSlcclxuXHRcdFx0XHQpXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XHJcblxyXG59OyIsImNvbnN0IGdldCA9IHJlcXVpcmUoJ2xvZGFzaC5nZXQnKTtcclxuY29uc3Qgc2V0ID0gcmVxdWlyZSgnbG9kYXNoLnNldCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaHVuZGVyID0+IHtcclxuXHJcblx0Y29uc3QgY29tbWVudEZpZWxkcyA9IFtcclxuXHRcdCdjdXN0b21lcicsXHJcblx0XHQnY29sbGFib3JhdG9yJyxcclxuXHRcdCdib2R5JyxcclxuXHRcdCdmbGFnZ2VkJyxcclxuXHRcdCdjcmVhdGVkQXQnLFxyXG5cdF07XHJcblxyXG5cdC8vIEltcGxlbWVudGF0aW9uXHJcblx0Y29uc3QgaW1wbGVtZW50YXRpb24gPSB7XHJcblx0XHRuYW1lOiAncHJvZHVjdC1yZXZpZXctY29tbWVudHMnXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ub3B0aW9ucyA9ICgpID0+ICh7XHJcblx0XHRyZXZpZXc6ICAgICAgICAgIG51bGwsICAgICAgICAgLy8gUmV2aWV3IElEXHJcblx0XHRwYWdlOiAgICAgICAgICAgIDEsICAgICAgICAgICAgLy8gV2hpY2ggcGFnZSBvZiBjb21tZW50cz9cclxuXHRcdGxpbWl0OiAgICAgICAgICAgMTAsICAgICAgICAgICAvLyBIb3cgbWFueSBjb21tZW50cyBhdCBvbmNlP1xyXG5cdFx0c29ydDogICAgICAgICAgICAnY3JlYXRlZEF0JywgIC8vIERlZmF1bHQgc29ydCB2YWx1ZVxyXG5cdFx0ZmlsdGVyOiAgICAgICAgICBudWxsLCAgICAgICAgIC8vIEV4dHJhIHF1ZXJ5IGZpbHRlclxyXG5cdFx0dXNlQm9keUV4Y2VycHQ6ICAxNDAsICAgICAgICAgIC8vIExlbmd0aCBvZiBhIGJvZHkgZXhjZXJwdCB8fCBmYWxzZVxyXG5cdFx0dXNlRmxhZzogICAgICAgICB0cnVlLCAgICAgICAgIC8vIFVzZSBmbGFnP1xyXG5cdFx0dXNlUGFnaW5hdGlvbjogICB0cnVlLCAgICAgICAgIC8vIFVzZSBQYWdpbmF0aW9uP1xyXG5cdFx0aGFzTm9Db21tZW50czogICBmYWxzZSwgICAgICAgIC8vIEhhcyBubyBjb21tZW50cz8gKHdoZW4gaXQncyBhbHJlYWR5IGtub3duKVxyXG5cdFx0Y29uZmlybU9uRGVsZXRlOiBUaHVuZGVyLm9wdGlvbnMuY29uZmlybWF0aW9uLnJldmlld0NvbW1lbnREZWxldGUsIC8vIFdoZXRoZXIgdG8gY29uZmlybSBiZWZvcmUgZGVsZXRpbmcgYSByZXZpZXcgY29tbWVudFxyXG5cclxuXHRcdG9uVW5hdXRoZW50aWNhdGVkV3JpdGVDb21tZW50OiBmdW5jdGlvbigkY29udGFpbmVyLCBjb250ZXh0KSB7XHJcblx0XHRcdHJldHVybiBUaHVuZGVyLm5vdGlmeSgnaW5mbycsIGNvbnRleHQubSgnbG9naW5SZXF1aXJlZCcpKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ucHJlID0gZnVuY3Rpb24oY29udGV4dCwgY2FsbGJhY2spIHtcclxuXHJcblx0XHRpZiAoY29udGV4dC5vcHRpb25zLmhhc05vQ29tbWVudHMpIHtcclxuXHRcdFx0Ly8gSWYgdGhlIHJldmlldyBkb2Vzbid0IGhhdmUgYW55IGNvbW1lbnRzLCBkbyBub3QgY2FsbCBBUElzLlxyXG5cdFx0XHRjb250ZXh0LmNvbW1lbnRzID0gW107XHJcblx0XHRcdGNvbnRleHQuY291bnQgPSB7IHJhdzogMCwgZm9ybWF0dGVkOiAnMCcsIGNvbnZlcnRlZDogJzAnIH07XHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgnY29tbWVudExpc3RGYWlsZWQnKVxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBkZWZhdWx0UXVlcnkgPSAkLmV4dGVuZCh7XHJcblx0XHRcdHJldmlldzogY29udGV4dC5vcHRpb25zLnJldmlldyxcclxuXHRcdH0sIFRodW5kZXIudXRpbC5wYXJzZVF1ZXJ5U3RyaW5nKGNvbnRleHQub3B0aW9ucy5maWx0ZXIpKTtcclxuXHJcblx0XHRyZXR1cm4gJC53aGVuKFxyXG5cdFx0XHRmZXRjaENvbW1lbnRzKCksXHJcblx0XHRcdGNvdW50Q29tbWVudHMoKVxyXG5cdFx0KS50aGVuKChjb21tZW50cywgY291bnQpID0+IGNhbGxiYWNrKG51bGwsICQuZXh0ZW5kKGNvbnRleHQsIHtcclxuXHRcdFx0Y29tbWVudHM6IChjb21tZW50c1swXSB8fCBbXSkubWFwKGMgPT4ge1xyXG5cdFx0XHRcdHJldHVybiBidWlsZFJldmlld0NvbW1lbnQoYywgY29udGV4dC5vcHRpb25zLnVzZUJvZHlFeGNlcnB0KTtcclxuXHRcdFx0fSksXHJcblx0XHRcdGNvdW50OiAgICBjb3VudCA/IGNvdW50WzBdLmNvdW50IDogbnVsbCxcclxuXHRcdH0pKSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRlcnJvcnMsXHJcblx0XHRcdGNhbGxiYWNrXHJcblx0XHQpKTtcclxuXHJcblx0XHRmdW5jdGlvbiBmZXRjaENvbW1lbnRzKCkge1xyXG5cclxuXHRcdFx0Y29uc3QgcXVlcnkgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFF1ZXJ5LCB7XHJcblx0XHRcdFx0cGFnZTogICBjb250ZXh0Lm9wdGlvbnMucGFnZSxcclxuXHRcdFx0XHRsaW1pdDogIGNvbnRleHQub3B0aW9ucy5saW1pdCxcclxuXHRcdFx0XHRzb3J0OiAgIGNvbnRleHQub3B0aW9ucy5zb3J0LFxyXG5cdFx0XHRcdGZpZWxkczogY29tbWVudEZpZWxkcy5qb2luKCcsJylcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRtZXRob2Q6ICdHRVQnLFxyXG5cdFx0XHRcdHVybDogICAgJy92MS9wcm9kdWN0cy9yZXZpZXdzL2NvbW1lbnRzJyxcclxuXHRcdFx0XHRxdWVyeTogIHF1ZXJ5XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjb3VudENvbW1lbnRzKCkge1xyXG5cclxuXHRcdFx0Y29uc3QgcXVlcnkgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFF1ZXJ5KTtcclxuXHJcblx0XHRcdGRlbGV0ZSBxdWVyeS5pZHM7XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRtZXRob2Q6ICdHRVQnLFxyXG5cdFx0XHRcdHVybDogICAgJy92MS9wcm9kdWN0cy9yZXZpZXdzL2NvbW1lbnRzL2NvdW50JyxcclxuXHRcdFx0XHRxdWVyeTogIHF1ZXJ5XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24uaW5pdCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuXHJcblx0XHRsZXQgY29tbWVudE1hcCA9IHt9O1xyXG5cclxuXHRcdGNvbnN0ICRjb250YWluZXIgPSAkKHRoaXMpO1xyXG5cdFx0Y29uc3QgJHdyaXRlQ29tbWVudCA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXdyaXRlLWNvbW1lbnQnKTtcclxuXHRcdGNvbnN0ICRoYXNOb0NvbW1lbnRzID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tcmV2aWV3LWhhcy1uby1jb21tZW50cycpO1xyXG5cdFx0Y29uc3QgJGNvbW1lbnRXcml0ZXJDb250YWluZXIgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1jb21tZW50LXdyaXRlci1jb250YWluZXInKTtcclxuXHRcdGNvbnN0ICRjb21tZW50Qm9keSA9ICRjb21tZW50V3JpdGVyQ29udGFpbmVyLmZpbmQoJ3RleHRhcmVhJyk7XHJcblx0XHRjb25zdCAkcG9zdENvbW1lbnQgPSAkY29tbWVudFdyaXRlckNvbnRhaW5lci5maW5kKCcudGh1bmRlci0tcG9zdC1jb21tZW50Jyk7XHJcblx0XHRjb25zdCAkY2FuY2VsQ29tbWVudCA9ICRjb21tZW50V3JpdGVyQ29udGFpbmVyLmZpbmQoJy50aHVuZGVyLS1jYW5jZWwtY29tbWVudCcpO1xyXG5cdFx0Y29uc3QgJGNvbW1lbnRMaXN0ID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tcmV2aWV3LWNvbW1lbnQtbGlzdCcpO1xyXG5cdFx0Y29uc3QgJHBhZ2luYXRpb24gPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1yZXZpZXctY29tbWVudC1saXN0LXBhZ2luYXRpb24nKTtcclxuXHJcblx0XHR1cGRhdGVDb21tZW50TWFwKCk7XHJcblxyXG5cdFx0JHdyaXRlQ29tbWVudC5vbignY2xpY2snLCBzdGFydENvbW1lbnRXcml0aW5nKTtcclxuXHRcdCRjYW5jZWxDb21tZW50Lm9uKCdjbGljaycsIGNhbmNlbENvbW1lbnQpO1xyXG5cclxuXHRcdCRjb250YWluZXIub24oJ2NsaWNrJywgJy50aHVuZGVyLS1yZWFkLW1vcmUnLCByZWFkTW9yZSk7XHJcblx0XHQkY29udGFpbmVyLm9uKCdjbGljaycsICcudGh1bmRlci0tZWRpdC1yZXZpZXctY29tbWVudCcsIGVkaXRDb21tZW50KTtcclxuXHRcdCRjb250YWluZXIub24oJ2NsaWNrJywgJy50aHVuZGVyLS1kZWxldGUtcmV2aWV3LWNvbW1lbnQnLCBkZWxldGVDb21tZW50KTtcclxuXHRcdCRjb250YWluZXIub24oJ2NsaWNrJywgJy50aHVuZGVyLS1mbGFnJywgZmxhZ0NvbW1lbnQpO1xyXG5cclxuXHJcblx0XHRUaHVuZGVyLnV0aWwubWFrZVJlY2FwdGNoYSh7XHJcblx0XHRcdGNvbXBvbmVudE5hbWU6IGltcGxlbWVudGF0aW9uLm5hbWUsXHJcblx0XHRcdGJ1dHRvbjogICAgICAgICRwb3N0Q29tbWVudCxcclxuXHRcdFx0dmFsaWRhdGU6ICAgICAgdmFsaWRhdGVDb21tZW50LFxyXG5cdFx0XHRjYWxsYmFjazogICAgICBwb3N0Q29tbWVudCxcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChjb250ZXh0Lm9wdGlvbnMudXNlUGFnaW5hdGlvbikge1xyXG5cclxuXHRcdFx0VGh1bmRlci5wbHVnaW5zLnBhZ2luYXRpb24oe1xyXG5cdFx0XHRcdHR5cGU6ICAgICAgICAgICdzaW1wbGUnLFxyXG5cdFx0XHRcdGNvbnRhaW5lcjogICAgICRwYWdpbmF0aW9uLFxyXG5cdFx0XHRcdGN1cnJlbnRQYWdlOiAgIGNvbnRleHQub3B0aW9ucy5wYWdlLFxyXG5cdFx0XHRcdHRvdGFsUmVzdWx0OiAgIGNvbnRleHQuY291bnQucmF3LFxyXG5cdFx0XHRcdHJlc3VsdFBlclBhZ2U6IGNvbnRleHQub3B0aW9ucy5saW1pdCxcclxuXHRcdFx0XHRvblBhZ2VDaGFuZ2U6ICAoeyBwYWdlIH0pID0+IFRodW5kZXIucmVuZGVyKFxyXG5cdFx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdGltcGxlbWVudGF0aW9uLm5hbWUsXHJcblx0XHRcdFx0XHQkLmV4dGVuZChjb250ZXh0Lm9wdGlvbnMsIHsgcGFnZSB9KVxyXG5cdFx0XHRcdClcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gdXBkYXRlQ29tbWVudE1hcCgpIHtcclxuXHJcblx0XHRcdGNvbW1lbnRNYXAgPSBjb250ZXh0LmNvbW1lbnRzLnJlZHVjZSgobywgY29tbWVudCkgPT4ge1xyXG5cdFx0XHRcdHJldHVybiBzZXQobywgY29tbWVudC5faWQsIGNvbW1lbnQpO1xyXG5cdFx0XHR9LCB7fSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHN0YXJ0Q29tbWVudFdyaXRpbmcoZXZlbnQpIHtcclxuXHJcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0XHRpZiAoVGh1bmRlci5hdXRoZW50aWNhdGVkKCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gc2hvd0NvbW1lbnRXcml0ZXIoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIuZXhlY3V0ZShcclxuXHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25VbmF1dGhlbnRpY2F0ZWRXcml0ZUNvbW1lbnQsXHJcblx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRjb250ZXh0XHJcblx0XHRcdCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldENvbW1lbnQoKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0cmV2aWV3OiBjb250ZXh0Lm9wdGlvbnMucmV2aWV3LFxyXG5cdFx0XHRcdGJvZHk6ICAgJGNvbW1lbnRCb2R5LnZhbCgpLFxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHZhbGlkYXRlQ29tbWVudChjb21tZW50KSB7XHJcblxyXG5cdFx0XHRjb21tZW50ID0gY29tbWVudCB8fCBnZXRDb21tZW50KCk7XHJcblxyXG5cdFx0XHRpZiAoIWNvbW1lbnQuYm9keSkge1xyXG5cdFx0XHRcdFRodW5kZXIubm90aWZ5KCdlcnJvcicsIGNvbnRleHQubSgnYm9keVJlcXVpcmVkJykpO1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcG9zdENvbW1lbnQodG9rZW4sIHJlc2V0UmVjYXB0Y2hhKSB7XHJcblxyXG5cdFx0XHRjb25zdCByZXNldFN0YXRlID0gKCkgPT4gcmVzZXRSZWNhcHRjaGEgJiYgcmVzZXRSZWNhcHRjaGEoKTtcclxuXHJcblx0XHRcdGNvbnN0IGRhdGEgPSBnZXRDb21tZW50KCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gY3JlYXRlQ29tbWVudChkYXRhKVxyXG5cdFx0XHRcdFx0LnRoZW4oY29tbWVudCA9PiBmZXRjaENvbW1lbnQoY29tbWVudCkpXHJcblx0XHRcdFx0XHQudGhlbihjb21tZW50ID0+IGRvbmUoY29tbWVudCkpO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gZG9uZShjb21tZW50KSB7XHJcblxyXG5cdFx0XHRcdGNvbW1lbnQgPSBidWlsZFJldmlld0NvbW1lbnQoY29tbWVudCwgY29udGV4dC5vcHRpb25zLnVzZUJvZHlFeGNlcnB0KTtcclxuXHJcblx0XHRcdFx0Y29udGV4dC5jb21tZW50cy51bnNoaWZ0KGNvbW1lbnQpO1xyXG5cclxuXHRcdFx0XHR1cGRhdGVDb21tZW50TWFwKCk7XHJcblxyXG5cdFx0XHRcdGNvbnN0ICR0ZW1wbGF0ZSA9ICQoVGh1bmRlci5jb21wb25lbnQoaW1wbGVtZW50YXRpb24ubmFtZSkudGVtcGxhdGUoJC5leHRlbmQoe30sIGNvbnRleHQsIHtcclxuXHRcdFx0XHRcdGNvbW1lbnRzOiBbY29tbWVudF1cclxuXHRcdFx0XHR9KSkpO1xyXG5cclxuXHRcdFx0XHRjb25zdCAkY29tbWVudCA9ICQoJHRlbXBsYXRlLmZpbmQoJy50aHVuZGVyLS1yZXZpZXctY29tbWVudC1saXN0JykuaHRtbCgpKTtcclxuXHJcblx0XHRcdFx0JGNvbW1lbnRMaXN0LnByZXBlbmQoJGNvbW1lbnQpO1xyXG5cclxuXHRcdFx0XHRjYW5jZWxDb21tZW50KCk7XHJcblxyXG5cdFx0XHRcdHJlc2V0U3RhdGUoKTtcclxuXHJcblx0XHRcdFx0JGhhc05vQ29tbWVudHMucmVtb3ZlKCk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBUaHVuZGVyLm5vdGlmeSgnc3VjY2VzcycsIGNvbnRleHQubSgnY29tbWVudFBvc3RTdWNjZXNzJykpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gY3JlYXRlQ29tbWVudChkYXRhKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgnY29tbWVudFBvc3RGYWlsZWQnKVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdFx0bWV0aG9kOiAgICAnUE9TVCcsXHJcblx0XHRcdFx0XHR1cmw6ICAgICAgICcvdjEvbWUvcHJvZHVjdHMvcmV2aWV3cy9jb21tZW50cycsXHJcblx0XHRcdFx0XHRkYXRhOiAgICAgIGRhdGEsXHJcblx0XHRcdFx0XHRyZWNhcHRjaGE6IHRva2VuLFxyXG5cdFx0XHRcdH0pLnRoZW4obnVsbCwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0XHRcdGVycm9ycyxcclxuXHRcdFx0XHRcdHJlc2V0U3RhdGVcclxuXHRcdFx0XHQpKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGZldGNoQ29tbWVudChjb21tZW50KSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgnY29tbWVudFJlYWRGYWlsZWQnKVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdFx0bWV0aG9kOiAnR0VUJyxcclxuXHRcdFx0XHRcdHVybDogICAgYC92MS9wcm9kdWN0cy9yZXZpZXdzL2NvbW1lbnRzLyR7Y29tbWVudC5faWR9YCxcclxuXHRcdFx0XHRcdHF1ZXJ5OiAge1xyXG5cdFx0XHRcdFx0XHRmaWVsZHM6IGNvbW1lbnRGaWVsZHMuam9pbignLCcpXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSkudGhlbihudWxsLCBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdFx0ZXJyb3JzLFxyXG5cdFx0XHRcdFx0cmVzZXRTdGF0ZVxyXG5cdFx0XHRcdCkpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjYW5jZWxDb21tZW50KGV2ZW50KSB7XHJcblxyXG5cdFx0XHRpZiAoZXZlbnQpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0XHQkY29tbWVudEJvZHkudmFsKG51bGwpO1xyXG5cdFx0XHRoaWRlQ29tbWVudFdyaXRlcigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNob3dDb21tZW50V3JpdGVyKCkge1xyXG5cdFx0XHQkd3JpdGVDb21tZW50LmhpZGUoKTtcclxuXHRcdFx0JGNvbW1lbnRXcml0ZXJDb250YWluZXIuc2hvdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGhpZGVDb21tZW50V3JpdGVyKCkge1xyXG5cdFx0XHQkd3JpdGVDb21tZW50LnNob3coKTtcclxuXHRcdFx0JGNvbW1lbnRXcml0ZXJDb250YWluZXIuaGlkZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlYWRNb3JlKGV2ZW50KSB7XHJcblxyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgJGNvbW1lbnQgPSAkKHRoaXMpLnBhcmVudHMoJ1tkYXRhLXJldmlldy1jb21tZW50XScpO1xyXG5cdFx0XHRjb25zdCBjb21tZW50SWQgPSAkY29tbWVudC5kYXRhKCdyZXZpZXdDb21tZW50Jyk7XHJcblx0XHRcdGNvbnN0IGJvZHkgPSBjb21tZW50TWFwW2NvbW1lbnRJZF0uYm9keTtcclxuXHJcblx0XHRcdCRjb21tZW50LmZpbmQoJy50aHVuZGVyLS1yZXZpZXctY29tbWVudC1ib2R5JykuaHRtbChib2R5KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZWRpdENvbW1lbnQoZXZlbnQpIHtcclxuXHJcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0XHRjb25zdCBpc0VkaXRpbmcgPSAkKHRoaXMpLmRhdGEoJ2VkaXRpbmcnKTtcclxuXHRcdFx0Y29uc3QgJGNvbW1lbnQgPSAkKHRoaXMpLnBhcmVudHMoJ1tkYXRhLXJldmlldy1jb21tZW50XScpO1xyXG5cdFx0XHRjb25zdCBjb21tZW50SWQgPSAkY29tbWVudC5kYXRhKCdyZXZpZXdDb21tZW50Jyk7XHJcblxyXG5cdFx0XHRpZiAoaXNFZGl0aW5nKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0ICRpbnB1dCA9ICRjb21tZW50LmZpbmQoJ3RleHRhcmVhLnRodW5kZXItLXJldmlldy1jb21tZW50LWJvZHknKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgZGF0YSA9IHsgYm9keTogJGlucHV0LnZhbCgpIHx8IG51bGwgfTtcclxuXHJcblx0XHRcdFx0aWYgKCF2YWxpZGF0ZUNvbW1lbnQoZGF0YSkpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgnc2F2ZUZhaWxlZCcpLFxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdFx0bWV0aG9kOiAnUFVUJyxcclxuXHRcdFx0XHRcdHVybDogICAgYC92MS9tZS9wcm9kdWN0cy9yZXZpZXdzL2NvbW1lbnRzLyR7Y29tbWVudElkfWAsXHJcblx0XHRcdFx0XHRkYXRhOiAgIGRhdGEsXHJcblx0XHRcdFx0fSkudGhlbihjb21tZW50ID0+IHtcclxuXHJcblx0XHRcdFx0XHQkKHRoaXMpLnRleHQoY29udGV4dC5tKCdlZGl0Q29tbWVudCcpKTtcclxuXHRcdFx0XHRcdCQodGhpcykuZGF0YSgnZWRpdGluZycsIGZhbHNlKTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCAkYm9keSA9ICQoYDxkaXYgY2xhc3M9XCIkeyRpbnB1dC5hdHRyKCdjbGFzcycpfVwiPjwvZGl2PmApO1xyXG5cclxuXHRcdFx0XHRcdCRib2R5Lmh0bWwoY29tbWVudC5ib2R5KTtcclxuXHJcblx0XHRcdFx0XHQkaW5wdXQucmVwbGFjZVdpdGgoJGJvZHkpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBUaHVuZGVyLm5vdGlmeSgnc3VjY2VzcycsIGNvbnRleHQubSgnc2F2ZVN1Y2Nlc3MnKSk7XHJcblxyXG5cdFx0XHRcdH0sIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0XHRcdGVyci5yZXNwb25zZUpTT04sXHJcblx0XHRcdFx0XHRlcnJvcnNcclxuXHRcdFx0XHQpKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGNvbW1lbnQgPSBjb21tZW50TWFwW2NvbW1lbnRJZF07XHJcblxyXG5cdFx0XHRcdGNvbnN0ICRib2R5ID0gJGNvbW1lbnQuZmluZCgnLnRodW5kZXItLXJldmlldy1jb21tZW50LWJvZHknKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgJGlucHV0ID0gJChgPHRleHRhcmVhIGNsYXNzPVwiJHskYm9keS5hdHRyKCdjbGFzcycpfVwiPiR7Y29tbWVudC5ib2R5IHx8ICcnfTwvdGV4dGFyZWE+YCk7XHJcblxyXG5cdFx0XHRcdCRib2R5LnJlcGxhY2VXaXRoKCRpbnB1dCk7XHJcblxyXG5cdFx0XHRcdCQodGhpcykudGV4dChjb250ZXh0Lm0oJ3NhdmVDb21tZW50JykpO1xyXG5cdFx0XHRcdCQodGhpcykuZGF0YSgnZWRpdGluZycsIHRydWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGRlbGV0ZUNvbW1lbnQoZXZlbnQpIHtcclxuXHJcblx0XHRcdGlmIChldmVudCkgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcblx0XHRcdGNvbnN0IHJlbW92ZUNvbW1lbnQgPSAoKSA9PiB7XHJcblxyXG5cdFx0XHRcdGNvbnN0ICRjb21tZW50ID0gJCh0aGlzKS5wYXJlbnRzKCdbZGF0YS1yZXZpZXctY29tbWVudF0nKTtcclxuXHRcdFx0XHRjb25zdCBjb21tZW50SWQgPSAkY29tbWVudC5kYXRhKCdyZXZpZXdDb21tZW50Jyk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgnZGVsZXRlRmFpbGVkJyksXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0XHRtZXRob2Q6ICdERUxFVEUnLFxyXG5cdFx0XHRcdFx0dXJsOiAgICBgL3YxL21lL3Byb2R1Y3RzL3Jldmlld3MvY29tbWVudHMvJHtjb21tZW50SWR9YCxcclxuXHRcdFx0XHR9KS50aGVuKCgpID0+IHtcclxuXHRcdFx0XHRcdCRjb21tZW50LmFkZENsYXNzKCdoaWRkZW4nKS5oaWRlKCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gVGh1bmRlci5ub3RpZnkoJ3N1Y2Nlc3MnLCBjb250ZXh0Lm0oJ2RlbGV0ZVN1Y2Nlc3MnKSk7XHJcblx0XHRcdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0XHRcdGVycm9yc1xyXG5cdFx0XHRcdCkpO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGlmICghY29udGV4dC5vcHRpb25zLmNvbmZpcm1PbkRlbGV0ZSkge1xyXG5cdFx0XHRcdHJldHVybiByZW1vdmVDb21tZW50KCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnBsdWdpbnMuY29uZmlybWF0aW9uKFxyXG5cdFx0XHRcdGNvbnRleHQubSgnZGVsZXRlQ29uZmlybScpLFxyXG5cdFx0XHRcdCgpID0+IHJlbW92ZUNvbW1lbnQoKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBmbGFnQ29tbWVudChldmVudCkge1xyXG5cclxuXHRcdFx0aWYgKGV2ZW50KSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgY29tbWVudElkID0gJCh0aGlzKS5wYXJlbnRzKCdbZGF0YS1yZXZpZXctY29tbWVudF0nKS5kYXRhKCdyZXZpZXdDb21tZW50Jyk7XHJcblxyXG5cdFx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdFx0ZGVmYXVsdDogICAgICAgICAgIGNvbnRleHQubSgnZmxhZ0ZhaWxlZCcpLFxyXG5cdFx0XHRcdCdkdXBsaWNhdGVkLWZsYWcnOiBjb250ZXh0Lm0oJ2R1cGxpY2F0ZWRGbGFnJyksXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRtZXRob2Q6ICdQT1NUJyxcclxuXHRcdFx0XHR1cmw6ICAgIGAvdjEvbWUvcHJvZHVjdHMvcmV2aWV3cy9jb21tZW50cy8ke2NvbW1lbnRJZH0vZmxhZ3NgLFxyXG5cdFx0XHR9KS50aGVuKCgpID0+IHtcclxuXHRcdFx0XHRyZXR1cm4gVGh1bmRlci5ub3RpZnkoJ3N1Y2Nlc3MnLCBjb250ZXh0Lm0oJ2ZsYWdTdWNjZXNzJykpO1xyXG5cdFx0XHR9LCBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0XHRlcnJvcnNcclxuXHRcdFx0KSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XHJcblxyXG5cdGZ1bmN0aW9uIGJ1aWxkUmV2aWV3Q29tbWVudChjb21tZW50LCB1c2VCb2R5RXhjZXJwdCkge1xyXG5cclxuXHRcdGNvbnN0IGN1c3RvbWVyID0gZ2V0KFRodW5kZXIuYXV0aGVudGljYXRlZCgnY3VzdG9tZXInKSwgJ3N1YicsICd1bmF1dGhlbnRpY2F0ZWQnKTtcclxuXHJcblx0XHRjb21tZW50LmVkaXRhYmxlID0gZ2V0KGNvbW1lbnQsICdjdXN0b21lci5faWQnKSA9PT0gY3VzdG9tZXI7XHJcblx0XHRjb21tZW50LmV4Y2VycHQgPSBUaHVuZGVyLnV0aWwuZXhjZXJwdChjb21tZW50LmJvZHksIHVzZUJvZHlFeGNlcnB0KSB8fCAnJztcclxuXHRcdGNvbW1lbnQuYm9keSA9IGNvbW1lbnQuYm9keSB8fCAnJztcclxuXHJcblx0XHRyZXR1cm4gY29tbWVudDtcclxuXHJcblx0fVxyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IFRodW5kZXIgPT4ge1xyXG5cclxuXHRjb25zdCByZXZpZXdGaWVsZHMgPSBbXHJcblx0XHQnY3VzdG9tZXInLFxyXG5cdFx0J3RpdGxlJyxcclxuXHRcdCdib2R5JyxcclxuXHRcdCdpbWFnZXMnLFxyXG5cdFx0J3JhdGluZycsXHJcblx0XHQnaGVscGVkJyxcclxuXHRcdCdmbGFnZ2VkJyxcclxuXHRcdCd0b3RhbENvbW1lbnQnLFxyXG5cdFx0J2NyZWF0ZWRBdCcsXHJcblx0XTtcclxuXHJcblx0Ly8gSW1wbGVtZW50YXRpb25cclxuXHRjb25zdCBpbXBsZW1lbnRhdGlvbiA9IHtcclxuXHRcdG5hbWU6ICdwcm9kdWN0LXJldmlldy13cml0ZXInXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ub3B0aW9ucyA9ICgpID0+ICh7XHJcblxyXG5cdFx0cHJvZHVjdDogICBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvZHVjdCBJRCB0byB3cml0ZSBhIHJldmlld1xyXG5cdFx0dXNlUmF0aW5nOiBUaHVuZGVyLm9wdGlvbnMucHJvZHVjdFJldmlld1JhdGluZywgLy8gVXNlIHJhdGluZz9cclxuXHJcblx0XHRvblJldmlld1Bvc3Q6IGZ1bmN0aW9uKCRjb250YWluZXIsIGNvbnRleHQsIHJldmlldykge30sXHJcblx0XHRvblJldmlld0NhbmNlbDogZnVuY3Rpb24oJGNvbnRhaW5lciwgY29udGV4dCkge31cclxuXHJcblx0fSk7XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLnByZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcblxyXG5cdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIGNvbnRleHQpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5pbml0ID0gZnVuY3Rpb24oY29udGV4dCkge1xyXG5cclxuXHRcdGNvbnN0IHJldmlldyA9IHsgaW1hZ2VzOiBbXSB9O1xyXG5cclxuXHRcdGNvbnN0ICRjb250YWluZXIgPSAkKHRoaXMpO1xyXG5cdFx0Y29uc3QgJHdyaXRlUmV2aWV3Rm9ybSA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXdyaXRlLXJldmlldy1mb3JtJyk7XHJcblx0XHRjb25zdCAkd3JpdGVSZXZpZXdJbWFnZUZvcm0gPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1yZXZpZXctaW1hZ2UtZm9ybScpO1xyXG5cdFx0Y29uc3QgJHdyaXRlUmV2aWV3SW1hZ2VzID0gJHdyaXRlUmV2aWV3SW1hZ2VGb3JtLmZpbmQoJy50aHVuZGVyLS1yZXZpZXctaW1hZ2VzJyk7XHJcblx0XHRjb25zdCAkcG9zdFJldmlldyA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXBvc3QtcHJvZHVjdC1yZXZpZXcnKTtcclxuXHRcdGNvbnN0ICRjYW5jZWxSZXZpZXcgPSAkKHRoaXMpLmZpbmQoJy50aHVuZGVyLS1jYW5jZWwtcHJvZHVjdC1yZXZpZXcnKTtcclxuXHJcblx0XHQkY2FuY2VsUmV2aWV3Lm9uKCdjbGljaycsIGNhbmNlbFJldmlld1dyaXRpbmcpO1xyXG5cclxuXHRcdCRjb250YWluZXIub24oJ2NsaWNrJywgJy50aHVuZGVyLS1kZWxldGUtcmV2aWV3LWltYWdlJywgZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHRjb25zdCBpbWFnZUlkID0gJCh0aGlzKS5wYXJlbnRzKCdbZGF0YS1pbWFnZV0nKS5kYXRhKCdpbWFnZScpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlbW92ZUltYWdlKGltYWdlSWQpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0VGh1bmRlci51dGlsLm1ha2VSZWNhcHRjaGEoe1xyXG5cdFx0XHRjb21wb25lbnROYW1lOiBpbXBsZW1lbnRhdGlvbi5uYW1lLFxyXG5cdFx0XHRidXR0b246ICAgICAgICAkcG9zdFJldmlldyxcclxuXHRcdFx0dmFsaWRhdGU6ICAgICAgdmFsaWRhdGVSZXZpZXcsXHJcblx0XHRcdGNhbGxiYWNrOiAgICAgIHBvc3RSZXZpZXcsXHJcblx0XHR9KTtcclxuXHJcblx0XHRUaHVuZGVyLnV0aWwuaW1hZ2VVcGxvYWRlcihcclxuXHRcdFx0JHdyaXRlUmV2aWV3SW1hZ2VGb3JtLFxyXG5cdFx0XHRpbWFnZSA9PiBhZGRJbWFnZShpbWFnZSksXHJcblx0XHRcdCgpID0+IFRodW5kZXIubm90aWZ5KCdlcnJvcicsIGNvbnRleHQubSgnaW1hZ2VVcGxvYWRGYWlsZWQnKSlcclxuXHRcdCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gY2FuY2VsUmV2aWV3V3JpdGluZyhldmVudCkge1xyXG5cclxuXHRcdFx0aWYgKGV2ZW50KSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0Ly8gUG9zc2libHkgYSBidWcgZnJvbSBCYWJlbD9cclxuXHRcdFx0Ly8gYHJldmlldy5pbWFnZXNgIGFjdHVhbGx5IGNvbnRhaW5zIG11bHRpcGxlIGlkLFxyXG5cdFx0XHQvLyBidXQgYHJlbW92ZUltYWdlKClgIG9ubHkgZ2V0cyBjYWxsZWQgb25jZSBpbiBgLmZvckVhY2hgXHJcblx0XHRcdHJldmlldy5pbWFnZXMuZm9yRWFjaChpbWFnZUlkID0+IHtcclxuXHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHJlbW92ZUltYWdlKGltYWdlSWQpLCAwKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXNldEZvcm0oKTtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdFx0Y29udGV4dC5vcHRpb25zLm9uUmV2aWV3Q2FuY2VsLFxyXG5cdFx0XHRcdCRjb250YWluZXIsXHJcblx0XHRcdFx0Y29udGV4dFxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZXNldEZvcm0oKSB7XHJcblxyXG5cdFx0XHRyZXZpZXcuaW1hZ2VzLmZvckVhY2goaW1hZ2VJZCA9PiByZW1vdmVJbWFnZShpbWFnZUlkLCB0cnVlKSk7XHJcblxyXG5cdFx0XHQkd3JpdGVSZXZpZXdGb3JtLmZpbmQoJ3NlbGVjdCcpLnZhbCg1KTtcclxuXHRcdFx0JHdyaXRlUmV2aWV3Rm9ybS5maW5kKCdpbnB1dFt0eXBlPVwidGV4dFwiXSx0ZXh0YXJlYScpLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0JCh0aGlzKS52YWwobnVsbCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHQkd3JpdGVSZXZpZXdJbWFnZUZvcm0uZmluZCgnaW5wdXRbdHlwZT1cImZpbGVcIl0nKS52YWwobnVsbCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldFJldmlldygpIHtcclxuXHJcblx0XHRcdHJldHVybiAkLmV4dGVuZChcclxuXHRcdFx0XHRUaHVuZGVyLnV0aWwuZm9ybVRvSlNPTigkd3JpdGVSZXZpZXdGb3JtLnNlcmlhbGl6ZUFycmF5KCkpLFxyXG5cdFx0XHRcdHJldmlld1xyXG5cdFx0XHQpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBhZGRJbWFnZShpbWFnZSkge1xyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIHJldmlld1xyXG5cdFx0XHRyZXZpZXcuaW1hZ2VzLnB1c2goaW1hZ2UuX2lkKTtcclxuXHJcblx0XHRcdC8vIFVwZGF0ZSBET01cclxuXHRcdFx0JHdyaXRlUmV2aWV3SW1hZ2VzLmFwcGVuZChgXHJcblx0XHRcdFx0PGRpdiBjbGFzcz1cInRodW5kZXItLXJldmlldy1pbWFnZVwiIGRhdGEtaW1hZ2U9XCIke2ltYWdlLl9pZH1cIj5cclxuXHRcdFx0XHRcdDxpbWcgc3JjPVwiJHtUaHVuZGVyLnV0aWwuaW1hZ2VVUkwoaW1hZ2UsIDEyMCwgMTIwKX1cIj5cclxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwidGh1bmRlci0tZGVsZXRlLXJldmlldy1pbWFnZVwiPiR7Y29udGV4dC5tKCdkZWxldGVJbWFnZScpfTwvc3Bhbj5cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0YC50cmltKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlbW92ZUltYWdlKGltYWdlSWQsIGRvTm90RGVsZXRlID0gZmFsc2UpIHtcclxuXHJcblx0XHRcdC8vIFVwZGF0ZSByZXZpZXdcclxuXHRcdFx0cmV2aWV3LmltYWdlcy5zcGxpY2UocmV2aWV3LmltYWdlcy5pbmRleE9mKGltYWdlSWQpLCAxKTtcclxuXHJcblx0XHRcdC8vIFVwZGF0ZSBET01cclxuXHRcdFx0JHdyaXRlUmV2aWV3SW1hZ2VzLmZpbmQoYFtkYXRhLWltYWdlPVwiJHtpbWFnZUlkfVwiXWApLnJlbW92ZSgpO1xyXG5cclxuXHRcdFx0aWYgKGRvTm90RGVsZXRlKSByZXR1cm47XHJcblxyXG5cdFx0XHQvLyBSZW1vdmUgZnJvbSB0aGUgc3RvcmFnZSAoRmlyZSAmIEZvcmdldClcclxuXHRcdFx0cmV0dXJuIFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0bWV0aG9kOiAnREVMRVRFJyxcclxuXHRcdFx0XHR1cmw6ICAgIGAvdjEvbWUvaW1hZ2VzLyR7aW1hZ2VJZH1gXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHZhbGlkYXRlUmV2aWV3KCkge1xyXG5cclxuXHRcdFx0Y29uc3QgcmV2aWV3ID0gZ2V0UmV2aWV3KCk7XHJcblxyXG5cdFx0XHRpZiAoIXJldmlldy50aXRsZSkge1xyXG5cdFx0XHRcdFRodW5kZXIubm90aWZ5KCdlcnJvcicsIGNvbnRleHQubSgndGl0bGVSZXF1aXJlZCcpKTtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHBvc3RSZXZpZXcodG9rZW4sIHJlc2V0UmVjYXB0Y2hhKSB7XHJcblxyXG5cdFx0XHRjb25zdCByZXNldFN0YXRlID0gKCkgPT4gcmVzZXRSZWNhcHRjaGEgJiYgcmVzZXRSZWNhcHRjaGEoKTtcclxuXHJcblx0XHRcdHJldHVybiBjcmVhdGVSZXZpZXcoKVxyXG5cdFx0XHRcdFx0LnRoZW4ocmV2aWV3ID0+IGZldGNoUmV2aWV3KHJldmlldykpXHJcblx0XHRcdFx0XHQudGhlbihyZXZpZXcgPT4gZG9uZShyZXZpZXcpKTtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGRvbmUocmV2aWV3KSB7XHJcblxyXG5cdFx0XHRcdHJlc2V0Rm9ybSgpO1xyXG5cclxuXHRcdFx0XHRUaHVuZGVyLm5vdGlmeSgnc3VjY2VzcycsIGNvbnRleHQubSgncmV2aWV3UG9zdFN1Y2Nlc3MnKSk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25SZXZpZXdQb3N0LFxyXG5cdFx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdGNvbnRleHQsXHJcblx0XHRcdFx0XHRyZXZpZXdcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gY3JlYXRlUmV2aWV3KCkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdFx0XHQnbm90LXB1cmNoYXNlZC1wcm9kdWN0JzogY29udGV4dC5tKCdub3RQdXJjaGFzZWRQcm9kdWN0JyksXHJcblx0XHRcdFx0XHRkZWZhdWx0OiAgICAgICAgICAgICAgICAgY29udGV4dC5tKCdyZXZpZXdQb3N0RmFpbGVkJylcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRcdG1ldGhvZDogICAgJ1BPU1QnLFxyXG5cdFx0XHRcdFx0dXJsOiAgICAgICAnL3YxL21lL3Byb2R1Y3RzL3Jldmlld3MnLFxyXG5cdFx0XHRcdFx0ZGF0YTogICAgICBnZXRSZXZpZXcoKSxcclxuXHRcdFx0XHRcdHJlY2FwdGNoYTogdG9rZW4sXHJcblx0XHRcdFx0fSkudGhlbihudWxsLCBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdFx0ZXJyb3JzLFxyXG5cdFx0XHRcdFx0cmVzZXRTdGF0ZVxyXG5cdFx0XHRcdCkpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gZmV0Y2hSZXZpZXcocmV2aWV3KSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgncmV2aWV3UmVhZEZhaWxlZCcpXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0XHRtZXRob2Q6ICdHRVQnLFxyXG5cdFx0XHRcdFx0dXJsOiAgICBgL3YxL3Byb2R1Y3RzL3Jldmlld3MvcHVibGlzaGVkLyR7cmV2aWV3Ll9pZH1gLFxyXG5cdFx0XHRcdFx0cXVlcnk6ICB7IGZpZWxkczogcmV2aWV3RmllbGRzLmpvaW4oJywnKSB9XHJcblx0XHRcdFx0fSkudGhlbihudWxsLCBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdFx0ZXJyb3JzLFxyXG5cdFx0XHRcdFx0cmVzZXRTdGF0ZVxyXG5cdFx0XHRcdCkpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xyXG5cclxufTsiLCJjb25zdCBnZXQgPSByZXF1aXJlKCdsb2Rhc2guZ2V0Jyk7XHJcbmNvbnN0IHNldCA9IHJlcXVpcmUoJ2xvZGFzaC5zZXQnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGh1bmRlciA9PiB7XHJcblxyXG5cdGNvbnN0IHJldmlld1F1ZXJ5ID0gc2hvd1Byb2R1Y3QgPT4gKHtcclxuXHRcdGZpZWxkczogW1xyXG5cdFx0XHQnY3VzdG9tZXInLFxyXG5cdFx0XHQndGl0bGUnLFxyXG5cdFx0XHQnYm9keScsXHJcblx0XHRcdCdpbWFnZXMnLFxyXG5cdFx0XHQncmF0aW5nJyxcclxuXHRcdFx0J2hlbHBlZCcsXHJcblx0XHRcdCdmbGFnZ2VkJyxcclxuXHRcdFx0J3RvdGFsQ29tbWVudCcsXHJcblx0XHRcdCdjcmVhdGVkQXQnLFxyXG5cdFx0XS5jb25jYXQoc2hvd1Byb2R1Y3QgPyAncHJvZHVjdCcgOiBbXSkuam9pbignLCcpLFxyXG5cdFx0ZW1iZWQ6ICcrcHJvZHVjdC50aHVtYm5haWwnXHJcblx0fSk7XHJcblxyXG5cdC8vIEltcGxlbWVudGF0aW9uXHJcblx0Y29uc3QgaW1wbGVtZW50YXRpb24gPSB7XHJcblx0XHRuYW1lOiAncHJvZHVjdC1yZXZpZXcnXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ub3B0aW9ucyA9ICgpID0+ICh7XHJcblx0XHRyZXZpZXc6ICAgICAgICAgICAgbnVsbCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpZXcgSUQgb3IgcmV2aWV3IG9iamVjdFxyXG5cdFx0dXNlQ3VzdG9tZXJBdmF0YXI6IFRodW5kZXIub3B0aW9ucy5jdXN0b21lckF2YXRhciwgICAgICAgLy8gVXNlIGN1c3RvbWVyIGF2YXRhclxyXG5cdFx0dXNlQm9keUV4Y2VycHQ6ICAgIDE0MCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQm9keSBleGNlcnB0IGxlbmd0aCB8fCBmYWxzZVxyXG5cdFx0dXNlUmF0aW5nOiAgICAgICAgIFRodW5kZXIub3B0aW9ucy5wcm9kdWN0UmV2aWV3UmF0aW5nLCAgLy8gVXNlIHJhdGluZz9cclxuXHRcdHVzZUhlbHBWb3RlOiAgICAgICB0cnVlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBoZWxwZnVsIHZvdGVzP1xyXG5cdFx0dXNlRmxhZzogICAgICAgICAgIHRydWUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGZsYWc/XHJcblx0XHR1c2VDb21tZW50czogICAgICAgVGh1bmRlci5vcHRpb25zLnByb2R1Y3RSZXZpZXdDb21tZW50LCAvLyBVc2UgcmV2aWV3IGNvbW1lbnRzP1xyXG5cdFx0Y29uZmlybU9uRGVsZXRlOiAgIFRodW5kZXIub3B0aW9ucy5jb25maXJtYXRpb24ucmV2aWV3RGVsZXRlLCAvLyBXaGV0aGVyIHRvIGNvbmZpcm0gYmVmb3JlIGRlbGV0aW5nIGEgcmV2aWV3XHJcblx0XHRzaG93UHJvZHVjdDogICAgICAgZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHByb2R1Y3QgZGV0YWlsP1xyXG5cdFx0Ly8gTG9hZCAmIFNob3cgY29tbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nP1xyXG5cdFx0Ly8gKElmIGl0J3MgYW4gb2JqZWN0LCBpdCB3aWxsIGJlIHBhc3NlZCBhcyBhbiBvcHRpb24gdG8gYHByb2R1Y3QtcmV2aWV3LWNvbW1lbnRzYCBjb21wb25lbnQpXHJcblx0XHRzaG93Q29tbWVudHM6ICAgICAgZmFsc2UsXHJcblxyXG5cdFx0b25EZWxldGU6IGZ1bmN0aW9uKCRjb250YWluZXIsIGNvbnRleHQpIHtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLm5vdGlmeSgnc3VjY2VzcycsIGNvbnRleHQubSgnZGVsZXRlU3VjY2VzcycpKTtcclxuXHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLnByZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcblxyXG5cdFx0Y29uc3QgcmV2aWV3ID0gY29udGV4dC5vcHRpb25zLnJldmlldztcclxuXHJcblx0XHRpZiAodHlwZW9mIHJldmlldyA9PT0gJ29iamVjdCcpIHtcclxuXHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBzZXRSZXZpZXcocmV2aWV3KSk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0ZGVmYXVsdDogY29udGV4dC5tKCdyZXZpZXdSZWFkRmFpbGVkJylcclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdG1ldGhvZDogJ0dFVCcsXHJcblx0XHRcdHVybDogICAgYC92MS9wcm9kdWN0cy9yZXZpZXdzL3B1Ymxpc2hlZC8ke3Jldmlld31gLFxyXG5cdFx0XHRxdWVyeTogIHJldmlld1F1ZXJ5KGNvbnRleHQub3B0aW9ucy5zaG93UHJvZHVjdClcclxuXHRcdH0pLnRoZW4ocmV2aWV3ID0+IHtcclxuXHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBzZXRSZXZpZXcocmV2aWV3KSk7XHJcblxyXG5cdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRlcnJvcnMsXHJcblx0XHRcdGNhbGxiYWNrXHJcblx0XHQpKTtcclxuXHJcblx0XHRmdW5jdGlvbiBzZXRSZXZpZXcocmV2aWV3KSB7XHJcblx0XHRcdHJldHVybiBzZXQoY29udGV4dCwgJ3JldmlldycsIGJ1aWxkUmV2aWV3KHJldmlldywgY29udGV4dC5vcHRpb25zLnVzZUJvZHlFeGNlcnB0KSk7XHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLmluaXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcblxyXG5cdFx0Y29uc3QgJGNvbnRhaW5lciA9ICQodGhpcyk7XHJcblx0XHRjb25zdCAkcmV2aWV3ID0gJGNvbnRhaW5lci5maW5kKCcudGh1bmRlci0tcHJvZHVjdC1yZXZpZXcnKTtcclxuXHRcdGNvbnN0ICRpbWFnZUZvcm0gPSAkY29udGFpbmVyLmZpbmQoJy50aHVuZGVyLS1lZGl0LXJldmlldy1pbWFnZS1mb3JtJyk7XHJcblx0XHRjb25zdCAkcmV2aWV3SW1hZ2VzID0gJGNvbnRhaW5lci5maW5kKCcudGh1bmRlci0tcmV2aWV3LWltYWdlcycpO1xyXG5cclxuXHRcdCRjb250YWluZXIub24oJ2NsaWNrJywgJy50aHVuZGVyLS1oZWxwZWQtdm90ZScsIGhlbHBWb3RlKTtcclxuXHRcdCRjb250YWluZXIub24oJ2NsaWNrJywgJy50aHVuZGVyLS1mbGFnJywgZmxhZyk7XHJcblx0XHQkY29udGFpbmVyLm9uKCdjbGljaycsICcudGh1bmRlci0tZWRpdC1wcm9kdWN0LXJldmlldycsIGVkaXRSZXZpZXcpO1xyXG5cdFx0JGNvbnRhaW5lci5vbignY2xpY2snLCAnLnRodW5kZXItLWRlbGV0ZS1wcm9kdWN0LXJldmlldycsIGRlbGV0ZVJldmlldyk7XHJcblx0XHQkY29udGFpbmVyLm9uKCdjbGljaycsICcudGh1bmRlci0tZGVsZXRlLXJldmlldy1pbWFnZScsIGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0Y29uc3QgJGltYWdlTGlzdCA9ICQodGhpcykucGFyZW50cygnLnRodW5kZXItLXJldmlldy1pbWFnZXMnKTtcclxuXHRcdFx0Y29uc3QgaW1hZ2VJZCA9ICQodGhpcykucGFyZW50cygnW2RhdGEtaW1hZ2VdJykuZGF0YSgnaW1hZ2UnKTtcclxuXHJcblx0XHRcdHJldHVybiByZW1vdmVJbWFnZSgkaW1hZ2VMaXN0LCBjb250ZXh0LnJldmlldywgaW1hZ2VJZCk7XHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0JGNvbnRhaW5lci5vbignY2xpY2snLCAnLnRodW5kZXItLXJlYWQtbW9yZScsIGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0Y29uc3QgJHJldmlld0JvZHkgPSAkKHRoaXMpLnBhcmVudHMoJy50aHVuZGVyLS1wcm9kdWN0LXJldmlldy1ib2R5Jyk7XHJcblxyXG5cdFx0XHQkcmV2aWV3Qm9keS5odG1sKGNvbnRleHQucmV2aWV3LmJvZHkpO1xyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdCRjb250YWluZXIub24oJ2NsaWNrJywgJy50aHVuZGVyLS1zaG93LXByb2R1Y3QtcmV2aWV3LWNvbW1lbnQnLCBzaG93Q29tbWVudHMpO1xyXG5cclxuXHRcdFRodW5kZXIudXRpbC5pbWFnZVVwbG9hZGVyKFxyXG5cdFx0XHQkaW1hZ2VGb3JtLFxyXG5cdFx0XHRpbWFnZSA9PiBhZGRJbWFnZSgkcmV2aWV3SW1hZ2VzLCBjb250ZXh0LnJldmlldywgaW1hZ2UpLFxyXG5cdFx0XHQoKSA9PiBUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBjb250ZXh0Lm0oJ2ltYWdlVXBsb2FkRmFpbGVkJykpXHJcblx0XHQpO1xyXG5cclxuXHRcdGlmIChjb250ZXh0Lm9wdGlvbnMudXNlQ29tbWVudHMgJiZcclxuXHRcdFx0Y29udGV4dC5vcHRpb25zLnNob3dDb21tZW50cykge1xyXG5cdFx0XHQvLyBJZiBgc2hvd0NvbW1lbnRzYCBvcHRpb24gaXMgc2V0IHRvIGB0cnVlYCxcclxuXHRcdFx0Ly8gcmVuZGVyIGNvbW1lbnRzIHdoZW4gdGhlIGNvbXBvbmVudCBpbml0aWF0ZXMuXHJcblx0XHRcdHNob3dDb21tZW50cygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHZhbGlkYXRlUmV2aWV3KHJldmlldykge1xyXG5cclxuXHRcdFx0aWYgKCFyZXZpZXcudGl0bGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gJ3RpdGxlUmVxdWlyZWQnO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBhZGRJbWFnZSgkaW1hZ2VMaXN0LCByZXZpZXcsIGltYWdlKSB7XHJcblxyXG5cdFx0XHQvLyBVcGRhdGUgcmV2aWV3XHJcblx0XHRcdHJldmlldy5pbWFnZXMucHVzaChpbWFnZSk7XHJcblxyXG5cdFx0XHQvLyBVcGRhdGUgRE9NXHJcblx0XHRcdCRpbWFnZUxpc3QuYXBwZW5kKGBcclxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwidGh1bmRlci0tcmV2aWV3LWltYWdlXCIgZGF0YS1pbWFnZT1cIiR7aW1hZ2UuX2lkfVwiPlxyXG5cdFx0XHRcdFx0PGltZyBzcmM9XCIke1RodW5kZXIudXRpbC5pbWFnZVVSTChpbWFnZSwgMTIwLCAxMjApfVwiPlxyXG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ0aHVuZGVyLS1kZWxldGUtcmV2aWV3LWltYWdlXCI+JHtjb250ZXh0Lm0oJ2RlbGV0ZUltYWdlJyl9PC9zcGFuPlxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRgLnRyaW0oKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlSW1hZ2UoJGltYWdlTGlzdCwgcmV2aWV3LCBpbWFnZUlkKSB7XHJcblxyXG5cdFx0XHRjb25zdCBpbWFnZSA9IHJldmlldy5pbWFnZXMuZmluZChpbWFnZSA9PiBpbWFnZSAmJiAoaW1hZ2UuX2lkID09PSBpbWFnZUlkKSk7XHJcblxyXG5cdFx0XHRpZiAoIWltYWdlKSByZXR1cm47XHJcblxyXG5cdFx0XHQvLyBVcGRhdGUgcmV2aWV3XHJcblx0XHRcdHJldmlldy5pbWFnZXMuc3BsaWNlKHJldmlldy5pbWFnZXMuaW5kZXhPZihpbWFnZSksIDEpO1xyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIERPTVxyXG5cdFx0XHQkaW1hZ2VMaXN0LmZpbmQoYFtkYXRhLWltYWdlPVwiJHtpbWFnZUlkfVwiXWApLnJlbW92ZSgpO1xyXG5cclxuXHRcdFx0Ly8gUmVtb3ZlIGZyb20gdGhlIHN0b3JhZ2UgKEZpcmUgJiBGb3JnZXQpXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ0RFTEVURScsXHJcblx0XHRcdFx0dXJsOiAgICBgL3YxL21lL2ltYWdlcy8ke2ltYWdlSWR9YFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBoZWxwVm90ZShldmVudCkge1xyXG5cclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcblx0XHRcdGNvbnN0IHJldmlldyA9IGNvbnRleHQucmV2aWV3O1xyXG5cdFx0XHRjb25zdCB1cERvd24gPSAkKHRoaXMpLmRhdGEoJ3R5cGUnKTtcclxuXHJcblx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHR1bmF1dGhvcml6ZWQ6ICAgICAgeyB0eXBlOiAnaW5mbycsIG1lc3NhZ2U6IGNvbnRleHQubSgnbG9naW5SZXF1aXJlZCcpIH0sXHJcblx0XHRcdFx0J2R1cGxpY2F0ZWQtdm90ZSc6IGNvbnRleHQubSgnZHVwbGljYXRlZFZvdGUnKSxcclxuXHRcdFx0XHRkZWZhdWx0OiAgICAgICAgICAgY29udGV4dC5tKCdoZWxwVm90ZUZhaWxlZCcpXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRtZXRob2Q6ICdQT1NUJyxcclxuXHRcdFx0XHR1cmw6ICAgIGAvdjEvbWUvcHJvZHVjdHMvcmV2aWV3cy8ke3Jldmlldy5faWR9L2hlbHBlZC8ke3VwRG93bn1gLFxyXG5cdFx0XHR9KS50aGVuKCgpID0+IHtcclxuXHRcdFx0XHRyZXR1cm4gVGh1bmRlci5ub3RpZnkoJ3N1Y2Nlc3MnLCBjb250ZXh0Lm0oJ2hlbHBWb3RlU3VjY2VzcycpKTtcclxuXHRcdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRcdGVyci5yZXNwb25zZUpTT04sXHJcblx0XHRcdFx0ZXJyb3JzXHJcblx0XHRcdCkpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBmbGFnKGV2ZW50KSB7XHJcblxyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgcmV2aWV3ID0gY29udGV4dC5yZXZpZXc7XHJcblxyXG5cdFx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdFx0dW5hdXRob3JpemVkOiAgICAgIHsgdHlwZTogJ2luZm8nLCBtZXNzYWdlOiBjb250ZXh0Lm0oJ2xvZ2luUmVxdWlyZWQnKSB9LFxyXG5cdFx0XHRcdCdkdXBsaWNhdGVkLWZsYWcnOiBjb250ZXh0Lm0oJ2R1cGxpY2F0ZWRGbGFnJyksXHJcblx0XHRcdFx0ZGVmYXVsdDogICAgICAgICAgIGNvbnRleHQubSgnZmxhZ0ZhaWxlZCcpXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRtZXRob2Q6ICdQT1NUJyxcclxuXHRcdFx0XHR1cmw6ICAgIGAvdjEvbWUvcHJvZHVjdHMvcmV2aWV3cy8ke3Jldmlldy5faWR9L2ZsYWdzYCxcclxuXHRcdFx0fSkudGhlbigoKSA9PiB7XHJcblx0XHRcdFx0cmV0dXJuIFRodW5kZXIubm90aWZ5KCdzdWNjZXNzJywgY29udGV4dC5tKCdmbGFnU3VjY2VzcycpKTtcclxuXHRcdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRcdGVyci5yZXNwb25zZUpTT04sXHJcblx0XHRcdFx0ZXJyb3JzXHJcblx0XHRcdCkpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBlZGl0UmV2aWV3KGV2ZW50KSB7XHJcblxyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgaXNFZGl0aW5nID0gJHJldmlldy5kYXRhKCdlZGl0aW5nJykgfHwgZmFsc2U7XHJcblxyXG5cdFx0XHRpZiAoaXNFZGl0aW5nKSB7XHJcblx0XHRcdFx0ZW5kUmV2aWV3RWRpdGluZygpO1xyXG5cdFx0XHRcdCRyZXZpZXcucmVtb3ZlQ2xhc3MoJ2VkaXRpbmcnKTtcclxuXHRcdFx0XHQkKHRoaXMpLnRleHQoY29udGV4dC5tKCdlZGl0UmV2aWV3JykpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YXJ0UmV2aWV3RWRpdGluZygpO1xyXG5cdFx0XHRcdCRyZXZpZXcuYWRkQ2xhc3MoJ2VkaXRpbmcnKTtcclxuXHRcdFx0XHQkKHRoaXMpLnRleHQoY29udGV4dC5tKCdzYXZlUmV2aWV3JykpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQkcmV2aWV3LmRhdGEoJ2VkaXRpbmcnLCAhaXNFZGl0aW5nKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc3RhcnRSZXZpZXdFZGl0aW5nKCkge1xyXG5cclxuXHRcdFx0Y29uc3QgcmV2aWV3ID0gY29udGV4dC5yZXZpZXc7XHJcblxyXG5cdFx0XHRjb25zdCAkcmF0aW5nID0gJGNvbnRhaW5lci5maW5kKCcudGh1bmRlci0tcmV2aWV3LXN0YXJzJyk7XHJcblx0XHRcdGNvbnN0ICR0aXRsZSA9ICRjb250YWluZXIuZmluZCgnLnRodW5kZXItLXByb2R1Y3QtcmV2aWV3LXRpdGxlJyk7XHJcblx0XHRcdGNvbnN0ICRib2R5ID0gJGNvbnRhaW5lci5maW5kKCcudGh1bmRlci0tcHJvZHVjdC1yZXZpZXctYm9keScpO1xyXG5cclxuXHRcdFx0Y29uc3QgJG5ld1JhdGluZyA9XHJcblx0XHRcdFx0JChUaHVuZGVyLnVpKCdyZXZpZXctc3Rhci1yYXRpbmcnKSgkcmF0aW5nLmRhdGEoJ3JhdGluZycpKSlcclxuXHRcdFx0XHRcdC5hZGRDbGFzcygkcmF0aW5nLmF0dHIoJ2NsYXNzJykpO1xyXG5cdFx0XHRjb25zdCAkbmV3VGl0bGUgPSAkKGA8aW5wdXQgY2xhc3M9XCIkeyR0aXRsZS5hdHRyKCdjbGFzcycpfVwiIHR5cGU9XCJ0ZXh0XCIgdmFsdWU9XCIke3Jldmlldy50aXRsZX1cIiByZXF1aXJlZD5gKTtcclxuXHRcdFx0Y29uc3QgJG5ld0JvZHkgPSAkKGA8dGV4dGFyZWEgY2xhc3M9XCIkeyRib2R5LmF0dHIoJ2NsYXNzJyl9XCI+JHtyZXZpZXcuYm9keX08L3RleHRhcmVhPmApO1xyXG5cclxuXHRcdFx0JHJhdGluZy5yZXBsYWNlV2l0aCgkbmV3UmF0aW5nKTtcclxuXHRcdFx0JHRpdGxlLnJlcGxhY2VXaXRoKCRuZXdUaXRsZSk7XHJcblx0XHRcdCRib2R5LnJlcGxhY2VXaXRoKCRuZXdCb2R5KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZW5kUmV2aWV3RWRpdGluZygpIHtcclxuXHJcblx0XHRcdGNvbnN0IHJldmlldyA9IGNvbnRleHQucmV2aWV3O1xyXG5cclxuXHRcdFx0Y29uc3QgZGF0YSA9IHtcclxuXHRcdFx0XHRyYXRpbmc6ICRjb250YWluZXIuZmluZCgnLnRodW5kZXItLXJldmlldy1zdGFycycpLnZhbCgpLFxyXG5cdFx0XHRcdHRpdGxlOiAgJGNvbnRhaW5lci5maW5kKCcudGh1bmRlci0tcHJvZHVjdC1yZXZpZXctdGl0bGUnKS52YWwoKSxcclxuXHRcdFx0XHRib2R5OiAgICRjb250YWluZXIuZmluZCgnLnRodW5kZXItLXByb2R1Y3QtcmV2aWV3LWJvZHknKS52YWwoKSxcclxuXHRcdFx0XHRpbWFnZXM6ICRjb250YWluZXIuZmluZCgnLnRodW5kZXItLXJldmlldy1pbWFnZXMgW2RhdGEtaW1hZ2VdJykubWFwKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuICQodGhpcykuZGF0YSgnaW1hZ2UnKTtcclxuXHRcdFx0XHR9KS5nZXQoKSxcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGNvbnN0IGVycm9yQ29kZSA9IHZhbGlkYXRlUmV2aWV3KGRhdGEpO1xyXG5cclxuXHRcdFx0aWYgKGVycm9yQ29kZSkge1xyXG5cdFx0XHRcdHJldHVybiBUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBjb250ZXh0Lm0oZXJyb3JDb2RlKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB1cGRhdGVSZXZpZXcoZGF0YSlcclxuXHRcdFx0XHQudGhlbihyZXZpZXcgPT4gZmV0Y2hSZXZpZXcocmV2aWV3KSlcclxuXHRcdFx0XHQudGhlbihyZXZpZXcgPT4gZG9uZShyZXZpZXcpKTtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGRvbmUocmV2aWV3KSB7XHJcblxyXG5cdFx0XHRcdGNvbnRleHQucmV2aWV3ID0gcmV2aWV3O1xyXG5cclxuXHRcdFx0XHRUaHVuZGVyLnJlbmRlcigkY29udGFpbmVyLCBpbXBsZW1lbnRhdGlvbi5uYW1lLCBjb250ZXh0KTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRodW5kZXIubm90aWZ5KCdzdWNjZXNzJywgY29udGV4dC5tKCdyZXZpZXdTYXZlU3VjY2VzcycpKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIHVwZGF0ZVJldmlldyhkYXRhKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgncmV2aWV3U2F2ZUZhaWxlZCcpXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0XHRtZXRob2Q6ICdQVVQnLFxyXG5cdFx0XHRcdFx0dXJsOiAgICBgL3YxL21lL3Byb2R1Y3RzL3Jldmlld3MvJHtyZXZpZXcuX2lkfWAsXHJcblx0XHRcdFx0XHRkYXRhOiAgIGRhdGFcclxuXHRcdFx0XHR9KS50aGVuKG51bGwsIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0XHRcdGVyci5yZXNwb25zZUpTT04sXHJcblx0XHRcdFx0XHRlcnJvcnNcclxuXHRcdFx0XHQpKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGZldGNoUmV2aWV3KHJldmlldykge1xyXG5cclxuXHRcdFx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdFx0XHRkZWZhdWx0OiBjb250ZXh0Lm0oJ3Jldmlld1JlYWRGYWlsZWQnKVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdFx0bWV0aG9kOiAnR0VUJyxcclxuXHRcdFx0XHRcdHVybDogICAgYC92MS9wcm9kdWN0cy9yZXZpZXdzL3B1Ymxpc2hlZC8ke3Jldmlldy5faWR9YCxcclxuXHRcdFx0XHRcdHF1ZXJ5OiAgcmV2aWV3UXVlcnkoY29udGV4dC5vcHRpb25zLnNob3dQcm9kdWN0KVxyXG5cdFx0XHRcdH0pLnRoZW4obnVsbCwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0XHRcdGVycm9yc1xyXG5cdFx0XHRcdCkpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBkZWxldGVSZXZpZXcoZXZlbnQpIHtcclxuXHJcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0XHRjb25zdCByZW1vdmVSZXZpZXcgPSAoKSA9PiB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHJldmlldyA9IGNvbnRleHQucmV2aWV3O1xyXG5cclxuXHRcdFx0XHRkZWxldGVSZXZpZXdJbWFnZXMocmV2aWV3KTtcclxuXHJcblx0XHRcdFx0Y29uc3QgZXJyb3JzID0ge1xyXG5cdFx0XHRcdFx0ZGVmYXVsdDogY29udGV4dC5tKCdkZWxldGVGYWlsZWQnKVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdFx0bWV0aG9kOiAnREVMRVRFJyxcclxuXHRcdFx0XHRcdHVybDogICAgYC92MS9tZS9wcm9kdWN0cy9yZXZpZXdzLyR7cmV2aWV3Ll9pZH1gLFxyXG5cdFx0XHRcdH0pLnRoZW4oKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdC8vIEhpZGUgdGhlIHJldmlld1xyXG5cdFx0XHRcdFx0JGNvbnRhaW5lci5hZGRDbGFzcygnaGlkZGVuJykuaGlkZSgpO1xyXG5cclxuXHRcdFx0XHRcdC8vIEhpZGUgY29tbWVudHMgb2YgdGhlIHJldmlld1xyXG5cdFx0XHRcdFx0JGNvbnRhaW5lci5uZXh0KCcudGh1bmRlci0tcmV2aWV3LWNvbW1lbnRzLWNvbnRhaW5lcicpLmFkZENsYXNzKCdoaWRkZW4nKS5oaWRlKCk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIFRodW5kZXIuZXhlY3V0ZShcclxuXHRcdFx0XHRcdFx0Y29udGV4dC5vcHRpb25zLm9uRGVsZXRlLFxyXG5cdFx0XHRcdFx0XHQkY29udGFpbmVyLFxyXG5cdFx0XHRcdFx0XHRjb250ZXh0XHJcblx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHR9LCBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdFx0ZXJyb3JzXHJcblx0XHRcdFx0KSk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0aWYgKCFjb250ZXh0Lm9wdGlvbnMuY29uZmlybU9uRGVsZXRlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlbW92ZVJldmlldygpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5wbHVnaW5zLmNvbmZpcm1hdGlvbihcclxuXHRcdFx0XHRjb250ZXh0Lm0oJ2RlbGV0ZUNvbmZpcm0nKSxcclxuXHRcdFx0XHQoKSA9PiByZW1vdmVSZXZpZXcoKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBkZWxldGVSZXZpZXdJbWFnZXMocmV2aWV3KSB7XHJcblxyXG5cdFx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdFx0ZGVmYXVsdDogY29udGV4dC5tKCdpbWFnZURlbGV0ZUZhaWxlZCcpXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRyZXR1cm4gJC53aGVuKFxyXG5cdFx0XHRcdC4uLnJldmlldy5pbWFnZXMubWFwKGltYWdlID0+IFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0XHRtZXRob2Q6ICdERUxFVEUnLFxyXG5cdFx0XHRcdFx0dXJsOiAgICBgL3YxL21lL2ltYWdlcy8ke2ltYWdlLl9pZCB8fCBpbWFnZX1gXHJcblx0XHRcdFx0fSkpXHJcblx0XHRcdCkudGhlbihudWxsLCBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0XHRlcnJvcnNcclxuXHRcdFx0KSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNob3dDb21tZW50cygpIHtcclxuXHJcblx0XHRcdGlmIChjb250ZXh0LmNvbW1lbnRzTG9hZGVkKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb250ZXh0LmNvbW1lbnRzTG9hZGVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdGNvbnN0IHJldmlldyA9IGNvbnRleHQucmV2aWV3O1xyXG5cclxuXHRcdFx0Y29uc3QgJGNvbW1lbnRzQ29udGFpbmVyID0gJChgPGRpdiBjbGFzcz1cInRodW5kZXItLXJldmlldy1jb21tZW50cy1jb250YWluZXJcIiBkYXRhLXJldmlldz1cIiR7cmV2aWV3Ll9pZH1cIj48L2Rpdj5gKTtcclxuXHJcblx0XHRcdCRjb21tZW50c0NvbnRhaW5lci5pbnNlcnRBZnRlcigkY29udGFpbmVyKTtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlbmRlcihcclxuXHRcdFx0XHQkY29tbWVudHNDb250YWluZXIsXHJcblx0XHRcdFx0J3Byb2R1Y3QtcmV2aWV3LWNvbW1lbnRzJyxcclxuXHRcdFx0XHQkLmV4dGVuZChcclxuXHRcdFx0XHRcdC8vIFVzZSBgc2hvd0NvbW1lbnRzYCBhcyBhbiBvcHRpb24gd2hlbiBpdCdzIGFuIG9iamVjdC5cclxuXHRcdFx0XHRcdHR5cGVvZiBjb250ZXh0Lm9wdGlvbnMuc2hvd0NvbW1lbnRzID09PSAnb2JqZWN0JyA/XHJcblx0XHRcdFx0XHRcdGNvbnRleHQub3B0aW9ucy5zaG93Q29tbWVudHMgOlxyXG5cdFx0XHRcdFx0XHR7fSxcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0cmV2aWV3OiByZXZpZXcuX2lkLFxyXG5cdFx0XHRcdFx0XHRoYXNOb0NvbW1lbnRzOiBjb250ZXh0LnJldmlldy50b3RhbENvbW1lbnQucmF3ID09PSAwLFxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdClcclxuXHRcdFx0KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcclxuXHJcblx0ZnVuY3Rpb24gYnVpbGRSZXZpZXcocmV2aWV3LCB1c2VCb2R5RXhjZXJwdCkge1xyXG5cclxuXHRcdGNvbnN0IGN1c3RvbWVyID0gZ2V0KFRodW5kZXIuYXV0aGVudGljYXRlZCgnY3VzdG9tZXInKSwgJ3N1YicsICd1bmF1dGhlbnRpY2F0ZWQnKTtcclxuXHJcblx0XHRyZXZpZXcuZWRpdGFibGUgPSBnZXQocmV2aWV3LCAnY3VzdG9tZXIuX2lkJykgPT09IGN1c3RvbWVyO1xyXG5cdFx0cmV2aWV3LmV4Y2VycHQgPSBUaHVuZGVyLnV0aWwuZXhjZXJwdChyZXZpZXcuYm9keSwgdXNlQm9keUV4Y2VycHQpIHx8ICcnO1xyXG5cdFx0cmV2aWV3LmJvZHkgPSByZXZpZXcuYm9keSB8fCAnJztcclxuXHJcblx0XHRyZXR1cm4gcmV2aWV3O1xyXG5cclxuXHR9XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gVGh1bmRlciA9PiB7XHJcblxyXG5cdGNvbnN0IGltcGxlbWVudGF0aW9uID0ge1xyXG5cdFx0bmFtZTogJ3Byb2R1Y3QtcmV2aWV3cydcclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5vcHRpb25zID0gKCkgPT4gKHtcclxuXHRcdHByb2R1Y3Q6ICAgICAgICAgICBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb2R1Y3QgSURcclxuXHRcdHBhZ2U6ICAgICAgICAgICAgICAxLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoaWNoIHBhZ2Ugb2YgcHJvZHVjdHM/XHJcblx0XHRsaW1pdDogICAgICAgICAgICAgMTAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIb3cgbWFueSBwcm9kdWN0cyBhdCBvbmNlP1xyXG5cdFx0c29ydDogICAgICAgICAgICAgICctY3JlYXRlZEF0JywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBzb3J0IHZhbHVlXHJcblx0XHRwcm9kdWN0UmF0aW5nOiAgICAgbnVsbCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9kdWN0IHJhdGluZz9cclxuXHRcdHVzZUN1c3RvbWVyQXZhdGFyOiBUaHVuZGVyLm9wdGlvbnMuY3VzdG9tZXJBdmF0YXIsICAgICAgIC8vIFVzZSBjdXN0b21lciBhdmF0YXI/XHJcblx0XHR1c2VCb2R5RXhjZXJwdDogICAgMTQwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCb2R5IGV4Y2VycHQgbGVuZ3RoIHx8IGZhbHNlXHJcblx0XHR1c2VSYXRpbmc6ICAgICAgICAgKCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgcmF0aW5nP1xyXG5cdFx0XHRUaHVuZGVyLm9wdGlvbnMucHJvZHVjdFJldmlldyAmJlxyXG5cdFx0XHRUaHVuZGVyLm9wdGlvbnMucHJvZHVjdFJldmlld1JhdGluZ1xyXG5cdFx0KSxcclxuXHRcdHVzZUhlbHBWb3RlOiAgICAgICB0cnVlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBoZWxwZnVsIHZvdGVzP1xyXG5cdFx0dXNlRmxhZzogICAgICAgICAgIHRydWUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGZsYWc/XHJcblx0XHR1c2VDb21tZW50czogICAgICAgVGh1bmRlci5vcHRpb25zLnByb2R1Y3RSZXZpZXdDb21tZW50LCAvLyBVc2UgY29tbWVudHM/XHJcblx0XHR1c2VQYWdpbmF0aW9uOiAgICAgdHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgUGFnaW5hdGlvbj9cclxuXHJcblx0XHRvblVuYXV0aGVudGljYXRlZFdyaXRlUmV2aWV3OiBmdW5jdGlvbigkY29udGFpbmVyLCBjb250ZXh0KSB7XHJcblx0XHRcdHJldHVybiBUaHVuZGVyLm5vdGlmeSgnaW5mbycsIGNvbnRleHQubSgnbG9naW5SZXF1aXJlZCcpKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ucHJlID0gZnVuY3Rpb24oY29udGV4dCwgY2FsbGJhY2spIHtcclxuXHJcblx0XHRjb25zdCBlcnJvcnMgPSB7XHJcblx0XHRcdGRlZmF1bHQ6IGNvbnRleHQubSgncmV2aWV3TGlzdEZhaWxlZCcpXHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiAkLndoZW4oXHJcblx0XHRcdGZldGNoUmV2aWV3cygpLFxyXG5cdFx0XHRjb3VudFJldmlld3MoKVxyXG5cdFx0KS50aGVuKChyZXZpZXdzLCBjb3VudCkgPT4gY2FsbGJhY2sobnVsbCwgJC5leHRlbmQoY29udGV4dCwge1xyXG5cdFx0XHRyZXZpZXdzOiByZXZpZXdzWzBdIHx8IFtdLFxyXG5cdFx0XHRjb3VudDogICBjb3VudCA/IGNvdW50WzBdLmNvdW50IDogbnVsbCxcclxuXHRcdH0pKSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRlcnJvcnMsXHJcblx0XHRcdGNhbGxiYWNrXHJcblx0XHQpKTtcclxuXHJcblx0XHRmdW5jdGlvbiBmZXRjaFJldmlld3MoKSB7XHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ0dFVCcsXHJcblx0XHRcdFx0dXJsOiAnL3YxL3Byb2R1Y3RzL3Jldmlld3MvcHVibGlzaGVkJyxcclxuXHRcdFx0XHRxdWVyeToge1xyXG5cdFx0XHRcdFx0cHJvZHVjdDogY29udGV4dC5vcHRpb25zLnByb2R1Y3QsXHJcblx0XHRcdFx0XHRwYWdlOiAgICBjb250ZXh0Lm9wdGlvbnMucGFnZSxcclxuXHRcdFx0XHRcdGxpbWl0OiAgIGNvbnRleHQub3B0aW9ucy5saW1pdCxcclxuXHRcdFx0XHRcdHNvcnQ6ICAgIGNvbnRleHQub3B0aW9ucy5zb3J0LFxyXG5cdFx0XHRcdFx0ZmllbGRzOiAgW1xyXG5cdFx0XHRcdFx0XHQnY3VzdG9tZXInLFxyXG5cdFx0XHRcdFx0XHQndGl0bGUnLFxyXG5cdFx0XHRcdFx0XHQnYm9keScsXHJcblx0XHRcdFx0XHRcdCdpbWFnZXMnLFxyXG5cdFx0XHRcdFx0XHQncmF0aW5nJyxcclxuXHRcdFx0XHRcdFx0J2hlbHBlZCcsXHJcblx0XHRcdFx0XHRcdCdmbGFnZ2VkJyxcclxuXHRcdFx0XHRcdFx0J3RvdGFsQ29tbWVudCcsXHJcblx0XHRcdFx0XHRcdCdjcmVhdGVkQXQnLFxyXG5cdFx0XHRcdFx0XS5qb2luKCcsJylcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjb3VudFJldmlld3MoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRtZXRob2Q6ICdHRVQnLFxyXG5cdFx0XHRcdHVybDogJy92MS9wcm9kdWN0cy9yZXZpZXdzL3B1Ymxpc2hlZC9jb3VudCcsXHJcblx0XHRcdFx0cXVlcnk6IHtcclxuXHRcdFx0XHRcdHByb2R1Y3Q6IGNvbnRleHQub3B0aW9ucy5wcm9kdWN0LFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5pbml0ID0gZnVuY3Rpb24oY29udGV4dCkge1xyXG5cclxuXHRcdGNvbnN0ICRjb250YWluZXIgPSAkKHRoaXMpO1xyXG5cdFx0Y29uc3QgJHdyaXRlUmV2aWV3ID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0td3JpdGUtcmV2aWV3Jyk7XHJcblx0XHRjb25zdCAkcmV2aWV3TGlzdCA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXByb2R1Y3QtcmV2aWV3LWxpc3QnKTtcclxuXHRcdGNvbnN0ICRwYWdpbmF0aW9uID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tcHJvZHVjdC1yZXZpZXctbGlzdC1wYWdpbmF0aW9uJyk7XHJcblx0XHRjb25zdCAkcmV2aWV3V3JpdGVyQ29udGFpbmVyID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tcmV2aWV3LXdyaXRlci1jb250YWluZXInKTtcclxuXHJcblx0XHQkd3JpdGVSZXZpZXcub24oJ2NsaWNrJywgc3RhcnRSZXZpZXdXcml0aW5nKTtcclxuXHJcblx0XHRUaHVuZGVyLnJlbmRlcigkcmV2aWV3V3JpdGVyQ29udGFpbmVyLCAncHJvZHVjdC1yZXZpZXctd3JpdGVyJywge1xyXG5cdFx0XHRwcm9kdWN0OiAgICAgICAgIGNvbnRleHQub3B0aW9ucy5wcm9kdWN0LFxyXG5cdFx0XHR1c2VSYXRpbmc6ICAgICAgIGNvbnRleHQub3B0aW9ucy51c2VSYXRpbmcsXHJcblx0XHRcdG9uUmV2aWV3UG9zdDogICAgb25SZXZpZXdQb3N0LFxyXG5cdFx0XHRvblJldmlld0NhbmNlbDogICgpID0+IGhpZGVSZXZpZXdXcml0ZXIoKSxcclxuXHRcdH0pO1xyXG5cclxuXHRcdGNvbnRleHQucmV2aWV3cy5mb3JFYWNoKHJldmlldyA9PiByZW5kZXJSZXZpZXcoJ2FwcGVuZCcsIHJldmlldykpO1xyXG5cclxuXHRcdGlmIChjb250ZXh0Lm9wdGlvbnMudXNlUGFnaW5hdGlvbikge1xyXG5cclxuXHRcdFx0VGh1bmRlci5wbHVnaW5zLnBhZ2luYXRpb24oe1xyXG5cdFx0XHRcdGNvbnRhaW5lcjogICAgICRwYWdpbmF0aW9uLFxyXG5cdFx0XHRcdGN1cnJlbnRQYWdlOiAgIGNvbnRleHQub3B0aW9ucy5wYWdlLFxyXG5cdFx0XHRcdHRvdGFsUmVzdWx0OiAgIGNvbnRleHQuY291bnQucmF3LFxyXG5cdFx0XHRcdHJlc3VsdFBlclBhZ2U6IGNvbnRleHQub3B0aW9ucy5saW1pdCxcclxuXHRcdFx0XHRvblBhZ2VDaGFuZ2U6ICAoeyBwYWdlIH0pID0+IFRodW5kZXIucmVuZGVyKFxyXG5cdFx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdGltcGxlbWVudGF0aW9uLm5hbWUsXHJcblx0XHRcdFx0XHQkLmV4dGVuZChjb250ZXh0Lm9wdGlvbnMsIHsgcGFnZSB9KVxyXG5cdFx0XHRcdClcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVuZGVyUmV2aWV3KGNvbW1hbmQsIHJldmlldykge1xyXG5cclxuXHRcdFx0Y29uc3QgJHJldmlld0NvbnRhaW5lciA9ICQoYDxkaXYgY2xhc3M9XCJ0aHVuZGVyLS1wcm9kdWN0LXJldmlldy13cmFwcGVyXCIgZGF0YS1yZXZpZXc9XCIke3Jldmlldy5faWR9XCI+PC9kaXY+YCk7XHJcblxyXG5cdFx0XHQkcmV2aWV3TGlzdFtjb21tYW5kXSgkcmV2aWV3Q29udGFpbmVyKTtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlbmRlcigkcmV2aWV3Q29udGFpbmVyLCAncHJvZHVjdC1yZXZpZXcnLCB7XHJcblx0XHRcdFx0cmV2aWV3OiAgICAgICAgICAgIHJldmlldyxcclxuXHRcdFx0XHR1c2VDdXN0b21lckF2YXRhcjogY29udGV4dC5vcHRpb25zLnVzZUN1c3RvbWVyQXZhdGFyLFxyXG5cdFx0XHRcdHVzZUJvZHlFeGNlcnB0OiAgICBjb250ZXh0Lm9wdGlvbnMudXNlQm9keUV4Y2VycHQsXHJcblx0XHRcdFx0dXNlUmF0aW5nOiAgICAgICAgIGNvbnRleHQub3B0aW9ucy51c2VSYXRpbmcsXHJcblx0XHRcdFx0dXNlSGVscFZvdGU6ICAgICAgIGNvbnRleHQub3B0aW9ucy51c2VIZWxwVm90ZSxcclxuXHRcdFx0XHR1c2VGbGFnOiAgICAgICAgICAgY29udGV4dC5vcHRpb25zLnVzZUZsYWcsXHJcblx0XHRcdFx0dXNlQ29tbWVudHM6ICAgICAgIGNvbnRleHQub3B0aW9ucy51c2VDb21tZW50cyxcclxuXHRcdFx0XHRzaG93UHJvZHVjdDogICAgICAgZmFsc2UsXHJcblx0XHRcdFx0c2hvd0NvbW1lbnRzOiAgICAgIGZhbHNlLFxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc3RhcnRSZXZpZXdXcml0aW5nKGV2ZW50KSB7XHJcblxyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0aWYgKFRodW5kZXIuYXV0aGVudGljYXRlZCgpKSB7XHJcblx0XHRcdFx0cmV0dXJuIHNob3dSZXZpZXdXcml0ZXIoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIFRodW5kZXIuZXhlY3V0ZShcclxuXHRcdFx0XHRjb250ZXh0Lm9wdGlvbnMub25VbmF1dGhlbnRpY2F0ZWRXcml0ZVJldmlldyxcclxuXHRcdFx0XHQkY29udGFpbmVyLFxyXG5cdFx0XHRcdGNvbnRleHRcclxuXHRcdFx0KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25SZXZpZXdQb3N0KF8kY29udGFpbmVyLCBfY29udGV4dCwgcmV2aWV3KSB7XHJcblxyXG5cdFx0XHRjb250ZXh0LnJldmlld3MudW5zaGlmdChyZXZpZXcpO1xyXG5cclxuXHRcdFx0aGlkZVJldmlld1dyaXRlcigpO1xyXG5cdFx0XHRyZW5kZXJSZXZpZXcoJ3ByZXBlbmQnLCByZXZpZXcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNob3dSZXZpZXdXcml0ZXIoKSB7XHJcblx0XHRcdCR3cml0ZVJldmlldy5oaWRlKCk7XHJcblx0XHRcdCRyZXZpZXdXcml0ZXJDb250YWluZXIuc2hvdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGhpZGVSZXZpZXdXcml0ZXIoKSB7XHJcblx0XHRcdCR3cml0ZVJldmlldy5zaG93KCk7XHJcblx0XHRcdCRyZXZpZXdXcml0ZXJDb250YWluZXIuaGlkZSgpO1xyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gVGh1bmRlciA9PiB7XHJcblxyXG5cdGNvbnN0IGltcGxlbWVudGF0aW9uID0ge1xyXG5cdFx0bmFtZTogJ3NlYXJjaC1wdXJjaGFzZSdcclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5vcHRpb25zID0gKCkgPT4gKHtcclxuXHRcdHR5cGU6ICdvcmRlcicsIC8vICdvcmRlcicgfHwgJ3N1YnNjcmlwdGlvbidcclxuXHJcblx0XHRvblNlYXJjaDogZnVuY3Rpb24oJGNvbnRhaW5lciwgY29udGV4dCwgc3ViamVjdCkge1xyXG5cclxuXHRcdFx0Y29uc3QgdHlwZSA9IGNvbnRleHQub3B0aW9ucy50eXBlO1xyXG5cclxuXHRcdFx0VGh1bmRlci5yZW5kZXIoJGNvbnRhaW5lciwgYCR7dHlwZX0tZGV0YWlsYCwge1xyXG5cdFx0XHRcdFt0eXBlXTogc3ViamVjdFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ucHJlID0gZnVuY3Rpb24oY29udGV4dCwgY2FsbGJhY2spIHtcclxuXHJcblx0XHRjb25zdCB0cmFuc2xhdGlvbktleXMgPSB7XHJcblx0XHRcdCduYW1lLmZpcnN0JzogJ2ZpcnN0TmFtZScsXHJcblx0XHRcdCduYW1lLmxhc3QnOiAgJ2xhc3ROYW1lJyxcclxuXHRcdFx0J25hbWUuZnVsbCc6ICAnZnVsbE5hbWUnLFxyXG5cdFx0fTtcclxuXHJcblx0XHRjb250ZXh0LmF1dGhGaWVsZHMgPSBUaHVuZGVyLm9wdGlvbnMub3JkZXJBdXRoRmllbGRzLm1hcChmaWVsZCA9PiAoe1xyXG5cdFx0XHRrZXk6IGZpZWxkLFxyXG5cdFx0XHR0cmFuc2xhdGlvbktleTogdHJhbnNsYXRpb25LZXlzW2ZpZWxkXSB8fCBmaWVsZCxcclxuXHRcdH0pKTtcclxuXHJcblx0XHRjb250ZXh0LnNob3dMaW5rcyA9IHtcclxuXHRcdFx0b3JkZXI6IHRydWUsXHJcblx0XHRcdHN1YnNjcmlwdGlvbjogISFUaHVuZGVyLm9wdGlvbnMucGF5bWVudE1ldGhvZHMuc3Vic2NyaXB0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBjb250ZXh0KTtcclxuXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24uaW5pdCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuXHJcblx0XHRjb25zdCAkY29udGFpbmVyID0gJCh0aGlzKTtcclxuXHRcdGNvbnN0ICRmb3JtID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tc2VhcmNoLXB1cmNoYXNlLWZvcm0nKTtcclxuXHRcdGNvbnN0ICRidXR0b24gPSAkZm9ybS5maW5kKCcudGh1bmRlci0tc2VhcmNoLXB1cmNoYXNlJyk7XHJcblx0XHRjb25zdCAkZ29Ub1NlYXJjaCA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWdvLXRvLXNlYXJjaC1wdXJjaGFzZScpO1xyXG5cdFx0Y29uc3QgYnV0dG9uU3Bpbm5lciA9IFRodW5kZXIudXRpbC5tYWtlQXN5bmNCdXR0b24oJGJ1dHRvbik7XHJcblxyXG5cdFx0JGdvVG9TZWFyY2gub24oJ2NsaWNrJywgZ29Ub1NlYXJjaCk7XHJcblxyXG5cdFx0VGh1bmRlci51dGlsLm1ha2VSZWNhcHRjaGEoaW1wbGVtZW50YXRpb24ubmFtZSwgJGJ1dHRvbiwgZnVuY3Rpb24odG9rZW4sIHJlc2V0UmVjYXB0Y2hhKSB7XHJcblxyXG5cdFx0XHRjb25zdCB0eXBlID0gY29udGV4dC5vcHRpb25zLnR5cGU7XHJcblx0XHRcdGNvbnN0IGRhdGEgPSBUaHVuZGVyLnV0aWwuZm9ybVRvSlNPTigkZm9ybS5zZXJpYWxpemVBcnJheSgpKTtcclxuXHRcdFx0Y29uc3Qgc3ViamVjdCA9IGRhdGEuc3ViamVjdDtcclxuXHJcblx0XHRcdGRlbGV0ZSBkYXRhLnN1YmplY3Q7XHJcblxyXG5cdFx0XHRjb25zdCByZXNldFN0YXRlID0gKCkgPT4ge1xyXG5cdFx0XHRcdGJ1dHRvblNwaW5uZXIuZG9uZSgpO1xyXG5cdFx0XHRcdHJldHVybiByZXNldFJlY2FwdGNoYSAmJiByZXNldFJlY2FwdGNoYSgpO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Y29uc3QgZXJyb3JzID0ge1xyXG5cdFx0XHRcdCdub3QtZXhpc3Rpbmctb3JkZXInOiAgICAgICAgY29udGV4dC5tKCdub3RFeGlzdGluZ09yZGVyJyksXHJcblx0XHRcdFx0J25vdC1leGlzdGluZy1zdWJzY3JpcHRpb24nOiBjb250ZXh0Lm0oJ25vdEV4aXN0aW5nU3Vic2NyaXB0aW9uJyksXHJcblx0XHRcdFx0J2ludmFsaWQtY3VzdG9tZXItaW5mbyc6ICAgICBjb250ZXh0Lm0oJ2ludmFsaWRDdXN0b21lckluZm8nKSxcclxuXHRcdFx0XHRkZWZhdWx0OiAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubSgnc2VhcmNoRmFpbGVkJylcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ1BPU1QnLFxyXG5cdFx0XHRcdHVybDogICAgYC92MS8ke3R5cGV9cy8ke3N1YmplY3R9L2F1dGhgLFxyXG5cdFx0XHRcdGRhdGE6ICAgZGF0YSxcclxuXHRcdFx0fSkudGhlbihhdXRoUmVzdWx0ID0+IHtcclxuXHJcblx0XHRcdFx0Y29uc3Qgc3RvcmFnZSA9IFRodW5kZXIucGx1Z2lucy5jcmVkZW50aWFsU3RvcmFnZTtcclxuXHRcdFx0XHRjb25zdCB0b2tlbiA9IGF1dGhSZXN1bHQudG9rZW47XHJcblxyXG5cdFx0XHRcdC8vIFNldCBhdXRoIHRva2VuIGluIHRoZSBzdG9yYWdlLlxyXG5cdFx0XHRcdHN0b3JhZ2Uuc2V0SXRlbShUaHVuZGVyLm9wdGlvbnMuYXV0aFN0b3JhZ2Uub3JkZXIsIHRva2VuKTtcclxuXHJcblx0XHRcdFx0VGh1bmRlci5leGVjdXRlKFxyXG5cdFx0XHRcdFx0Y29udGV4dC5vcHRpb25zLm9uU2VhcmNoLFxyXG5cdFx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdGNvbnRleHQsXHJcblx0XHRcdFx0XHRzdWJqZWN0XHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHJlc2V0U3RhdGUoKTtcclxuXHJcblx0XHRcdH0sIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdGVycm9ycyxcclxuXHRcdFx0XHQoKSA9PiByZXNldFN0YXRlKClcclxuXHRcdFx0KSk7XHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ29Ub1NlYXJjaCgpIHtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlbmRlcigkY29udGFpbmVyLCAnc2VhcmNoLXB1cmNoYXNlJywge1xyXG5cdFx0XHRcdHR5cGU6ICQodGhpcykuZGF0YSgndHlwZScpXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xyXG5cclxufTsiLCJjb25zdCBnZXQgPSByZXF1aXJlKCdsb2Rhc2guZ2V0Jyk7XHJcbmNvbnN0IHNldCA9IHJlcXVpcmUoJ2xvZGFzaC5zZXQnKTtcclxuY29uc3QgY2FtZWxDYXNlID0gcmVxdWlyZSgnbG9kYXNoLmNhbWVsY2FzZScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaHVuZGVyID0+IHtcclxuXHJcblx0Y29uc3QgaW1wbGVtZW50YXRpb24gPSB7XHJcblx0XHRuYW1lOiAnc3Vic2NyaXB0aW9uLWRldGFpbCdcclxuXHR9O1xyXG5cclxuXHRpbXBsZW1lbnRhdGlvbi5vcHRpb25zID0gKCkgPT4gKHtcclxuXHRcdHN1YnNjcmlwdGlvbjogICAgJycsIC8vIFN1YnNjcmlwdGlvbiBJRCB0byByZW5kZXJcclxuXHRcdGN1c3RvbWVyRmllbGRzOiAgVGh1bmRlci5vcHRpb25zLmN1c3RvbWVyT3JkZXJGaWVsZHMubWFwKGZpZWxkID0+IGZpZWxkLnNwbGl0KCc6JylbMF0pLFxyXG5cdFx0cmVjaXBpZW50RmllbGRzOiBUaHVuZGVyLm9wdGlvbnMucmVjaXBpZW50RmllbGRzLm1hcChmaWVsZCA9PiBmaWVsZC5zcGxpdCgnOicpWzBdKSxcclxuXHR9KTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24ucHJlID0gZnVuY3Rpb24oY29udGV4dCwgY2FsbGJhY2spIHtcclxuXHJcblx0XHRjb25zdCB7IHN1YnNjcmlwdGlvbiB9ID0gY29udGV4dC5vcHRpb25zO1xyXG5cclxuXHRcdGNvbnRleHQuY291cG9uRGV0YWlsID0gY291cG9uID0+IHtcclxuXHJcblx0XHRcdGlmICghY291cG9uKSByZXR1cm4gJyc7XHJcblxyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdGNvbnRleHQubSgnZGlzY291bnRlZEJ5JywgeyB2YWx1ZTogY291cG9uLmRpc2NvdW50LnZhbHVlLmNvbnZlcnRlZCB9KSxcclxuXHRcdFx0XHQnJiMxMDsoJyxcclxuXHRcdFx0XHRjb250ZXh0Lm0oKHtcclxuXHRcdFx0XHRcdGZpcnN0OiAnZmlyc3ROVGltZXNEaXNjb3VudGVkJyxcclxuXHRcdFx0XHRcdGxhc3Q6ICAnbGFzdE5UaW1lc0Rpc2NvdW50ZWQnLFxyXG5cdFx0XHRcdFx0ZXZlcnk6ICdhbGxEaXNjb3VudGVkJyxcclxuXHRcdFx0XHR9KVtjb3Vwb24uc3Vic2NyaXB0aW9uLnR5cGVdLCB7XHJcblx0XHRcdFx0XHRjb3VudDogZ2V0KGNvdXBvbi5zdWJzY3JpcHRpb24sICd2YWx1ZS5jb252ZXJ0ZWQnKSxcclxuXHRcdFx0XHRcdHNtYXJ0X2NvdW50OiBnZXQoY291cG9uLnN1YnNjcmlwdGlvbiwgJ3ZhbHVlLnJhdycpLFxyXG5cdFx0XHRcdH0pLFxyXG5cdFx0XHRcdCcpJ1xyXG5cdFx0XHRdLmpvaW4oJycpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgdHJhbnNsYXRpb25LZXlzID0ge1xyXG5cdFx0XHQnbmFtZS5maXJzdCc6ICdmaXJzdE5hbWUnLFxyXG5cdFx0XHQnbmFtZS5sYXN0JzogICdsYXN0TmFtZScsXHJcblx0XHRcdCduYW1lLmZ1bGwnOiAgJ2Z1bGxOYW1lJyxcclxuXHRcdH07XHJcblxyXG5cdFx0Y29udGV4dC5jdXN0b21lckZpZWxkcyA9IFRodW5kZXIudXRpbC5wYXJzZUFycmF5U3RyaW5nKFxyXG5cdFx0XHRjb250ZXh0Lm9wdGlvbnMuY3VzdG9tZXJGaWVsZHNcclxuXHRcdCkubWFwKGtleSA9PiAoe1xyXG5cdFx0XHRrZXk6IGtleSxcclxuXHRcdFx0dHJhbnNsYXRpb25LZXk6IGNhbWVsQ2FzZShbJ2N1c3RvbWVyJywgdHJhbnNsYXRpb25LZXlzW2tleV0gfHwga2V5XSksXHJcblx0XHR9KSk7XHJcblxyXG5cdFx0Y29udGV4dC5yZWNpcGllbnRGaWVsZHMgPSBUaHVuZGVyLnV0aWwucGFyc2VBcnJheVN0cmluZyhcclxuXHRcdFx0Y29udGV4dC5vcHRpb25zLnJlY2lwaWVudEZpZWxkc1xyXG5cdFx0KS5tYXAoa2V5ID0+ICh7XHJcblx0XHRcdGtleToga2V5LFxyXG5cdFx0XHR0cmFuc2xhdGlvbktleTogY2FtZWxDYXNlKFsnYWRkcmVzcycsIHRyYW5zbGF0aW9uS2V5c1trZXldIHx8IGtleV0pLFxyXG5cdFx0fSkpO1xyXG5cclxuXHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0ZGVmYXVsdDogY29udGV4dC5tKCdzdWJzY3JpcHRpb25SZWFkRmFpbGVkJylcclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdG1ldGhvZDogJ0dFVCcsXHJcblx0XHRcdHVybDogICAgYC92MS9tZS9zdWJzY3JpcHRpb25zLyR7c3Vic2NyaXB0aW9ufWAsXHJcblx0XHR9KS50aGVuKHN1YnNjcmlwdGlvbiA9PiB7XHJcblxyXG5cdFx0XHRjb25zdCBpdGVtTWFwID0gc3Vic2NyaXB0aW9uLml0ZW1zLnJlZHVjZSgobywgaXRlbSkgPT4ge1xyXG5cdFx0XHRcdHJldHVybiBbXS5jb25jYXQoaXRlbSwgaXRlbS5idW5kbGVJdGVtcyB8fCBbXSkucmVkdWNlKChvLCBpdGVtKSA9PiB7XHJcblx0XHRcdFx0XHRyZXR1cm4gc2V0KG8sIGl0ZW0uX2lkLCBpdGVtKTtcclxuXHRcdFx0XHR9LCBvKTtcclxuXHRcdFx0fSwge30pO1xyXG5cclxuXHRcdFx0Y29uc3QgZGlzY291bnQgPSBzdWJzY3JpcHRpb24uZGlzY291bnQgfHwge307XHJcblxyXG5cdFx0XHRPYmplY3Qua2V5cyhkaXNjb3VudCkuZm9yRWFjaChzY29wZSA9PiB7XHJcblxyXG5cdFx0XHRcdGlmIChzY29wZSA9PT0gJ3NoaXBwaW5nJykge1xyXG5cdFx0XHRcdFx0Ly8gSU1QT1JUQU5UOiBGb3Igbm93IHdlIHdpbGwgb25seSBkaXNwbGF5ICdpdGVtcycgYW5kICdjYXJ0JyBjb3Vwb25zXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRbXS5jb25jYXQoZGlzY291bnRbc2NvcGVdKS5mb3JFYWNoKCh7IGl0ZW0sIGNvdXBvbiB9KSA9PiB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCFjb3Vwb24pIHJldHVybjtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gaXRlbSA/XHJcblx0XHRcdFx0XHRcdFx0c2V0KGl0ZW1NYXBbaXRlbS5faWRdLCAnYXBwbGllZENvdXBvbicsIGNvdXBvbikgOlxyXG5cdFx0XHRcdFx0XHRcdHNldChzdWJzY3JpcHRpb24sICdhcHBsaWVkQ291cG9uJywgY291cG9uKTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29uc3Qgc2NoZWR1bGVTdGF0dXMgPSBzdWJzY3JpcHRpb24uc3RhdHVzID09PSAnY2FuY2VsbGVkJyA/ICdjYW5jZWxsZWQnIDogbnVsbDtcclxuXHJcblx0XHRcdHN1YnNjcmlwdGlvbi5zY2hlZHVsZXMuZm9yRWFjaChzY2hlZHVsZSA9PiB7XHJcblx0XHRcdFx0Ly8gV2hlbiB0aGUgc3Vic2NyaXB0aW9uIGlzIGNhbmNlbGxlZCxcclxuXHRcdFx0XHQvLyBtYWtlIGFsbCBzY2hlZHVsZXMnIHN0YXR1c2VzIGFzICdjYW5jZWxsZWQnIGFzIHdlbGwgdW5sZXNzIGEgc2NoZWR1bGUgaXMgJ2RvbmUnLlxyXG5cdFx0XHRcdHNjaGVkdWxlLnN0YXR1cyA9IHNjaGVkdWxlLnN0YXR1cyA9PT0gJ2RvbmUnID9cclxuXHRcdFx0XHRcdFx0XHRcdFx0c2NoZWR1bGUuc3RhdHVzIDpcclxuXHRcdFx0XHRcdFx0XHRcdFx0c2NoZWR1bGVTdGF0dXMgfHwgc2NoZWR1bGUuc3RhdHVzO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGNvbnRleHQuc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xyXG5cclxuXHRcdFx0Ly8gU2V0IHBheW1lbnQgZGV0YWlscy5cclxuXHRcdFx0Y29uc3QgcGF5bWVudE1ldGhvZCA9IHN1YnNjcmlwdGlvbi5wYXltZW50TWV0aG9kO1xyXG5cclxuXHRcdFx0Y29uc3QgdGh1bmRlclBheW1lbnRNZXRob2RNYXAgPVxyXG5cdFx0XHRcdFRodW5kZXIub3B0aW9ucy5wYXltZW50TWV0aG9kcy5zdWJzY3JpcHRpb25cclxuXHRcdFx0XHRcdC5yZWR1Y2UoKG8sIHApID0+IHNldChvLCBwLmlkLCBwKSwge30pO1xyXG5cclxuXHRcdFx0Y29uc3QgdGh1bmRlclBheW1lbnRNZXRob2QgPVxyXG5cdFx0XHRcdHRodW5kZXJQYXltZW50TWV0aG9kTWFwW3BheW1lbnRNZXRob2QuX2lkXSB8fFxyXG5cdFx0XHRcdHRodW5kZXJQYXltZW50TWV0aG9kTWFwW3BheW1lbnRNZXRob2Quc2x1Z107XHJcblxyXG5cdFx0XHRjb25zdCBzaG91bGRQYXkgPVxyXG5cdFx0XHRcdHN1YnNjcmlwdGlvbi5zdGF0dXMgPT09ICdwZW5kaW5nJyAmJlxyXG5cdFx0XHRcdHRodW5kZXJQYXltZW50TWV0aG9kO1xyXG5cclxuXHRcdFx0Y29udGV4dC5wYXltZW50TWV0aG9kID0gdGh1bmRlclBheW1lbnRNZXRob2Q7XHJcblx0XHRcdGNvbnRleHQuc2hvdWxkUGF5ID0gc2hvdWxkUGF5O1xyXG5cclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIGNvbnRleHQpO1xyXG5cclxuXHRcdH0sIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0ZXJyLnJlc3BvbnNlSlNPTixcclxuXHRcdFx0ZXJyb3JzLFxyXG5cdFx0XHRjYWxsYmFja1xyXG5cdFx0KSk7XHJcblxyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLmluaXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcblxyXG5cdFx0Y29uc3Qge1xyXG5cdFx0XHRzdWJzY3JpcHRpb24sXHJcblx0XHRcdHBheW1lbnRNZXRob2QsXHJcblx0XHRcdHNob3VsZFBheVxyXG5cdFx0fSA9IGNvbnRleHQ7XHJcblxyXG5cdFx0Y29uc3QgJGNvbnRhaW5lciA9ICQodGhpcyk7XHJcblx0XHRjb25zdCAkYmFja1RvU3Vic2NyaXB0aW9ucyA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWJhY2stdG8tc3Vic2NyaXB0aW9ucycpO1xyXG5cdFx0Y29uc3QgJGNhbmNlbFN1YnNjcmlwdGlvbiA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLWNhbmNlbC1zdWJzY3JpcHRpb24nKTtcclxuXHRcdGNvbnN0ICRjYW5jZWxsYXRpb25Gb3JtID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tc3Vic2NyaXB0aW9uLWNhbmNlbGxhdGlvbi1mb3JtJyk7XHJcblx0XHRjb25zdCAkY2FuY2VsbGF0aW9uUmVhc29uID0gJGNhbmNlbGxhdGlvbkZvcm0uZmluZCgndGV4dGFyZWEnKTtcclxuXHRcdGNvbnN0ICRjYW5jZWxCdXR0b24gPSAkY2FuY2VsbGF0aW9uRm9ybS5maW5kKCdidXR0b24nKTtcclxuXHRcdGNvbnN0ICR2aWV3T3JkZXIgPSAkKHRoaXMpLmZpbmQoJ1tkYXRhLW9yZGVyXVtkYXRhLXN0YXR1cz1cImRvbmVcIl0nKTtcclxuXHRcdGNvbnN0ICRvbWl0dGVkU2NoZWR1bGVzID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tc3Vic2NyaXB0aW9uLW9taXR0ZWQtc2NoZWR1bGVzJyk7XHJcblx0XHRjb25zdCAkdmlld0FsbFNjaGVkdWxlcyA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXZpZXctYWxsLXNjaGVkdWxlcycpO1xyXG5cdFx0Y29uc3QgJGhpZGRlblNjaGVkdWxlcyA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXN1YnNjcmlwdGlvbi1zY2hlZHVsZS5oaWRkZW4nKTtcclxuXHJcblx0XHRjb25zdCBjYW5jZWxCdXR0b25TcGlubmVyID0gVGh1bmRlci51dGlsLm1ha2VBc3luY0J1dHRvbigkY2FuY2VsQnV0dG9uKTtcclxuXHJcblx0XHQkY2FuY2VsU3Vic2NyaXB0aW9uLm9uKCdjbGljaycsIHN0YXJ0Q2FuY2VsbGF0aW9uKTtcclxuXHRcdCRjYW5jZWxCdXR0b24ub24oJ2NsaWNrJywgY2FuY2VsU3Vic2NyaXB0aW9uKTtcclxuXHRcdCR2aWV3QWxsU2NoZWR1bGVzLm9uKCdjbGljaycsIHZpZXdBbGxTY2hlZHVsZXMpO1xyXG5cdFx0JHZpZXdPcmRlci5vbignY2xpY2snLCAnLnRodW5kZXItLXNjaGVkdWxlLW9yZGVyJywgZXZlbnQgPT4ge1xyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZW5kZXIoJGNvbnRhaW5lciwgJ29yZGVyLWRldGFpbCcsIHtcclxuXHRcdFx0XHRvcmRlcjogJChldmVudC5kZWxlZ2F0ZVRhcmdldCkuZGF0YSgnb3JkZXInKSxcclxuXHRcdFx0XHRiYWNrOiB7XHJcblx0XHRcdFx0XHQkY29udGFpbmVyOiAkY29udGFpbmVyLFxyXG5cdFx0XHRcdFx0Y29tcG9uZW50OiAgaW1wbGVtZW50YXRpb24ubmFtZSxcclxuXHRcdFx0XHRcdG9wdGlvbnM6ICAgIGNvbnRleHQub3B0aW9uc1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRUaHVuZGVyLnV0aWwuYmluZEJhY2tCdXR0b24oJGJhY2tUb1N1YnNjcmlwdGlvbnMsIGNvbnRleHQpO1xyXG5cclxuXHRcdC8vIFJlbmRlciBhIHBheW1lbnQgZm9ybSBpZiBpdCdzIG5lZWRlZC5cclxuXHRcdGlmIChzaG91bGRQYXkpIHtcclxuXHJcblx0XHRcdGNvbnN0ICRwYXltZW50Rm9ybUNvbnRhaW5lciA9ICQodGhpcykuZmluZCgnLnRodW5kZXItLXBheW1lbnQtZm9ybS1jb250YWluZXInKTtcclxuXHRcdFx0Y29uc3QgJG1ha2VQYXltZW50ID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tbWFrZS1wYXltZW50Jyk7XHJcblx0XHRcdGNvbnN0IG1ha2VQYXltZW50U3Bpbm5lciA9IFRodW5kZXIudXRpbC5tYWtlQXN5bmNCdXR0b24oJG1ha2VQYXltZW50LCB7IGJpbmQ6IGZhbHNlIH0pO1xyXG5cclxuXHRcdFx0VGh1bmRlci5yZW5kZXIoJHBheW1lbnRGb3JtQ29udGFpbmVyLCAncGF5bWVudC1mb3JtJywge1xyXG5cdFx0XHRcdHR5cGU6ICdzdWJzY3JpcHRpb24nLFxyXG5cdFx0XHRcdHBheW1lbnRNZXRob2RzOiBbcGF5bWVudE1ldGhvZC5pZF1cclxuXHRcdFx0fSwgKGVyciwgeyBpbnRlcmZhY2VzOiBwYXltZW50SGFuZGxlciB9KSA9PiAkbWFrZVBheW1lbnQub24oJ2NsaWNrJywgKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBwYXltZW50SGFuZGxlci52YWxpZGF0ZSgpO1xyXG5cclxuXHRcdFx0XHRpZiAodmFsaWRhdGlvbkVycm9yKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gVGh1bmRlci5ub3RpZnkoJ2Vycm9yJywgdmFsaWRhdGlvbkVycm9yLm1lc3NhZ2UpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgY2FyZCA9IHBheW1lbnRIYW5kbGVyLmdldENhcmQoKTtcclxuXHJcblx0XHRcdFx0bWFrZVBheW1lbnRTcGlubmVyLnJ1bigpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gcGF5bWVudEhhbmRsZXIubWFrZVBheW1lbnQoe1xyXG5cdFx0XHRcdFx0c3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24sXHJcblx0XHRcdFx0XHRjdXN0b21lcjogICAgIHN1YnNjcmlwdGlvbi5jdXN0b21lclxyXG5cdFx0XHRcdH0sIGVyciA9PiB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdFx0XHRUaHVuZGVyLm5vdGlmeSgnZXJyb3InLCBjb250ZXh0Lm0oJ3BheW1lbnRGYWlsZWQnKSk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBtYWtlUGF5bWVudFNwaW5uZXIuZG9uZSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGVycm9ycyA9IHtcclxuXHRcdFx0XHRcdFx0ZGVmYXVsdDogY29udGV4dC5tKCdzY2hlZHVsaW5nRmFpbGVkJylcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdFx0XHRcdG1ldGhvZDogJ1BPU1QnLFxyXG5cdFx0XHRcdFx0XHR1cmw6ICAgIGAvdjEvbWUvc3Vic2NyaXB0aW9ucy8ke3N1YnNjcmlwdGlvbi5faWR9L3NjaGVkdWxlZGAsXHJcblx0XHRcdFx0XHRcdGRhdGE6ICAgY2FyZCA/IHsgY2FyZCB9IDoge31cclxuXHRcdFx0XHRcdH0pLnRoZW4oKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdFx0VGh1bmRlci5ub3RpZnkoJ3N1Y2Nlc3MnLCBjb250ZXh0Lm0oJ3NjaGVkdWxpbmdTdWNjZXNzJykpO1xyXG5cdFx0XHRcdFx0XHRtYWtlUGF5bWVudFNwaW5uZXIuZG9uZSgpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gVGh1bmRlci5yZW5kZXIoJGNvbnRhaW5lciwgaW1wbGVtZW50YXRpb24ubmFtZSwgY29udGV4dC5vcHRpb25zKTtcclxuXHJcblx0XHRcdFx0XHR9LCBlcnIgPT4gVGh1bmRlci51dGlsLnJlcXVlc3RFcnJvckhhbmRsZXIoXHJcblx0XHRcdFx0XHRcdGVyci5yZXNwb25zZUpTT04sXHJcblx0XHRcdFx0XHRcdGVycm9ycyxcclxuXHRcdFx0XHRcdFx0KCkgPT4gbWFrZVBheW1lbnRTcGlubmVyLmRvbmUoKVxyXG5cdFx0XHRcdFx0KSk7XHJcblxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0fSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHN0YXJ0Q2FuY2VsbGF0aW9uKCkge1xyXG5cdFx0XHQkKHRoaXMpLmFkZENsYXNzKCdoaWRkZW4nKTtcclxuXHRcdFx0JGNhbmNlbGxhdGlvbkZvcm0ucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xyXG5cdFx0XHQkY2FuY2VsbGF0aW9uUmVhc29uLmZvY3VzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY2FuY2VsU3Vic2NyaXB0aW9uKGV2ZW50KSB7XHJcblxyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgZGF0YSA9IFRodW5kZXIudXRpbC5mb3JtVG9KU09OKCRjYW5jZWxsYXRpb25Gb3JtLnNlcmlhbGl6ZUFycmF5KCkpO1xyXG5cclxuXHRcdFx0Y29uc3QgZXJyb3JzID0ge1xyXG5cdFx0XHRcdCdpbnZhbGlkLXN1YnNjcmlwdGlvbi1zdGF0dXMnOiBjb250ZXh0Lm0oJ2ludmFsaWRTdWJzY3JpcHRpb25TdGF0dXMnKSxcclxuXHRcdFx0XHRkZWZhdWx0OiBjb250ZXh0Lm0oJ2NhbmNlbGxhdGlvbkZhaWxlZCcpLFxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Y29uc3QgcmVzZXRTdGF0ZSA9ICgpID0+IHtcclxuXHRcdFx0XHRjYW5jZWxCdXR0b25TcGlubmVyLmRvbmUoKTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHJldHVybiBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ1BPU1QnLFxyXG5cdFx0XHRcdHVybDogICAgYC92MS9tZS9zdWJzY3JpcHRpb25zLyR7c3Vic2NyaXB0aW9uLl9pZH0vY2FuY2VsbGF0aW9uYCxcclxuXHRcdFx0XHRkYXRhOiAgIGRhdGEsXHJcblx0XHRcdH0pLnRoZW4oKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRyZXNldFN0YXRlKCk7XHJcblxyXG5cdFx0XHRcdFRodW5kZXIubm90aWZ5KCdzdWNjZXNzJywgY29udGV4dC5tKCdjYW5jZWxsYXRpb25TdWNjZXNzJykpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gVGh1bmRlci5yZW5kZXIoJGNvbnRhaW5lciwgaW1wbGVtZW50YXRpb24ubmFtZSwgY29udGV4dC5vcHRpb25zKTtcclxuXHJcblx0XHRcdH0sIGVyciA9PiBUaHVuZGVyLnV0aWwucmVxdWVzdEVycm9ySGFuZGxlcihcclxuXHRcdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRcdGVycm9ycyxcclxuXHRcdFx0XHRyZXNldFN0YXRlXHJcblx0XHRcdCkpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiB2aWV3QWxsU2NoZWR1bGVzKCkge1xyXG5cdFx0XHQkb21pdHRlZFNjaGVkdWxlcy5hZGRDbGFzcygnaGlkZGVuJyk7XHJcblx0XHRcdCRoaWRkZW5TY2hlZHVsZXMucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gVGh1bmRlciA9PiB7XHJcblxyXG5cdGNvbnN0IGltcGxlbWVudGF0aW9uID0ge1xyXG5cdFx0bmFtZTogJ3N1YnNjcmlwdGlvbi1saXN0J1xyXG5cdH07XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLm9wdGlvbnMgPSAoKSA9PiAoe1xyXG5cdFx0cGFnZTogICAgICAgICAgICAgICAxLCAgICAvLyBXaGljaCBwYWdlIG9mIHN1YnNjcmlwdGlvbnM/XHJcblx0XHRsaW1pdDogICAgICAgICAgICAgIDEwLCAgIC8vIEhvdyBtYW55IHN1YnNjcmlwdGlvbnMgYXQgb25jZT9cclxuXHRcdHVzZVBhZ2luYXRpb246ICAgICAgdHJ1ZSwgLy8gVXNlIHBhZ2luYXRpb24/XHJcblx0XHRvblZpZXdTdWJzY3JpcHRpb246IGZ1bmN0aW9uKCRjb250YWluZXIsIGNvbnRleHQsIHN1YnNjcmlwdGlvbklkKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gVGh1bmRlci5yZW5kZXIoJGNvbnRhaW5lciwgJ3N1YnNjcmlwdGlvbi1kZXRhaWwnLCB7XHJcblx0XHRcdFx0c3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb25JZCxcclxuXHRcdFx0XHRiYWNrOiAgICAgICAgIHtcclxuXHRcdFx0XHRcdCRjb250YWluZXI6ICRjb250YWluZXIsXHJcblx0XHRcdFx0XHRjb21wb25lbnQ6ICBpbXBsZW1lbnRhdGlvbi5uYW1lLFxyXG5cdFx0XHRcdFx0b3B0aW9uczogICAgY29udGV4dC5vcHRpb25zXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGltcGxlbWVudGF0aW9uLnByZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcblxyXG5cdFx0Y29uc3QgZXJyb3JzID0ge1xyXG5cdFx0XHRkZWZhdWx0OiBjb250ZXh0Lm0oJ3N1YnNjcmlwdGlvbkxpc3RGYWlsZWQnKVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gJC53aGVuKFxyXG5cdFx0XHRUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ0dFVCcsXHJcblx0XHRcdFx0dXJsOiAgICAnL3YxL21lL3N1YnNjcmlwdGlvbnMnLFxyXG5cdFx0XHRcdHF1ZXJ5OiAge1xyXG5cdFx0XHRcdFx0cGFnZTogICBjb250ZXh0Lm9wdGlvbnMucGFnZSxcclxuXHRcdFx0XHRcdGxpbWl0OiAgY29udGV4dC5vcHRpb25zLmxpbWl0LFxyXG5cdFx0XHRcdFx0c29ydDogICAnLWNyZWF0ZWRBdCcsXHJcblx0XHRcdFx0XHRmaWVsZHM6IFtcclxuXHRcdFx0XHRcdFx0J3N0YXR1cycsXHJcblx0XHRcdFx0XHRcdCdwbGFuJyxcclxuXHRcdFx0XHRcdFx0J3NjaGVkdWxlcycsXHJcblx0XHRcdFx0XHRcdCdpdGVtcy5wcm9kdWN0JyxcclxuXHRcdFx0XHRcdFx0J2NhbmNlbGxhdGlvbicsXHJcblx0XHRcdFx0XHRcdCdlbmRzQXQnLFxyXG5cdFx0XHRcdFx0XHQnY3JlYXRlZEF0JyxcclxuXHRcdFx0XHRcdF0uam9pbignLCcpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KSxcclxuXHRcdFx0Y29udGV4dC5vcHRpb25zLnVzZVBhZ2luYXRpb24gPyBUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ0dFVCcsXHJcblx0XHRcdFx0dXJsOiAgICAnL3YxL21lL3N1YnNjcmlwdGlvbnMvY291bnQnLFxyXG5cdFx0XHRcdHF1ZXJ5OiAge1xyXG5cdFx0XHRcdFx0cmF3OiB0cnVlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KSA6IG51bGxcclxuXHRcdCkudGhlbigoc3Vic2NyaXB0aW9ucywgY291bnQpID0+IHtcclxuXHJcblx0XHRcdGNvbnRleHQuc3Vic2NyaXB0aW9ucyA9IChzdWJzY3JpcHRpb25zWzBdIHx8IFtdKS5tYXAocyA9PiB7XHJcblxyXG5cdFx0XHRcdHMubWF4U2NoZWR1bGVkQW1vdW50ID0gcy5zY2hlZHVsZXMucmVkdWNlKChtYXgsIHMpID0+IHtcclxuXHRcdFx0XHRcdHJldHVybiBtYXggPiBzLmFtb3VudC5yYXcgPyBtYXggOiBzLmFtb3VudDtcclxuXHRcdFx0XHR9LCAwKTtcclxuXHJcblx0XHRcdFx0cy5kdXJhdGlvbiA9IFtcclxuXHRcdFx0XHRcdHMuc2NoZWR1bGVzWzBdLnRpbWUgPT09ICdub3cnID9cclxuXHRcdFx0XHRcdFx0cy5jcmVhdGVkQXQgOlxyXG5cdFx0XHRcdFx0XHRzLnNjaGVkdWxlc1swXS50aW1lLFxyXG5cdFx0XHRcdFx0cy5lbmRzQXRcclxuXHRcdFx0XHRdO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gcztcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjb250ZXh0LmNvdW50ID0gY291bnQgPyBjb3VudFswXS5jb3VudCA6IG51bGw7XHJcblxyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgY29udGV4dCk7XHJcblxyXG5cdFx0fSwgZXJyID0+IFRodW5kZXIudXRpbC5yZXF1ZXN0RXJyb3JIYW5kbGVyKFxyXG5cdFx0XHRlcnIucmVzcG9uc2VKU09OLFxyXG5cdFx0XHRlcnJvcnMsXHJcblx0XHRcdGNhbGxiYWNrXHJcblx0XHQpKTtcclxuXHJcblx0fTtcclxuXHJcblx0aW1wbGVtZW50YXRpb24uaW5pdCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuXHJcblx0XHRjb25zdCAkY29udGFpbmVyID0gJCh0aGlzKTtcclxuXHRcdGNvbnN0ICRzdWJzY3JpcHRpb24gPSAkKHRoaXMpLmZpbmQoJ1tkYXRhLXN1YnNjcmlwdGlvbl0nKTtcclxuXHRcdGNvbnN0ICRwYWdpbmF0aW9uID0gJCh0aGlzKS5maW5kKCcudGh1bmRlci0tc3Vic2NyaXB0aW9uLWxpc3QtcGFnaW5hdGlvbicpO1xyXG5cclxuXHRcdCRzdWJzY3JpcHRpb24ub24oJ2NsaWNrJywgW1xyXG5cdFx0XHQnLnRodW5kZXItLXN1YnNjcmlwdGlvbi1pZCcsXHJcblx0XHRcdCcudGh1bmRlci0tc3Vic2NyaXB0aW9uLXRodW1ibmFpbCcsXHJcblx0XHRcdCcudGh1bmRlci0tc3Vic2NyaXB0aW9uLWZpcnN0LWl0ZW0nLFxyXG5cdFx0XHQnLnRodW5kZXItLXN1YnNjcmlwdGlvbi1yZXN0LWl0ZW1zJyxcclxuXHRcdF0uam9pbignLCcpLCBldmVudCA9PiBUaHVuZGVyLmV4ZWN1dGUoXHJcblx0XHRcdGNvbnRleHQub3B0aW9ucy5vblZpZXdTdWJzY3JpcHRpb24sXHJcblx0XHRcdCRjb250YWluZXIsXHJcblx0XHRcdGNvbnRleHQsXHJcblx0XHRcdCQoZXZlbnQuZGVsZWdhdGVUYXJnZXQpLmRhdGEoJ3N1YnNjcmlwdGlvbicpXHJcblx0XHQpKTtcclxuXHJcblx0XHRpZiAoY29udGV4dC5vcHRpb25zLnVzZVBhZ2luYXRpb24pIHtcclxuXHJcblx0XHRcdFRodW5kZXIucGx1Z2lucy5wYWdpbmF0aW9uKHtcclxuXHRcdFx0XHRjb250YWluZXI6ICAgICAkcGFnaW5hdGlvbixcclxuXHRcdFx0XHRjdXJyZW50UGFnZTogICBjb250ZXh0Lm9wdGlvbnMucGFnZSxcclxuXHRcdFx0XHR0b3RhbFJlc3VsdDogICBjb250ZXh0LmNvdW50LFxyXG5cdFx0XHRcdHJlc3VsdFBlclBhZ2U6IGNvbnRleHQub3B0aW9ucy5saW1pdCxcclxuXHRcdFx0XHRvblBhZ2VDaGFuZ2U6ICAoeyBwYWdlIH0pID0+IFRodW5kZXIucmVuZGVyKFxyXG5cdFx0XHRcdFx0JGNvbnRhaW5lcixcclxuXHRcdFx0XHRcdGltcGxlbWVudGF0aW9uLm5hbWUsXHJcblx0XHRcdFx0XHQkLmV4dGVuZChjb250ZXh0Lm9wdGlvbnMsIHsgcGFnZSB9KVxyXG5cdFx0XHRcdClcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBsb2NhbFN0b3JhZ2U7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXNzYWdlLCBvaywgbm8gPSAoKSA9PiB7fSkge1xyXG5cclxuXHRyZXR1cm4gY29uZmlybShg8J+UlCAke21lc3NhZ2V9YCkgPyBvaygpIDogbm8oKTtcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBzZXNzaW9uU3RvcmFnZTsiLCJjb25zdCBlbW9qaUJ5VHlwZSA9IHtcclxuXHRlcnJvcjogICAn8J+aqCcsXHJcblx0c3VjY2VzczogJ+KchScsXHJcblx0aW5mbzogICAgJ/CfkqwnLFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0eXBlLCBtZXNzYWdlKSB7XHJcblxyXG5cdHJldHVybiBhbGVydChgJHtlbW9qaUJ5VHlwZVt0eXBlXSB8fCAnJ30gJHttZXNzYWdlfWApO1xyXG5cclxufTsiLCJjb25zdCBncm91cFN0YXJ0ID0gKGdyb3VwLCBwYWdlc0F0T25jZSkgPT4ge1xyXG5cdHJldHVybiAoKGdyb3VwIC0gMSkgKiBwYWdlc0F0T25jZSkgKyAxO1xyXG59O1xyXG5cclxuY29uc3QgZ3JvdXBFbmQgPSAoZ3JvdXAsIHBhZ2VzQXRPbmNlKSA9PiB7XHJcblx0cmV0dXJuIGdyb3VwU3RhcnQoZ3JvdXAsIHBhZ2VzQXRPbmNlKSArIHBhZ2VzQXRPbmNlIC0gMTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKG9wdGlvbnMgPSB7fSkgPT4ge1xyXG5cclxuXHRjb25zdCB7XHJcblx0XHR0eXBlID0gJ25vcm1hbCcsXHJcblx0XHRjb250YWluZXIsXHJcblx0XHRjdXJyZW50UGFnZSA9IDEsXHJcblx0XHR0b3RhbFJlc3VsdCxcclxuXHRcdHJlc3VsdFBlclBhZ2UsXHJcblx0XHRwYWdlc0F0T25jZSA9IDEwLFxyXG5cdFx0b25QYWdlQ2hhbmdlID0gKCkgPT4ge31cclxuXHR9ID0gb3B0aW9ucztcclxuXHJcblxyXG5cdGNvbnN0IGxhc3RQYWdlID0gTWF0aC5jZWlsKHRvdGFsUmVzdWx0IC8gcmVzdWx0UGVyUGFnZSk7XHJcblx0Y29uc3QgdG90YWxHcm91cHMgPSBNYXRoLmNlaWwobGFzdFBhZ2UgLyBwYWdlc0F0T25jZSk7XHJcblx0Y29uc3QgY3VycmVudEdyb3VwID0gTWF0aC5jZWlsKGN1cnJlbnRQYWdlIC8gcGFnZXNBdE9uY2UpO1xyXG5cdGNvbnN0IGN1cnJlbnRHcm91cFN0YXJ0ID0gZ3JvdXBTdGFydChjdXJyZW50R3JvdXAsIHBhZ2VzQXRPbmNlKTtcclxuXHJcblx0Y29uc3QgaXRlcmF0b3IgPSBBcnJheS5hcHBseShudWxsLCBBcnJheShwYWdlc0F0T25jZSkpXHJcblx0XHRcdFx0XHRcdC5tYXAoKHYsIGkpID0+IGkpXHJcblx0XHRcdFx0XHRcdC5maWx0ZXIodiA9PiBjdXJyZW50R3JvdXBTdGFydCArIHYgPD0gbGFzdFBhZ2UpO1xyXG5cclxuXHRpZiAoaXRlcmF0b3IubGVuZ3RoIDw9IDEpIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdGNvbnN0IHBhZ2UgPSAodGV4dCwgdHlwZSwgcGFnZSwgY3VycmVudCkgPT4gYFxyXG5cdFx0PGxpIGRhdGEtcGFnZT1cIiR7IHBhZ2UgfVwiXHJcblx0XHRcdGNsYXNzPVwiJHsgdHlwZSB9ICR7IHBhZ2UgPT09IGN1cnJlbnQgPyAnY3VycmVudCcgOiAnJyB9XCI+XHJcblx0XHRcdDxzcGFuPiR7IHRleHQgfHwgcGFnZSB9PC9zcGFuPlxyXG5cdFx0PC9saT5cclxuXHRgLnRyaW0oKTtcclxuXHJcblx0Y29uc3QgJHBhZ2luYXRpb24gPSAkKFtcclxuXHRcdGA8dWwgY2xhc3M9XCJ0aHVuZGVyLS1wYWdpbmF0aW9uICR7dHlwZX1cIj5gLFxyXG5cclxuXHRcdFx0Y3VycmVudEdyb3VwIDw9IDEgP1xyXG5cdFx0XHRcdCcnIDpcclxuXHRcdFx0XHRwYWdlKCc8JywgJ3RodW5kZXItLXBhZ2luYXRpb24tcHJldicsIGdyb3VwRW5kKGN1cnJlbnRHcm91cCAtIDEsIHBhZ2VzQXRPbmNlKSksXHJcblxyXG5cdFx0XHQuLi5pdGVyYXRvci5tYXAoaSA9PiBwYWdlKFxyXG5cdFx0XHRcdG51bGwsXHJcblx0XHRcdFx0J3RodW5kZXItLXBhZ2luYXRpb24tcGFnZScsXHJcblx0XHRcdFx0Y3VycmVudEdyb3VwU3RhcnQgKyBpLFxyXG5cdFx0XHRcdGN1cnJlbnRQYWdlXHJcblx0XHRcdCkpLFxyXG5cclxuXHRcdFx0Y3VycmVudEdyb3VwID49IHRvdGFsR3JvdXBzID9cclxuXHRcdFx0XHQnJyA6XHJcblx0XHRcdFx0cGFnZSgnPicsICd0aHVuZGVyLS1wYWdpbmF0aW9uLW5leHQnLCBncm91cFN0YXJ0KGN1cnJlbnRHcm91cCArIDEsIHBhZ2VzQXRPbmNlKSksXHJcblxyXG5cdFx0YDwvdWw+YCxcclxuXHRdLmpvaW4oJycpKTtcclxuXHJcblx0Y29udGFpbmVyLmh0bWwoJHBhZ2luYXRpb24pO1xyXG5cclxuXHQkcGFnaW5hdGlvbi5maW5kKCdbZGF0YS1wYWdlXScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdGNvbnN0IHBhZ2UgPSAkKHRoaXMpLmRhdGEoJ3BhZ2UnKTtcclxuXHJcblx0XHRpZiAoY3VycmVudFBhZ2UgPT09IHBhZ2UpIHJldHVybjtcclxuXHJcblx0XHRjb25zdCAkb3ZlcmxheSA9ICQodGhpcykucGFyZW50cygnI3RodW5kZXItLW92ZXJsYXknKTtcclxuXHJcblx0XHRjb25zdCBpc092ZXJsYXkgPSAhISRvdmVybGF5Lmxlbmd0aDtcclxuXHJcblx0XHRjb25zdCAkc2Nyb2xsVGFyZ2V0ID0gaXNPdmVybGF5ID8gJG92ZXJsYXkuZXEoMCkgOiAkKCdodG1sLCBib2R5Jyk7XHJcblx0XHRjb25zdCAkcG9zaXRpb25UYXJnZXQgPSAkKHRoaXMpLnBhcmVudHMoJy50aHVuZGVyLS1jb250ZW50cycpLmVxKDApO1xyXG5cclxuXHRcdGNvbnN0IG9mZnNldCA9IC02MDtcclxuXHJcblx0XHRjb25zdCBzY3JvbGxUb3AgPSBpc092ZXJsYXkgPyAoXHJcblx0XHRcdCRwb3NpdGlvblRhcmdldC5vZmZzZXQoKS50b3BcclxuXHRcdFx0XHQtICRzY3JvbGxUYXJnZXQub2Zmc2V0KCkudG9wXHJcblx0XHRcdFx0KyAkc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcCgpXHJcblx0XHRcdFx0KyBvZmZzZXRcclxuXHRcdCkgOiAoXHJcblx0XHRcdCRwb3NpdGlvblRhcmdldC5vZmZzZXQoKS50b3AgKyBvZmZzZXRcclxuXHRcdCk7XHJcblxyXG5cdFx0Y29uc3Qgc2hvdWxkTm90U2Nyb2xsID0gKFxyXG5cdFx0XHQhaXNPdmVybGF5ICYmXHJcblx0XHRcdCRzY3JvbGxUYXJnZXQuc2Nyb2xsVG9wKCkgPD0gc2Nyb2xsVG9wXHJcblx0XHQpO1xyXG5cclxuXHRcdG9uUGFnZUNoYW5nZSh7IHBhZ2UgfSk7XHJcblxyXG5cdFx0aWYgKHNob3VsZE5vdFNjcm9sbCkgcmV0dXJuO1xyXG5cclxuXHRcdC8vIOyYpOuyhOugiOydtCDssL3snbgg6rK97JqwXHJcblx0XHRyZXR1cm4gc2V0VGltZW91dCgoKSA9PiAkc2Nyb2xsVGFyZ2V0LmFuaW1hdGUoeyBzY3JvbGxUb3AgfSwgNDAwKSwgMzAwKTtcclxuXHJcblx0fSk7XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odG8pIHtcclxuXHJcblx0cmV0dXJuIGxvY2F0aW9uLnJlcGxhY2UodG8pO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBgZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFIa0FBQUI1Q0FZQUFBQWQrbzVKQUFBQUNYQklXWE1BQUFzU0FBQUxFZ0hTM1g3OEFBQUlvMGxFUVZSNG5PMmRXMjRUU1JSQWI2SWdIZ0ljUUVJZ0JQRmZmU2F6Z3NrT0pyTUN6QXJ3ckdCZ0I4a0tTSFpnVmpESkRwTFAra3RBQ0JRQndZQjRDQUdqMjl3eTNYYTN1NnE3SHJmYWRTUXJHWTFDbC92MHJicGR6NldmUDM5Q1Y1QlNiZ0xBS2dCczBGZkMvOWJsbUQ3dkFPQVFmeGRDSEhmaDFrUXJXVXE1UVJMeDB3ZUFkUWVYR1pQd2ZmVlRDUEhPd1hXY0VvMWtLV1dmaEc3UnoxNmdvaHlSOUpFUVlqOVFHWXhnTFZsS3VVcFNoNDRpdFMwWTZTTUEyQlpDSERJc1h3Wkx5ZFMyRGdEZ1BvUGk2SEtDc2dGZ2wxdVZ6a3F5bEJMRlBnS0FOUWJGYWNNZWZnOHVpUnNMeVIyU093MEwyVUVsZDFqdU5FRmxCNUZNcnovWWZ2M3AvZUxoR0ZPQzlzaDNDYnhLcG13WnYrUkRieGZsQnlab0E1K3ZYOTRrVThhOHV3QlZzeTQ3VklVN3o4U1hYVjhBZmduRzZQMHZDUzZBdGRrK05WMU9jUnJKVkQzdk0rM0k0TVFESWNTdXEvSTRpMlI2UW8rVFlDMmVTQ21kU1hZU3lmUnE5TVQ2UDl4OXNGOTgwM1k3YlQyU3BaVERKTGd4NjlSTzkyMytvMVlqbWFxY21QcWJ1VEttaUxZeTZHRXRrcE5ncS9Sc1p0NVdKQ2ZCVHJBbXVyVmtLZVYyRXV5TW5vMDJ1cFZreXFJWHVZdlNCeWg2UkgwT2pWaHArb2RTeWkzdVdmUzVjK2ZnOHVYTGNPblNwZXozOCtmUFQvN2ZqeDgvNE11WEwvRDE2MWY0OU9rVGZQejRNV2haYTFpblRxVkdWWGVqN0pyYWlmMkE4NnptZ2xKdjNMaVIvZFFGcForZG5jSGJ0Mit6MzVteUo0UVltQmJOV0RMbnJrcU0xbHUzYmhuSm5RWUZ2Mzc5T2hQT0ZPTXUwQ1p0OGk1SHdTaTIzKyszRW93c0x5L0R6WnMzczRjRmYyZklFOU9NMnlpU3VYWlg5bnE5VElwdHNMMSs5dXdaeCtyYnFQdFQrMUdsTkg2N1ZkRWNnSkhyUWpDQ2lkcWRPM2NDZjhOUzFtbnloUlltOWRFdXQwUUwyMkRYRXZBaHd1cWJJUTlwSWtZdFdwS3BtbVkzSDh0WHUzbnQyclhXYmIwanRCS3cyanRFMlRUTGF0cm5qY2RYTW9hczBheWJ1ZWlFd1NPTzc4TytiN3J2aDhxQVlWMjM1MXpKOU1mc3VpMnhMUTV4dzY5ZXZlcjltaHIwNnBLd3VrajJQa2RZQit5cURNR1ZLMWM0M2c3ay9yeG9ycFJNZjhSeWRDbFV0WWxKWHI3L214bVZBVGt2a2xsR01WQjF2WWpYcnFFeW1rc2xjNDVpb0U2S1VGeTRjQ0gwMTU5SGFXQldSZkl3U0JFVGJibGZOdTVjSmRsNE9DdkJoaGwzTTVLcGQ0dmxPTEVpNUlEQjkrL2ZnMTFiazVsYXVDeVN0N2lVdGdxYzBSRUtISmxpenRyMFVHUkJNaVZjZjNIL0ZpRnZkTWdIeklCQ05FOUhNdnNvUm5CT1Znanc0V0k4TlNoUHdXT1VrbkhTWFlpYlBSNlB2Vit6SWIzOE1PUkVNcVhlMFd6djRIc09GajVVRVVtR2ZNRG1JOWxrSDhyZytKNVZpUTlWSkZXMVlqYVNZNU9NTi96bHk1ZGVyb1Z0TWM3Z2pJeDExVEVTcldTZ3R0bDFGZXJ6WVhKQTVqUXZPY29kQVY2OWV1WDBsUW9GUi9CdVhFWDJ2cHhKMXAwUXhoV2NObXY3dFFvaitNV0xGOXlYejlSUmlHVG5POUM0QklVOGYvNGMzcng1WStVcWFyNTE1SUpCZVYzSi8wZnNZSEwwNGNPSGJBcHRrNGtGYWoxVWhFbFdGZmkrM0ZlU3JlNVJFUktNUW94cUhITldVMm5yQnZxeHFuLy8vbjMyZ0VUMm1xUkR2ek9SakZKUktQN01TLzMyN1ZzMmNyUzB0RlNZbzQzTGcvQ2pScFZ3a3A2YXFQZjU4K2VzanhybGQwRDZocExNZW1peENwU0o2NkJRanMxcE9mbXFYcjJtUmR3K3I2N1kzazdJQnhpUjE2OWY5ekwzR21lRzRnZWJnZFBUMDJDREl5M0lxdXVvSkt0RmFMNG4xT0YxNzk2OW15Vm1LRHNpK28yM2t3aUJxeVdxSnFoa2p1bVMxbEpZcnJJdWc0TmdCVWIxdlh2M3VDNVNueUdLVW1LYnlFV3dRb21PQWZhU3NlMjlmZnMyZzVMTWdxS1pybDB1d0Y0eTQ3MDdNaGl2WFo3QVdqTGo1YUlGbUs1ZG5zQmFNdmVicCtEK01MS1ZIR29OY2xPWXJsM09ZQ3NaWDVsaWduTjUyVXErZVBFaWcxS1l3YlhtV2VaNkJuQk1WYldDYVpuM1dVWnlMRDFKMDNBdHR5clZVZUJ5RkdDKzBMc1NwbHROSENySjBaM1RuOURtblpJY3hkbjhDWE13NTFLUzJaN0huMmhGMWd3cnlTeU9aVTlZSnd2ZVRESWRNaFhWa3IyRUZyOGxFNmxkN2g2WjB5UzV1NHpWTVlCSmNuZVorSnhJSnVzbmkzNW5Pc1JJZlpYcGZyZ1V6ZDFoTnBLSlVXZS84bUp4SklTWXZCWVhKQXNoUnFuSzdnU0Y0eVRLaGsxU05NZFB3V0daWkhhSGlpU00ySnMrRkd4R010WGxCK20rUnN2TU1VSlZvOXhHQno0bTJIQlNOdE9uVkRLZDZwa1NzUGd3MnJrZU9KOUJrU2pscE9ySTNVckpLWnFqbzlGcE1wQ2lPUm9xb3hqcUpLZG9qb1pXSjd4Qk9uU0VQUWQxeDkvWFNxYVUvT25DM0xMNHFEM2VTWGMyK05EbjlLQUlUbXdwSmNBZUlqdHFZc0E4dENSVEw1aTNKQ3lpc3g0S2VONys2VVRYaWZhNkRpSEV0cy91VHR3Q01UWThiK2cybU82anJzSjA4YzZXcjJyYjFvNjN2c0JkKzNDTFIwODhObG1vYUNTWm5od3YyVGJlc0ZnMlJmTmNWcHdRWU5SMEdpL0RvNGtGajAzL3JnbTQreDMzaU1iOEFUYy85NVJEakpzY0k3R0VPOFUyUVVvNThuVWFISzc3eGYxRE9LMy9WWHRqZXo3VjVnK2RiSHFhTnRzdURtaXltUE96S3pCcnhROHVEY1ZscmFFUHFzYXk0RmJKbnQ4QUhqUVJERzBpR1g0ZkdJWVhYbXY4anlSMCtJZmViaHJSYW1rOEpXTGVNdTRGWmErTllMQ3hNUXhWSVp0SnRCTlFjT3UzR1N1YlhDVFJUckFpR0d4dThaUVRuWVltMjdOalN6QzBUYnpLb0dUTVM5YmRVUjdVRFIyYVluMVBJa3JHTnRQd3BESFkxUDF0V3pDNGlPUThVa3JzZnZ2WDJRVzZ3eEVOT0RqWnU4V3BaUGdsZW92bWNVZDVMSkVIbnBxTUtEWEJ1V1Q0M1U2UFlqcHAzUU5ZUFE5ZFZNL1RlSkdza0ZJT2FhQjcwYVA2Z0tMWHk2NUxYaVhETDlGOVdsVG5aWENER2Q2aU40OTN5UW82czNsM2dmcTlkN0FXYzluMlZoRk1za0pLT2FBcXZLdXk5MGh1c0EzeGdrdFdkRkIyY0xrS05wSVZKSHNRYVNZK3BpWm9tNE5jQlR2SkNrclFoalNVeVQyNjhWMTM1RHVoMG9XdDVEelVvYkpGM2FWY2hCL1F1LytJVTlTV0VZWGtQRkxLRFpLdFByN2V1WTlvNENYN2hNaVNteEtkNUdtb1d0K2dEMHBmYlRrQ05xWXBUY2YwODVEcllTeTZSQzk1SHZRdXJzc3g5MnEzRVFEd1A3RStnQ2ZrblVvaEFBQUFBRWxGVGtTdVFtQ0NgO1xyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHJldHVybiBgXHJcblx0XHQ8c3BhbiBjbGFzcz1cInRodW5kZXItLWJ1dHRvbi1zcGlubmVyXCI+PC9zcGFuPlxyXG5cdGAudHJpbSgpO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRyZXR1cm4gYFxyXG5cdFx0PGRpdiBjbGFzcz1cInRodW5kZXItLWNvbXBvbmVudC1zcGlubmVyLXdyYXBwZXJcIj5cclxuXHRcdFx0PGRpdiBjbGFzcz1cInRodW5kZXItLWNvbXBvbmVudC1zcGlubmVyXCI+PC9kaXY+XHJcblx0XHQ8L2Rpdj5cclxuXHRgLnRyaW0oKTtcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gYGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQlVBQUFBVUNBTUFBQUJWbFlZQkFBQUFDWEJJV1hNQUFBc1NBQUFMRWdIUzNYNzhBQUFBWUZCTVZFWC8vLy9ZMk5qVzF0YlQwOVBZMk5qVjFkWFQwOVBYMTlmWDE5ZlgxOWZYMTlmVzF0YlcxdGJXMXRiVjFkWFYxZFhVMU5UVjFkWFQwOVBVMU5UVTFOVFQwOVBVMU5UVjFkWFcxdGJYMTlmWTJOaloyZG5hMnRyYjI5dmMzTnpkM2QwTWxwaUVBQUFBRlhSU1RsTUFIeTR3UEQxQWNJZWNyOERQM09mdjh2YjUrLzVsZFpkbEFBQUFxRWxFUVZRWUdXWEJnVnJDSUJnRjBHdFJ1SWd0by9zampuSGYveTFkU3Z1YW5vUE42enVlT1hMQWs4bEtPdUNCWjIwVzhDQ2RwUXNkZGo3WUpObUlQKzRZcGg5ZXRLcE1ZL0JZRFdRdTg2S2JPcCtORE1DWXRkZEtBZ1lXN1ZSR0FBTm4vYk5ZeEsvQVdadkZKdHhGTm5YTlRnZmNPUzdxR2owNlQyM28wUjJwalEzb1FwWlVTMm1TY2tBWHN1Yk1VMkt1eXAvb29obEhEL2lKbGlkMEwxL1I0Y2JGN3plc3JxZ2lGeDVaSitEZkFBQUFBRWxGVGtTdVFtQ0NgO1xyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIGBkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJVQUFBQVVDQU1BQUFCVmxZWUJBQUFBQ1hCSVdYTUFBQXNTQUFBTEVnSFMzWDc4QUFBQWFWQk1WRVgvLy8vNHlRRDJ4d0R5d3dENHlRRDF4Z0R5d3dENHlRRDN5QUQzeUFEM3lBRDJ4d0QyeHdEMnh3RDF4Z0QxeGdEenhBRDB4UUR5d3dEenhBRHp4QUR5d3dEenhBRDB4UUQxeGdEMnh3RDN5QUQ0eVFENXlnRDZ5d0Q3ekFEOHpRRDl6Z0QrendELzBBQkRHLytFQUFBQUZYUlNUbE1BSHk0d1BEMUFjSWVjcjhEUDNPZnY4dmI1Ky81bGRaZGxBQUFBcTBsRVFWUVlHV1hCQVZhRE1CUUV3SzFHVTR5QjFyajhGRVRDM3YrUVlodDUwczVnOC95S1I0NXM4S0N6SVIxd3gzTmUrb0E3NlNLTmROaDVZNUZrTGY2NFkrZytPV28xTTdYQlk5V1FOazVGVi9QWHhjZ0F0S2E5WlVoQXcxRTczNHdBR2s3NnAvUVJ2d0luYlVyZjRTYXlxRnJzZk1DTlkxRlY2RkY1YWtPUDZraHQrZ1pWTUVuek1CUkpPYUFLV1ZQbU9USFB5dStvb2hsYkQvaU9aaDJxcDFOMHVITHg0d1dySDkrUkdMZS8yUnlxQUFBQUFFbEZUa1N1UW1DQ2A7XHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gYGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQlFBQUFBVUNBWUFBQUNOaVIwTkFBQUFDWEJJV1hNQUFBc1NBQUFMRWdIUzNYNzhBQUFDQjBsRVFWUTRqWjJVTzJzVVVSVEgvK2Z1bWRtZGdDUldRaG9WaEowbFdnaUNFUkppYnlVSStnRXNMYmEyOFFOWWFDOHAvQUJpSUdBblJCQTBXd2xhVExOR2U5dlZlZHg3cnB3Wlo1ME0yVWYyd05tWnZmZmMzNXpuaGZkK29hYkgyUG41N2RXRFpXeEpmK1pKTnFMTFJZR1RIK3RmS1FpQzNYNi8vM0dldlpsTEF5Q0Mxd0NJaU9DY08xeGtQeGVZaldqSFd1eUZJUkNHSVVSa0kwbVM0Y3BBNTNCb2pNS0FUcWNEWTR4NitYd2xZRGFpb1hQWTZQWCtyM1c3WFUwOEowbnlkdGE1YVZHeUVUMzBIbys4eHcwUmJJb2c2blNBdGJYSzhQdUZjZmtzaXFKVUlySkU5TXNZOHhuQWh6aU9YNWJBOUJqRFBNZUw4ZzhCR3FLQ21LdDNYV3NDcTFRNHplZFVhNmVZK1lCRjhFUVBSbEVGV0VZMG42cTFLRkM5RnBHN2hnaEhJaHJLY3JDelJEMjIxbXJSamt6dnRuOGNCTmpQODlXZ0NzdnpYRDBleDNGOHZ3eFNvY3o0a3FibmcycithdGhnTUxpR1p0dEUyLzRtTThZSzFSUXNFczFibG1WYTdUODFETzArakxaOXViRmd2S2VpVUdQTTArYmFLYUNPMnJMaFV0MVBMV2szeWkyZzZzTnpRUGRtZXVnOUxyVVBhZmhaVmsxSSs2cFRvUGYrWW5PTlc0ZnYxTTJ0aGRGV3NyYmFzclljT1dKbW5ZanlvdmduNnpNOXJFVXJQWm1VTU11TWd5REExYTJ0NjRhWjk1MXpOazFUcUZaTytDdW52RzZHOGZzVDdZcmd2VEdZR0lNMzJwOW5mVkR2UkJGNXB2Y2pNOStMNC9oZHVRSGdMNDNJS3lPNnBORXZBQUFBQUVsRlRrU3VRbUNDYDtcclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBgZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCUUFBQUFVQ0FZQUFBQ05pUjBOQUFBQUNYQklXWE1BQUFzU0FBQUxFZ0hTM1g3OEFBQUJjMGxFUVZRNEVhVlUyMDNEUUJBY0l2NUpDU2xncFpnT1FnWFFBYVlDWEVKS2dBcGlLaUFkSkZRQWFLZUEwSUU3TUJwckhWMGNKODVqcEpQdDgzbjJOZU9idXE0eEJKSVRBR016K3hrNk96cVJURVRmSkordUpnVHdCcUFDOEJIM2x4T1NuQUY0QkZBQW1LdHNrdk5yTWxSR1gyYTJOTE5OUEJja3gyY1Rrc3dCVEFIa25RRFZzZEtiS1VmRURNQXN1ZDRCZURlem9pZlFBc0J2REt0WlpyWnVDTjFkay91TTgrbWg5U0daUkcrN3dZVVhFWmJ0Q3pPckRuYnpDRUphR3Raa0ZQMlluaUtKSTFDV3p3Q1dVQS9kUFhmMzJ0MExQWit6M0QyTGI4dkdkZTNIQ1dsK0ttR1FWUzJaMW82WFNhcnNWd0QzUTc1TkxMa3hzNnpkNytxd2RjRkI0U1lZeDNSVG5lNFJ0cEVHL3lwSkJUdkJlNTF5cVh5RTI1NE0vOUtORUhFUmxpdGJSd1JrQkwzZjduVXpWUHI2Q1RRV0k2bjdWZXhyQ0N1UzY3Q2ZzRmRKWDhrWlNSMlVYeFZaRTVlTGxNbERCRnhFTUFYUjJxSXJHMlVpSzZyaEtxL0p0b3VRak5yUWVIcmJjd0QvNDhNSXIrUEhJcW9BQUFBQVNVVk9SSzVDWUlJPWA7XHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0aWYgKCF0aGlzLm9wdGlvbnMuaGVhZGVyKSByZXR1cm4gJyc7XHJcblxyXG5cdGNvbnN0IHRlbXBsYXRlcyA9IFtdO1xyXG5cdGNvbnN0IHsgaXRlbXMgfSA9IHRoaXMub3B0aW9ucy5oZWFkZXI7XHJcblxyXG5cdGNvbnN0IG1lbnVJdGVtID0gKGNvbXBvbmVudCwgbWVzc2FnZSkgPT4ge1xyXG5cdFx0cmV0dXJuIGA8bGk+PGEgZGF0YS1jb21wb25lbnQ9XCIke2NvbXBvbmVudH1cIj4ke21lc3NhZ2V9PC9hPjwvbGk+YDtcclxuXHR9O1xyXG5cclxuXHRpdGVtcy5mb3JFYWNoKHR5cGUgPT4ge1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnY3VzdG9tZXInKSB7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5hdXRoZW50aWNhdGVkKCkpIHtcclxuXHJcblx0XHRcdFx0dGVtcGxhdGVzLnB1c2goYFxyXG5cdFx0XHRcdFx0PGxpPjxhIGRhdGEtdGh1bmRlci1sb2dvdXQ+JHt0aGlzLnBvbHlnbG90LnQoJ2hlYWRlci1uYXZpZ2F0aW9uLmxvZ291dCcpfTwvYT48L2xpPlxyXG5cdFx0XHRcdGApO1xyXG5cclxuXHRcdFx0XHR0ZW1wbGF0ZXMucHVzaChtZW51SXRlbShcclxuXHRcdFx0XHRcdCdjdXN0b21lci1kYXNoYm9hcmQnLFxyXG5cdFx0XHRcdFx0dGhpcy5wb2x5Z2xvdC50KCdoZWFkZXItbmF2aWdhdGlvbi5wcm9maWxlJylcclxuXHRcdFx0XHQpKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRlbXBsYXRlcy5wdXNoKG1lbnVJdGVtKFxyXG5cdFx0XHRcdFx0J2N1c3RvbWVyLXJlZ2lzdGVyJyxcclxuXHRcdFx0XHRcdHRoaXMucG9seWdsb3QudCgnaGVhZGVyLW5hdmlnYXRpb24ucmVnaXN0ZXInKVxyXG5cdFx0XHRcdCkpO1xyXG5cclxuXHRcdFx0XHR0ZW1wbGF0ZXMucHVzaChtZW51SXRlbShcclxuXHRcdFx0XHRcdCdjdXN0b21lci1sb2dpbicsXHJcblx0XHRcdFx0XHR0aGlzLnBvbHlnbG90LnQoJ2hlYWRlci1uYXZpZ2F0aW9uLmxvZ2luJylcclxuXHRcdFx0XHQpKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdzZWFyY2gtcHVyY2hhc2UnKSB7XHJcblxyXG5cdFx0XHRpZiAoIXRoaXMuYXV0aGVudGljYXRlZCgpKSB7XHJcblxyXG5cdFx0XHRcdHRlbXBsYXRlcy5wdXNoKG1lbnVJdGVtKFxyXG5cdFx0XHRcdFx0J3NlYXJjaC1wdXJjaGFzZScsXHJcblx0XHRcdFx0XHR0aGlzLnBvbHlnbG90LnQoJ2hlYWRlci1uYXZpZ2F0aW9uLnNlYXJjaE9yZGVyJylcclxuXHRcdFx0XHQpKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdjYXJ0Jykge1xyXG5cclxuXHRcdFx0dGVtcGxhdGVzLnB1c2gobWVudUl0ZW0oXHJcblx0XHRcdFx0J2NhcnQnLFxyXG5cdFx0XHRcdHRoaXMucG9seWdsb3QudCgnaGVhZGVyLW5hdmlnYXRpb24uY2FydCcpXHJcblx0XHRcdCkpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBgXHJcblx0XHQ8ZGl2IGlkPVwidGh1bmRlci0taGVhZGVyLW5hdmlnYXRpb25cIj5cclxuXHRcdFx0PHVsPlxyXG5cdFx0XHRcdCR7dGVtcGxhdGVzLmpvaW4oJycpfVxyXG5cdFx0XHQ8L3VsPlxyXG5cdFx0PC9kaXY+XHJcblx0YDtcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gYGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRHdBQUFBOENBTUFBQUFOSWlsQUFBQUFnVkJNVkVVQUFBQUFBQUFBQUFEWTJOZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRHY3Kzh6TXpNQUFBQUFBQUFBQUFEYTJ0b0FBQUFBQUFBQUFBQUFBQURkM2QwQUFBRFkyTmpNek16cjYrdlEwTkM5dmIwQUFBRDM5L2Z3OFBEUTBOQzd1N3NqSXlPZ29LQXBLU21xcXFvNU9UbDFkWFZDUWtMLy8vK1ZIc1o4QUFBQUtuUlNUbE1BQlF1OUV3bEJJQjR4TGhFVjNVOUZJaGk3UENrbEQ3ZzBsNHpoeEd4WDk5NmNnM1JtWW1CSFJqNEFqaGlDQUFBQkprbEVRVlJJeCszWHkyN0RJQkFGVUE4eEJodWFCTnY0bFNaOXYvai9EK3lVZHFSbTE1bEdsU3FaaFhkSDk1ckZhQ2grZktBUUhnRFFHajh5cXdibm5OSWdzSHJ3MWhqckJ3MTg2MEpzbHZsb3ZBSzJMVzNUalNtbG8zVWF1TGxvMjRSbk5valp1VlcyYWRralp0dE50bU50SFRBN2syMjdQaWlRNVc2cWh1NkxiM2UxS1ZuV2ZiZDdyMFM1WkVIYW1heXdNNnlkMTg2c3pwZTNnczZFVmVpNzlzdE9uTndjYktZeDIrdmRGRmtXY1JtWFQzdXErakNnNVdEZjMzM1ltNGRURjJuYU1aTHZjL0xoaVpJbC8zelkwajlMYnZ0cWk5TlNDV2M4YWZnenJVcFRuK3VDcDMrVnZUWmZtLy9INWhxMXNEbnRZYUxtTDdRQlNwcmZ2dEh1eWRCblc2OVl6NFE1bWpiOVowdVlOeFZqL1RpLzB2YkoxVUh5dWlGTjc2b0x2dWplQWFQblFPTjRRRXd0QUFBQUFFbEZUa1N1UW1DQ2A7XHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0cmV0dXJuIGBcclxuXHRcdDxkaXYgY2xhc3M9XCJ0aHVuZGVyLS1vdmVybGF5LW5hdlwiPlxyXG5cdFx0XHQ8c3BhbiBjbGFzcz1cInRodW5kZXItLWNsb3NlLW92ZXJsYXlcIiBkYXRhLXRodW5kZXItY2xvc2U+JnRpbWVzOzxzcGFuPlxyXG5cdFx0PC9kaXY+XHJcblx0YC50cmltKCk7XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGVmYXVsdFJhdGluZyA9IDUpIHtcclxuXHJcblx0Y29uc3QgcmF0aW5ncyA9IFsxLCAyLCAzLCA0LCA1XTtcclxuXHJcblx0cmV0dXJuIGBcclxuXHQ8c2VsZWN0IG5hbWU9XCJyYXRpbmdcIj4ke3JhdGluZ3MubWFwKHIgPT4gYFxyXG5cdFx0PG9wdGlvbiB2YWx1ZT1cIiR7cn1cIiAke2RlZmF1bHRSYXRpbmcgPT09IHIgPyAnc2VsZWN0ZWQnIDogJyd9PiR7J+KtkCcucmVwZWF0KHIpfTwvb3B0aW9uPlxyXG5cdGAudHJpbSgpKS5qb2luKCcnKX1cclxuXHQ8L3NlbGVjdD5cclxuXHRgLnRyaW0oKTtcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdGFycmVkID0gMCkge1xyXG5cclxuXHRjb25zdCBzdGFycyA9IFtdO1xyXG5cclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJyZWQgLSAxOyBpKyspIHtcclxuXHRcdHN0YXJzLnB1c2goMSk7XHJcblx0fVxyXG5cclxuXHRjb25zdCByZXN0ID0gc3RhcnJlZCAtIHN0YXJzLmxlbmd0aDtcclxuXHJcblx0aWYgKHJlc3QgPiAwKSB7XHJcblx0XHRzdGFycy5wdXNoKHJlc3QpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIFtcclxuXHRcdGA8c3BhbiBjbGFzcz1cInRodW5kZXItLXJldmlldy1zdGFyc1wiIGRhdGEtcmF0aW5nPVwiJHtzdGFycmVkfVwiPmAsXHJcblx0XHQuLi5BcnJheS5hcHBseShudWxsLCB7IGxlbmd0aDogNSB9KS5tYXAoKGVsLCBpKSA9PiB7XHJcblx0XHRcdHJldHVybiBzdGFycmVkID09PSAwID9cclxuXHRcdFx0XHRcdGA8aW1nIHNyYz1cIiR7dGhpcy51aShzdGFyKC0xKSkoKX1cIj5gIDpcclxuXHRcdFx0XHRcdGA8aW1nIHNyYz1cIiR7dGhpcy51aShzdGFyKHN0YXJzW2ldIHx8IDApKSgpfVwiPmA7XHJcblx0XHR9KSxcclxuXHRcdGA8L3NwYW4+YCxcclxuXHRdLmpvaW4oJycpO1xyXG5cclxufTtcclxuXHJcbmZ1bmN0aW9uIHN0YXIobiA9IDApIHtcclxuXHJcblx0aWYgKG4gPT09IC0xKSByZXR1cm4gJ2hhbGxvdy1zdGFyJztcclxuXHRpZiAobiA9PT0gMCkgcmV0dXJuICdlbXB0eS1zdGFyJztcclxuXHRpZiAobiA9PT0gMSkgcmV0dXJuICdmaWxsZWQtc3Rhcic7XHJcblxyXG5cdHJldHVybiBuID49IDAuNSA/XHJcblx0XHQnaGFsZi1maWxsZWQtc3RhcicgOlxyXG5cdFx0J2VtcHR5LXN0YXInO1xyXG5cclxufSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIGBkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUR3QUFBQThDQU1BQUFBTklpbEFBQUFBZ1ZCTVZFVUFBQUFBQUFBQUFBQUFBQUQ1K2ZrQUFBQUFBQUFBQUFBQUFBQUFBQUIxZFhVQUFBQUFBQUFBQUFDcnE2dHRiVzBBQUFBQUFBQUFBQUFBQUFBQUFBRDcrL3NBQUFCL2YzOEFBQUI0ZUhnQUFBQUFBQURZMk5pK3ZyNWlZbUlBQUFEMzkvZjE5Zlh3OFBDdnI2K2FtcHJOemMwQUFBQ05qWTFCUVVGTlRVMy8vLzhpVTJMK0FBQUFLblJTVGxNQUF3WU05UWtXTlJ3bGFCQXJQWTl3RWlNWkxSLzBLR0F4WlRwT2w0RjhST2JZeTdxZWkyUldQalhkaW9IYUFBQUJCMGxFUVZSSXgrM1h5VzRESVF3RzRBSENoQW5UbGdGbXk5SjBYM2ovQjJ3VEV2bVEwKzhjb2tqNC9zbkNTSmIvNnFMRXNTcFdDU20xbHBJNFpMV3l6aW90QmNNcTUyTVh2Vk80RnRxWjMrMzJlNGgxMWxoalA3eW0xSTlUbHpXR1RVanBYOCtrSWR3ZjlHSzFiTEpHc0cvSEJWZHIxeTFYdUthSnJaKzRXbHZUUGpDMXVLV1dSUmQ5ajdxN1Rqc2xLMHlIczU2RHNWSkEyc1ZwLzV6MTJOUWEzSWwxczk1azNRZlAySW1ici9kMHFHQXl4anAvSE8xTDdneTlPZXdmRTcwWjNXZ25PMC9SYW9GYittZkJ0RTFkYkxIRm9yYmlXcnJEY0V2YkRyZDBlKzVZbG4vMUVzNjdqaXcwcnplNjlQR01NZXcrZjlwSUZrbzNodElOcnEwRGNoVS8wZjBCUDYxQUdwSjBrZzRBQUFBQVNVVk9SSzVDWUlJPWA7XHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0cmV0dXJuIGBcclxuXHRcdDxkaXYgY2xhc3M9XCJ0aHVuZGVyLS1zZWN0aW9uLXNwaW5uZXItd3JhcHBlclwiPlxyXG5cdFx0XHQ8c3BhbiBjbGFzcz1cInRodW5kZXItLXNlY3Rpb24tc3Bpbm5lclwiPjwvc3Bhbj5cclxuXHRcdDwvZGl2PlxyXG5cdGAudHJpbSgpO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMgPSB7fSkge1xyXG5cclxuXHRsZXQge1xyXG5cdFx0dHlwZSA9ICdsb2dpbicsIC8vICdsb2dpbicgb3IgJ3JlZ2lzdGVyJ1xyXG5cdFx0dmVuZG9ycyA9IFtcclxuXHRcdFx0J2ZhY2Vib29rJyxcclxuXHRcdFx0J2dvb2dsZScsXHJcblx0XHRcdCdpbnN0YWdyYW0nLFxyXG5cdFx0XHQnbmF2ZXInLFxyXG5cdFx0XHQna2FrYW8nLFxyXG5cdFx0XSxcclxuXHRcdGxvZ29zID0ge1xyXG5cdFx0XHRmYWNlYm9vazogIGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjIxXCIgaGVpZ2h0PVwiMjFcIj48cGF0aCBkPVwiTTE5LjQuNUgxLjZDMSAuNS41IDEgLjUgMS42djE3LjhjMCAuNi41IDEuMSAxLjEgMS4xaDkuNnYtNy43SDguNnYtM2gyLjZWNy41YzAtMi42IDEuNi00IDMuOS00IC44IDAgMS42IDAgMi4zLjF2Mi43aC0xLjZjLTEuMyAwLTEuNS42LTEuNSAxLjV2MS45aDNsLS40IDNoLTIuNnY3LjdoNS4xYy42IDAgMS4xLS41IDEuMS0xLjFWMS42YzAtLjYtLjUtMS4xLTEuMS0xLjF6XCIgZmlsbD1cIiNmZmZcIi8+PC9zdmc+YCxcclxuXHRcdFx0Z29vZ2xlOiAgICBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyMVwiIGhlaWdodD1cIjIxXCI+PHBhdGggZD1cIk0yMC4xIDEwLjdjMC0uNy0uMS0xLjQtLjItMmgtOS40djMuOWg1LjRjLS4yIDEuMy0uOSAyLjMtMiAzdjIuNWgzLjJjMS45LTEuOCAzLTQuMyAzLTcuNHpcIiBmaWxsPVwiIzQyODVmNFwiLz48cGF0aCBkPVwiTTEwLjUgMjAuNWMyLjcgMCA1LS45IDYuNi0yLjRsLTMuMi0yLjVjLS45LjYtMiAxLTMuNCAxLTIuNiAwLTQuOC0xLjgtNS42LTQuMUgxLjZWMTVjMS42IDMuMyA1IDUuNSA4LjkgNS41elwiIGZpbGw9XCIjMzRhODUzXCIvPjxwYXRoIGQ9XCJNNC45IDEyLjRjLS4yLS42LS4zLTEuMi0uMy0xLjlzLjEtMS4zLjMtMS45VjZIMS42Qy45IDcuNC41IDguOS41IDEwLjVzLjQgMy4xIDEuMSA0LjVsMy4zLTIuNnpcIiBmaWxsPVwiI2ZiYmMwNVwiLz48cGF0aCBkPVwiTTEwLjUgNC41YzEuNSAwIDIuOC41IDMuOCAxLjVsMi45LTIuOWMtMS43LTEuNi00LTIuNi02LjctMi42QzYuNi41IDMuMiAyLjcgMS42IDZsMy4zIDIuNmMuOC0yLjQgMy00LjEgNS42LTQuMXpcIiBmaWxsPVwiI2VhNDMzNVwiLz48cGF0aCBkPVwiTS41LjVoMjB2MjBILjVWLjV6XCIgZmlsbD1cIm5vbmVcIi8+PC9zdmc+YCxcclxuXHRcdFx0aW5zdGFncmFtOiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyMVwiIGhlaWdodD1cIjIxXCI+PHN0eWxlPi5zdDB7ZmlsbDojZmZmfTwvc3R5bGU+PHBhdGggY2xhc3M9XCJzdDBcIiBkPVwiTTEwLjUgMS45YzIuOCAwIDMuMSAwIDQuMi4xIDEgMCAxLjYuMiAxLjkuNC41LjIuOC40IDEuMi44LjQuNC42LjcuOCAxLjIuMi4zLjQuOC40IDEuOS4xIDEuMS4xIDEuNC4xIDQuMnMwIDMuMS0uMSA0LjJjMCAxLS4yIDEuNi0uNCAxLjktLjIuNS0uNC44LS44IDEuMi0uNC40LS43LjYtMS4yLjgtLjQuMS0uOS4zLTEuOS40LTEuMS4xLTEuNC4xLTQuMi4xcy0zLjEgMC00LjItLjFjLTEgMC0xLjYtLjItMS45LS40LS41LS4yLS44LS40LTEuMi0uOC0uNC0uNC0uNi0uNy0uOC0xLjItLjItLjMtLjQtLjgtLjQtMS45LS4xLTEuMS0uMS0xLjQtLjEtNC4yczAtMy4xLjEtNC4yYzAtMSAuMi0xLjYuNC0xLjkuMi0uNS40LS44LjgtMS4yLjQtLjQuNy0uNiAxLjItLjguMy0uMi44LS40IDEuOS0uNCAxLjEtLjEgMS40LS4xIDQuMi0uMW0wLTEuOUM3LjYgMCA3LjMgMCA2LjIuMSA1LjEuMSA0LjMuMyAzLjYuNmMtLjcuMi0xLjMuNi0xLjggMS4yLS42LjUtMSAxLjEtMS4yIDEuOC0uMy43LS41IDEuNS0uNSAyLjZDMCA3LjMgMCA3LjYgMCAxMC41czAgMy4yLjEgNC4zYy4xIDEuMS4yIDEuOS41IDIuNS4zLjcuNiAxLjMgMS4yIDEuOS42LjYgMS4yLjkgMS45IDEuMi43LjMgMS40LjQgMi41LjUgMS4xLjEgMS40LjEgNC4zLjFzMy4yIDAgNC4zLS4xYzEuMS0uMSAxLjktLjIgMi41LS41LjctLjMgMS4zLS42IDEuOS0xLjIuNi0uNi45LTEuMiAxLjItMS45LjMtLjcuNC0xLjQuNS0yLjUuMS0xLjEuMS0xLjUuMS00LjNzMC0zLjItLjEtNC4zYy0uMS0xLjEtLjItMS45LS41LTIuNS0uMy0uNy0uNi0xLjMtMS4yLTEuOS0uNi0uNi0xLjItLjktMS45LTEuMi0uNy0uMy0xLjQtLjQtMi41LS41LTEuMS0uMS0xLjQtLjEtNC4zLS4xelwiLz48cGF0aCBjbGFzcz1cInN0MFwiIGQ9XCJNMTAuNSA1LjFjLTMgMC01LjQgMi40LTUuNCA1LjRzMi40IDUuNCA1LjQgNS40IDUuNC0yLjQgNS40LTUuNC0yLjQtNS40LTUuNC01LjR6bTAgOC45QzguNiAxNCA3IDEyLjQgNyAxMC41UzguNiA3IDEwLjUgNyAxNCA4LjYgMTQgMTAuNSAxMi40IDE0IDEwLjUgMTR6XCIvPjxjaXJjbGUgY2xhc3M9XCJzdDBcIiBjeD1cIjE2LjFcIiBjeT1cIjQuOVwiIHI9XCIxLjNcIi8+PC9zdmc+YCxcclxuXHRcdFx0bmF2ZXI6ICAgICBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyMVwiIGhlaWdodD1cIjIxXCI+PHBhdGggZmlsbD1cIiNmZmZcIiBkPVwiTTEzLjUgMS44djguOGwtNi04LjhILjl2MTcuNWg2LjZ2LTguOWw2IDguOWg2LjZWMS44elwiLz48L3N2Zz5gLFxyXG5cdFx0XHRrYWthbzogICAgIGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjIxXCIgaGVpZ2h0PVwiMjFcIj48cGF0aCBkPVwiTTEwLjUgMS43QzUgMS43LjUgNS4yLjUgOS42YzAgMi44IDEuOSA1LjMgNC43IDYuNy0uMi44LS44IDIuOC0uOSAzLjMtLjEuNS4yLjUuNC40LjItLjEgMi43LTEuOSAzLjgtMi42LjYuMSAxLjIuMSAxLjkuMSA1LjUgMCAxMC0zLjUgMTAtNy45UzE2IDEuNyAxMC41IDEuN3pcIiBmaWxsPVwiIzNjMWUxZVwiLz48L3N2Zz5gLFxyXG5cdFx0fSxcclxuXHR9ID0gb3B0aW9ucztcclxuXHJcblx0dmVuZG9ycyA9IHR5cGVvZiB2ZW5kb3JzID09PSAnc3RyaW5nJyA/XHJcblx0XHRcdFx0dmVuZG9ycy5zcGxpdCgnLCcpLmZpbHRlcih2ID0+IHYpIDpcclxuXHRcdFx0XHR2ZW5kb3JzO1xyXG5cclxuXHRpZiAodmVuZG9ycy5sZW5ndGggPT09IDApIHtcclxuXHRcdHJldHVybiAnJztcclxuXHR9XHJcblxyXG5cdHJldHVybiBgXHJcblx0XHQ8dWwgY2xhc3M9XCJ0aHVuZGVyLS1zb2NpYWwtYXBwLWFjdGlvbnMgdGh1bmRlci0tc29jaWFsLWFwcC0ke3R5cGV9XCI+XHJcblx0XHRcdCR7IHZlbmRvcnMubWFwKHZlbmRvciA9PiBgXHJcblx0XHRcdDxsaSBjbGFzcz1cInRodW5kZXItc29jaWFsLWFwcC0ke3ZlbmRvcn1cIj5cclxuXHRcdFx0XHQ8YnV0dG9uIGRhdGEtc29jaWFsLWFwcD1cIiR7dmVuZG9yfVwiPlxyXG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ0aHVuZGVyLS1zb2NpYWwtYXBwLWxvZ29cIj4ke2xvZ29zW3ZlbmRvcl19PC9zcGFuPlxyXG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ0aHVuZGVyLS1zb2NpYWwtYXBwLWJ1dHRvbi1tZXNzYWdlXCI+JHt0aGlzLnBvbHlnbG90LnQoYHNvY2lhbC1sb2dpbi4ke3R5cGV9Qnkke3ZlbmRvclswXS50b1VwcGVyQ2FzZSgpICsgdmVuZG9yLnNsaWNlKDEpfWApfTwvc3Bhbj5cclxuXHRcdFx0XHQ8L2J1dHRvbj5cclxuXHRcdFx0PC9saT5cclxuXHRcdFx0YCkuam9pbignJykgfVxyXG5cdFx0PC91bD5cclxuXHRgLnRyaW0oKTtcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihib2R5KSB7XHJcblxyXG5cdHJldHVybiBgXHJcblx0XHQ8ZGl2IGNsYXNzPVwidGh1bmRlci0tdGV4dC1ib3gtb3ZlcmxheVwiPlxyXG5cdFx0XHQ8ZGl2IGNsYXNzPVwidGh1bmRlci0tdGV4dC1ib3gtb3ZlcmxheS1oZWFkZXJcIj5cclxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cInRodW5kZXItLXRleHQtYm94LW92ZXJsYXktY2xvc2VcIj7Dlzwvc3Bhbj5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHRcdDxkaXYgY2xhc3M9XCJ0aHVuZGVyLS10ZXh0LWJveC1vdmVybGF5LWJvZHlcIj5cclxuXHRcdFx0XHQke2JvZHl9XHJcblx0XHRcdDwvZGl2PlxyXG5cdFx0PC9kaXY+XHJcblx0YC50cmltKCk7XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gKGZyb20sIHR5cGUsIHZhbHVlKSA9PiB7XHJcblxyXG5cdGNvbnN0IHRpbWVNYXAgPSB7XHJcblx0XHRkYXlzOiAgODY0MDAwMDAsICAvLyDtlZjro6jrpbwg67CA66as7LSI66GcIO2ZmOyCsFxyXG5cdFx0d2Vla3M6IDYwNDgwMDAwMCwgLy8g7ZWcIOyjvOulvCDrsIDrpqzstIjroZwg7ZmY7IKwXHJcblx0fTtcclxuXHJcblx0Y29uc3QgdG9EYXRlID0gZGF0ZSA9PiBkYXRlID8gbmV3IERhdGUoZGF0ZSkgOiBuZXcgRGF0ZSgpO1xyXG5cclxuXHRjb25zdCBvcmlnaW5hbCA9IHRvRGF0ZShmcm9tKTtcclxuXHRjb25zdCBvcmlnaW5hbFRpbWUgPSBvcmlnaW5hbC52YWx1ZU9mKCk7XHJcblx0Y29uc3Qgb3JpZ2luYWxZZWFyID0gb3JpZ2luYWwuZ2V0RnVsbFllYXIoKTtcclxuXHRjb25zdCBvcmlnaW5hbE1vbnRoID0gb3JpZ2luYWwuZ2V0TW9udGgoKTtcclxuXHRjb25zdCBvcmlnaW5hbERhdGUgPSBvcmlnaW5hbC5nZXREYXRlKCk7XHJcblxyXG5cdC8vIGBkYXlzYCwgYHdlZWtzYCDsvIDsnbTsiqQgKOuLqOyInO2eiCDsmKTtlITshYvsnYQg6rOE7IKw7ZW0IOuNlO2VqClcclxuXHRpZiAodGltZU1hcFt0eXBlXSkge1xyXG5cclxuXHRcdGNvbnN0IG9mZnNldCA9IHRpbWVNYXBbdHlwZV0gKiBOdW1iZXIodmFsdWUpO1xyXG5cclxuXHRcdHJldHVybiB0b0RhdGUob3JpZ2luYWxUaW1lICsgb2Zmc2V0KTtcclxuXHR9XHJcblxyXG5cdC8vIOyblCDsvIDsnbTsiqRcclxuXHRpZiAodHlwZSA9PT0gJ21vbnRocycpIHtcclxuXHJcblx0XHRjb25zdCB5ZWFyT2Zmc2V0ID0gTWF0aC5mbG9vcigob3JpZ2luYWxNb250aCArIE51bWJlcih2YWx1ZSkpIC8gMTIpO1xyXG5cdFx0Y29uc3QgbmV3TW9udGggPSAob3JpZ2luYWxNb250aCArIE51bWJlcih2YWx1ZSkpICUgMTI7XHJcblxyXG5cdFx0b3JpZ2luYWwuc2V0RnVsbFllYXIob3JpZ2luYWxZZWFyICsgeWVhck9mZnNldCk7XHJcblx0XHRvcmlnaW5hbC5zZXRNb250aChuZXdNb250aCk7XHJcblxyXG5cdFx0aWYgKG5ld01vbnRoICE9PSBvcmlnaW5hbC5nZXRNb250aCgpKSB7XHJcblx0XHRcdG9yaWdpbmFsLnNldERhdGUoMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9yaWdpbmFsO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIOuFhCDsvIDsnbTsiqRcclxuXHRpZiAodHlwZSA9PT0gJ3llYXJzJykge1xyXG5cclxuXHRcdGNvbnN0IGV4cGlyZXNZZWFyID0gb3JpZ2luYWwuZ2V0RnVsbFllYXIoKSArIE51bWJlcih2YWx1ZSk7XHJcblxyXG5cdFx0b3JpZ2luYWwuc2V0RnVsbFllYXIoZXhwaXJlc1llYXIpO1xyXG5cclxuXHRcdC8vIOq4sOyhtCDrgqDsp5zqsIAgMuyblCAyOeydvOydtOuptOyEnCxcclxuXHRcdC8vIOuNlO2VtOynhCDrgqDsp5zroZwg6rCU7J2EIOuVjCAz7JuU7J20IOuQnCDqsr3smrAgKDLsm5QgMjnsnbzsnbQg7JeG64qUIOqyveyasClcclxuXHRcdGlmIChvcmlnaW5hbE1vbnRoID09PSAxICYmXHJcblx0XHRcdG9yaWdpbmFsRGF0ZSA9PT0gMjkgJiZcclxuXHRcdFx0b3JpZ2luYWwuZ2V0TW9udGgoKSA9PT0gMikge1xyXG5cdFx0XHRvcmlnaW5hbC5zZXREYXRlKDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvcmlnaW5hbDtcclxuXHJcblx0fVxyXG5cclxuXHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHRpbWUgdHlwZScpO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9ICh7XHJcblx0JHRlcm1zLFxyXG5cdGFncmVlbWVudHNcclxufSkgPT4ge1xyXG5cclxuXHRjb25zdCAkYWxsID0gJHRlcm1zLmZpbHRlcignW2RhdGEtYWdyZWVtZW50LXNjb3BlPVwiYWxsXCJdJyk7XHJcblx0Y29uc3QgJGFsbENoZWNrID0gJGFsbC5maW5kKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcclxuXHJcblx0JHRlcm1zID0gJHRlcm1zLmZpbHRlcignW2RhdGEtYWdyZWVtZW50LXNjb3BlIT1cImFsbFwiXScpO1xyXG5cdGNvbnN0ICR0ZXJtc0NoZWNrcyA9ICR0ZXJtcy5maW5kKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcclxuXHJcblx0Y29uc3QgJHJlcXVpcmVkVGVybXNDaGVja3MgPSAkdGVybXMuZmluZCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdW3JlcXVpcmVkXScpO1xyXG5cclxuXHQkdGVybXNDaGVja3Mub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdCRhbGxDaGVjay5wcm9wKCdjaGVja2VkJywgJHRlcm1zQ2hlY2tzLm1hcChmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuICQodGhpcykuaXMoJzpjaGVja2VkJyk7XHJcblx0XHR9KS5nZXQoKS5ldmVyeSh2ID0+IHYpKTtcclxuXHJcblx0fSk7XHJcblxyXG5cdCRhbGxDaGVjay5vbignY2hhbmdlJywgZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0Y29uc3QgY2hlY2tlZCA9ICRhbGxDaGVjay5pcygnOmNoZWNrZWQnKTtcclxuXHJcblx0XHQkdGVybXNDaGVja3MuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0JCh0aGlzKS5wcm9wKCdjaGVja2VkJywgY2hlY2tlZCk7XHJcblx0XHR9KTtcclxuXHJcblx0fSk7XHJcblxyXG5cdCR0ZXJtcy5maW5kKCdhJykuZmlsdGVyKCc6bm90KFtocmVmXSknKS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcblxyXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdGNvbnN0IHNjb3BlID0gJCh0aGlzKS5wYXJlbnRzKCdbZGF0YS1hZ3JlZW1lbnQtc2NvcGVdJykuZGF0YSgnYWdyZWVtZW50U2NvcGUnKTtcclxuXHRcdGNvbnN0ICRvdmVybGF5ID0gJChUaHVuZGVyLnVpKCd0ZXh0LWJveC1vdmVybGF5JykoYWdyZWVtZW50c1tzY29wZV0udGV4dCkpO1xyXG5cdFx0Y29uc3QgJGNsb3NlID0gJG92ZXJsYXkuZmluZCgnLnRodW5kZXItLXRleHQtYm94LW92ZXJsYXktY2xvc2UnKTtcclxuXHJcblx0XHQkKCdib2R5JykuYXBwZW5kKCRvdmVybGF5KTtcclxuXHJcblx0XHQkY2xvc2Uub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcblx0XHRcdCRvdmVybGF5LnJlbW92ZSgpO1xyXG5cdFx0fSk7XHJcblxyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gKCkgPT4ge1xyXG5cclxuXHRcdGlmICghJHJlcXVpcmVkVGVybXNDaGVja3MubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgJHJlcXVpcmVkVGVybXNDaGVja3MubGVuZ3RoOyBpKyspIHtcclxuXHJcblx0XHRcdGNvbnN0ICR0ZXJtID0gJHJlcXVpcmVkVGVybXNDaGVja3MuZXEoaSk7XHJcblxyXG5cdFx0XHRpZiAoISR0ZXJtLmlzKCc6Y2hlY2tlZCcpKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHNjb3BlID0gJHRlcm0ucGFyZW50cygnW2RhdGEtYWdyZWVtZW50LXNjb3BlXScpLmRhdGEoJ2FncmVlbWVudFNjb3BlJyk7XHJcblxyXG5cdFx0XHRcdFRodW5kZXIubm90aWZ5KCdlcnJvcicsIGFncmVlbWVudHNbc2NvcGVdLmVycm9yKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cclxufTsiLCJjb25zdCBnZXQgPSByZXF1aXJlKCdsb2Rhc2guZ2V0Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCRidXR0b24sIGNvbnRleHQpIHtcclxuXHJcblx0Y29uc3QgaGlzdG9yeSA9IGdldChjb250ZXh0LCAnb3B0aW9ucy5iYWNrJyk7XHJcblxyXG5cdGlmICghJGJ1dHRvbiB8fCAhaGlzdG9yeSkgcmV0dXJuO1xyXG5cclxuXHRjb25zdCB7XHJcblx0XHQkY29udGFpbmVyLFxyXG5cdFx0Y29tcG9uZW50LFxyXG5cdFx0b3B0aW9ucyxcclxuXHR9ID0gaGlzdG9yeTtcclxuXHJcblx0JGJ1dHRvbi5vbignY2xpY2snLCBldmVudCA9PiB7XHJcblxyXG5cdFx0aWYgKGV2ZW50KSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnJlbmRlcigkY29udGFpbmVyLCBjb21wb25lbnQsIG9wdGlvbnMgfHwge30pO1xyXG5cclxuXHR9KTtcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dGhpcy5vcHRpb25zLnJlY2FwdGNoYS5xdWV1ZS5mb3JFYWNoKG9wdGlvbiA9PiB7XHJcblxyXG5cdFx0dGhpcy51dGlsLm1ha2VSZWNhcHRjaGEob3B0aW9uLmNvbXBvbmVudE5hbWUsIG9wdGlvbi4kYnV0dG9uLCBvcHRpb24uZm4pO1xyXG5cclxuXHR9KTtcclxuXHJcblx0dGhpcy5vcHRpb25zLnJlY2FwdGNoYS5xdWV1ZSA9IFtdO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCRjb250YWluZXIsIHZhbGlkYXRlID0gKCgpID0+IHRydWUpKSB7XHJcblxyXG5cdGNvbnN0IFRodW5kZXIgPSB0aGlzO1xyXG5cclxuXHRjb25zdCAkc29jaWFsQnV0dG9uID0gJGNvbnRhaW5lci5maW5kKCdbZGF0YS1zb2NpYWwtYXBwXScpO1xyXG5cclxuXHQkc29jaWFsQnV0dG9uLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdGlmICghdmFsaWRhdGUoKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgdmVuZG9yID0gJCh0aGlzKS5kYXRhKCdzb2NpYWxBcHAnKTtcclxuXHJcblx0XHRUaHVuZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRtZXRob2Q6ICdQT1NUJyxcclxuXHRcdFx0dXJsOiAgICBgL3YxL2N1c3RvbWVycy9hdXRoLyR7dmVuZG9yfWBcclxuXHRcdH0pLmRvbmUoZGF0YSA9PiB7XHJcblxyXG5cdFx0XHRsb2NhdGlvbi5yZXBsYWNlKGRhdGEucmVkaXJlY3QpO1xyXG5cclxuXHRcdH0pLmZhaWwoKHJlcywgc3RhdHVzKSA9PiB7XHJcblxyXG5cdFx0XHQvLyBUT0RPOiBFcnJvciBoYW5kbGluZ1xyXG5cclxuXHRcdH0pO1xyXG5cclxuXHR9KTtcclxuXHJcbn07IiwiY29uc3QgcmVmdW5kU3RhdHVzVG9DaGVjayA9IHtcclxuXHRyZXF1ZXN0ZWQ6IHRydWUsXHJcblx0YWNjZXB0ZWQ6ICB0cnVlLFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAob3JkZXIsIGl0ZW1JZCkgPT4ge1xyXG5cclxuXHRpZiAoIUFycmF5LmlzQXJyYXkob3JkZXIuaXRlbXMpIHx8XHJcblx0XHQhQXJyYXkuaXNBcnJheShvcmRlci5yZWZ1bmRzKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdPcmRlciBtdXN0IGhhdmUgaXRlbXMgYW5kIHJlZnVuZHMgZmllbGQgdG8gY2hlY2sgaXRlbSByZWZ1bmQgc3RhdHVzLicpO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgaXRlbVF1YW50aXR5ID0gb3JkZXIuaXRlbXNcclxuXHRcdFx0XHRcdC5yZWR1Y2UoKGFsbCwgaXRlbSkgPT4gYWxsLmNvbmNhdChpdGVtLCBpdGVtLmJ1bmRsZUl0ZW1zKSwgW10pXHJcblx0XHRcdFx0XHQuZmluZChpdGVtID0+IGl0ZW0uX2lkID09PSBpdGVtSWQpXHJcblx0XHRcdFx0XHQucXVhbnRpdHlcclxuXHRcdFx0XHRcdC5yYXc7XHJcblxyXG5cdGNvbnN0IHJlZnVuZGVkUXVhbnRpdHkgPSBvcmRlci5yZWZ1bmRzXHJcblx0XHRcdFx0XHQuZmlsdGVyKHIgPT4gcmVmdW5kU3RhdHVzVG9DaGVja1tyLnN0YXR1c10pIC8vIHJlcXVlc3RlZCwgYWNjZXB0ZWQg7ZmY67aIIOuCtOyXreyXkOyEnFxyXG5cdFx0XHRcdFx0LnJlZHVjZSgoc3VtLCByKSA9PiB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBpdGVtID0gci5pdGVtcy5maW5kKGkgPT4gaS5pdGVtLl9pZCA9PT0gaXRlbUlkKTtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiBzdW0gKyAoaXRlbSA/IGl0ZW0ucXVhbnRpdHkucmF3IDogMCk7XHJcblxyXG5cdFx0XHRcdFx0fSwgMCk7IC8vIOydtCDslYTsnbTthZzsl5Ag64yA7ZW07IScIO2ZmOu2iOuQnCDsoITssrQg7IiY65+J7J2EIOqzhOyCsFxyXG5cclxuXHRpZiAoaXRlbVF1YW50aXR5IDw9IHJlZnVuZGVkUXVhbnRpdHkpIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGZhbHNlO1xyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWxlbSkge1xyXG5cclxuXHRcdGNvbnN0ICR0ZW1wID0gJCgnPGlucHV0PicpO1xyXG5cclxuXHRcdCR0ZW1wLmNzcyh7XHJcblx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG5cdFx0XHRsZWZ0OiAgICAgJy05OTk5cHgnLFxyXG5cdFx0XHR0b3A6ICAgICAgJzAnLFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0JCgnYm9keScpLmFwcGVuZCgkdGVtcCk7XHJcblxyXG5cdFx0JHRlbXAudmFsKCQoZWxlbSkudGV4dCgpLnRyaW0oKSkuc2VsZWN0KCk7XHJcblxyXG5cdFx0bGV0IHJlc3VsdCA9IGZhbHNlO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdHJlc3VsdCA9IGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XHJcblx0XHRcdHRoaXMubm90aWZ5KCdzdWNjZXNzJywgdGhpcy5wb2x5Z2xvdC50KCdnZW5lcmFsLmNvcHlTdWNjZWVkZWQnKSk7XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0dGhpcy5ub3RpZnkoJ2Vycm9yJywgdGhpcy5wb2x5Z2xvdC50KCdnZW5lcmFsLmNvcHlGYWlsZWQnKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0JHRlbXAucmVtb3ZlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvZGUgPSBudWxsLCBuYW1lID0gJycpIHtcclxuXHJcblx0aWYgKCFjb2RlIHx8ICFuYW1lKSByZXR1cm4gJyc7XHJcblxyXG5cdGNvbnN0IGZsYWcgPVxyXG5cdFx0Y29kZS50b1VwcGVyQ2FzZSgpXHJcblx0XHRcdC5yZXBsYWNlKC8uL2csIGNoYXIgPT4gU3RyaW5nLmZyb21Db2RlUG9pbnQoY2hhci5jaGFyQ29kZUF0KDApICsgMTI3Mzk3KSk7XHJcblxyXG5cdHJldHVybiBbZmxhZywgbmFtZV0uZmlsdGVyKHYgPT4gdikuam9pbignICcpO1xyXG5cclxufTsiLCJjb25zdCBnZXQgPSByZXF1aXJlKCdsb2Rhc2guZ2V0Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGN1c3RvbWVyKSB7XHJcblxyXG5cdGlmICghY3VzdG9tZXIpIHJldHVybiBudWxsO1xyXG5cclxuXHRmb3IgKGNvbnN0IGZpZWxkIG9mIHRoaXMub3B0aW9ucy5jdXN0b21lcklkZW50aXR5KSB7XHJcblxyXG5cdFx0Y29uc3QgdmFsdWUgPSBnZXQoY3VzdG9tZXIsIGZpZWxkKTtcclxuXHJcblx0XHRpZiAodmFsdWUpIHtcclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBudWxsO1xyXG59OyIsIi8vIERhdmlkIFdhbHNoJ3MgZGVib3VuY2UgZnVuY3Rpb24gc25pcHBldHMgKHNsaWdodGx5IG1vZGlmaWVkKVxyXG4vLyBSZWY6IGh0dHBzOi8vZGF2aWR3YWxzaC5uYW1lL2phdmFzY3JpcHQtZGVib3VuY2UtZnVuY3Rpb25cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcclxuXHJcblx0bGV0IHRpbWVvdXQ7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRsZXQgY29udGV4dCA9IHRoaXM7XHJcblx0XHRsZXQgYXJncyA9IGFyZ3VtZW50cztcclxuXHRcdGxldCBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xyXG5cdFx0bGV0IGxhdGVyID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRpbWVvdXQgPSBudWxsO1xyXG5cdFx0XHRpZiAoIWltbWVkaWF0ZSkgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG5cdFx0dGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xyXG5cdFx0aWYgKGNhbGxOb3cpIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0fTtcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSAodGV4dCwgbGVuZ3RoKSA9PiB7XHJcblxyXG5cdGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJykge1xyXG5cdFx0cmV0dXJuIHRleHQ7XHJcblx0fVxyXG5cclxuXHQvLyBSZW1vdmUgSFRNTCB0YWdzXHJcblx0dGV4dCA9ICQoYDxkaXY+JHt0ZXh0IHx8ICcnfTwvZGl2PmApLnRleHQoKTtcclxuXHJcblx0Y29uc3QgcmVkdWNlZCA9IHRleHRcclxuXHRcdFx0XHRcdC5yZXBsYWNlKC9cXHMrL2csICcgJykgLy8gUmVwbGFjZSBhbGwgZW1wdHkgc3BhY2VkIHRvIG9uZSBzcGFjZVxyXG5cdFx0XHRcdFx0LnRyaW0oKVxyXG5cdFx0XHRcdFx0LnNsaWNlKDAsIGxlbmd0aClcclxuXHRcdFx0XHRcdC50cmltKCk7XHJcblxyXG5cdHJldHVybiB0ZXh0Lmxlbmd0aCA8PSBsZW5ndGggP1xyXG5cdFx0XHRyZWR1Y2VkIDpcclxuXHRcdFx0YCR7cmVkdWNlZH0uLi5gO1xyXG59OyIsImNvbnN0IHNldCA9IHJlcXVpcmUoJ2xvZGFzaC5zZXQnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJGNvbnRhaW5lciwgZm9sbG93LCBtZW51SXRlbXMgPSBbXSkge1xyXG5cclxuXHRjb25zdCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zbGljZSgyKTtcclxuXHJcblx0Y29uc3QgaXRlbU1hcCA9IG1lbnVJdGVtcy5yZWR1Y2UoKG8sIGl0ZW0sIGkpID0+IHtcclxuXHRcdHJldHVybiBzZXQobywgW2Ake2lkfS4ke2l9YF0sIGl0ZW0pO1xyXG5cdH0sIHt9KTtcclxuXHJcblx0Y29uc3QgaXRlbXMgPSBtZW51SXRlbXMubWFwKChpdGVtLCBpKSA9PiB7XHJcblx0XHRyZXR1cm4gYDxsaT48c3BhbiBkYXRhLXNjcm9sbC10bz1cIiR7aWR9LiR7aX1cIj4ke2l0ZW0ubmFtZX08L3NwYW4+PC9saT5gO1xyXG5cdH0pLmpvaW4oJycpO1xyXG5cclxuXHQkY29udGFpbmVyXHJcblx0XHQuYWRkQ2xhc3MoJ3RodW5kZXItLWZvbGxvd2luZy1uYXYtY29udGFpbmVyJylcclxuXHRcdC5hZGRDbGFzcyhmb2xsb3cgPyAnc3RpY2t5JyA6ICcnKVxyXG5cdFx0Lmh0bWwoYDx1bCBjbGFzcz1cInRodW5kZXItLWZvbGxvd2luZy1uYXZcIj4ke2l0ZW1zfTwvdWw+YCk7XHJcblxyXG5cdCRjb250YWluZXIub24oJ2NsaWNrJywgJ1tkYXRhLXNjcm9sbC10b10nLCBmdW5jdGlvbihldmVudCkge1xyXG5cclxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0Y29uc3QgaXRlbUlkID0gJCh0aGlzKS5kYXRhKCdzY3JvbGxUbycpO1xyXG5cdFx0Y29uc3QgaXRlbSA9IGl0ZW1NYXBbaXRlbUlkXTtcclxuXHJcblx0XHRyZXR1cm4gaXRlbS4kZWwuZ2V0KDApLnNjcm9sbEludG9WaWV3KCk7XHJcblxyXG5cdH0pO1xyXG5cclxufTsiLCJjb25zdCBzZXQgPSByZXF1aXJlKCdsb2Rhc2guc2V0Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWQpIHtcclxuXHJcblx0Y29uc3QgZGF0YSA9IHt9O1xyXG5cclxuXHRzZXJpYWxpemVkLmZvckVhY2goZCA9PiBzZXQoZGF0YSwgZC5uYW1lLCBkLnZhbHVlIHx8IG51bGwpKTtcclxuXHJcblx0cmV0dXJuIGRhdGE7XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obnVtYmVyLCBjdXJyZW5jeSA9IHt9KSB7XHJcblxyXG5cdGlmICh0eXBlb2YgbnVtYmVyICE9PSAnbnVtYmVyJykge1xyXG5cclxuXHRcdHJldHVybiAnJztcclxuXHR9XHJcblxyXG5cdGNvbnN0IHsgcHJlY2lzaW9uLCBkZWxpbWl0ZXIgPSB7fSB9ID0gY3VycmVuY3k7XHJcblx0Y29uc3QgeyB0aG91c2FuZHMgPSAnJywgZGVjaW1hbCA9ICcuJyB9ID0gZGVsaW1pdGVyO1xyXG5cclxuXHRpZiAodHlwZW9mIHByZWNpc2lvbiA9PT0gJ251bWJlcicpIHtcclxuXHJcblx0XHRudW1iZXIgPSB0aGlzLnV0aWwudG9QcmVjaXNpb24obnVtYmVyLCBwcmVjaXNpb24pO1xyXG5cdH1cclxuXHJcblx0bGV0IFthLCBiID0gJyddID0gU3RyaW5nKG51bWJlcikuc3BsaXQoJy4nKTtcclxuXHJcblx0Y29uc3QgcmV2ZXJzZWRBcnJheSA9IGEuc3BsaXQoJycpLnJldmVyc2UoKTtcclxuXHJcblx0Y29uc3Qgc2VnbWVudHMgPSBbXTtcclxuXHJcblx0d2hpbGUgKHJldmVyc2VkQXJyYXkubGVuZ3RoKSB7XHJcblxyXG5cdFx0c2VnbWVudHMudW5zaGlmdChyZXZlcnNlZEFycmF5LnNwbGljZSgwLCAzKS5yZXZlcnNlKCkuam9pbignJykpO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmIChwcmVjaXNpb24pIHtcclxuXHJcblx0XHRjb25zdCBkaWZmID0gcHJlY2lzaW9uIC0gYi5sZW5ndGg7XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmOyBpKyspIHtcclxuXHRcdFx0YiArPSAnMCc7XHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIFtzZWdtZW50cy5qb2luKHRob3VzYW5kcyksIGJdLmpvaW4oYiA/IGRlY2ltYWwgOiAnJyk7XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obnVtYmVyLCBjdXJyZW5jeSA9IHt9KSB7XHJcblxyXG5cdGNvbnN0IGZvcm1hdHRlZE51bWJlciA9IHRoaXMudXRpbC5mb3JtYXROdW1iZXIobnVtYmVyLCBjdXJyZW5jeSk7XHJcblxyXG5cdGlmICghZm9ybWF0dGVkTnVtYmVyKSB7XHJcblxyXG5cdFx0cmV0dXJuICcnO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgeyBzeW1ib2wgPSAnJywgZm9ybWF0ID0gJ3twcmljZX0nIH0gPSBjdXJyZW5jeTtcclxuXHJcblx0cmV0dXJuIGZvcm1hdFxyXG5cdFx0XHQucmVwbGFjZSgne3N5bWJvbH0nLCBzeW1ib2wpXHJcblx0XHRcdC5yZXBsYWNlKCd7cHJpY2V9JywgZm9ybWF0dGVkTnVtYmVyKTtcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb2RlKSB7XHJcblxyXG5cdGlmICghY29kZSkge1xyXG5cdFx0cmV0dXJuIGRlZmVycmVkLnJlamVjdChuZXcgRXJyb3IoJ0N1cnJlbmN5IGNvZGUgaXMgcmVxdWlyZWQuJykpO1xyXG5cdH1cclxuXHJcblx0Y29kZSA9IGNvZGUudG9VcHBlckNhc2UoKTtcclxuXHJcblx0Y29uc3QgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XHJcblx0Y29uc3Qga2V5ID0gYF9fY3VycmVuY3k6JHtjb2RlfV9fYDtcclxuXHRjb25zdCBzYXZlZCA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oa2V5KTtcclxuXHJcblx0aWYgKHNhdmVkKSB7XHJcblxyXG5cdFx0cmV0dXJuIGRlZmVycmVkLnJlc29sdmUoSlNPTi5wYXJzZShzYXZlZCkpO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdFRodW5kZXIucmVxdWVzdCh7XHJcblx0XHRcdG1ldGhvZDogJ0dFVCcsXHJcblx0XHRcdHVybDogJy92MS9jdXJyZW5jaWVzJyxcclxuXHRcdFx0cXVlcnk6IHtcclxuXHRcdFx0XHRyYXc6IHRydWUsXHJcblx0XHRcdFx0ZmllbGRzOiBbXHJcblx0XHRcdFx0XHQnY29kZScsXHJcblx0XHRcdFx0XHQnZGVsaW1pdGVyJyxcclxuXHRcdFx0XHRcdCdmb3JtYXQnLFxyXG5cdFx0XHRcdFx0J3ByZWNpc2lvbicsXHJcblx0XHRcdFx0XHQnc3ltYm9sJyxcclxuXHRcdFx0XHRdLmpvaW4oJywnKSxcclxuXHRcdFx0XHRjb2RlOiBjb2RlLFxyXG5cdFx0XHR9XHJcblx0XHR9KS50aGVuKHJlcyA9PiB7XHJcblx0XHRcdHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShyZXNbMF0pKTtcclxuXHRcdFx0cmV0dXJuIGRlZmVycmVkLnJlc29sdmUocmVzWzBdKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRjb25zdCB7IGFjdGlvbiwgY3VzdG9tZXIsIHRva2VuIH0gPSB0aGlzLnV0aWwudXJsUXVlcnkoKTtcclxuXHJcblx0aWYgKCFhY3Rpb24pIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0aWYgKGFjdGlvbiAmJiBjdXN0b21lciAmJiB0b2tlbikge1xyXG5cclxuXHRcdGNvbnN0IHN0b3JhZ2UgPSB0aGlzLnBsdWdpbnMuY3JlZGVudGlhbFN0b3JhZ2U7XHJcblxyXG5cdFx0c3RvcmFnZS5zZXRJdGVtKHRoaXMub3B0aW9ucy5hdXRoU3RvcmFnZS5jdXN0b21lciwgdG9rZW4pO1xyXG5cclxuXHRcdC8vIFJlLXJlbmRlciBoZWFkZXJcclxuXHRcdHRoaXMuaGVhZGVyKCk7XHJcblx0fVxyXG5cclxuXHRjb25zdCBxdWVyeSA9IHRoaXMudXRpbC51cmxRdWVyeSgpO1xyXG5cdGNvbnN0IHBheWxvYWQgPSB7fTtcclxuXHJcblx0W1xyXG5cdFx0J2FjdGlvbicsXHJcblx0XHQnY3VzdG9tZXInLFxyXG5cdFx0J3Rva2VuJyxcclxuXHRcdCdlcnJvcicsXHJcblx0XS5mb3JFYWNoKGZpZWxkID0+IHBheWxvYWRbZmllbGRdID0gcXVlcnlbZmllbGRdKTtcclxuXHJcblx0cmV0dXJuIHBheWxvYWQ7XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW1hZ2UsIHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcblx0aWYgKCFpbWFnZSkgcmV0dXJuICcnO1xyXG5cclxuXHRsZXQgZGltZW5zaW9uID0gW107XHJcblxyXG5cdHdpZHRoID0gd2lkdGggPyAnd2lkdGg9JyArIHdpZHRoIDogJyc7XHJcblx0aGVpZ2h0ID0gaGVpZ2h0ID8gJ2hlaWdodD0nICsgaGVpZ2h0IDogJyc7XHJcblxyXG5cdGlmICh3aWR0aCkgIGRpbWVuc2lvbi5wdXNoKHdpZHRoKTtcclxuXHRpZiAoaGVpZ2h0KSBkaW1lbnNpb24ucHVzaChoZWlnaHQpO1xyXG5cclxuXHRkaW1lbnNpb24gPSBkaW1lbnNpb24ubGVuZ3RoID8gJz8nICsgZGltZW5zaW9uLmpvaW4oJyYnKSA6ICcnO1xyXG5cclxuXHRyZXR1cm4gaW1hZ2UudXJsICsgZGltZW5zaW9uO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCR1cGxvYWRGb3JtLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcclxuXHJcblx0Y29uc3QgJGZpbGUgPSAkdXBsb2FkRm9ybS5maW5kKCdpbnB1dFt0eXBlPVwiZmlsZVwiXScpO1xyXG5cdGNvbnN0ICRsYWJlbCA9ICR1cGxvYWRGb3JtLmZpbmQoYGxhYmVsW2Zvcj1cIiR7JGZpbGUuYXR0cignaWQnKX1cIl1gKTtcclxuXHRjb25zdCBvcmlnaW5hbExhYmVsID0gJGxhYmVsLnRleHQoKTtcclxuXHJcblx0cmV0dXJuICRmaWxlLm9uKCdjaGFuZ2UnLCAoKSA9PiB7XHJcblxyXG5cdFx0aWYgKCEkZmlsZS52YWwoKSkge1xyXG5cdFx0XHRyZXR1cm4gJGxhYmVsLmh0bWwob3JpZ2luYWxMYWJlbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0JGxhYmVsLmh0bWwodGhpcy51aSgnYnV0dG9uLXNwaW5uZXInKSk7XHJcblxyXG5cdFx0JHVwbG9hZEZvcm0uYWpheFN1Ym1pdCh7XHJcblx0XHRcdG1ldGhvZDogICdQT1NUJyxcclxuXHRcdFx0dXJsOiAgICAgYCR7dGhpcy5vcHRpb25zLmJhc2VVUkx9L3YxL21lL2ltYWdlc2AsXHJcblx0XHRcdGhlYWRlcnM6IHRoaXMucmVxdWVzdC5nZXRSZXF1ZXN0SGVhZGVycygpLFxyXG5cdFx0XHRzdWNjZXNzOiAoLi4uYXJncykgPT4ge1xyXG5cdFx0XHRcdCRsYWJlbC5odG1sKG9yaWdpbmFsTGFiZWwpO1xyXG5cdFx0XHRcdHJldHVybiBzdWNjZXNzQ2FsbGJhY2soLi4uYXJncyk7XHJcblx0XHRcdH0sXHJcblx0XHRcdGVycm9yOiAoLi4uYXJncykgPT4ge1xyXG5cdFx0XHRcdCRsYWJlbC5odG1sKG9yaWdpbmFsTGFiZWwpO1xyXG5cdFx0XHRcdHJldHVybiBlcnJvckNhbGxiYWNrKC4uLmFyZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0fSk7XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0ZSwgdGltZVRvQ29tcGFyZSA9IERhdGUubm93KCkpIHtcclxuXHJcblx0cmV0dXJuIG5ldyBEYXRlKGRhdGUpLnZhbHVlT2YoKSAtIHRpbWVUb0NvbXBhcmUgPCAwO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhZ3MgPSBbXSwgbWVzc2FnZSkge1xyXG5cclxuXHRjb25zdCB0eXBlID0gdGFncy5pbmRleE9mKCdlcnJvcicpID09PSAtMSA/XHJcblx0XHRcdFx0XHQnbG9nJyA6XHJcblx0XHRcdFx0XHQnZXJyb3InO1xyXG5cclxuXHRyZXR1cm4gY29uc29sZVt0eXBlXShgWyR7IHRhZ3Muam9pbignLCcpIH1dIFRodW5kZXI6ICR7IG1lc3NhZ2UgfWApO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCRidXR0b24sIG9wdGlvbnMpIHtcclxuXHJcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdGNvbnN0IHtcclxuXHRcdGJpbmQgPSB0cnVlXHJcblx0fSA9IG9wdGlvbnM7XHJcblxyXG5cdGNvbnN0IG9yaWdpbmFsID0gJGJ1dHRvbi5odG1sKCk7XHJcblxyXG5cdGNvbnN0IHJ1biA9ICgpID0+ICRidXR0b24uaHRtbCh0aGlzLnVpKCdidXR0b24tc3Bpbm5lcicpKTtcclxuXHRjb25zdCBkb25lID0gKCkgPT4gJGJ1dHRvbi5odG1sKG9yaWdpbmFsKTtcclxuXHJcblx0aWYgKGJpbmQpIHtcclxuXHRcdCRidXR0b24ub24oJ2NsaWNrJywgcnVuKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7IHJ1biwgZG9uZSB9O1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbXBvbmVudE5hbWUsICRidXR0b24sIGNhbGxiYWNrKSB7XHJcblxyXG5cdGxldCB2YWxpZGF0ZSA9ICgpID0+IHRydWU7XHJcblxyXG5cdGlmICh0eXBlb2YgY29tcG9uZW50TmFtZSA9PT0gJ29iamVjdCcpIHtcclxuXHJcblx0XHRjb25zdCBvcHRpb25zID0gY29tcG9uZW50TmFtZTtcclxuXHJcblx0XHRjb21wb25lbnROYW1lID0gb3B0aW9ucy5jb21wb25lbnROYW1lO1xyXG5cdFx0JGJ1dHRvbiA9IG9wdGlvbnMuYnV0dG9uO1xyXG5cdFx0dmFsaWRhdGUgPSBvcHRpb25zLnZhbGlkYXRlIHx8IHZhbGlkYXRlO1xyXG5cdFx0Y2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xyXG5cdH1cclxuXHJcblx0Y29uc3Qgc2lnbmF0dXJlID0gJ3RodW5kZXItLXJlY2FwdGNoYS1oYW5kbGVyJztcclxuXHJcblx0aWYgKCEkYnV0dG9uLmhhc0NsYXNzKHNpZ25hdHVyZSkpIHtcclxuXHJcblx0XHQkYnV0dG9uLmFkZENsYXNzKHNpZ25hdHVyZSk7XHJcblxyXG5cdFx0JGJ1dHRvbi5kYXRhKCdleGVjdXRlJywgKCRidXR0b24uZGF0YSgnZXhlY3V0ZScpIHx8IFtdKS5jb25jYXQoY2FsbGJhY2spKTtcclxuXHJcblx0XHQkYnV0dG9uLm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblxyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0aWYgKCF2YWxpZGF0ZSgpKSByZXR1cm47XHJcblxyXG5cdFx0XHQkYnV0dG9uLmRhdGEoJ2V4ZWN1dGUnKS5mb3JFYWNoKGV4ZWN1dGUgPT4gZXhlY3V0ZSgpKTtcclxuXHRcdH0pO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmICghdGhpcy51dGlsLnVzZVJlY2FwdGNoYShjb21wb25lbnROYW1lKSkge1xyXG5cdFx0cmV0dXJuICRidXR0b24uZGF0YSgnZXhlY3V0ZScpO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgZ3JlY2FwdGNoYSA9IHdpbmRvdy5ncmVjYXB0Y2hhO1xyXG5cclxuXHRpZiAoIWdyZWNhcHRjaGEgfHwgIWdyZWNhcHRjaGEucmVuZGVyKSB7XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnJlY2FwdGNoYS5xdWV1ZS5wdXNoKHtcclxuXHRcdFx0Y29tcG9uZW50TmFtZSxcclxuXHRcdFx0JGJ1dHRvbixcclxuXHRcdFx0Zm46IGNhbGxiYWNrXHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gJGJ1dHRvbi5kYXRhKCdleGVjdXRlJyk7XHJcblx0fVxyXG5cclxuXHRjb25zdCAkY2hhbGxlbmdlID0gJCgnPGRpdiBjbGFzcz1cImctcmVjYXB0Y2hhXCI+PC9kaXY+Jyk7XHJcblxyXG5cdCRidXR0b24uYmVmb3JlKCRjaGFsbGVuZ2UpO1xyXG5cclxuXHRjb25zdCBjaGFsbGVuZ2UgPSAkY2hhbGxlbmdlLmdldCgwKTtcclxuXHJcblx0Y29uc3QgaWQgPSBncmVjYXB0Y2hhLnJlbmRlcihjaGFsbGVuZ2UsIHtcclxuXHRcdHNpdGVrZXk6ICB0aGlzLm9wdGlvbnMucmVjYXB0Y2hhLnNpdGVrZXksXHJcblx0XHRzaXplOiAgICAgJ2ludmlzaWJsZScsXHJcblx0XHRiYWRnZTogICAgJ2JvdHRvbXJpZ2h0JyxcclxuXHRcdGlzb2xhdGVkOiB0cnVlLFxyXG5cdFx0Y2FsbGJhY2s6IHRva2VuID0+IGNhbGxiYWNrKHRva2VuLCAoKSA9PiBncmVjYXB0Y2hhLnJlc2V0KGlkKSksXHJcblx0XHQnZXhwaXJlZC1jYWxsYmFjayc6IGVyciA9PiB7XHJcblx0XHRcdC8vIFRPRE86IEltcGxlbWVudCBjYWxsYmFja1xyXG5cdFx0fSxcclxuXHRcdCdlcnJvci1jYWxsYmFjayc6IGVyciA9PiB7XHJcblx0XHRcdC8vIFRPRE86IEltcGxlbWVudCBjYWxsYmFja1xyXG5cdFx0fSxcclxuXHR9KTtcclxuXHJcblx0JGNoYWxsZW5nZS5wcm9wKCdpZCcsICdnLXJlY2FwdGNoYS0nICsgaWQpO1xyXG5cclxuXHRjb25zdCBjYWxsYmFja3MgPSAoJGJ1dHRvbi5kYXRhKCdleGVjdXRlJykgfHwgW10pXHJcblx0XHRcdFx0XHRcdC5jb25jYXQoKCkgPT4gZ3JlY2FwdGNoYS5leGVjdXRlKGlkKSlcclxuXHRcdFx0XHRcdFx0LmZpbHRlcihmbiA9PiBmbiAhPT0gY2FsbGJhY2spOyAvLyBSZW1vdmUgb3JpZ2luYWwgY2FsbGJhY2tcclxuXHJcblx0JGJ1dHRvbi5kYXRhKCdleGVjdXRlJywgY2FsbGJhY2tzKTtcclxuXHJcblx0cmV0dXJuICRidXR0b24uZGF0YSgnZXhlY3V0ZScpO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IG9yZGVyID0+IHtcclxuXHJcblx0aWYgKCFvcmRlcikgcmV0dXJuIG51bGw7XHJcblxyXG5cdGlmIChvcmRlci5zdGF0dXMgPT09ICdwbGFjZWQnIHx8XHJcblx0XHRvcmRlci5zdGF0dXMgPT09ICdjYW5jZWxsZWQnKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdGNvbnN0IGhhc1RhbmdpYmxlSXRlbSA9IG9yZGVyLml0ZW1zLnJlZHVjZSgoaXRlbXMsIGl0ZW0pID0+IHtcclxuXHRcdHJldHVybiBpdGVtcy5jb25jYXQoaXRlbSwgaXRlbS5idW5kbGVJdGVtcyB8fCBbXSk7XHJcblx0fSwgW10pLnNvbWUoaXRlbSA9PiBpdGVtLnR5cGUgPT09ICd0YW5naWJsZScpO1xyXG5cclxuXHRpZiAoIWhhc1RhbmdpYmxlSXRlbSkgcmV0dXJuIG51bGw7XHJcblxyXG5cdGlmIChvcmRlci5yZWNlaXZlZEF0KSB7XHJcblx0XHRyZXR1cm4gJ3JlY2VpdmVkJztcclxuXHR9XHJcblxyXG5cdGNvbnN0IGNvdW50QnlTdGF0dXMgPSBvcmRlci5mdWxmaWxsbWVudHMucmVkdWNlKChvLCB7IHN0YXR1cyB9KSA9PiB7XHJcblx0XHRvW3N0YXR1c10gPSBvW3N0YXR1c10gfHwgMDtcclxuXHRcdG9bc3RhdHVzXSsrO1xyXG5cdFx0cmV0dXJuIG87XHJcblx0fSwge30pO1xyXG5cclxuXHRpZiAob3JkZXIuZnVsZmlsbG1lbnRzLmxlbmd0aCA9PT0gMCB8fFxyXG5cdFx0b3JkZXIuZnVsZmlsbG1lbnRzLmxlbmd0aCA9PT0gY291bnRCeVN0YXR1cy5wZW5kaW5nKSB7XHJcblx0XHRyZXR1cm4gJ3BlbmRpbmcnO1xyXG5cdH1cclxuXHJcblx0aWYgKG9yZGVyLmZ1bGZpbGxtZW50cy5sZW5ndGggPT09IGNvdW50QnlTdGF0dXMuYXJyaXZlZCkge1xyXG5cdFx0cmV0dXJuICdhcnJpdmVkJztcclxuXHR9XHJcblxyXG5cdHJldHVybiAnc2hpcHBlZCc7XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsdWUpIHtcclxuXHJcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgP1xyXG5cdFx0XHR2YWx1ZS5zcGxpdCgnLCcpLmZpbHRlcih2ID0+IHYpIDpcclxuXHRcdFx0dmFsdWU7XHJcblxyXG59OyIsImNvbnN0IHNldCA9IHJlcXVpcmUoJ2xvZGFzaC5zZXQnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcXVlcnkgPT4ge1xyXG5cclxuXHRxdWVyeSA9IHF1ZXJ5IHx8IHt9O1xyXG5cclxuXHRpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xyXG5cdFx0cmV0dXJuIHF1ZXJ5O1xyXG5cdH1cclxuXHJcblx0aWYgKHR5cGVvZiBxdWVyeSAhPT0gJ3N0cmluZycpIHtcclxuXHRcdHJldHVybiB7fTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBxdWVyeS5zcGxpdCgnJicpLnJlZHVjZSgobywgc2VnbWVudCkgPT4ge1xyXG5cclxuXHRcdGNvbnN0IFtrZXksIC4uLnZhbHVlc10gPSBzZWdtZW50LnNwbGl0KCc9Jyk7XHJcblxyXG5cdFx0cmV0dXJuIHNldChvLCBba2V5XSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlcy5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJykpKTtcclxuXHJcblx0fSwge30pO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHByb2R1Y3QsIHZhcmlhbnQpIHtcclxuXHJcblx0cmV0dXJuIFtdLmNvbmNhdChcclxuXHRcdHByb2R1Y3QubmFtZSxcclxuXHRcdHZhcmlhbnQgJiYgdmFyaWFudC50eXBlcy5sZW5ndGggPyB0aGlzLnV0aWwudmFyaWFudE5hbWUodmFyaWFudCkgOiBbXVxyXG5cdCkuam9pbignIC8gJyk7XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJGNvbnRhaW5lcikge1xyXG5cclxuXHQkY29udGFpbmVyLmZpbmQoJy50aHVuZGVyLS1xdWFudGl0eScpLmVhY2goZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0Y29uc3QgbWluID0gcGFyc2VJbnQoJCh0aGlzKS5hdHRyKCdtaW4nKSB8fCAwKTtcclxuXHRcdGNvbnN0IG1heCA9IHBhcnNlSW50KCQodGhpcykuYXR0cignbWF4JykgfHwgMTAwKTtcclxuXHJcblx0XHRjb25zdCAkd3JhcHBlciA9ICQoYFxyXG5cdFx0XHQ8c3BhbiBjbGFzcz1cInRodW5kZXItLXF1YW50aXR5LXdyYXBwZXJcIj48L3NwYW4+XHJcblx0XHRgKTtcclxuXHJcblx0XHQkKHRoaXMpLndyYXAoJHdyYXBwZXIpO1xyXG5cclxuXHRcdGNvbnN0ICRkZWMgPSAkKGA8c3BhbiBjbGFzcz1cInRodW5kZXItLXF1YW50aXR5LWFjdGlvblwiIGRhdGEtdHlwZT1cImRlY1wiPlxyXG5cdFx0XHQ8c3BhbiBjbGFzcz1cInRodW5kZXItLXF1YW50aXR5LWFjdGlvbi1iYXJcIj48L3NwYW4+XHJcblx0XHQ8L3NwYW4+YCk7XHJcblx0XHRjb25zdCAkaW5jID0gJChgPHNwYW4gY2xhc3M9XCJ0aHVuZGVyLS1xdWFudGl0eS1hY3Rpb25cIiBkYXRhLXR5cGU9XCJpbmNcIj5cclxuXHRcdFx0PHNwYW4gY2xhc3M9XCJ0aHVuZGVyLS1xdWFudGl0eS1hY3Rpb24tYmFyXCI+PC9zcGFuPlxyXG5cdFx0XHQ8c3BhbiBjbGFzcz1cInRodW5kZXItLXF1YW50aXR5LWFjdGlvbi1iYXJcIj48L3NwYW4+XHJcblx0XHQ8L3NwYW4+YCk7XHJcblxyXG5cdFx0JGRlYy5pbnNlcnRCZWZvcmUoJCh0aGlzKSk7XHJcblx0XHQkaW5jLmluc2VydEFmdGVyKCQodGhpcykpO1xyXG5cclxuXHRcdCRkZWMub24oJ2NsaWNrJywgKCkgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3Qgb2xkVmFsID0gcGFyc2VJbnQoJCh0aGlzKS52YWwoKSk7XHJcblx0XHRcdGNvbnN0IG5ld1ZhbCA9IG9sZFZhbCAtIDE7XHJcblxyXG5cdFx0XHRpZiAob2xkVmFsID09PSBtaW4pIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCQodGhpcykudmFsKG5ld1ZhbCk7XHJcblx0XHRcdCQodGhpcykudHJpZ2dlcignY2hhbmdlJyk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQkaW5jLm9uKCdjbGljaycsICgpID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IG9sZFZhbCA9IHBhcnNlSW50KCQodGhpcykudmFsKCkpO1xyXG5cdFx0XHRjb25zdCBuZXdWYWwgPSBvbGRWYWwgKyAxO1xyXG5cclxuXHRcdFx0aWYgKG9sZFZhbCA9PT0gbWF4KSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQkKHRoaXMpLnZhbChuZXdWYWwpO1xyXG5cdFx0XHQkKHRoaXMpLnRyaWdnZXIoJ2NoYW5nZScpO1xyXG5cdFx0fSk7XHJcblxyXG5cdH0pO1xyXG5cclxufTsiLCJjb25zdCBnZXQgPSByZXF1aXJlKCdsb2Rhc2guZ2V0Jyk7XHJcblxyXG5jb25zdCBIYW5kbGVyRXJyb3IgPSAoY29kZSwgbWVzc2FnZSkgPT4ge1xyXG5cclxuXHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuXHJcblx0ZXJyb3IuY29kZSA9IGNvZGU7XHJcblxyXG5cdHJldHVybiBlcnJvcjtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJlcywgY29kZVRvTWVzc2FnZSwgY2FsbGJhY2sgPSAoKSA9PiB7fSkge1xyXG5cclxuXHRpZiAoIXJlcy5lcnJvcikge1xyXG5cdFx0Ly8gTm90IGFuIGVycm9yIGNhc2VcclxuXHRcdHJldHVybiBjYWxsYmFjaygpO1xyXG5cdH1cclxuXHJcblx0Ly8gRmluZCBhIENsYXlmdWwgZXJyb3IgY29kZVxyXG5cdGNvbnN0IGVycm9yQ29kZSA9IGdldChyZXMsICdlcnJvckNvZGUnLCBudWxsKTtcclxuXHJcblx0Y29uc3QgbWVzc2FnZUdldHRlciA9IGNvZGVUb01lc3NhZ2VbZXJyb3JDb2RlXTtcclxuXHRjb25zdCBkZWZhdWx0TWVzc2FnZSA9IGNvZGVUb01lc3NhZ2UuZGVmYXVsdDtcclxuXHRjb25zdCBtZXNzYWdlID0gbWVzc2FnZUdldHRlciA/IChcclxuXHRcdHR5cGVvZiBtZXNzYWdlR2V0dGVyID09PSAnZnVuY3Rpb24nID9cclxuXHRcdFx0bWVzc2FnZUdldHRlcihyZXMpIHx8IGRlZmF1bHRNZXNzYWdlIDpcclxuXHRcdFx0bWVzc2FnZUdldHRlci5tZXNzYWdlIHx8IG1lc3NhZ2VHZXR0ZXIgfHwgZGVmYXVsdE1lc3NhZ2VcclxuXHQpIDogZGVmYXVsdE1lc3NhZ2U7XHJcblxyXG5cdGlmIChtZXNzYWdlKSB7XHJcblx0XHR0aGlzLnBsdWdpbnMubm90aWZpY2F0aW9uKGdldChtZXNzYWdlR2V0dGVyLCAndHlwZScpIHx8ICdlcnJvcicsIG1lc3NhZ2UpO1xyXG5cdFx0cmV0dXJuIGNhbGxiYWNrKEhhbmRsZXJFcnJvcihlcnJvckNvZGUsIG1lc3NhZ2UpKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjYWxsYmFjayhIYW5kbGVyRXJyb3IoJ3Vua25vd24nLCAnVW5rbm93biBFcnJvcicpKTtcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0ZXh0ID0gJycpIHtcclxuXHJcblx0cmV0dXJuICQoYDxkaXY+JHt0ZXh0fTwvZGl2PmApLnRleHQoKTtcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihudW1iZXIgPSAwLCBwcmVjaXNpb24gPSAwKSB7XHJcblxyXG5cdGNvbnN0IG4gPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcclxuXHJcblx0cmV0dXJuIE1hdGgucm91bmQobnVtYmVyICogbikgLyBuO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuXHJcblx0cmV0dXJuIHRoaXMudWlzW25hbWVdID8gdGhpcy51aXNbbmFtZV0oKSA6ICcnO1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuXHJcblx0aWYgKCFkYXRhKSByZXR1cm4gbnVsbDtcclxuXHJcblx0Y29uc3QgcmVjYXB0Y2hhRmllbGQgPSAnZy1yZWNhcHRjaGEtcmVzcG9uc2UnO1xyXG5cdGNvbnN0IHJlc3BvbnNlID0gZGF0YVtyZWNhcHRjaGFGaWVsZF07XHJcblxyXG5cdGRlbGV0ZSBkYXRhW3JlY2FwdGNoYUZpZWxkXTtcclxuXHJcblx0cmV0dXJuIHJlc3BvbnNlIHx8IG51bGw7XHJcblxyXG59OyIsImNvbnN0IHBhcnNlUXVlcnlTdHJpbmcgPSByZXF1aXJlKCcuL3BhcnNlUXVlcnlTdHJpbmcuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdC8vIFNpbmNlIFNQQShTaW5nbGUgUGFnZSBBcHApIG1pZ2h0IHVzZSBoYXNoYmFuZygvIy8/aGVsbG89d29ybGQpIGluIGl0cyB1cmwsXHJcblx0Ly8gYGxvY2F0aW9uLmhyZWZgIGlzIGJlaW5nIHVzZWQgdG8gZmluZCBxdWVyeSBzdHJpbmcuXHJcblx0Y29uc3QgWywgcXVlcnlBZnRlciA9ICcnXSA9IGxvY2F0aW9uLmhyZWYuc3BsaXQoJz8nKTtcclxuXHJcblx0Ly8gUmVtb3ZlIFVSTCBoYXNoXHJcblx0Y29uc3QgW3NlYXJjaF0gPSBxdWVyeUFmdGVyLnNwbGl0KCcjJyk7XHJcblxyXG5cdGlmICghc2VhcmNoKSByZXR1cm4ge307XHJcblxyXG5cdHJldHVybiBwYXJzZVF1ZXJ5U3RyaW5nKHNlYXJjaCk7XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlTmFtZSkge1xyXG5cclxuXHRyZXR1cm4gdGhpcy5vcHRpb25zLnJlY2FwdGNoYS5zaXRla2V5ICYmXHJcblx0XHRcdHRoaXMub3B0aW9ucy5yZWNhcHRjaGEubW9kdWxlcy5zb21lKG0gPT4gbSA9PT0gbW9kdWxlTmFtZSk7XHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhKSB7XHJcblxyXG5cdGlmICghZGF0YS51c2VySWRPckVtYWlsKSB7XHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHR9XHJcblxyXG5cdGlmIChkYXRhLnVzZXJJZE9yRW1haWwuaW5kZXhPZignQCcpID4gMCkge1xyXG5cdFx0ZGF0YS5lbWFpbCA9IGRhdGEudXNlcklkT3JFbWFpbDtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZGF0YS51c2VySWQgPSBkYXRhLnVzZXJJZE9yRW1haWw7XHJcblx0fVxyXG5cclxuXHRkZWxldGUgZGF0YS51c2VySWRPckVtYWlsO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YXJpYW50KSB7XHJcblxyXG5cdHJldHVybiB2YXJpYW50LnR5cGVzXHJcblx0XHRcdC5tYXAodHlwZSA9PiBgJHt0eXBlLm9wdGlvbi5uYW1lfSAtICR7dHlwZS52YXJpYXRpb24udmFsdWV9YClcclxuXHRcdFx0LmpvaW4oJywgJyk7XHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzPVwiMS4yLjRcIiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIHRvID0gdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcbiAgdmFyIGZyb20gPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0byk7XG4gIHZhciBpbmMgPSAxO1xuICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XG4gICAgaW5jID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH0gcmV0dXJuIE87XG59O1xuIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFzYyA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSByZXN1bHRbaW5kZXhdID0gcmVzOyAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXMpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcbiIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xudmFyIGZhY3RvcmllcyA9IHt9O1xuXG52YXIgY29uc3RydWN0ID0gZnVuY3Rpb24gKEYsIGxlbiwgYXJncykge1xuICBpZiAoIShsZW4gaW4gZmFjdG9yaWVzKSkge1xuICAgIGZvciAodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCBsZW47IGkrKykgbltpXSA9ICdhWycgKyBpICsgJ10nO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgIGZhY3Rvcmllc1tsZW5dID0gRnVuY3Rpb24oJ0YsYScsICdyZXR1cm4gbmV3IEYoJyArIG4uam9pbignLCcpICsgJyknKTtcbiAgfSByZXR1cm4gZmFjdG9yaWVzW2xlbl0oRiwgYXJncyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24gYmluZCh0aGF0IC8qICwgLi4uYXJncyAqLykge1xuICB2YXIgZm4gPSBhRnVuY3Rpb24odGhpcyk7XG4gIHZhciBwYXJ0QXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgYm91bmQgPSBmdW5jdGlvbiAoLyogYXJncy4uLiAqLykge1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuICBpZiAoaXNPYmplY3QoZm4ucHJvdG90eXBlKSkgYm91bmQucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICByZXR1cm4gYm91bmQ7XG59O1xuIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIGZhc3RLZXkgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTSVpFID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gIHZhciBlbnRyeTtcbiAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvciAoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgaWYgKGVudHJ5LmsgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgZm9yICh2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnApIGVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uO1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZiAodGhhdC5fZiA9PSBlbnRyeSkgdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYgKHRoYXQuX2wgPT0gZW50cnkpIHRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgICAgICB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpO1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2YpIHtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUodGhpcywgTkFNRSlbU0laRV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgIHZhciBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmICghdGhhdC5fZikgdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYgKHByZXYpIHByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKEMsIE5BTUUsIElTX01BUCkge1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHRoaXMuX3QgPSB2YWxpZGF0ZShpdGVyYXRlZCwgTkFNRSk7IC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgICAgICAgICAgICAgICAgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIga2luZCA9IHRoYXQuX2s7XG4gICAgICB2YXIgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmICghdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKSB7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZ2V0V2VhayA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xudmFyICRoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbnZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xudmFyIGlkID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYgKH5pbmRleCkgdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmICh0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHsgbmV3IEMoaXRlcik7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSgpLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBwcm90by5jbGVhcikgZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuNycgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZiAoZ2V0U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7XG4gICAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYgKHRhcmdldCkgcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIGhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmIChJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dCkgZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsInZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciByZSA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tLRVldKHJlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaCAoZikgeyAvKiBlbXB0eSAqLyB9XG4gIH0gcmV0dXJuIHRydWU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGxlbmd0aCwgZXhlYykge1xuICB2YXIgU1lNQk9MID0gd2tzKEtFWSk7XG4gIHZhciBmbnMgPSBleGVjKGRlZmluZWQsIFNZTUJPTCwgJydbS0VZXSk7XG4gIHZhciBzdHJmbiA9IGZuc1swXTtcbiAgdmFyIHJ4Zm4gPSBmbnNbMV07XG4gIGlmIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pKSB7XG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJmbik7XG4gICAgaGlkZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyXG4gICAgICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXG4gICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgICAgPyBmdW5jdGlvbiAoc3RyaW5nLCBhcmcpIHsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHRhcmdldCwgQykge1xuICB2YXIgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgdmFyIFA7XG4gIGlmIChTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKSB7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59O1xuIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgYXJncywgdGhhdCkge1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG4iLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KSB7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbiIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG0xID0gTWF0aC5leHBtMTtcbm1vZHVsZS5leHBvcnRzID0gKCEkZXhwbTFcbiAgLy8gT2xkIEZGIGJ1Z1xuICB8fCAkZXhwbTEoMTApID4gMjIwMjUuNDY1Nzk0ODA2NzE5IHx8ICRleHBtMSgxMCkgPCAyMjAyNS40NjU3OTQ4MDY3MTY1MTY4XG4gIC8vIFRvciBCcm93c2VyIGJ1Z1xuICB8fCAkZXhwbTEoLTJlLTE3KSAhPSAtMmUtMTdcbikgPyBmdW5jdGlvbiBleHBtMSh4KSB7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBNYXRoLmV4cCh4KSAtIDE7XG59IDogJGV4cG0xO1xuIiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIEVQU0lMT04gPSBwb3coMiwgLTUyKTtcbnZhciBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKTtcbnZhciBNQVgzMiA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpO1xudmFyIE1JTjMyID0gcG93KDIsIC0xMjYpO1xuXG52YXIgcm91bmRUaWVzVG9FdmVuID0gZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIG4gKyAxIC8gRVBTSUxPTiAtIDEgLyBFUFNJTE9OO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmZyb3VuZCB8fCBmdW5jdGlvbiBmcm91bmQoeCkge1xuICB2YXIgJGFicyA9IE1hdGguYWJzKHgpO1xuICB2YXIgJHNpZ24gPSBzaWduKHgpO1xuICB2YXIgYSwgcmVzdWx0O1xuICBpZiAoJGFicyA8IE1JTjMyKSByZXR1cm4gJHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oJGFicyAvIE1JTjMyIC8gRVBTSUxPTjMyKSAqIE1JTjMyICogRVBTSUxPTjMyO1xuICBhID0gKDEgKyBFUFNJTE9OMzIgLyBFUFNJTE9OKSAqICRhYnM7XG4gIHJlc3VsdCA9IGEgLSAoYSAtICRhYnMpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIGlmIChyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KSByZXR1cm4gJHNpZ24gKiBJbmZpbml0eTtcbiAgcmV0dXJuICRzaWduICogcmVzdWx0O1xufTtcbiIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMXAgfHwgZnVuY3Rpb24gbG9nMXAoeCkge1xuICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBNYXRoLmxvZygxICsgeCk7XG59O1xuIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTtcbiIsInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIE9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZiAoaXNOb2RlKSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIFNhZmFyaSAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgfSBlbHNlIGlmIChPYnNlcnZlciAmJiAhKGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci5zdGFuZGFsb25lKSkge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgLy8gUHJvbWlzZS5yZXNvbHZlIHdpdGhvdXQgYW4gYXJndW1lbnQgdGhyb3dzIGFuIGVycm9yIGluIExHIFdlYk9TIDJcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYgKCFoZWFkKSB7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcbiIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgZXhlYykge1xuICB2YXIgZm4gPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV07XG4gIHZhciBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuIiwidmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBpc0VudW0gPSByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlzRW50cmllcykge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoaXQpO1xuICAgIHZhciBrZXlzID0gZ2V0S2V5cyhPKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoTywga2V5ID0ga2V5c1tpKytdKSkge1xuICAgICAgcmVzdWx0LnB1c2goaXNFbnRyaWVzID8gW2tleSwgT1trZXldXSA6IE9ba2V5XSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcbiIsIi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIFJlZmxlY3QgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0ICYmIFJlZmxlY3Qub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ09QTi5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICByZXR1cm4gZ2V0U3ltYm9scyA/IGtleXMuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGU6IGZhbHNlLCB2OiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IGU6IHRydWUsIHY6IGUgfTtcbiAgfVxufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXTtcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwiLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59O1xuIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiByZXF1aXJlKCcuL19saWJyYXJ5JykgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcbiIsIi8vIGhlbHBlciBmb3IgU3RyaW5nI3tzdGFydHNXaXRoLCBlbmRzV2l0aCwgaW5jbHVkZXN9XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBzZWFyY2hTdHJpbmcsIE5BTUUpIHtcbiAgaWYgKGlzUmVnRXhwKHNlYXJjaFN0cmluZykpIHRocm93IFR5cGVFcnJvcignU3RyaW5nIycgKyBOQU1FICsgXCIgZG9lc24ndCBhY2NlcHQgcmVnZXghXCIpO1xuICByZXR1cm4gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgbWF4TGVuZ3RoLCBmaWxsU3RyaW5nLCBsZWZ0KSB7XG4gIHZhciBTID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICB2YXIgc3RyaW5nTGVuZ3RoID0gUy5sZW5ndGg7XG4gIHZhciBmaWxsU3RyID0gZmlsbFN0cmluZyA9PT0gdW5kZWZpbmVkID8gJyAnIDogU3RyaW5nKGZpbGxTdHJpbmcpO1xuICB2YXIgaW50TWF4TGVuZ3RoID0gdG9MZW5ndGgobWF4TGVuZ3RoKTtcbiAgaWYgKGludE1heExlbmd0aCA8PSBzdHJpbmdMZW5ndGggfHwgZmlsbFN0ciA9PSAnJykgcmV0dXJuIFM7XG4gIHZhciBmaWxsTGVuID0gaW50TWF4TGVuZ3RoIC0gc3RyaW5nTGVuZ3RoO1xuICB2YXIgc3RyaW5nRmlsbGVyID0gcmVwZWF0LmNhbGwoZmlsbFN0ciwgTWF0aC5jZWlsKGZpbGxMZW4gLyBmaWxsU3RyLmxlbmd0aCkpO1xuICBpZiAoc3RyaW5nRmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4pIHN0cmluZ0ZpbGxlciA9IHN0cmluZ0ZpbGxlci5zbGljZSgwLCBmaWxsTGVuKTtcbiAgcmV0dXJuIGxlZnQgPyBzdHJpbmdGaWxsZXIgKyBTIDogUyArIHN0cmluZ0ZpbGxlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwZWF0KGNvdW50KSB7XG4gIHZhciBzdHIgPSBTdHJpbmcoZGVmaW5lZCh0aGlzKSk7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIG4gPSB0b0ludGVnZXIoY291bnQpO1xuICBpZiAobiA8IDAgfHwgbiA9PSBJbmZpbml0eSkgdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO1xuICBmb3IgKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpIGlmIChuICYgMSkgcmVzICs9IHN0cjtcbiAgcmV0dXJuIHJlcztcbn07XG4iLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjZWwgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW5kZXhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgdmFyIG51bWJlciA9IHRvSW50ZWdlcihpdCk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChudW1iZXIpO1xuICBpZiAobnVtYmVyICE9PSBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIGxlbmd0aCEnKTtcbiAgcmV0dXJuIGxlbmd0aDtcbn07XG4iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcbiIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykpIHtcbiAgdmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG4gIHZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbiAgdmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbiAgdmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiAgdmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG4gIHZhciAkYnVmZmVyID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJyk7XG4gIHZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbiAgdmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xuICB2YXIgcHJvcGVydHlEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuICB2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiAgdmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG4gIHZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG4gIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuICB2YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG4gIHZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xuICB2YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuICB2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbiAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4gIHZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuICB2YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG4gIHZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG4gIHZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbiAgdmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG4gIHZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuICB2YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG4gIHZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbiAgdmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xuICB2YXIgY3JlYXRlQXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJyk7XG4gIHZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG4gIHZhciBBcnJheUl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG4gIHZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbiAgdmFyICRpdGVyRGV0ZWN0ID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKTtcbiAgdmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xuICB2YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xuICB2YXIgYXJyYXlDb3B5V2l0aGluID0gcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKTtcbiAgdmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuICB2YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xuICB2YXIgZFAgPSAkRFAuZjtcbiAgdmFyIGdPUEQgPSAkR09QRC5mO1xuICB2YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuICB2YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbiAgdmFyIFVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheTtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG4gIHZhciBTSEFSRURfQlVGRkVSID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVI7XG4gIHZhciBCWVRFU19QRVJfRUxFTUVOVCA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG4gIHZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheVtQUk9UT1RZUEVdO1xuICB2YXIgJEFycmF5QnVmZmVyID0gJGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbiAgdmFyICREYXRhVmlldyA9ICRidWZmZXIuRGF0YVZpZXc7XG4gIHZhciBhcnJheUZvckVhY2ggPSBjcmVhdGVBcnJheU1ldGhvZCgwKTtcbiAgdmFyIGFycmF5RmlsdGVyID0gY3JlYXRlQXJyYXlNZXRob2QoMik7XG4gIHZhciBhcnJheVNvbWUgPSBjcmVhdGVBcnJheU1ldGhvZCgzKTtcbiAgdmFyIGFycmF5RXZlcnkgPSBjcmVhdGVBcnJheU1ldGhvZCg0KTtcbiAgdmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xuICB2YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbiAgdmFyIGFycmF5SW5jbHVkZXMgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpO1xuICB2YXIgYXJyYXlJbmRleE9mID0gY3JlYXRlQXJyYXlJbmNsdWRlcyhmYWxzZSk7XG4gIHZhciBhcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JzLnZhbHVlcztcbiAgdmFyIGFycmF5S2V5cyA9IEFycmF5SXRlcmF0b3JzLmtleXM7XG4gIHZhciBhcnJheUVudHJpZXMgPSBBcnJheUl0ZXJhdG9ycy5lbnRyaWVzO1xuICB2YXIgYXJyYXlMYXN0SW5kZXhPZiA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2Y7XG4gIHZhciBhcnJheVJlZHVjZSA9IEFycmF5UHJvdG8ucmVkdWNlO1xuICB2YXIgYXJyYXlSZWR1Y2VSaWdodCA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQ7XG4gIHZhciBhcnJheUpvaW4gPSBBcnJheVByb3RvLmpvaW47XG4gIHZhciBhcnJheVNvcnQgPSBBcnJheVByb3RvLnNvcnQ7XG4gIHZhciBhcnJheVNsaWNlID0gQXJyYXlQcm90by5zbGljZTtcbiAgdmFyIGFycmF5VG9TdHJpbmcgPSBBcnJheVByb3RvLnRvU3RyaW5nO1xuICB2YXIgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmc7XG4gIHZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbiAgdmFyIFRBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbiAgdmFyIFRZUEVEX0NPTlNUUlVDVE9SID0gdWlkKCd0eXBlZF9jb25zdHJ1Y3RvcicpO1xuICB2YXIgREVGX0NPTlNUUlVDVE9SID0gdWlkKCdkZWZfY29uc3RydWN0b3InKTtcbiAgdmFyIEFMTF9DT05TVFJVQ1RPUlMgPSAkdHlwZWQuQ09OU1RSO1xuICB2YXIgVFlQRURfQVJSQVkgPSAkdHlwZWQuVFlQRUQ7XG4gIHZhciBWSUVXID0gJHR5cGVkLlZJRVc7XG4gIHZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG5cbiAgdmFyICRtYXAgPSBjcmVhdGVBcnJheU1ldGhvZCgxLCBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsbG9jYXRlKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsZW5ndGgpO1xuICB9KTtcblxuICB2YXIgTElUVExFX0VORElBTiA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgfSk7XG5cbiAgdmFyIEZPUkNFRF9TRVQgPSAhIVVpbnQ4QXJyYXkgJiYgISFVaW50OEFycmF5W1BST1RPVFlQRV0uc2V0ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgVWludDhBcnJheSgxKS5zZXQoe30pO1xuICB9KTtcblxuICB2YXIgdG9PZmZzZXQgPSBmdW5jdGlvbiAoaXQsIEJZVEVTKSB7XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihpdCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIGlmIChpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpIHJldHVybiBpdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIHR5cGVkIGFycmF5IScpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIChDLCBsZW5ndGgpIHtcbiAgICBpZiAoIShpc09iamVjdChDKSAmJiBUWVBFRF9DT05TVFJVQ1RPUiBpbiBDKSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICB9IHJldHVybiBuZXcgQyhsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbiAoTywgbGlzdCkge1xuICAgIHJldHVybiBmcm9tTGlzdChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGlzdCk7XG4gIH07XG5cbiAgdmFyIGZyb21MaXN0ID0gZnVuY3Rpb24gKEMsIGxpc3QpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gYWxsb2NhdGUoQywgbGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uIChpdCwga2V5LCBpbnRlcm5hbCkge1xuICAgIGRQKGl0LCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kW2ludGVybmFsXTsgfSB9KTtcbiAgfTtcblxuICB2YXIgJGZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcGZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChzb3VyY2UpO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZXMsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIWlzQXJyYXlJdGVyKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgdmFsdWVzID0gW10sIGkgPSAwOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGkrKykge1xuICAgICAgICB2YWx1ZXMucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgIH0gTyA9IHZhbHVlcztcbiAgICB9XG4gICAgaWYgKG1hcHBpbmcgJiYgYUxlbiA+IDIpIG1hcGZuID0gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTsgbGVuZ3RoID4gaTsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciAkb2YgPSBmdW5jdGlvbiBvZigvKiAuLi5pdGVtcyAqLykge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxuICB2YXIgVE9fTE9DQUxFX0JVRyA9ICEhVWludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgVWludDhBcnJheSgxKSk7IH0pO1xuXG4gIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcbiAgICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpKSA6IHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyogLCBlbmQgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUNvcHlXaXRoaW4uY2FsbCh2YWxpZGF0ZSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlFdmVyeSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmlsbDogZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0LCBlbmQgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5RmlsbC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5RmlsdGVyKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kKHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICBhcnJheUZvckVhY2godmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZih2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlKb2luLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiAkbWFwKHZhbGlkYXRlKHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoO1xuICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IobGVuZ3RoIC8gMik7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbWlkZGxlKSB7XG4gICAgICAgIHZhbHVlID0gdGhhdFtpbmRleF07XG4gICAgICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICAgICAgdGhhdFtsZW5ndGhdID0gdmFsdWU7XG4gICAgICB9IHJldHVybiB0aGF0O1xuICAgIH0sXG4gICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5U29tZSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICAgIHJldHVybiBhcnJheVNvcnQuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgY29tcGFyZWZuKTtcbiAgICB9LFxuICAgIHN1YmFycmF5OiBmdW5jdGlvbiBzdWJhcnJheShiZWdpbiwgZW5kKSB7XG4gICAgICB2YXIgTyA9IHZhbGlkYXRlKHRoaXMpO1xuICAgICAgdmFyIGxlbmd0aCA9IE8ubGVuZ3RoO1xuICAgICAgdmFyICRiZWdpbiA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pKShcbiAgICAgICAgTy5idWZmZXIsXG4gICAgICAgIE8uYnl0ZU9mZnNldCArICRiZWdpbiAqIE8uQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIHRvTGVuZ3RoKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCkpIC0gJGJlZ2luKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyICRzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgc3RhcnQsIGVuZCkpO1xuICB9O1xuXG4gIHZhciAkc2V0ID0gZnVuY3Rpb24gc2V0KGFycmF5TGlrZSAvKiAsIG9mZnNldCAqLykge1xuICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHNbMV0sIDEpO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB2YXIgc3JjID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgoc3JjLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpZiAobGVuICsgb2Zmc2V0ID4gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuKSB0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcbiAgfTtcblxuICB2YXIgJGl0ZXJhdG9ycyA9IHtcbiAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlLZXlzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlWYWx1ZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc1RBSW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KVxuICAgICAgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXVxuICAgICAgJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJ1xuICAgICAgJiYga2V5IGluIHRhcmdldFxuICAgICAgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICB9O1xuICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgID8gcHJvcGVydHlEZXNjKDIsIHRhcmdldFtrZXldKVxuICAgICAgOiBnT1BEKHRhcmdldCwga2V5KTtcbiAgfTtcbiAgdmFyICRzZXREZXNjID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICBpZiAoaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgICYmIGlzT2JqZWN0KGRlc2MpXG4gICAgICAmJiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgICYmICFoYXMoZGVzYywgJ2dldCcpXG4gICAgICAmJiAhaGFzKGRlc2MsICdzZXQnKVxuICAgICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ3dyaXRhYmxlJykgfHwgZGVzYy53cml0YWJsZSlcbiAgICAgICYmICghaGFzKGRlc2MsICdlbnVtZXJhYmxlJykgfHwgZGVzYy5lbnVtZXJhYmxlKVxuICAgICkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IHJldHVybiBkUCh0YXJnZXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYgKCFBTExfQ09OU1RSVUNUT1JTKSB7XG4gICAgJEdPUEQuZiA9ICRnZXREZXNjO1xuICAgICREUC5mID0gJHNldERlc2M7XG4gIH1cblxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFBTExfQ09OU1RSVUNUT1JTLCAnT2JqZWN0Jywge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgZGVmaW5lUHJvcGVydHk6ICRzZXREZXNjXG4gIH0pO1xuXG4gIGlmIChmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9TdHJpbmcuY2FsbCh7fSk7IH0pKSB7XG4gICAgYXJyYXlUb1N0cmluZyA9IGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyICRUeXBlZEFycmF5UHJvdG90eXBlJCA9IHJlZGVmaW5lQWxsKHt9LCBwcm90byk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJGl0ZXJhdG9ycyk7XG4gIGhpZGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBJVEVSQVRPUiwgJGl0ZXJhdG9ycy52YWx1ZXMpO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIHtcbiAgICBzbGljZTogJHNsaWNlLFxuICAgIHNldDogJHNldCxcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkgeyAvKiBub29wICovIH0sXG4gICAgdG9TdHJpbmc6IGFycmF5VG9TdHJpbmcsXG4gICAgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZ1xuICB9KTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J1ZmZlcicsICdiJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlT2Zmc2V0JywgJ28nKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVMZW5ndGgnLCAnbCcpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnbGVuZ3RoJywgJ2UnKTtcbiAgZFAoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBUQUcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbVFlQRURfQVJSQVldOyB9XG4gIH0pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgQ0xBTVBFRCA9ICEhQ0xBTVBFRDtcbiAgICB2YXIgTkFNRSA9IEtFWSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5JztcbiAgICB2YXIgR0VUVEVSID0gJ2dldCcgKyBLRVk7XG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgS0VZO1xuICAgIHZhciBUeXBlZEFycmF5ID0gZ2xvYmFsW05BTUVdO1xuICAgIHZhciBCYXNlID0gVHlwZWRBcnJheSB8fCB7fTtcbiAgICB2YXIgVEFDID0gVHlwZWRBcnJheSAmJiBnZXRQcm90b3R5cGVPZihUeXBlZEFycmF5KTtcbiAgICB2YXIgRk9SQ0VEID0gIVR5cGVkQXJyYXkgfHwgISR0eXBlZC5BQlY7XG4gICAgdmFyIE8gPSB7fTtcbiAgICB2YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkgJiYgVHlwZWRBcnJheVtQUk9UT1RZUEVdO1xuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIHJldHVybiBkYXRhLnZbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICBpZiAoQ0xBTVBFRCkgdmFsdWUgPSAodmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhmZiA/IDB4ZmYgOiB2YWx1ZSAmIDB4ZmY7XG4gICAgICBkYXRhLnZbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCB2YWx1ZSwgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgZFAodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSwgJ19kJyk7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbmRleChkYXRhKTtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyID0gbmV3ICRBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBvZmZzZXQgPSB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyk7XG4gICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgaWYgKCRsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCRsZW4gJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IHRvTGVuZ3RoKCRsZW5ndGgpICogQllURVM7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCArIG9mZnNldCA+ICRsZW4pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgYjogYnVmZmVyLFxuICAgICAgICAgIG86IG9mZnNldCxcbiAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGU6IGxlbmd0aCxcbiAgICAgICAgICB2OiBuZXcgJERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkgYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IGNyZWF0ZSgkVHlwZWRBcnJheVByb3RvdHlwZSQpO1xuICAgICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBUeXBlZEFycmF5KTtcbiAgICB9IGVsc2UgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5KDEpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSkgfHwgISRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkobnVsbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheSgxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoaXRlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSwgdHJ1ZSkpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSk7XG4gICAgICAgIHZhciBrbGFzcztcbiAgICAgICAgLy8gYHdzYCBtb2R1bGUgYnVnLCB0ZW1wb3JhcmlseSByZW1vdmUgdmFsaWRhdGlvbiBsZW5ndGggZm9yIFVpbnQ4QXJyYXlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkgcmV0dXJuIG5ldyBCYXNlKHRvSW5kZXgoZGF0YSkpO1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiAkb2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IEJhc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGFycmF5Rm9yRWFjaChUQUMgIT09IEZ1bmN0aW9uLnByb3RvdHlwZSA/IGdPUE4oQmFzZSkuY29uY2F0KGdPUE4oVEFDKSkgOiBnT1BOKEJhc2UpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBUeXBlZEFycmF5KSkgaGlkZShUeXBlZEFycmF5LCBrZXksIEJhc2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IFR5cGVkQXJyYXlQcm90b3R5cGU7XG4gICAgICBpZiAoIUxJQlJBUlkpIFR5cGVkQXJyYXlQcm90b3R5cGUuY29uc3RydWN0b3IgPSBUeXBlZEFycmF5O1xuICAgIH1cbiAgICB2YXIgJG5hdGl2ZUl0ZXJhdG9yID0gVHlwZWRBcnJheVByb3RvdHlwZVtJVEVSQVRPUl07XG4gICAgdmFyIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3JcbiAgICAgICYmICgkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSAndmFsdWVzJyB8fCAkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSB1bmRlZmluZWQpO1xuICAgIHZhciAkaXRlcmF0b3IgPSAkaXRlcmF0b3JzLnZhbHVlcztcbiAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRZUEVEX0FSUkFZLCBOQU1FKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgIGlmIChDTEFNUEVEID8gbmV3IFR5cGVkQXJyYXkoMSlbVEFHXSAhPSBOQU1FIDogIShUQUcgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIHtcbiAgICAgIGRQKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRBRywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5BTUU7IH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIE9bTkFNRV0gPSBUeXBlZEFycmF5O1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheSAhPSBCYXNlKSwgTyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUywgTkFNRSwge1xuICAgICAgQllURVNfUEVSX0VMRU1FTlQ6IEJZVEVTXG4gICAgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgQmFzZS5vZi5jYWxsKFR5cGVkQXJyYXksIDEpOyB9KSwgTkFNRSwge1xuICAgICAgZnJvbTogJGZyb20sXG4gICAgICBvZjogJG9mXG4gICAgfSk7XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAsIE5BTUUsIHByb3RvKTtcblxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFRF9TRVQsIE5BTUUsIHsgc2V0OiAkc2V0IH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuXG4gICAgaWYgKCFMSUJSQVJZICYmIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZykgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyA9IGFycmF5VG9TdHJpbmc7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEpLnNsaWNlKCk7XG4gICAgfSksIE5BTUUsIHsgc2xpY2U6ICRzbGljZSB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgVHlwZWRBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuICAgIH0pKSwgTkFNRSwgeyB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nIH0pO1xuXG4gICAgSXRlcmF0b3JzW05BTUVdID0gQ09SUkVDVF9JVEVSX05BTUUgPyAkbmF0aXZlSXRlcmF0b3IgOiAkaXRlcmF0b3I7XG4gICAgaWYgKCFMSUJSQVJZICYmICFDT1JSRUNUX0lURVJfTkFNRSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBJVEVSQVRPUiwgJGl0ZXJhdG9yKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xudmFyIERBVEFfVklFVyA9ICdEYXRhVmlldyc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCEnO1xudmFyIFdST05HX0lOREVYID0gJ1dyb25nIGluZGV4ISc7XG52YXIgJEFycmF5QnVmZmVyID0gZ2xvYmFsW0FSUkFZX0JVRkZFUl07XG52YXIgJERhdGFWaWV3ID0gZ2xvYmFsW0RBVEFfVklFV107XG52YXIgTWF0aCA9IGdsb2JhbC5NYXRoO1xudmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3ctcmVzdHJpY3RlZC1uYW1lc1xudmFyIEluZmluaXR5ID0gZ2xvYmFsLkluZmluaXR5O1xudmFyIEJhc2VCdWZmZXIgPSAkQXJyYXlCdWZmZXI7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xudmFyIEJVRkZFUiA9ICdidWZmZXInO1xudmFyIEJZVEVfTEVOR1RIID0gJ2J5dGVMZW5ndGgnO1xudmFyIEJZVEVfT0ZGU0VUID0gJ2J5dGVPZmZzZXQnO1xudmFyICRCVUZGRVIgPSBERVNDUklQVE9SUyA/ICdfYicgOiBCVUZGRVI7XG52YXIgJExFTkdUSCA9IERFU0NSSVBUT1JTID8gJ19sJyA6IEJZVEVfTEVOR1RIO1xudmFyICRPRkZTRVQgPSBERVNDUklQVE9SUyA/ICdfbycgOiBCWVRFX09GRlNFVDtcblxuLy8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcbmZ1bmN0aW9uIHBhY2tJRUVFNzU0KHZhbHVlLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShuQnl0ZXMpO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gbUxlbiA9PT0gMjMgPyBwb3coMiwgLTI0KSAtIHBvdygyLCAtNzcpIDogMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDA7XG4gIHZhciBlLCBtLCBjO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKHZhbHVlICE9IHZhbHVlIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBtID0gdmFsdWUgIT0gdmFsdWUgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gZmxvb3IobG9nKHZhbHVlKSAvIExOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBwb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIHBvdygyLCBlQmlhcyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltpKytdID0gbSAmIDI1NSwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG4gIGUgPSBlIDw8IG1MZW4gfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW2krK10gPSBlICYgMjU1LCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcbiAgYnVmZmVyWy0taV0gfD0gcyAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIHVucGFja0lFRUU3NTQoYnVmZmVyLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IGVMZW4gLSA3O1xuICB2YXIgaSA9IG5CeXRlcyAtIDE7XG4gIHZhciBzID0gYnVmZmVyW2ktLV07XG4gIHZhciBlID0gcyAmIDEyNztcbiAgdmFyIG07XG4gIHMgPj49IDc7XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICBlID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogcyA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgcG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH0gcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBwb3coMiwgZSAtIG1MZW4pO1xufVxuXG5mdW5jdGlvbiB1bnBhY2tJMzIoYnl0ZXMpIHtcbiAgcmV0dXJuIGJ5dGVzWzNdIDw8IDI0IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG59XG5mdW5jdGlvbiBwYWNrSTgoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0kxNihpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0kzMihpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmYsIGl0ID4+IDE2ICYgMHhmZiwgaXQgPj4gMjQgJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tGNjQoaXQpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCA1MiwgOCk7XG59XG5mdW5jdGlvbiBwYWNrRjMyKGl0KSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgMjMsIDQpO1xufVxuXG5mdW5jdGlvbiBhZGRHZXR0ZXIoQywga2V5LCBpbnRlcm5hbCkge1xuICBkUChDW1BST1RPVFlQRV0sIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbaW50ZXJuYWxdOyB9IH0pO1xufVxuXG5mdW5jdGlvbiBnZXQodmlldywgYnl0ZXMsIGluZGV4LCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICBpZiAoaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gIHZhciBwYWNrID0gc3RvcmUuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpO1xuICByZXR1cm4gaXNMaXR0bGVFbmRpYW4gPyBwYWNrIDogcGFjay5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBzZXQodmlldywgYnl0ZXMsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4O1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcbiAgaWYgKGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYjtcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdO1xuICB2YXIgcGFjayA9IGNvbnZlcnNpb24oK3ZhbHVlKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKSBzdG9yZVtzdGFydCArIGldID0gcGFja1tpc0xpdHRsZUVuZGlhbiA/IGkgOiBieXRlcyAtIGkgLSAxXTtcbn1cblxuaWYgKCEkdHlwZWQuQUJWKSB7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuICAgIHZhciBieXRlTGVuZ3RoID0gdG9JbmRleChsZW5ndGgpO1xuICAgIHRoaXMuX2IgPSBhcnJheUZpbGwuY2FsbChuZXcgQXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlclskTEVOR1RIXTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGJ5dGVPZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aChieXRlTGVuZ3RoKTtcbiAgICBpZiAob2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHRoaXNbJEJVRkZFUl0gPSBidWZmZXI7XG4gICAgdGhpc1skT0ZGU0VUXSA9IG9mZnNldDtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgICBhZGRHZXR0ZXIoJEFycmF5QnVmZmVyLCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQlVGRkVSLCAnX2InKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9PRkZTRVQsICdfbycpO1xuICB9XG5cbiAgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbiAgICB9LFxuICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgMjMsIDQpO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQ2NDogZnVuY3Rpb24gZ2V0RmxvYXQ2NChieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgNTIsIDgpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0YzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Y2NCwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICRBcnJheUJ1ZmZlcigxKTtcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgJEFycmF5QnVmZmVyKC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgJEFycmF5QnVmZmVyKDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbmV3ICRBcnJheUJ1ZmZlcihOYU4pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIHJldHVybiAkQXJyYXlCdWZmZXIubmFtZSAhPSBBUlJBWV9CVUZGRVI7XG4gIH0pKSB7XG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlcik7XG4gICAgICByZXR1cm4gbmV3IEJhc2VCdWZmZXIodG9JbmRleChsZW5ndGgpKTtcbiAgICB9O1xuICAgIHZhciBBcnJheUJ1ZmZlclByb3RvID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBCYXNlQnVmZmVyW1BST1RPVFlQRV07XG4gICAgZm9yICh2YXIga2V5cyA9IGdPUE4oQmFzZUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajspIHtcbiAgICAgIGlmICghKChrZXkgPSBrZXlzW2orK10pIGluICRBcnJheUJ1ZmZlcikpIGhpZGUoJEFycmF5QnVmZmVyLCBrZXksIEJhc2VCdWZmZXJba2V5XSk7XG4gICAgfVxuICAgIGlmICghTElCUkFSWSkgQXJyYXlCdWZmZXJQcm90by5jb25zdHJ1Y3RvciA9ICRBcnJheUJ1ZmZlcjtcbiAgfVxuICAvLyBpT1MgU2FmYXJpIDcueCBidWdcbiAgdmFyIHZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpO1xuICB2YXIgJHNldEludDggPSAkRGF0YVZpZXdbUFJPVE9UWVBFXS5zZXRJbnQ4O1xuICB2aWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XG4gIHZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYgKHZpZXcuZ2V0SW50OCgwKSB8fCAhdmlldy5nZXRJbnQ4KDEpKSByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuaGlkZSgkRGF0YVZpZXdbUFJPVE9UWVBFXSwgJHR5cGVkLlZJRVcsIHRydWUpO1xuZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuZXhwb3J0c1tEQVRBX1ZJRVddID0gJERhdGFWaWV3O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgVFlQRUQgPSB1aWQoJ3R5cGVkX2FycmF5Jyk7XG52YXIgVklFVyA9IHVpZCgndmlldycpO1xudmFyIEFCViA9ICEhKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBnbG9iYWwuRGF0YVZpZXcpO1xudmFyIENPTlNUUiA9IEFCVjtcbnZhciBpID0gMDtcbnZhciBsID0gOTtcbnZhciBUeXBlZDtcblxudmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMgPSAoXG4gICdJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheSdcbikuc3BsaXQoJywnKTtcblxud2hpbGUgKGkgPCBsKSB7XG4gIGlmIChUeXBlZCA9IGdsb2JhbFtUeXBlZEFycmF5Q29uc3RydWN0b3JzW2krK11dKSB7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFRZUEVELCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gIH0gZWxzZSBDT05TVFIgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCVjogQUJWLFxuICBDT05TVFI6IENPTlNUUixcbiAgVFlQRUQ6IFRZUEVELFxuICBWSUVXOiBWSUVXXG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbmF2aWdhdG9yID0gZ2xvYmFsLm5hdmlnYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG4iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5JywgeyBjb3B5V2l0aGluOiByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpIH0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnY29weVdpdGhpbicpO1xuIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5JywgeyBmaWxsOiByZXF1aXJlKCcuL19hcnJheS1maWxsJykgfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNik7XG52YXIgS0VZID0gJ2ZpbmRJbmRleCc7XG52YXIgZm9yY2VkID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmaW5kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDUpO1xudmFyIEtFWSA9ICdmaW5kJztcbnZhciBmb3JjZWQgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmIChLRVkgaW4gW10pIEFycmF5KDEpW0tFWV0oZnVuY3Rpb24gKCkgeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikgeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDKCk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvciAocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbi8vIFdlYktpdCBBcnJheS5vZiBpc24ndCBnZW5lcmljXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKEFycmF5Lm9mLmNhbGwoRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShhTGVuKTtcbiAgICB3aGlsZSAoYUxlbiA+IGluZGV4KSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBhTGVuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBGUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoJycgKyB0aGlzKS5tYXRjaChuYW1lUkUpWzFdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgTUFQID0gJ01hcCc7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKE1BUCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTUFQKSwga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTtcbiIsIi8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbG9nMXAgPSByZXF1aXJlKCcuL19tYXRoLWxvZzFwJyk7XG52YXIgc3FydCA9IE1hdGguc3FydDtcbnZhciAkYWNvc2ggPSBNYXRoLmFjb3NoO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFjb3NoXG4gIC8vIFY4IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM1MDlcbiAgJiYgTWF0aC5mbG9vcigkYWNvc2goTnVtYmVyLk1BWF9WQUxVRSkpID09IDcxMFxuICAvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYWNvc2goSW5maW5pdHkpIC0+IE5hTlxuICAmJiAkYWNvc2goSW5maW5pdHkpID09IEluZmluaXR5XG4pLCAnTWF0aCcsIHtcbiAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHgpIHtcbiAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogeCA+IDk0OTA2MjY1LjYyNDI1MTU2XG4gICAgICA/IE1hdGgubG9nKHgpICsgTWF0aC5MTjJcbiAgICAgIDogbG9nMXAoeCAtIDEgKyBzcXJ0KHggLSAxKSAqIHNxcnQoeCArIDEpKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhc2luaCA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpIHtcbiAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpO1xufVxuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXNpbmgoMCkgLT4gLTBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHsgYXNpbmg6IGFzaW5oIH0pO1xuIiwiLy8gMjAuMi4yLjcgTWF0aC5hdGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXRhbmggPSBNYXRoLmF0YW5oO1xuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXRhbmgoLTApIC0+IDBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXRhbmggJiYgMSAvICRhdGFuaCgtMCkgPCAwKSwgJ01hdGgnLCB7XG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KSB7XG4gICAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogTWF0aC5sb2coKDEgKyB4KSAvICgxIC0geCkpIC8gMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuOSBNYXRoLmNicnQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNicnQ6IGZ1bmN0aW9uIGNicnQoeCkge1xuICAgIHJldHVybiBzaWduKHggPSAreCkgKiBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xMSBNYXRoLmNsejMyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KSB7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIE1hdGguZmxvb3IoTWF0aC5sb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY29zaDogZnVuY3Rpb24gY29zaCh4KSB7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCRleHBtMSAhPSBNYXRoLmV4cG0xKSwgJ01hdGgnLCB7IGV4cG0xOiAkZXhwbTEgfSk7XG4iLCIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgZnJvdW5kOiByZXF1aXJlKCcuL19tYXRoLWZyb3VuZCcpIH0pO1xuIiwiLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFicyA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbGFyZyA9IDA7XG4gICAgdmFyIGFyZywgZGl2O1xuICAgIHdoaWxlIChpIDwgYUxlbikge1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgIGlmIChsYXJnIDwgYXJnKSB7XG4gICAgICAgIGRpdiA9IGxhcmcgLyBhcmc7XG4gICAgICAgIHN1bSA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYgKGFyZyA+IDApIHtcbiAgICAgICAgZGl2ID0gYXJnIC8gbGFyZztcbiAgICAgICAgc3VtICs9IGRpdiAqIGRpdjtcbiAgICAgIH0gZWxzZSBzdW0gKz0gYXJnO1xuICAgIH1cbiAgICByZXR1cm4gbGFyZyA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGxhcmcgKiBNYXRoLnNxcnQoc3VtKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbXVsID0gTWF0aC5pbXVsO1xuXG4vLyBzb21lIFdlYktpdCB2ZXJzaW9ucyBmYWlscyB3aXRoIGJpZyBudW1iZXJzLCBzb21lIGhhcyB3cm9uZyBhcml0eVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICRpbXVsKDB4ZmZmZmZmZmYsIDUpICE9IC01IHx8ICRpbXVsLmxlbmd0aCAhPSAyO1xufSksICdNYXRoJywge1xuICBpbXVsOiBmdW5jdGlvbiBpbXVsKHgsIHkpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciB4biA9ICt4O1xuICAgIHZhciB5biA9ICt5O1xuICAgIHZhciB4bCA9IFVJTlQxNiAmIHhuO1xuICAgIHZhciB5bCA9IFVJTlQxNiAmIHluO1xuICAgIHJldHVybiAwIHwgeGwgKiB5bCArICgoVUlOVDE2ICYgeG4gPj4+IDE2KSAqIHlsICsgeGwgKiAoVUlOVDE2ICYgeW4gPj4+IDE2KSA8PCAxNiA+Pj4gMCk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMTA6IGZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzEwRTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBsb2cxcDogcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpIH0pO1xuIiwiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNpZ246IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpIH0pO1xuIiwiLy8gMjAuMi4yLjMwIE1hdGguc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxuLy8gVjggbmVhciBDaHJvbWl1bSAzOCBoYXMgYSBwcm9ibGVtIHdpdGggdmVyeSBzbWFsbCBudW1iZXJzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIU1hdGguc2luaCgtMmUtMTcpICE9IC0yZS0xNztcbn0pLCAnTWF0aCcsIHtcbiAgc2luaDogZnVuY3Rpb24gc2luaCh4KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxXG4gICAgICA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyXG4gICAgICA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdGFuaDogZnVuY3Rpb24gdGFuaCh4KSB7XG4gICAgdmFyIGEgPSBleHBtMSh4ID0gK3gpO1xuICAgIHZhciBiID0gZXhwbTEoLXgpO1xuICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKGl0KSB7XG4gICAgcmV0dXJuIChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpIH0pO1xuIiwiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgX2lzRmluaXRlID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgaXNJbnRlZ2VyOiByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJykgfSk7XG4iLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjUgTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJyk7XG52YXIgYWJzID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc1NhZmVJbnRlZ2VyOiBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKG51bWJlcikge1xuICAgIHJldHVybiBpc0ludGVnZXIobnVtYmVyKSAmJiBhYnMobnVtYmVyKSA8PSAweDFmZmZmZmZmZmZmZmZmO1xuICB9XG59KTtcbiIsIi8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgTUFYX1NBRkVfSU5URUdFUjogMHgxZmZmZmZmZmZmZmZmZiB9KTtcbiIsIi8vIDIwLjEuMi4xMCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IE1JTl9TQUZFX0lOVEVHRVI6IC0weDFmZmZmZmZmZmZmZmZmIH0pO1xuIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcbiIsIi8vIDE5LjEuMi41IE9iamVjdC5mcmVlemUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZnJlZXplJywgZnVuY3Rpb24gKCRmcmVlemUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZyZWV6ZShpdCkge1xuICAgIHJldHVybiAkZnJlZXplICYmIGlzT2JqZWN0KGl0KSA/ICRmcmVlemUobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5TmFtZXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKS5mO1xufSk7XG4iLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTEgT2JqZWN0LmlzRXh0ZW5zaWJsZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNFeHRlbnNpYmxlJywgZnVuY3Rpb24gKCRpc0V4dGVuc2libGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZShpdCkgOiB0cnVlIDogZmFsc2U7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xMiBPYmplY3QuaXNGcm96ZW4oTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRnJvemVuJywgZnVuY3Rpb24gKCRpc0Zyb3plbikge1xuICByZXR1cm4gZnVuY3Rpb24gaXNGcm96ZW4oaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRnJvemVuID8gJGlzRnJvemVuKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjEzIE9iamVjdC5pc1NlYWxlZChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNTZWFsZWQnLCBmdW5jdGlvbiAoJGlzU2VhbGVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc1NlYWxlZChpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNTZWFsZWQgPyAkaXNTZWFsZWQoaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBpczogcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpIH0pO1xuIiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjE1IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdwcmV2ZW50RXh0ZW5zaW9ucycsIGZ1bmN0aW9uICgkcHJldmVudEV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KSB7XG4gICAgcmV0dXJuICRwcmV2ZW50RXh0ZW5zaW9ucyAmJiBpc09iamVjdChpdCkgPyAkcHJldmVudEV4dGVuc2lvbnMobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24gKCRzZWFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzZWFsKGl0KSB7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0IH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnM7XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52OCB8fCAnJztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpXG4gICAgICAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2VcbiAgICAgIC8vIHY4IDYuNiAoTm9kZSAxMCBhbmQgQ2hyb21lIDY2KSBoYXZlIGEgYnVnIHdpdGggcmVzb2x2aW5nIGN1c3RvbSB0aGVuYWJsZXNcbiAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgzMDU2NVxuICAgICAgLy8gd2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgICAgICYmIHY4LmluZGV4T2YoJzYuNicpICE9PSAwXG4gICAgICAmJiB1c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lLzY2JykgPT09IC0xO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHByb21pc2UsIGlzUmVqZWN0KSB7XG4gIGlmIChwcm9taXNlLl9uKSByZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIG9rID0gcHJvbWlzZS5fcyA9PSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuLCBleGl0ZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9oID09IDIpIG9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIG1heSB0aHJvd1xuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGRvbWFpbiAmJiAhZXhpdGVkKSBkb21haW4uZXhpdCgpO1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgcmV0dXJuIHByb21pc2UuX2ggIT09IDEgJiYgKHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYykubGVuZ3RoID09PSAwO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92IH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgICRyZWplY3QuY2FsbCh7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fYSkgdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9zKSBub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09ICRQcm9taXNlIHx8IEMgPT09IFdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBQcm9taXNlOiAkUHJvbWlzZSB9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKExJQlJBUlkgJiYgdGhpcyA9PT0gV3JhcHBlciA/ICRQcm9taXNlIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgckFwcGx5ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmFwcGx5O1xudmFyIGZBcHBseSA9IEZ1bmN0aW9uLmFwcGx5O1xuLy8gTVMgRWRnZSBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgckFwcGx5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCkge1xuICAgIHZhciBUID0gYUZ1bmN0aW9uKHRhcmdldCk7XG4gICAgdmFyIEwgPSBhbk9iamVjdChhcmd1bWVudHNMaXN0KTtcbiAgICByZXR1cm4gckFwcGx5ID8gckFwcGx5KFQsIHRoaXNBcmd1bWVudCwgTCkgOiBmQXBwbHkuY2FsbChULCB0aGlzQXJndW1lbnQsIEwpO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL19iaW5kJyk7XG52YXIgckNvbnN0cnVjdCA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5jb25zdHJ1Y3Q7XG5cbi8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xudmFyIEFSR1NfQlVHID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgckNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHKSwgJ1JlZmxlY3QnLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJncyAvKiAsIG5ld1RhcmdldCAqLykge1xuICAgIGFGdW5jdGlvbihUYXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFGdW5jdGlvbihhcmd1bWVudHNbMl0pO1xuICAgIGlmIChBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpIHJldHVybiByQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICBpZiAoVGFyZ2V0ID09IG5ld1RhcmdldCkge1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldCgpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgICRhcmdzLnB1c2guYXBwbHkoJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsICRhcmdzKSkoKTtcbiAgICB9XG4gICAgLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG4gICAgdmFyIHByb3RvID0gbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3QucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gRnVuY3Rpb24uYXBwbHkuY2FsbChUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTtcbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMyBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4vLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShkUC5mKHt9LCAxLCB7IHZhbHVlOiAxIH0pLCAxLCB7IHZhbHVlOiAyIH0pO1xufSksICdSZWZsZWN0Jywge1xuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcykge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShwcm9wZXJ0eUtleSwgdHJ1ZSk7XG4gICAgYW5PYmplY3QoYXR0cmlidXRlcyk7XG4gICAgdHJ5IHtcbiAgICAgIGRQLmYodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbiIsIi8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHZhciBkZXNjID0gZ09QRChhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjcgUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnZXRQcm90byA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZih0YXJnZXQpIHtcbiAgICByZXR1cm4gZ2V0UHJvdG8oYW5PYmplY3QodGFyZ2V0KSk7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5IC8qICwgcmVjZWl2ZXIgKi8pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl07XG4gIHZhciBkZXNjLCBwcm90bztcbiAgaWYgKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKSByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgaWYgKGRlc2MgPSBnT1BELmYodGFyZ2V0LCBwcm9wZXJ0eUtleSkpIHJldHVybiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICA/IGRlc2MudmFsdWVcbiAgICA6IGRlc2MuZ2V0ICE9PSB1bmRlZmluZWRcbiAgICAgID8gZGVzYy5nZXQuY2FsbChyZWNlaXZlcilcbiAgICAgIDogdW5kZWZpbmVkO1xuICBpZiAoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkgcmV0dXJuIGdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgeyBnZXQ6IGdldCB9KTtcbiIsIi8vIDI2LjEuOSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjEwIFJlZmxlY3QuaXNFeHRlbnNpYmxlKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0YXJnZXQpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHJldHVybiAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZSh0YXJnZXQpIDogdHJ1ZTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7IG93bktleXM6IHJlcXVpcmUoJy4vX293bi1rZXlzJykgfSk7XG4iLCIvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgaWYgKCRwcmV2ZW50RXh0ZW5zaW9ucykgJHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbiIsIi8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzZXRQcm90byA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpO1xuXG5pZiAoc2V0UHJvdG8pICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pIHtcbiAgICBzZXRQcm90by5jaGVjayh0YXJnZXQsIHByb3RvKTtcbiAgICB0cnkge1xuICAgICAgc2V0UHJvdG8uc2V0KHRhcmdldCwgcHJvdG8pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG4iLCIvLyAyNi4xLjEzIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgWywgcmVjZWl2ZXJdKVxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViAvKiAsIHJlY2VpdmVyICovKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCA0ID8gdGFyZ2V0IDogYXJndW1lbnRzWzNdO1xuICB2YXIgb3duRGVzYyA9IGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIHZhciBleGlzdGluZ0Rlc2NyaXB0b3IsIHByb3RvO1xuICBpZiAoIW93bkRlc2MpIHtcbiAgICBpZiAoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkge1xuICAgICAgcmV0dXJuIHNldChwcm90bywgcHJvcGVydHlLZXksIFYsIHJlY2VpdmVyKTtcbiAgICB9XG4gICAgb3duRGVzYyA9IGNyZWF0ZURlc2MoMCk7XG4gIH1cbiAgaWYgKGhhcyhvd25EZXNjLCAndmFsdWUnKSkge1xuICAgIGlmIChvd25EZXNjLndyaXRhYmxlID09PSBmYWxzZSB8fCAhaXNPYmplY3QocmVjZWl2ZXIpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGV4aXN0aW5nRGVzY3JpcHRvciA9IGdPUEQuZihyZWNlaXZlciwgcHJvcGVydHlLZXkpKSB7XG4gICAgICBpZiAoZXhpc3RpbmdEZXNjcmlwdG9yLmdldCB8fCBleGlzdGluZ0Rlc2NyaXB0b3Iuc2V0IHx8IGV4aXN0aW5nRGVzY3JpcHRvci53cml0YWJsZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XG4gICAgICBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKTtcbiAgICB9IGVsc2UgZFAuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGNyZWF0ZURlc2MoMCwgVikpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBvd25EZXNjLnNldCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAob3duRGVzYy5zZXQuY2FsbChyZWNlaXZlciwgViksIHRydWUpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7IHNldDogc2V0IH0pO1xuIiwiLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgLy4vZy5mbGFncyAhPSAnZycpIHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoUmVnRXhwLnByb3RvdHlwZSwgJ2ZsYWdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogcmVxdWlyZSgnLi9fZmxhZ3MnKVxufSk7XG4iLCIvLyBAQG1hdGNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ21hdGNoJywgMSwgZnVuY3Rpb24gKGRlZmluZWQsIE1BVENILCAkbWF0Y2gpIHtcbiAgLy8gMjEuMS4zLjExIFN0cmluZy5wcm90b3R5cGUubWF0Y2gocmVnZXhwKVxuICByZXR1cm4gW2Z1bmN0aW9uIG1hdGNoKHJlZ2V4cCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtNQVRDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRtYXRjaF07XG59KTtcbiIsIi8vIEBAcmVwbGFjZSBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlKSB7XG4gIC8vIDIxLjEuMy4xNCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSlcbiAgcmV0dXJuIFtmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGZuLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICB9LCAkcmVwbGFjZV07XG59KTtcbiIsIi8vIEBAc2VhcmNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NlYXJjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBTRUFSQ0gsICRzZWFyY2gpIHtcbiAgLy8gMjEuMS4zLjE1IFN0cmluZy5wcm90b3R5cGUuc2VhcmNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzZWFyY2gocmVnZXhwKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW1NFQVJDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbU0VBUkNIXShTdHJpbmcoTykpO1xuICB9LCAkc2VhcmNoXTtcbn0pO1xuIiwiLy8gQEBzcGxpdCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBTUExJVCwgJHNwbGl0KSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG4gIHZhciBfc3BsaXQgPSAkc3BsaXQ7XG4gIHZhciAkcHVzaCA9IFtdLnB1c2g7XG4gIHZhciAkU1BMSVQgPSAnc3BsaXQnO1xuICB2YXIgTEVOR1RIID0gJ2xlbmd0aCc7XG4gIHZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG4gIGlmIChcbiAgICAnYWJiYydbJFNQTElUXSgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fFxuICAgICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fFxuICAgICcuJ1skU1BMSVRdKC8oLj8pKC4/KS8pW0xFTkdUSF0gIT0gNCB8fFxuICAgICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHxcbiAgICAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF1cbiAgKSB7XG4gICAgdmFyIE5QQ0cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHVuZGVmaW5lZDsgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICAkc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmICghaXNSZWdFeHAoc2VwYXJhdG9yKSkgcmV0dXJuIF9zcGxpdC5jYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgdmFyIGxhc3RMYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIHNwbGl0TGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gNDI5NDk2NzI5NSA6IGxpbWl0ID4+PiAwO1xuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICB2YXIgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aCwgaTtcbiAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgaWYgKCFOUENHKSBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3JDb3B5LnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yQ29weS5leGVjKHN0cmluZykpIHtcbiAgICAgICAgLy8gYHNlcGFyYXRvckNvcHkubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yIE5QQ0dcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgICAgaWYgKCFOUENHICYmIG1hdGNoW0xFTkdUSF0gPiAxKSBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHNbTEVOR1RIXSAtIDI7IGkrKykgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkgJHB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0W0xFTkdUSF0gPj0gc3BsaXRMaW1pdCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KSBzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdKys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSkge1xuICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yQ29weS50ZXN0KCcnKSkgb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmICgnMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pIHtcbiAgICAkc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiBfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuICB9XG4gIC8vIDIxLjEuMy4xNyBTdHJpbmcucHJvdG90eXBlLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpXG4gIHJldHVybiBbZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSBzZXBhcmF0b3IgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VwYXJhdG9yW1NQTElUXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdCkgOiAkc3BsaXQuY2FsbChTdHJpbmcoTyksIHNlcGFyYXRvciwgbGltaXQpO1xuICB9LCAkc3BsaXRdO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTRVQgPSAnU2V0JztcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBTRVQpLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKGZhbHNlKTtcbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KHBvcylcbiAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcykge1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7XG4iLCIvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgRU5EU19XSVRIID0gJ2VuZHNXaXRoJztcbnZhciAkZW5kc1dpdGggPSAnJ1tFTkRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKEVORFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBFTkRTX1dJVEgpO1xuICAgIHZhciBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aCk7XG4gICAgdmFyIGVuZCA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBNYXRoLm1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbik7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkZW5kc1dpdGhcbiAgICAgID8gJGVuZHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBlbmQpXG4gICAgICA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBjb2RlO1xuICAgIHdoaWxlIChhTGVuID4gaSkge1xuICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcbiAgICAgIGlmICh0b0Fic29sdXRlSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKSB0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXG4gICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcbiAgICAgICk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcbiIsIi8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIElOQ0xVREVTID0gJ2luY2x1ZGVzJztcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShJTkNMVURFUyksICdTdHJpbmcnLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICByZXR1cm4gISF+Y29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIElOQ0xVREVTKVxuICAgICAgLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKSB7XG4gICAgdmFyIHRwbCA9IHRvSU9iamVjdChjYWxsU2l0ZS5yYXcpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0cGwubGVuZ3RoKTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAobGVuID4gaSkge1xuICAgICAgcmVzLnB1c2goU3RyaW5nKHRwbFtpKytdKSk7XG4gICAgICBpZiAoaSA8IGFMZW4pIHJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4xMyBTdHJpbmcucHJvdG90eXBlLnJlcGVhdChjb3VudClcbiAgcmVwZWF0OiByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jylcbn0pO1xuIiwiLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJztcbnZhciAkc3RhcnRzV2l0aCA9ICcnW1NUQVJUU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShTVEFSVFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgU1RBUlRTX1dJVEgpO1xuICAgIHZhciBpbmRleCA9IHRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGF0Lmxlbmd0aCkpO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGhcbiAgICAgID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICAkcmVwbGFjZXIgPSByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbnZhciBidWZmZXIgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIEFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuQXJyYXlCdWZmZXI7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyICRBcnJheUJ1ZmZlciA9IGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbnZhciAkRGF0YVZpZXcgPSBidWZmZXIuRGF0YVZpZXc7XG52YXIgJGlzVmlldyA9ICR0eXBlZC5BQlYgJiYgQXJyYXlCdWZmZXIuaXNWaWV3O1xudmFyICRzbGljZSA9ICRBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG52YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEFycmF5QnVmZmVyICE9PSAkQXJyYXlCdWZmZXIpLCB7IEFycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXIgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISR0eXBlZC5DT05TVFIsIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjMuMSBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKVxuICBpc1ZpZXc6IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xuICAgIHJldHVybiAkaXNWaWV3ICYmICRpc1ZpZXcoaXQpIHx8IGlzT2JqZWN0KGl0KSAmJiBWSUVXIGluIGl0O1xuICB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlUgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFuZXcgJEFycmF5QnVmZmVyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS40LjMgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKCRzbGljZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJHNsaWNlLmNhbGwoYW5PYmplY3QodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgdmFyIGxlbiA9IGFuT2JqZWN0KHRoaXMpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIGZpcnN0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQsIGxlbik7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRBcnJheUJ1ZmZlcikpKHRvTGVuZ3RoKGZpbiAtIGZpcnN0KSk7XG4gICAgdmFyIHZpZXdTID0gbmV3ICREYXRhVmlldyh0aGlzKTtcbiAgICB2YXIgdmlld1QgPSBuZXcgJERhdGFWaWV3KHJlc3VsdCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoZmlyc3QgPCBmaW4pIHtcbiAgICAgIHZpZXdULnNldFVpbnQ4KGluZGV4KyssIHZpZXdTLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKEFSUkFZX0JVRkZFUik7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDY0JywgOCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0NjRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDE2JywgMiwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4Q2xhbXBlZEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59LCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBlYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKTtcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgV0VBS19NQVAgPSAnV2Vha01hcCc7XG52YXIgZ2V0V2VhayA9IG1ldGEuZ2V0V2VhaztcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmU7XG52YXIgdG1wID0ge307XG52YXIgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgV0VBS19NQVApKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSwga2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShXRUFLX01BUCwgd3JhcHBlciwgbWV0aG9kcywgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmIChmYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgJFdlYWtNYXAoKS5zZXQoKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh0bXApLCA3KS5nZXQodG1wKSAhPSA3OyB9KSkge1xuICBJbnRlcm5hbE1hcCA9IHdlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgV0VBS19NQVApO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHByb3RvID0gJFdlYWtNYXAucHJvdG90eXBlO1xuICAgIHZhciBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBrZXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBzdG9yZSBmcm96ZW4gb2JqZWN0cyBvbiBpbnRlcm5hbCB3ZWFrbWFwIHNoaW1cbiAgICAgIGlmIChpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKSB7XG4gICAgICAgIGlmICghdGhpcy5fZikgdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZltrZXldKGEsIGIpO1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBXRUFLX1NFVCA9ICdXZWFrU2V0JztcblxuLy8gMjMuNCBXZWFrU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShXRUFLX1NFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha1NldCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjQuMy4xIFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19TRVQpLCB2YWx1ZSwgdHJ1ZSk7XG4gIH1cbn0sIHdlYWssIGZhbHNlLCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2luY2x1ZGVzJyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGVudHJpZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoaXQpIHtcbiAgICByZXR1cm4gJGVudHJpZXMoaXQpO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG93bktleXMgPSByZXF1aXJlKCcuL19vd24ta2V5cycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXREZXNjID0gZ09QRC5mO1xuICAgIHZhciBrZXlzID0gb3duS2V5cyhPKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXksIGRlc2M7XG4gICAgd2hpbGUgKGtleXMubGVuZ3RoID4gaSkge1xuICAgICAgZGVzYyA9IGdldERlc2MoTywga2V5ID0ga2V5c1tpKytdKTtcbiAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHZhbHVlcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKGZhbHNlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGl0KSB7XG4gICAgcmV0dXJuICR2YWx1ZXMoaXQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYWQgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMjgwXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIC9WZXJzaW9uXFwvMTBcXC5cXGQrKFxcLlxcZCspPyBTYWZhcmlcXC8vLnRlc3QodXNlckFnZW50KSwgJ1N0cmluZycsIHtcbiAgcGFkRW5kOiBmdW5jdGlvbiBwYWRFbmQobWF4TGVuZ3RoIC8qICwgZmlsbFN0cmluZyA9ICcgJyAqLykge1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGZhbHNlKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFkID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzI4MFxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAvVmVyc2lvblxcLzEwXFwuXFxkKyhcXC5cXGQrKT8gU2FmYXJpXFwvLy50ZXN0KHVzZXJBZ2VudCksICdTdHJpbmcnLCB7XG4gIHBhZFN0YXJ0OiBmdW5jdGlvbiBwYWRTdGFydChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbn0pO1xuIiwidmFyICRpdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbnZhciBET01JdGVyYWJsZXMgPSB7XG4gIENTU1J1bGVMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogZmFsc2UsXG4gIENTU1ZhbHVlTGlzdDogZmFsc2UsXG4gIENsaWVudFJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NUmVjdExpc3Q6IGZhbHNlLFxuICBET01TdHJpbmdMaXN0OiBmYWxzZSxcbiAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogZmFsc2UsXG4gIEZpbGVMaXN0OiBmYWxzZSxcbiAgSFRNTEFsbENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxGb3JtRWxlbWVudDogZmFsc2UsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiBmYWxzZSxcbiAgTWVkaWFMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgTWltZVR5cGVBcnJheTogZmFsc2UsXG4gIE5hbWVkTm9kZU1hcDogZmFsc2UsXG4gIE5vZGVMaXN0OiB0cnVlLFxuICBQYWludFJlcXVlc3RMaXN0OiBmYWxzZSxcbiAgUGx1Z2luOiBmYWxzZSxcbiAgUGx1Z2luQXJyYXk6IGZhbHNlLFxuICBTVkdMZW5ndGhMaXN0OiBmYWxzZSxcbiAgU1ZHTnVtYmVyTGlzdDogZmFsc2UsXG4gIFNWR1BhdGhTZWdMaXN0OiBmYWxzZSxcbiAgU1ZHUG9pbnRMaXN0OiBmYWxzZSxcbiAgU1ZHU3RyaW5nTGlzdDogZmFsc2UsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IGZhbHNlLFxuICBTb3VyY2VCdWZmZXJMaXN0OiBmYWxzZSxcbiAgU3R5bGVTaGVldExpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBUZXh0VHJhY2tDdWVMaXN0OiBmYWxzZSxcbiAgVGV4dFRyYWNrTGlzdDogZmFsc2UsXG4gIFRvdWNoTGlzdDogZmFsc2Vcbn07XG5cbmZvciAodmFyIGNvbGxlY3Rpb25zID0gZ2V0S2V5cyhET01JdGVyYWJsZXMpLCBpID0gMDsgaSA8IGNvbGxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gY29sbGVjdGlvbnNbaV07XG4gIHZhciBleHBsaWNpdCA9IERPTUl0ZXJhYmxlc1tOQU1FXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIHZhciBrZXk7XG4gIGlmIChwcm90bykge1xuICAgIGlmICghcHJvdG9bSVRFUkFUT1JdKSBoaWRlKHByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIGlmICghcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IEFycmF5VmFsdWVzO1xuICAgIGlmIChleHBsaWNpdCkgZm9yIChrZXkgaW4gJGl0ZXJhdG9ycykgaWYgKCFwcm90b1trZXldKSByZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xuICB9XG59XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICR0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIsIHtcbiAgc2V0SW1tZWRpYXRlOiAkdGFzay5zZXQsXG4gIGNsZWFySW1tZWRpYXRlOiAkdGFzay5jbGVhclxufSk7XG4iLCIvLyBpZTktIHNldFRpbWVvdXQgJiBzZXRJbnRlcnZhbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZml4XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTtcbnZhciBzbGljZSA9IFtdLnNsaWNlO1xudmFyIE1TSUUgPSAvTVNJRSAuXFwuLy50ZXN0KHVzZXJBZ2VudCk7IC8vIDwtIGRpcnR5IGllOS0gY2hlY2tcbnZhciB3cmFwID0gZnVuY3Rpb24gKHNldCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGZuLCB0aW1lIC8qICwgLi4uYXJncyAqLykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICB2YXIgYXJncyA9IGJvdW5kQXJncyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGZhbHNlO1xuICAgIHJldHVybiBzZXQoYm91bmRBcmdzID8gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICAodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSA6IGZuLCB0aW1lKTtcbiAgfTtcbn07XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiArICRleHBvcnQuRiAqIE1TSUUsIHtcbiAgc2V0VGltZW91dDogd3JhcChnbG9iYWwuc2V0VGltZW91dCksXG4gIHNldEludGVydmFsOiB3cmFwKGdsb2JhbC5zZXRJbnRlcnZhbClcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzJyk7XG52YXIgZm9yZWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbnZhciBoYXNTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sKCkgPT09ICdzeW1ib2wnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIGFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBvYmogPSB7fTtcblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAneCcsIHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiBvYmogfSk7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuICAgICAgICBmb3IgKHZhciBfIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycywgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cblx0XHRyZXR1cm4gb2JqLnggPT09IG9iajtcblx0fSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIElFIDguICovXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgYXJlUHJvcGVydHlEZXNjcmlwdG9yc1N1cHBvcnRlZCgpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCB2YWx1ZSwgcHJlZGljYXRlKSB7XG5cdGlmIChuYW1lIGluIG9iamVjdCAmJiAoIWlzRnVuY3Rpb24ocHJlZGljYXRlKSB8fCAhcHJlZGljYXRlKCkpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG9iamVjdFtuYW1lXSA9IHZhbHVlO1xuXHR9XG59O1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCkge1xuXHR2YXIgcHJlZGljYXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDoge307XG5cdHZhciBwcm9wcyA9IGtleXMobWFwKTtcblx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRwcm9wcyA9IHByb3BzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG1hcCkpO1xuXHR9XG5cdGZvcmVhY2gocHJvcHMsIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0ZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIHByZWRpY2F0ZXNbbmFtZV0pO1xuXHR9KTtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMuc3VwcG9ydHNEZXNjcmlwdG9ycyA9ICEhc3VwcG9ydHNEZXNjcmlwdG9ycztcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0aWVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTtcbnZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGhhc0RvbnRFbnVtQnVnID0gIWlzRW51bWVyYWJsZS5jYWxsKHsgdG9TdHJpbmc6IG51bGwgfSwgJ3RvU3RyaW5nJyk7XG52YXIgaGFzUHJvdG9FbnVtQnVnID0gaXNFbnVtZXJhYmxlLmNhbGwoZnVuY3Rpb24gKCkge30sICdwcm90b3R5cGUnKTtcbnZhciBkb250RW51bXMgPSBbXG5cdCd0b1N0cmluZycsXG5cdCd0b0xvY2FsZVN0cmluZycsXG5cdCd2YWx1ZU9mJyxcblx0J2hhc093blByb3BlcnR5Jyxcblx0J2lzUHJvdG90eXBlT2YnLFxuXHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHQnY29uc3RydWN0b3InXG5dO1xudmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcblx0dmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuXHRyZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcbn07XG52YXIgZXhjbHVkZWRLZXlzID0ge1xuXHQkYXBwbGljYXRpb25DYWNoZTogdHJ1ZSxcblx0JGNvbnNvbGU6IHRydWUsXG5cdCRleHRlcm5hbDogdHJ1ZSxcblx0JGZyYW1lOiB0cnVlLFxuXHQkZnJhbWVFbGVtZW50OiB0cnVlLFxuXHQkZnJhbWVzOiB0cnVlLFxuXHQkaW5uZXJIZWlnaHQ6IHRydWUsXG5cdCRpbm5lcldpZHRoOiB0cnVlLFxuXHQkb3V0ZXJIZWlnaHQ6IHRydWUsXG5cdCRvdXRlcldpZHRoOiB0cnVlLFxuXHQkcGFnZVhPZmZzZXQ6IHRydWUsXG5cdCRwYWdlWU9mZnNldDogdHJ1ZSxcblx0JHBhcmVudDogdHJ1ZSxcblx0JHNjcm9sbExlZnQ6IHRydWUsXG5cdCRzY3JvbGxUb3A6IHRydWUsXG5cdCRzY3JvbGxYOiB0cnVlLFxuXHQkc2Nyb2xsWTogdHJ1ZSxcblx0JHNlbGY6IHRydWUsXG5cdCR3ZWJraXRJbmRleGVkREI6IHRydWUsXG5cdCR3ZWJraXRTdG9yYWdlSW5mbzogdHJ1ZSxcblx0JHdpbmRvdzogdHJ1ZVxufTtcbnZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuXHQvKiBnbG9iYWwgd2luZG93ICovXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Zm9yICh2YXIgayBpbiB3aW5kb3cpIHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFleGNsdWRlZEtleXNbJyQnICsga10gJiYgaGFzLmNhbGwod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufSgpKTtcbnZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAobykge1xuXHQvKiBnbG9iYWwgd2luZG93ICovXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnKSB7XG5cdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG52YXIga2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHR2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG5cdHZhciBpc0Z1bmN0aW9uID0gdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0dmFyIGlzU3RyaW5nID0gaXNPYmplY3QgJiYgdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBTdHJpbmddJztcblx0dmFyIHRoZUtleXMgPSBbXTtcblxuXHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcblx0fVxuXG5cdHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcblx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0Lmxlbmd0aDsgKytqKSB7XG5cdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGopKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcblx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG5cblx0XHRmb3IgKHZhciBrID0gMDsgayA8IGRvbnRFbnVtcy5sZW5ndGg7ICsraykge1xuXHRcdFx0aWYgKCEoc2tpcENvbnN0cnVjdG9yICYmIGRvbnRFbnVtc1trXSA9PT0gJ2NvbnN0cnVjdG9yJykgJiYgaGFzLmNhbGwob2JqZWN0LCBkb250RW51bXNba10pKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChkb250RW51bXNba10pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGhlS2V5cztcbn07XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHJldHVybiAoT2JqZWN0LmtleXMoYXJndW1lbnRzKSB8fCAnJykubGVuZ3RoID09PSAyO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0dmFyIG9yaWdpbmFsS2V5cyA9IE9iamVjdC5rZXlzO1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRPYmplY3Qua2V5cyA9IGtleXNTaGltO1xuXHR9XG5cdHJldHVybiBPYmplY3Qua2V5cyB8fCBrZXlzU2hpbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHR2YXIgaXNBcmdzID0gc3RyID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcblx0aWYgKCFpc0FyZ3MpIHtcblx0XHRpc0FyZ3MgPSBzdHIgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHRcdHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0fVxuXHRyZXR1cm4gaXNBcmdzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsc1xuXHRTZXQsXG5cdE1hcCxcblx0V2Vha1NldCxcblx0V2Vha01hcCxcblxuXHRQcm9taXNlLFxuXG5cdFN5bWJvbCxcblx0UHJveHksXG5cblx0QXRvbWljcyxcblx0U2hhcmVkQXJyYXlCdWZmZXIsXG5cblx0QXJyYXlCdWZmZXIsXG5cdERhdGFWaWV3LFxuXHRVaW50OEFycmF5LFxuXHRGbG9hdDMyQXJyYXksXG5cdEZsb2F0NjRBcnJheSxcblx0SW50OEFycmF5LFxuXHRJbnQxNkFycmF5LFxuXHRJbnQzMkFycmF5LFxuXHRVaW50OENsYW1wZWRBcnJheSxcblx0VWludDE2QXJyYXksXG5cdFVpbnQzMkFycmF5LFxuKi9cblxudmFyIHVuZGVmaW5lZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zaGFkb3ctcmVzdHJpY3RlZC1uYW1lc1xuXG52YXIgVGhyb3dUeXBlRXJyb3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG5cdD8gKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0OyB9KCkpXG5cdDogZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IH07XG5cbnZhciBoYXNTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJztcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG52YXIgZ2VuZXJhdG9yOyAvLyA9IGZ1bmN0aW9uICogKCkge307XG52YXIgZ2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3IgPyBnZXRQcm90byhnZW5lcmF0b3IpIDogdW5kZWZpbmVkO1xudmFyIGFzeW5jRm47IC8vIGFzeW5jIGZ1bmN0aW9uKCkge307XG52YXIgYXN5bmNGdW5jdGlvbiA9IGFzeW5jRm4gPyBhc3luY0ZuLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkO1xudmFyIGFzeW5jR2VuOyAvLyBhc3luYyBmdW5jdGlvbiAqICgpIHt9O1xudmFyIGFzeW5jR2VuRnVuY3Rpb24gPSBhc3luY0dlbiA/IGdldFByb3RvKGFzeW5jR2VuKSA6IHVuZGVmaW5lZDtcbnZhciBhc3luY0dlbkl0ZXJhdG9yID0gYXN5bmNHZW4gPyBhc3luY0dlbigpIDogdW5kZWZpbmVkO1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xuXG52YXIgSU5UUklOU0lDUyA9IHtcblx0JyQgJUFycmF5JSc6IEFycmF5LFxuXHQnJCAlQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJCAlQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLnByb3RvdHlwZSxcblx0JyQgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCckICVBcnJheVByb3RvdHlwZSUnOiBBcnJheS5wcm90b3R5cGUsXG5cdCckICVBcnJheVByb3RvX2VudHJpZXMlJzogQXJyYXkucHJvdG90eXBlLmVudHJpZXMsXG5cdCckICVBcnJheVByb3RvX2ZvckVhY2glJzogQXJyYXkucHJvdG90eXBlLmZvckVhY2gsXG5cdCckICVBcnJheVByb3RvX2tleXMlJzogQXJyYXkucHJvdG90eXBlLmtleXMsXG5cdCckICVBcnJheVByb3RvX3ZhbHVlcyUnOiBBcnJheS5wcm90b3R5cGUudmFsdWVzLFxuXHQnJCAlQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyQgJUFzeW5jRnVuY3Rpb24lJzogYXN5bmNGdW5jdGlvbixcblx0JyQgJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogYXN5bmNGdW5jdGlvbiA/IGFzeW5jRnVuY3Rpb24ucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuXHQnJCAlQXN5bmNHZW5lcmF0b3IlJzogYXN5bmNHZW4gPyBnZXRQcm90byhhc3luY0dlbkl0ZXJhdG9yKSA6IHVuZGVmaW5lZCxcblx0JyQgJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogYXN5bmNHZW5GdW5jdGlvbixcblx0JyQgJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IGFzeW5jR2VuRnVuY3Rpb24gPyBhc3luY0dlbkZ1bmN0aW9uLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcblx0JyQgJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogYXN5bmNHZW5JdGVyYXRvciAmJiBoYXNTeW1ib2xzICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yID8gYXN5bmNHZW5JdGVyYXRvcltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSA6IHVuZGVmaW5lZCxcblx0JyQgJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyQgJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyQgJUJvb2xlYW5Qcm90b3R5cGUlJzogQm9vbGVhbi5wcm90b3R5cGUsXG5cdCckICVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCckICVEYXRhVmlld1Byb3RvdHlwZSUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcucHJvdG90eXBlLFxuXHQnJCAlRGF0ZSUnOiBEYXRlLFxuXHQnJCAlRGF0ZVByb3RvdHlwZSUnOiBEYXRlLnByb3RvdHlwZSxcblx0JyQgJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCckICVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJCAlZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyQgJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCckICVFcnJvciUnOiBFcnJvcixcblx0JyQgJUVycm9yUHJvdG90eXBlJSc6IEVycm9yLnByb3RvdHlwZSxcblx0JyQgJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCckICVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxuXHQnJCAlRXZhbEVycm9yUHJvdG90eXBlJSc6IEV2YWxFcnJvci5wcm90b3R5cGUsXG5cdCckICVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCckICVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXkucHJvdG90eXBlLFxuXHQnJCAlRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJCAlRmxvYXQ2NEFycmF5UHJvdG90eXBlJSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LnByb3RvdHlwZSxcblx0JyQgJUZ1bmN0aW9uJSc6IEZ1bmN0aW9uLFxuXHQnJCAlRnVuY3Rpb25Qcm90b3R5cGUlJzogRnVuY3Rpb24ucHJvdG90eXBlLFxuXHQnJCAlR2VuZXJhdG9yJSc6IGdlbmVyYXRvciA/IGdldFByb3RvKGdlbmVyYXRvcigpKSA6IHVuZGVmaW5lZCxcblx0JyQgJUdlbmVyYXRvckZ1bmN0aW9uJSc6IGdlbmVyYXRvckZ1bmN0aW9uLFxuXHQnJCAlR2VuZXJhdG9yUHJvdG90eXBlJSc6IGdlbmVyYXRvckZ1bmN0aW9uID8gZ2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuXHQnJCAlSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJCAlSW50OEFycmF5UHJvdG90eXBlJSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LnByb3RvdHlwZSxcblx0JyQgJUludDE2QXJyYXklJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MTZBcnJheSxcblx0JyQgJUludDE2QXJyYXlQcm90b3R5cGUlJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LnByb3RvdHlwZSxcblx0JyQgJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyQgJUludDMyQXJyYXlQcm90b3R5cGUlJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheS5wcm90b3R5cGUsXG5cdCckICVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyQgJWlzTmFOJSc6IGlzTmFOLFxuXHQnJCAlSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpIDogdW5kZWZpbmVkLFxuXHQnJCAlSlNPTiUnOiBKU09OLFxuXHQnJCAlSlNPTlBhcnNlJSc6IEpTT04ucGFyc2UsXG5cdCckICVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNYXAsXG5cdCckICVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJCAlTWFwUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLnByb3RvdHlwZSxcblx0JyQgJU1hdGglJzogTWF0aCxcblx0JyQgJU51bWJlciUnOiBOdW1iZXIsXG5cdCckICVOdW1iZXJQcm90b3R5cGUlJzogTnVtYmVyLnByb3RvdHlwZSxcblx0JyQgJU9iamVjdCUnOiBPYmplY3QsXG5cdCckICVPYmplY3RQcm90b3R5cGUlJzogT2JqZWN0LnByb3RvdHlwZSxcblx0JyQgJU9ialByb3RvX3RvU3RyaW5nJSc6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdCckICVPYmpQcm90b192YWx1ZU9mJSc6IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZixcblx0JyQgJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyQgJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJCAlUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuXHQnJCAlUHJvbWlzZVByb3RvdHlwZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLnByb3RvdHlwZSxcblx0JyQgJVByb21pc2VQcm90b190aGVuJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UucHJvdG90eXBlLnRoZW4sXG5cdCckICVQcm9taXNlX2FsbCUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLmFsbCxcblx0JyQgJVByb21pc2VfcmVqZWN0JSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UucmVqZWN0LFxuXHQnJCAlUHJvbWlzZV9yZXNvbHZlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UucmVzb2x2ZSxcblx0JyQgJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcblx0JyQgJVJhbmdlRXJyb3IlJzogUmFuZ2VFcnJvcixcblx0JyQgJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogUmFuZ2VFcnJvci5wcm90b3R5cGUsXG5cdCckICVSZWZlcmVuY2VFcnJvciUnOiBSZWZlcmVuY2VFcnJvcixcblx0JyQgJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFJlZmVyZW5jZUVycm9yLnByb3RvdHlwZSxcblx0JyQgJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyQgJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCckICVSZWdFeHBQcm90b3R5cGUlJzogUmVnRXhwLnByb3RvdHlwZSxcblx0JyQgJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyQgJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IFNldCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCckICVTZXRQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQucHJvdG90eXBlLFxuXHQnJCAlU2hhcmVkQXJyYXlCdWZmZXIlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHQnJCAlU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLnByb3RvdHlwZSxcblx0JyQgJVN0cmluZyUnOiBTdHJpbmcsXG5cdCckICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyQgJVN0cmluZ1Byb3RvdHlwZSUnOiBTdHJpbmcucHJvdG90eXBlLFxuXHQnJCAlU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG5cdCckICVTeW1ib2xQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG5cdCckICVTeW50YXhFcnJvciUnOiBTeW50YXhFcnJvcixcblx0JyQgJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFN5bnRheEVycm9yLnByb3RvdHlwZSxcblx0JyQgJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuXHQnJCAlVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJCAlVHlwZWRBcnJheVByb3RvdHlwZSUnOiBUeXBlZEFycmF5ID8gVHlwZWRBcnJheS5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG5cdCckICVUeXBlRXJyb3IlJzogVHlwZUVycm9yLFxuXHQnJCAlVHlwZUVycm9yUHJvdG90eXBlJSc6IFR5cGVFcnJvci5wcm90b3R5cGUsXG5cdCckICVVaW50OEFycmF5JSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXksXG5cdCckICVVaW50OEFycmF5UHJvdG90eXBlJSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXkucHJvdG90eXBlLFxuXHQnJCAlVWludDhDbGFtcGVkQXJyYXklJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHQnJCAlVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LnByb3RvdHlwZSxcblx0JyQgJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcblx0JyQgJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheS5wcm90b3R5cGUsXG5cdCckICVVaW50MzJBcnJheSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXksXG5cdCckICVVaW50MzJBcnJheVByb3RvdHlwZSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXkucHJvdG90eXBlLFxuXHQnJCAlVVJJRXJyb3IlJzogVVJJRXJyb3IsXG5cdCckICVVUklFcnJvclByb3RvdHlwZSUnOiBVUklFcnJvci5wcm90b3R5cGUsXG5cdCckICVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCckICVXZWFrTWFwUHJvdG90eXBlJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAucHJvdG90eXBlLFxuXHQnJCAlV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0LFxuXHQnJCAlV2Vha1NldFByb3RvdHlwZSUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0LnByb3RvdHlwZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHR2YXIga2V5ID0gJyQgJyArIG5hbWU7XG5cdGlmICghKGtleSBpbiBJTlRSSU5TSUNTKSkge1xuXHRcdHRocm93IG5ldyBTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcblx0fVxuXG5cdC8vIGlzdGFuYnVsIGlnbm9yZSBpZiAvLyBob3BlZnVsbHkgdGhpcyBpcyBpbXBvc3NpYmxlIHRvIHRlc3QgOi0pXG5cdGlmICh0eXBlb2YgSU5UUklOU0lDU1trZXldID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0fVxuXHRyZXR1cm4gSU5UUklOU0lDU1trZXldO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4vR2V0SW50cmluc2ljJyk7XG5cbnZhciAkT2JqZWN0ID0gR2V0SW50cmluc2ljKCclT2JqZWN0JScpO1xudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG52YXIgJFN0cmluZyA9IEdldEludHJpbnNpYygnJVN0cmluZyUnKTtcblxudmFyICRpc05hTiA9IHJlcXVpcmUoJy4vaGVscGVycy9pc05hTicpO1xudmFyICRpc0Zpbml0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0Zpbml0ZScpO1xuXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vaGVscGVycy9zaWduJyk7XG52YXIgbW9kID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZCcpO1xuXG52YXIgSXNDYWxsYWJsZSA9IHJlcXVpcmUoJ2lzLWNhbGxhYmxlJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCdlcy10by1wcmltaXRpdmUvZXM1Jyk7XG5cbnZhciBoYXMgPSByZXF1aXJlKCdoYXMnKTtcblxuLy8gaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OVxudmFyIEVTNSA9IHtcblx0VG9QcmltaXRpdmU6IHRvUHJpbWl0aXZlLFxuXG5cdFRvQm9vbGVhbjogZnVuY3Rpb24gVG9Cb29sZWFuKHZhbHVlKSB7XG5cdFx0cmV0dXJuICEhdmFsdWU7XG5cdH0sXG5cdFRvTnVtYmVyOiBmdW5jdGlvbiBUb051bWJlcih2YWx1ZSkge1xuXHRcdHJldHVybiArdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW1wbGljaXQtY29lcmNpb25cblx0fSxcblx0VG9JbnRlZ2VyOiBmdW5jdGlvbiBUb0ludGVnZXIodmFsdWUpIHtcblx0XHR2YXIgbnVtYmVyID0gdGhpcy5Ub051bWJlcih2YWx1ZSk7XG5cdFx0aWYgKCRpc05hTihudW1iZXIpKSB7IHJldHVybiAwOyB9XG5cdFx0aWYgKG51bWJlciA9PT0gMCB8fCAhJGlzRmluaXRlKG51bWJlcikpIHsgcmV0dXJuIG51bWJlcjsgfVxuXHRcdHJldHVybiBzaWduKG51bWJlcikgKiBNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikpO1xuXHR9LFxuXHRUb0ludDMyOiBmdW5jdGlvbiBUb0ludDMyKHgpIHtcblx0XHRyZXR1cm4gdGhpcy5Ub051bWJlcih4KSA+PiAwO1xuXHR9LFxuXHRUb1VpbnQzMjogZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuXHRcdHJldHVybiB0aGlzLlRvTnVtYmVyKHgpID4+PiAwO1xuXHR9LFxuXHRUb1VpbnQxNjogZnVuY3Rpb24gVG9VaW50MTYodmFsdWUpIHtcblx0XHR2YXIgbnVtYmVyID0gdGhpcy5Ub051bWJlcih2YWx1ZSk7XG5cdFx0aWYgKCRpc05hTihudW1iZXIpIHx8IG51bWJlciA9PT0gMCB8fCAhJGlzRmluaXRlKG51bWJlcikpIHsgcmV0dXJuIDA7IH1cblx0XHR2YXIgcG9zSW50ID0gc2lnbihudW1iZXIpICogTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpKTtcblx0XHRyZXR1cm4gbW9kKHBvc0ludCwgMHgxMDAwMCk7XG5cdH0sXG5cdFRvU3RyaW5nOiBmdW5jdGlvbiBUb1N0cmluZyh2YWx1ZSkge1xuXHRcdHJldHVybiAkU3RyaW5nKHZhbHVlKTtcblx0fSxcblx0VG9PYmplY3Q6IGZ1bmN0aW9uIFRvT2JqZWN0KHZhbHVlKSB7XG5cdFx0dGhpcy5DaGVja09iamVjdENvZXJjaWJsZSh2YWx1ZSk7XG5cdFx0cmV0dXJuICRPYmplY3QodmFsdWUpO1xuXHR9LFxuXHRDaGVja09iamVjdENvZXJjaWJsZTogZnVuY3Rpb24gQ2hlY2tPYmplY3RDb2VyY2libGUodmFsdWUsIG9wdE1lc3NhZ2UpIHtcblx0XHQvKiBqc2hpbnQgZXFudWxsOnRydWUgKi9cblx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3Iob3B0TWVzc2FnZSB8fCAnQ2Fubm90IGNhbGwgbWV0aG9kIG9uICcgKyB2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0SXNDYWxsYWJsZTogSXNDYWxsYWJsZSxcblx0U2FtZVZhbHVlOiBmdW5jdGlvbiBTYW1lVmFsdWUoeCwgeSkge1xuXHRcdGlmICh4ID09PSB5KSB7IC8vIDAgPT09IC0wLCBidXQgdGhleSBhcmUgbm90IGlkZW50aWNhbC5cblx0XHRcdGlmICh4ID09PSAwKSB7IHJldHVybiAxIC8geCA9PT0gMSAvIHk7IH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gJGlzTmFOKHgpICYmICRpc05hTih5KTtcblx0fSxcblxuXHQvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLThcblx0VHlwZTogZnVuY3Rpb24gVHlwZSh4KSB7XG5cdFx0aWYgKHggPT09IG51bGwpIHtcblx0XHRcdHJldHVybiAnTnVsbCc7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiAnVW5kZWZpbmVkJztcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuICdPYmplY3QnO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG5cdFx0XHRyZXR1cm4gJ051bWJlcic7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgeCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRyZXR1cm4gJ0Jvb2xlYW4nO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gJ1N0cmluZyc7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1wcm9wZXJ0eS1kZXNjcmlwdG9yLXNwZWNpZmljYXRpb24tdHlwZVxuXHRJc1Byb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gSXNQcm9wZXJ0eURlc2NyaXB0b3IoRGVzYykge1xuXHRcdGlmICh0aGlzLlR5cGUoRGVzYykgIT09ICdPYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHZhciBhbGxvd2VkID0ge1xuXHRcdFx0J1tbQ29uZmlndXJhYmxlXV0nOiB0cnVlLFxuXHRcdFx0J1tbRW51bWVyYWJsZV1dJzogdHJ1ZSxcblx0XHRcdCdbW0dldF1dJzogdHJ1ZSxcblx0XHRcdCdbW1NldF1dJzogdHJ1ZSxcblx0XHRcdCdbW1ZhbHVlXV0nOiB0cnVlLFxuXHRcdFx0J1tbV3JpdGFibGVdXSc6IHRydWVcblx0XHR9O1xuXHRcdC8vIGpzY3M6ZGlzYWJsZVxuXHRcdGZvciAodmFyIGtleSBpbiBEZXNjKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0XHRcdGlmIChoYXMoRGVzYywga2V5KSAmJiAhYWxsb3dlZFtrZXldKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8ganNjczplbmFibGVcblx0XHR2YXIgaXNEYXRhID0gaGFzKERlc2MsICdbW1ZhbHVlXV0nKTtcblx0XHR2YXIgSXNBY2Nlc3NvciA9IGhhcyhEZXNjLCAnW1tHZXRdXScpIHx8IGhhcyhEZXNjLCAnW1tTZXRdXScpO1xuXHRcdGlmIChpc0RhdGEgJiYgSXNBY2Nlc3Nvcikge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1Byb3BlcnR5IERlc2NyaXB0b3JzIG1heSBub3QgYmUgYm90aCBhY2Nlc3NvciBhbmQgZGF0YSBkZXNjcmlwdG9ycycpO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOC4xMC4xXG5cdElzQWNjZXNzb3JEZXNjcmlwdG9yOiBmdW5jdGlvbiBJc0FjY2Vzc29yRGVzY3JpcHRvcihEZXNjKSB7XG5cdFx0aWYgKHR5cGVvZiBEZXNjID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5Jc1Byb3BlcnR5RGVzY3JpcHRvcihEZXNjKSkge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Rlc2MgbXVzdCBiZSBhIFByb3BlcnR5IERlc2NyaXB0b3InKTtcblx0XHR9XG5cblx0XHRpZiAoIWhhcyhEZXNjLCAnW1tHZXRdXScpICYmICFoYXMoRGVzYywgJ1tbU2V0XV0nKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy04LjEwLjJcblx0SXNEYXRhRGVzY3JpcHRvcjogZnVuY3Rpb24gSXNEYXRhRGVzY3JpcHRvcihEZXNjKSB7XG5cdFx0aWYgKHR5cGVvZiBEZXNjID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5Jc1Byb3BlcnR5RGVzY3JpcHRvcihEZXNjKSkge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Rlc2MgbXVzdCBiZSBhIFByb3BlcnR5IERlc2NyaXB0b3InKTtcblx0XHR9XG5cblx0XHRpZiAoIWhhcyhEZXNjLCAnW1tWYWx1ZV1dJykgJiYgIWhhcyhEZXNjLCAnW1tXcml0YWJsZV1dJykpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOC4xMC4zXG5cdElzR2VuZXJpY0Rlc2NyaXB0b3I6IGZ1bmN0aW9uIElzR2VuZXJpY0Rlc2NyaXB0b3IoRGVzYykge1xuXHRcdGlmICh0eXBlb2YgRGVzYyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuSXNQcm9wZXJ0eURlc2NyaXB0b3IoRGVzYykpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdEZXNjIG11c3QgYmUgYSBQcm9wZXJ0eSBEZXNjcmlwdG9yJyk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLklzQWNjZXNzb3JEZXNjcmlwdG9yKERlc2MpICYmICF0aGlzLklzRGF0YURlc2NyaXB0b3IoRGVzYykpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOC4xMC40XG5cdEZyb21Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIEZyb21Qcm9wZXJ0eURlc2NyaXB0b3IoRGVzYykge1xuXHRcdGlmICh0eXBlb2YgRGVzYyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBEZXNjO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5Jc1Byb3BlcnR5RGVzY3JpcHRvcihEZXNjKSkge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Rlc2MgbXVzdCBiZSBhIFByb3BlcnR5IERlc2NyaXB0b3InKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5Jc0RhdGFEZXNjcmlwdG9yKERlc2MpKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR2YWx1ZTogRGVzY1snW1tWYWx1ZV1dJ10sXG5cdFx0XHRcdHdyaXRhYmxlOiAhIURlc2NbJ1tbV3JpdGFibGVdXSddLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiAhIURlc2NbJ1tbRW51bWVyYWJsZV1dJ10sXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogISFEZXNjWydbW0NvbmZpZ3VyYWJsZV1dJ11cblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmICh0aGlzLklzQWNjZXNzb3JEZXNjcmlwdG9yKERlc2MpKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRnZXQ6IERlc2NbJ1tbR2V0XV0nXSxcblx0XHRcdFx0c2V0OiBEZXNjWydbW1NldF1dJ10sXG5cdFx0XHRcdGVudW1lcmFibGU6ICEhRGVzY1snW1tFbnVtZXJhYmxlXV0nXSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiAhIURlc2NbJ1tbQ29uZmlndXJhYmxlXV0nXVxuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Zyb21Qcm9wZXJ0eURlc2NyaXB0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIGZ1bGx5IHBvcHVsYXRlZCBQcm9wZXJ0eSBEZXNjcmlwdG9yJyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy04LjEwLjVcblx0VG9Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIFRvUHJvcGVydHlEZXNjcmlwdG9yKE9iaikge1xuXHRcdGlmICh0aGlzLlR5cGUoT2JqKSAhPT0gJ09iamVjdCcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdUb1Byb3BlcnR5RGVzY3JpcHRvciByZXF1aXJlcyBhbiBvYmplY3QnKTtcblx0XHR9XG5cblx0XHR2YXIgZGVzYyA9IHt9O1xuXHRcdGlmIChoYXMoT2JqLCAnZW51bWVyYWJsZScpKSB7XG5cdFx0XHRkZXNjWydbW0VudW1lcmFibGVdXSddID0gdGhpcy5Ub0Jvb2xlYW4oT2JqLmVudW1lcmFibGUpO1xuXHRcdH1cblx0XHRpZiAoaGFzKE9iaiwgJ2NvbmZpZ3VyYWJsZScpKSB7XG5cdFx0XHRkZXNjWydbW0NvbmZpZ3VyYWJsZV1dJ10gPSB0aGlzLlRvQm9vbGVhbihPYmouY29uZmlndXJhYmxlKTtcblx0XHR9XG5cdFx0aWYgKGhhcyhPYmosICd2YWx1ZScpKSB7XG5cdFx0XHRkZXNjWydbW1ZhbHVlXV0nXSA9IE9iai52YWx1ZTtcblx0XHR9XG5cdFx0aWYgKGhhcyhPYmosICd3cml0YWJsZScpKSB7XG5cdFx0XHRkZXNjWydbW1dyaXRhYmxlXV0nXSA9IHRoaXMuVG9Cb29sZWFuKE9iai53cml0YWJsZSk7XG5cdFx0fVxuXHRcdGlmIChoYXMoT2JqLCAnZ2V0JykpIHtcblx0XHRcdHZhciBnZXR0ZXIgPSBPYmouZ2V0O1xuXHRcdFx0aWYgKHR5cGVvZiBnZXR0ZXIgIT09ICd1bmRlZmluZWQnICYmICF0aGlzLklzQ2FsbGFibGUoZ2V0dGVyKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdnZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0XHR9XG5cdFx0XHRkZXNjWydbW0dldF1dJ10gPSBnZXR0ZXI7XG5cdFx0fVxuXHRcdGlmIChoYXMoT2JqLCAnc2V0JykpIHtcblx0XHRcdHZhciBzZXR0ZXIgPSBPYmouc2V0O1xuXHRcdFx0aWYgKHR5cGVvZiBzZXR0ZXIgIT09ICd1bmRlZmluZWQnICYmICF0aGlzLklzQ2FsbGFibGUoc2V0dGVyKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignc2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHRcdFx0fVxuXHRcdFx0ZGVzY1snW1tTZXRdXSddID0gc2V0dGVyO1xuXHRcdH1cblxuXHRcdGlmICgoaGFzKGRlc2MsICdbW0dldF1dJykgfHwgaGFzKGRlc2MsICdbW1NldF1dJykpICYmIChoYXMoZGVzYywgJ1tbVmFsdWVdXScpIHx8IGhhcyhkZXNjLCAnW1tXcml0YWJsZV1dJykpKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignSW52YWxpZCBwcm9wZXJ0eSBkZXNjcmlwdG9yLiBDYW5ub3QgYm90aCBzcGVjaWZ5IGFjY2Vzc29ycyBhbmQgYSB2YWx1ZSBvciB3cml0YWJsZSBhdHRyaWJ1dGUnKTtcblx0XHR9XG5cdFx0cmV0dXJuIGRlc2M7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRVM1O1xuIiwidmFyICRpc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSAhPT0gYTsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHR5cGVvZiB4ID09PSAnbnVtYmVyJyAmJiAhJGlzTmFOKHgpICYmIHggIT09IEluZmluaXR5ICYmIHggIT09IC1JbmZpbml0eTsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIGlzTmFOKGEpIHtcblx0cmV0dXJuIGEgIT09IGE7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtb2QobnVtYmVyLCBtb2R1bG8pIHtcblx0dmFyIHJlbWFpbiA9IG51bWJlciAlIG1vZHVsbztcblx0cmV0dXJuIE1hdGguZmxvb3IocmVtYWluID49IDAgPyByZW1haW4gOiByZW1haW4gKyBtb2R1bG8pO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2lnbihudW1iZXIpIHtcblx0cmV0dXJuIG51bWJlciA+PSAwID8gMSA6IC0xO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzUHJpbWl0aXZlJyk7XG5cbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnaXMtY2FsbGFibGUnKTtcblxuLy8gaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OC4xMlxudmFyIEVTNWludGVybmFsU2xvdHMgPSB7XG5cdCdbW0RlZmF1bHRWYWx1ZV1dJzogZnVuY3Rpb24gKE8sIGhpbnQpIHtcblx0XHR2YXIgYWN0dWFsSGludCA9IGhpbnQgfHwgKHRvU3RyLmNhbGwoTykgPT09ICdbb2JqZWN0IERhdGVdJyA/IFN0cmluZyA6IE51bWJlcik7XG5cblx0XHRpZiAoYWN0dWFsSGludCA9PT0gU3RyaW5nIHx8IGFjdHVhbEhpbnQgPT09IE51bWJlcikge1xuXHRcdFx0dmFyIG1ldGhvZHMgPSBhY3R1YWxIaW50ID09PSBTdHJpbmcgPyBbJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnXSA6IFsndmFsdWVPZicsICd0b1N0cmluZyddO1xuXHRcdFx0dmFyIHZhbHVlLCBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0aWYgKGlzQ2FsbGFibGUoT1ttZXRob2RzW2ldXSkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IE9bbWV0aG9kc1tpXV0oKTtcblx0XHRcdFx0XHRpZiAoaXNQcmltaXRpdmUodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBkZWZhdWx0IHZhbHVlJyk7XG5cdFx0fVxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgW1tEZWZhdWx0VmFsdWVdXSBoaW50IHN1cHBsaWVkJyk7XG5cdH1cbn07XG5cbi8vIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVG9QcmltaXRpdmUoaW5wdXQsIFByZWZlcnJlZFR5cGUpIHtcblx0aWYgKGlzUHJpbWl0aXZlKGlucHV0KSkge1xuXHRcdHJldHVybiBpbnB1dDtcblx0fVxuXHRyZXR1cm4gRVM1aW50ZXJuYWxTbG90c1snW1tEZWZhdWx0VmFsdWVdXSddKGlucHV0LCBQcmVmZXJyZWRUeXBlKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpO1xufTtcbiIsIi8qKlxuICogRXZFbWl0dGVyIHYxLjEuMFxuICogTGlsJyBldmVudCBlbWl0dGVyXG4gKiBNSVQgTGljZW5zZVxuICovXG5cbi8qIGpzaGludCB1bnVzZWQ6IHRydWUsIHVuZGVmOiB0cnVlLCBzdHJpY3Q6IHRydWUgKi9cblxuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLyogZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgd2luZG93ICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EIC0gUmVxdWlyZUpTXG4gICAgZGVmaW5lKCBmYWN0b3J5ICk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlMgLSBCcm93c2VyaWZ5LCBXZWJwYWNrXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZ2xvYmFsLkV2RW1pdHRlciA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KCB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBFdkVtaXR0ZXIoKSB7fVxuXG52YXIgcHJvdG8gPSBFdkVtaXR0ZXIucHJvdG90eXBlO1xuXG5wcm90by5vbiA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICBpZiAoICFldmVudE5hbWUgfHwgIWxpc3RlbmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBzZXQgZXZlbnRzIGhhc2hcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgLy8gc2V0IGxpc3RlbmVycyBhcnJheVxuICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzWyBldmVudE5hbWUgXSA9IGV2ZW50c1sgZXZlbnROYW1lIF0gfHwgW107XG4gIC8vIG9ubHkgYWRkIG9uY2VcbiAgaWYgKCBsaXN0ZW5lcnMuaW5kZXhPZiggbGlzdGVuZXIgKSA9PSAtMSApIHtcbiAgICBsaXN0ZW5lcnMucHVzaCggbGlzdGVuZXIgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ub25jZSA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICBpZiAoICFldmVudE5hbWUgfHwgIWxpc3RlbmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBhZGQgZXZlbnRcbiAgdGhpcy5vbiggZXZlbnROYW1lLCBsaXN0ZW5lciApO1xuICAvLyBzZXQgb25jZSBmbGFnXG4gIC8vIHNldCBvbmNlRXZlbnRzIGhhc2hcbiAgdmFyIG9uY2VFdmVudHMgPSB0aGlzLl9vbmNlRXZlbnRzID0gdGhpcy5fb25jZUV2ZW50cyB8fCB7fTtcbiAgLy8gc2V0IG9uY2VMaXN0ZW5lcnMgb2JqZWN0XG4gIHZhciBvbmNlTGlzdGVuZXJzID0gb25jZUV2ZW50c1sgZXZlbnROYW1lIF0gPSBvbmNlRXZlbnRzWyBldmVudE5hbWUgXSB8fCB7fTtcbiAgLy8gc2V0IGZsYWdcbiAgb25jZUxpc3RlbmVyc1sgbGlzdGVuZXIgXSA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5vZmYgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBsaXN0ZW5lciApIHtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbIGV2ZW50TmFtZSBdO1xuICBpZiAoICFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKCBsaXN0ZW5lciApO1xuICBpZiAoIGluZGV4ICE9IC0xICkge1xuICAgIGxpc3RlbmVycy5zcGxpY2UoIGluZGV4LCAxICk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmVtaXRFdmVudCA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGFyZ3MgKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzWyBldmVudE5hbWUgXTtcbiAgaWYgKCAhbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBjb3B5IG92ZXIgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIGlmIC5vZmYoKSBpbiBsaXN0ZW5lclxuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoMCk7XG4gIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAvLyBvbmNlIHN0dWZmXG4gIHZhciBvbmNlTGlzdGVuZXJzID0gdGhpcy5fb25jZUV2ZW50cyAmJiB0aGlzLl9vbmNlRXZlbnRzWyBldmVudE5hbWUgXTtcblxuICBmb3IgKCB2YXIgaT0wOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXVxuICAgIHZhciBpc09uY2UgPSBvbmNlTGlzdGVuZXJzICYmIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF07XG4gICAgaWYgKCBpc09uY2UgKSB7XG4gICAgICAvLyByZW1vdmUgbGlzdGVuZXJcbiAgICAgIC8vIHJlbW92ZSBiZWZvcmUgdHJpZ2dlciB0byBwcmV2ZW50IHJlY3Vyc2lvblxuICAgICAgdGhpcy5vZmYoIGV2ZW50TmFtZSwgbGlzdGVuZXIgKTtcbiAgICAgIC8vIHVuc2V0IG9uY2UgZmxhZ1xuICAgICAgZGVsZXRlIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF07XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgbGlzdGVuZXJcbiAgICBsaXN0ZW5lci5hcHBseSggdGhpcywgYXJncyApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5hbGxPZmYgPSBmdW5jdGlvbigpIHtcbiAgZGVsZXRlIHRoaXMuX2V2ZW50cztcbiAgZGVsZXRlIHRoaXMuX29uY2VFdmVudHM7XG59O1xuXG5yZXR1cm4gRXZFbWl0dGVyO1xuXG59KSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnaXMtY2FsbGFibGUnKTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmb3JFYWNoQXJyYXkgPSBmdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoU3RyaW5nID0gZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoT2JqZWN0ID0gZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAoIWlzQ2FsbGFibGUoaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciByZWNlaXZlcjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIHJlY2VpdmVyID0gdGhpc0FyZztcbiAgICB9XG5cbiAgICBpZiAodG9TdHIuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcbiIsIlxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKG9iaiwgZm4sIGN0eCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsID09PSArbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIiwiLyohXG4gKiBpbWFnZXNMb2FkZWQgdjQuMS40XG4gKiBKYXZhU2NyaXB0IGlzIGFsbCBsaWtlIFwiWW91IGltYWdlcyBhcmUgZG9uZSB5ZXQgb3Igd2hhdD9cIlxuICogTUlUIExpY2Vuc2VcbiAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7ICd1c2Ugc3RyaWN0JztcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG5cbiAgLypnbG9iYWwgZGVmaW5lOiBmYWxzZSwgbW9kdWxlOiBmYWxzZSwgcmVxdWlyZTogZmFsc2UgKi9cblxuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZSggW1xuICAgICAgJ2V2LWVtaXR0ZXIvZXYtZW1pdHRlcidcbiAgICBdLCBmdW5jdGlvbiggRXZFbWl0dGVyICkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgRXZFbWl0dGVyICk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICByZXF1aXJlKCdldi1lbWl0dGVyJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LmltYWdlc0xvYWRlZCA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICB3aW5kb3cuRXZFbWl0dGVyXG4gICAgKTtcbiAgfVxuXG59KSggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLFxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgZmFjdG9yeSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5mdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIEV2RW1pdHRlciApIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgJCA9IHdpbmRvdy5qUXVlcnk7XG52YXIgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBoZWxwZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8vIGV4dGVuZCBvYmplY3RzXG5mdW5jdGlvbiBleHRlbmQoIGEsIGIgKSB7XG4gIGZvciAoIHZhciBwcm9wIGluIGIgKSB7XG4gICAgYVsgcHJvcCBdID0gYlsgcHJvcCBdO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG52YXIgYXJyYXlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLy8gdHVybiBlbGVtZW50IG9yIG5vZGVMaXN0IGludG8gYW4gYXJyYXlcbmZ1bmN0aW9uIG1ha2VBcnJheSggb2JqICkge1xuICBpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuICAgIC8vIHVzZSBvYmplY3QgaWYgYWxyZWFkeSBhbiBhcnJheVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgaXNBcnJheUxpa2UgPSB0eXBlb2Ygb2JqID09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoubGVuZ3RoID09ICdudW1iZXInO1xuICBpZiAoIGlzQXJyYXlMaWtlICkge1xuICAgIC8vIGNvbnZlcnQgbm9kZUxpc3QgdG8gYXJyYXlcbiAgICByZXR1cm4gYXJyYXlTbGljZS5jYWxsKCBvYmogKTtcbiAgfVxuXG4gIC8vIGFycmF5IG9mIHNpbmdsZSBpbmRleFxuICByZXR1cm4gWyBvYmogXTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaW1hZ2VzTG9hZGVkIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheSwgRWxlbWVudCwgTm9kZUxpc3QsIFN0cmluZ30gZWxlbVxuICogQHBhcmFtIHtPYmplY3Qgb3IgRnVuY3Rpb259IG9wdGlvbnMgLSBpZiBmdW5jdGlvbiwgdXNlIGFzIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkFsd2F5cyAtIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIEltYWdlc0xvYWRlZCggZWxlbSwgb3B0aW9ucywgb25BbHdheXMgKSB7XG4gIC8vIGNvZXJjZSBJbWFnZXNMb2FkZWQoKSB3aXRob3V0IG5ldywgdG8gYmUgbmV3IEltYWdlc0xvYWRlZCgpXG4gIGlmICggISggdGhpcyBpbnN0YW5jZW9mIEltYWdlc0xvYWRlZCApICkge1xuICAgIHJldHVybiBuZXcgSW1hZ2VzTG9hZGVkKCBlbGVtLCBvcHRpb25zLCBvbkFsd2F5cyApO1xuICB9XG4gIC8vIHVzZSBlbGVtIGFzIHNlbGVjdG9yIHN0cmluZ1xuICB2YXIgcXVlcnlFbGVtID0gZWxlbTtcbiAgaWYgKCB0eXBlb2YgZWxlbSA9PSAnc3RyaW5nJyApIHtcbiAgICBxdWVyeUVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCBlbGVtICk7XG4gIH1cbiAgLy8gYmFpbCBpZiBiYWQgZWxlbWVudFxuICBpZiAoICFxdWVyeUVsZW0gKSB7XG4gICAgY29uc29sZS5lcnJvciggJ0JhZCBlbGVtZW50IGZvciBpbWFnZXNMb2FkZWQgJyArICggcXVlcnlFbGVtIHx8IGVsZW0gKSApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZWxlbWVudHMgPSBtYWtlQXJyYXkoIHF1ZXJ5RWxlbSApO1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoIHt9LCB0aGlzLm9wdGlvbnMgKTtcbiAgLy8gc2hpZnQgYXJndW1lbnRzIGlmIG5vIG9wdGlvbnMgc2V0XG4gIGlmICggdHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJyApIHtcbiAgICBvbkFsd2F5cyA9IG9wdGlvbnM7XG4gIH0gZWxzZSB7XG4gICAgZXh0ZW5kKCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMgKTtcbiAgfVxuXG4gIGlmICggb25BbHdheXMgKSB7XG4gICAgdGhpcy5vbiggJ2Fsd2F5cycsIG9uQWx3YXlzICk7XG4gIH1cblxuICB0aGlzLmdldEltYWdlcygpO1xuXG4gIGlmICggJCApIHtcbiAgICAvLyBhZGQgalF1ZXJ5IERlZmVycmVkIG9iamVjdFxuICAgIHRoaXMuanFEZWZlcnJlZCA9IG5ldyAkLkRlZmVycmVkKCk7XG4gIH1cblxuICAvLyBIQUNLIGNoZWNrIGFzeW5jIHRvIGFsbG93IHRpbWUgdG8gYmluZCBsaXN0ZW5lcnNcbiAgc2V0VGltZW91dCggdGhpcy5jaGVjay5iaW5kKCB0aGlzICkgKTtcbn1cblxuSW1hZ2VzTG9hZGVkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2RW1pdHRlci5wcm90b3R5cGUgKTtcblxuSW1hZ2VzTG9hZGVkLnByb3RvdHlwZS5vcHRpb25zID0ge307XG5cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUuZ2V0SW1hZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW1hZ2VzID0gW107XG5cbiAgLy8gZmlsdGVyICYgZmluZCBpdGVtcyBpZiB3ZSBoYXZlIGFuIGl0ZW0gc2VsZWN0b3JcbiAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKCB0aGlzLmFkZEVsZW1lbnRJbWFnZXMsIHRoaXMgKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBlbGVtZW50XG4gKi9cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUuYWRkRWxlbWVudEltYWdlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAvLyBmaWx0ZXIgc2libGluZ3NcbiAgaWYgKCBlbGVtLm5vZGVOYW1lID09ICdJTUcnICkge1xuICAgIHRoaXMuYWRkSW1hZ2UoIGVsZW0gKTtcbiAgfVxuICAvLyBnZXQgYmFja2dyb3VuZCBpbWFnZSBvbiBlbGVtZW50XG4gIGlmICggdGhpcy5vcHRpb25zLmJhY2tncm91bmQgPT09IHRydWUgKSB7XG4gICAgdGhpcy5hZGRFbGVtZW50QmFja2dyb3VuZEltYWdlcyggZWxlbSApO1xuICB9XG5cbiAgLy8gZmluZCBjaGlsZHJlblxuICAvLyBubyBub24tZWxlbWVudCBub2RlcywgIzE0M1xuICB2YXIgbm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuICBpZiAoICFub2RlVHlwZSB8fCAhZWxlbWVudE5vZGVUeXBlc1sgbm9kZVR5cGUgXSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNoaWxkSW1ncyA9IGVsZW0ucXVlcnlTZWxlY3RvckFsbCgnaW1nJyk7XG4gIC8vIGNvbmNhdCBjaGlsZEVsZW1zIHRvIGZpbHRlckZvdW5kIGFycmF5XG4gIGZvciAoIHZhciBpPTA7IGkgPCBjaGlsZEltZ3MubGVuZ3RoOyBpKysgKSB7XG4gICAgdmFyIGltZyA9IGNoaWxkSW1nc1tpXTtcbiAgICB0aGlzLmFkZEltYWdlKCBpbWcgKTtcbiAgfVxuXG4gIC8vIGdldCBjaGlsZCBiYWNrZ3JvdW5kIGltYWdlc1xuICBpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZCA9PSAnc3RyaW5nJyApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBlbGVtLnF1ZXJ5U2VsZWN0b3JBbGwoIHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kICk7XG4gICAgZm9yICggaT0wOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKysgKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHRoaXMuYWRkRWxlbWVudEJhY2tncm91bmRJbWFnZXMoIGNoaWxkICk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZWxlbWVudE5vZGVUeXBlcyA9IHtcbiAgMTogdHJ1ZSxcbiAgOTogdHJ1ZSxcbiAgMTE6IHRydWVcbn07XG5cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUuYWRkRWxlbWVudEJhY2tncm91bmRJbWFnZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuICBpZiAoICFzdHlsZSApIHtcbiAgICAvLyBGaXJlZm94IHJldHVybnMgbnVsbCBpZiBpbiBhIGhpZGRlbiBpZnJhbWUgaHR0cHM6Ly9idWd6aWwubGEvNTQ4Mzk3XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGdldCB1cmwgaW5zaWRlIHVybChcIi4uLlwiKVxuICB2YXIgcmVVUkwgPSAvdXJsXFwoKFsnXCJdKT8oLio/KVxcMVxcKS9naTtcbiAgdmFyIG1hdGNoZXMgPSByZVVSTC5leGVjKCBzdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgKTtcbiAgd2hpbGUgKCBtYXRjaGVzICE9PSBudWxsICkge1xuICAgIHZhciB1cmwgPSBtYXRjaGVzICYmIG1hdGNoZXNbMl07XG4gICAgaWYgKCB1cmwgKSB7XG4gICAgICB0aGlzLmFkZEJhY2tncm91bmQoIHVybCwgZWxlbSApO1xuICAgIH1cbiAgICBtYXRjaGVzID0gcmVVUkwuZXhlYyggc3R5bGUuYmFja2dyb3VuZEltYWdlICk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtJbWFnZX0gaW1nXG4gKi9cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUuYWRkSW1hZ2UgPSBmdW5jdGlvbiggaW1nICkge1xuICB2YXIgbG9hZGluZ0ltYWdlID0gbmV3IExvYWRpbmdJbWFnZSggaW1nICk7XG4gIHRoaXMuaW1hZ2VzLnB1c2goIGxvYWRpbmdJbWFnZSApO1xufTtcblxuSW1hZ2VzTG9hZGVkLnByb3RvdHlwZS5hZGRCYWNrZ3JvdW5kID0gZnVuY3Rpb24oIHVybCwgZWxlbSApIHtcbiAgdmFyIGJhY2tncm91bmQgPSBuZXcgQmFja2dyb3VuZCggdXJsLCBlbGVtICk7XG4gIHRoaXMuaW1hZ2VzLnB1c2goIGJhY2tncm91bmQgKTtcbn07XG5cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgdGhpcy5wcm9ncmVzc2VkQ291bnQgPSAwO1xuICB0aGlzLmhhc0FueUJyb2tlbiA9IGZhbHNlO1xuICAvLyBjb21wbGV0ZSBpZiBubyBpbWFnZXNcbiAgaWYgKCAhdGhpcy5pbWFnZXMubGVuZ3RoICkge1xuICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBmdW5jdGlvbiBvblByb2dyZXNzKCBpbWFnZSwgZWxlbSwgbWVzc2FnZSApIHtcbiAgICAvLyBIQUNLIC0gQ2hyb21lIHRyaWdnZXJzIGV2ZW50IGJlZm9yZSBvYmplY3QgcHJvcGVydGllcyBoYXZlIGNoYW5nZWQuICM4M1xuICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMucHJvZ3Jlc3MoIGltYWdlLCBlbGVtLCBtZXNzYWdlICk7XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLmltYWdlcy5mb3JFYWNoKCBmdW5jdGlvbiggbG9hZGluZ0ltYWdlICkge1xuICAgIGxvYWRpbmdJbWFnZS5vbmNlKCAncHJvZ3Jlc3MnLCBvblByb2dyZXNzICk7XG4gICAgbG9hZGluZ0ltYWdlLmNoZWNrKCk7XG4gIH0pO1xufTtcblxuSW1hZ2VzTG9hZGVkLnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uKCBpbWFnZSwgZWxlbSwgbWVzc2FnZSApIHtcbiAgdGhpcy5wcm9ncmVzc2VkQ291bnQrKztcbiAgdGhpcy5oYXNBbnlCcm9rZW4gPSB0aGlzLmhhc0FueUJyb2tlbiB8fCAhaW1hZ2UuaXNMb2FkZWQ7XG4gIC8vIHByb2dyZXNzIGV2ZW50XG4gIHRoaXMuZW1pdEV2ZW50KCAncHJvZ3Jlc3MnLCBbIHRoaXMsIGltYWdlLCBlbGVtIF0gKTtcbiAgaWYgKCB0aGlzLmpxRGVmZXJyZWQgJiYgdGhpcy5qcURlZmVycmVkLm5vdGlmeSApIHtcbiAgICB0aGlzLmpxRGVmZXJyZWQubm90aWZ5KCB0aGlzLCBpbWFnZSApO1xuICB9XG4gIC8vIGNoZWNrIGlmIGNvbXBsZXRlZFxuICBpZiAoIHRoaXMucHJvZ3Jlc3NlZENvdW50ID09IHRoaXMuaW1hZ2VzLmxlbmd0aCApIHtcbiAgICB0aGlzLmNvbXBsZXRlKCk7XG4gIH1cblxuICBpZiAoIHRoaXMub3B0aW9ucy5kZWJ1ZyAmJiBjb25zb2xlICkge1xuICAgIGNvbnNvbGUubG9nKCAncHJvZ3Jlc3M6ICcgKyBtZXNzYWdlLCBpbWFnZSwgZWxlbSApO1xuICB9XG59O1xuXG5JbWFnZXNMb2FkZWQucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBldmVudE5hbWUgPSB0aGlzLmhhc0FueUJyb2tlbiA/ICdmYWlsJyA6ICdkb25lJztcbiAgdGhpcy5pc0NvbXBsZXRlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0RXZlbnQoIGV2ZW50TmFtZSwgWyB0aGlzIF0gKTtcbiAgdGhpcy5lbWl0RXZlbnQoICdhbHdheXMnLCBbIHRoaXMgXSApO1xuICBpZiAoIHRoaXMuanFEZWZlcnJlZCApIHtcbiAgICB2YXIganFNZXRob2QgPSB0aGlzLmhhc0FueUJyb2tlbiA/ICdyZWplY3QnIDogJ3Jlc29sdmUnO1xuICAgIHRoaXMuanFEZWZlcnJlZFsganFNZXRob2QgXSggdGhpcyApO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuZnVuY3Rpb24gTG9hZGluZ0ltYWdlKCBpbWcgKSB7XG4gIHRoaXMuaW1nID0gaW1nO1xufVxuXG5Mb2FkaW5nSW1hZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZFbWl0dGVyLnByb3RvdHlwZSApO1xuXG5Mb2FkaW5nSW1hZ2UucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oKSB7XG4gIC8vIElmIGNvbXBsZXRlIGlzIHRydWUgYW5kIGJyb3dzZXIgc3VwcG9ydHMgbmF0dXJhbCBzaXplcyxcbiAgLy8gdHJ5IHRvIGNoZWNrIGZvciBpbWFnZSBzdGF0dXMgbWFudWFsbHkuXG4gIHZhciBpc0NvbXBsZXRlID0gdGhpcy5nZXRJc0ltYWdlQ29tcGxldGUoKTtcbiAgaWYgKCBpc0NvbXBsZXRlICkge1xuICAgIC8vIHJlcG9ydCBiYXNlZCBvbiBuYXR1cmFsV2lkdGhcbiAgICB0aGlzLmNvbmZpcm0oIHRoaXMuaW1nLm5hdHVyYWxXaWR0aCAhPT0gMCwgJ25hdHVyYWxXaWR0aCcgKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBub25lIG9mIHRoZSBjaGVja3MgYWJvdmUgbWF0Y2hlZCwgc2ltdWxhdGUgbG9hZGluZyBvbiBkZXRhY2hlZCBlbGVtZW50LlxuICB0aGlzLnByb3h5SW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgdGhpcy5wcm94eUltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgdGhpcyApO1xuICB0aGlzLnByb3h5SW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgdGhpcyApO1xuICAvLyBiaW5kIHRvIGltYWdlIGFzIHdlbGwgZm9yIEZpcmVmb3guICMxOTFcbiAgdGhpcy5pbWcuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCB0aGlzICk7XG4gIHRoaXMuaW1nLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIHRoaXMgKTtcbiAgdGhpcy5wcm94eUltYWdlLnNyYyA9IHRoaXMuaW1nLnNyYztcbn07XG5cbkxvYWRpbmdJbWFnZS5wcm90b3R5cGUuZ2V0SXNJbWFnZUNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIGNoZWNrIGZvciBub24temVybywgbm9uLXVuZGVmaW5lZCBuYXR1cmFsV2lkdGhcbiAgLy8gZml4ZXMgU2FmYXJpK0luZmluaXRlU2Nyb2xsK01hc29ucnkgYnVnIGluZmluaXRlLXNjcm9sbCM2NzFcbiAgcmV0dXJuIHRoaXMuaW1nLmNvbXBsZXRlICYmIHRoaXMuaW1nLm5hdHVyYWxXaWR0aDtcbn07XG5cbkxvYWRpbmdJbWFnZS5wcm90b3R5cGUuY29uZmlybSA9IGZ1bmN0aW9uKCBpc0xvYWRlZCwgbWVzc2FnZSApIHtcbiAgdGhpcy5pc0xvYWRlZCA9IGlzTG9hZGVkO1xuICB0aGlzLmVtaXRFdmVudCggJ3Byb2dyZXNzJywgWyB0aGlzLCB0aGlzLmltZywgbWVzc2FnZSBdICk7XG59O1xuXG4vLyAtLS0tLSBldmVudHMgLS0tLS0gLy9cblxuLy8gdHJpZ2dlciBzcGVjaWZpZWQgaGFuZGxlciBmb3IgZXZlbnQgdHlwZVxuTG9hZGluZ0ltYWdlLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdmFyIG1ldGhvZCA9ICdvbicgKyBldmVudC50eXBlO1xuICBpZiAoIHRoaXNbIG1ldGhvZCBdICkge1xuICAgIHRoaXNbIG1ldGhvZCBdKCBldmVudCApO1xuICB9XG59O1xuXG5Mb2FkaW5nSW1hZ2UucHJvdG90eXBlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvbmZpcm0oIHRydWUsICdvbmxvYWQnICk7XG4gIHRoaXMudW5iaW5kRXZlbnRzKCk7XG59O1xuXG5Mb2FkaW5nSW1hZ2UucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb25maXJtKCBmYWxzZSwgJ29uZXJyb3InICk7XG4gIHRoaXMudW5iaW5kRXZlbnRzKCk7XG59O1xuXG5Mb2FkaW5nSW1hZ2UucHJvdG90eXBlLnVuYmluZEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnByb3h5SW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCB0aGlzICk7XG4gIHRoaXMucHJveHlJbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZXJyb3InLCB0aGlzICk7XG4gIHRoaXMuaW1nLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdsb2FkJywgdGhpcyApO1xuICB0aGlzLmltZy5yZW1vdmVFdmVudExpc3RlbmVyKCAnZXJyb3InLCB0aGlzICk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBCYWNrZ3JvdW5kIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbmZ1bmN0aW9uIEJhY2tncm91bmQoIHVybCwgZWxlbWVudCApIHtcbiAgdGhpcy51cmwgPSB1cmw7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuaW1nID0gbmV3IEltYWdlKCk7XG59XG5cbi8vIGluaGVyaXQgTG9hZGluZ0ltYWdlIHByb3RvdHlwZVxuQmFja2dyb3VuZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMb2FkaW5nSW1hZ2UucHJvdG90eXBlICk7XG5cbkJhY2tncm91bmQucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW1nLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgdGhpcyApO1xuICB0aGlzLmltZy5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCB0aGlzICk7XG4gIHRoaXMuaW1nLnNyYyA9IHRoaXMudXJsO1xuICAvLyBjaGVjayBpZiBpbWFnZSBpcyBhbHJlYWR5IGNvbXBsZXRlXG4gIHZhciBpc0NvbXBsZXRlID0gdGhpcy5nZXRJc0ltYWdlQ29tcGxldGUoKTtcbiAgaWYgKCBpc0NvbXBsZXRlICkge1xuICAgIHRoaXMuY29uZmlybSggdGhpcy5pbWcubmF0dXJhbFdpZHRoICE9PSAwLCAnbmF0dXJhbFdpZHRoJyApO1xuICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gIH1cbn07XG5cbkJhY2tncm91bmQucHJvdG90eXBlLnVuYmluZEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmltZy5yZW1vdmVFdmVudExpc3RlbmVyKCAnbG9hZCcsIHRoaXMgKTtcbiAgdGhpcy5pbWcucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgdGhpcyApO1xufTtcblxuQmFja2dyb3VuZC5wcm90b3R5cGUuY29uZmlybSA9IGZ1bmN0aW9uKCBpc0xvYWRlZCwgbWVzc2FnZSApIHtcbiAgdGhpcy5pc0xvYWRlZCA9IGlzTG9hZGVkO1xuICB0aGlzLmVtaXRFdmVudCggJ3Byb2dyZXNzJywgWyB0aGlzLCB0aGlzLmVsZW1lbnQsIG1lc3NhZ2UgXSApO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0galF1ZXJ5IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbkltYWdlc0xvYWRlZC5tYWtlSlF1ZXJ5UGx1Z2luID0gZnVuY3Rpb24oIGpRdWVyeSApIHtcbiAgalF1ZXJ5ID0galF1ZXJ5IHx8IHdpbmRvdy5qUXVlcnk7XG4gIGlmICggIWpRdWVyeSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gc2V0IGxvY2FsIHZhcmlhYmxlXG4gICQgPSBqUXVlcnk7XG4gIC8vICQoKS5pbWFnZXNMb2FkZWQoKVxuICAkLmZuLmltYWdlc0xvYWRlZCA9IGZ1bmN0aW9uKCBvcHRpb25zLCBjYWxsYmFjayApIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgSW1hZ2VzTG9hZGVkKCB0aGlzLCBvcHRpb25zLCBjYWxsYmFjayApO1xuICAgIHJldHVybiBpbnN0YW5jZS5qcURlZmVycmVkLnByb21pc2UoICQodGhpcykgKTtcbiAgfTtcbn07XG4vLyB0cnkgbWFraW5nIHBsdWdpblxuSW1hZ2VzTG9hZGVkLm1ha2VKUXVlcnlQbHVnaW4oKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnJldHVybiBJbWFnZXNMb2FkZWQ7XG5cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxudmFyIGNvbnN0cnVjdG9yUmVnZXggPSAvXlxccypjbGFzcyAvO1xudmFyIGlzRVM2Q2xhc3NGbiA9IGZ1bmN0aW9uIGlzRVM2Q2xhc3NGbih2YWx1ZSkge1xuXHR0cnkge1xuXHRcdHZhciBmblN0ciA9IGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0dmFyIHNpbmdsZVN0cmlwcGVkID0gZm5TdHIucmVwbGFjZSgvXFwvXFwvLipcXG4vZywgJycpO1xuXHRcdHZhciBtdWx0aVN0cmlwcGVkID0gc2luZ2xlU3RyaXBwZWQucmVwbGFjZSgvXFwvXFwqWy5cXHNcXFNdKlxcKlxcLy9nLCAnJyk7XG5cdFx0dmFyIHNwYWNlU3RyaXBwZWQgPSBtdWx0aVN0cmlwcGVkLnJlcGxhY2UoL1xcbi9tZywgJyAnKS5yZXBsYWNlKC8gezJ9L2csICcgJyk7XG5cdFx0cmV0dXJuIGNvbnN0cnVjdG9yUmVnZXgudGVzdChzcGFjZVN0cmlwcGVkKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTsgLy8gbm90IGEgZnVuY3Rpb25cblx0fVxufTtcblxudmFyIHRyeUZ1bmN0aW9uT2JqZWN0ID0gZnVuY3Rpb24gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmbkNsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbnZhciBnZW5DbGFzcyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTsgfVxuXHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0dmFyIHN0ckNsYXNzID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdHJldHVybiBzdHJDbGFzcyA9PT0gZm5DbGFzcyB8fCBzdHJDbGFzcyA9PT0gZ2VuQ2xhc3M7XG59O1xuIiwiLyohXG4gKiBqUXVlcnkgRm9ybSBQbHVnaW5cbiAqIHZlcnNpb246IDQuMi4yXG4gKiBSZXF1aXJlcyBqUXVlcnkgdjEuNy4yIG9yIGxhdGVyXG4gKiBQcm9qZWN0IHJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnktZm9ybS9mb3JtXG5cbiAqIENvcHlyaWdodCAyMDE3IEtldmluIE1vcnJpc1xuICogQ29weXJpZ2h0IDIwMDYgTS4gQWxzdXBcblxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTEdQTC0yLjErIG9yIE1JVCBsaWNlbnNlc1xuICogaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS1mb3JtL2Zvcm0jbGljZW5zZVxuXG4gKiBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gKiBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gKiBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uOyBlaXRoZXJcbiAqIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAqIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbiFmdW5jdGlvbihlKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImpxdWVyeVwiXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbih0LHIpe3JldHVybiB2b2lkIDA9PT1yJiYocj1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93Pyh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk6KHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKSh0KSksZShyKSxyfTplKGpRdWVyeSl9KGZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHQodCl7dmFyIHI9dC5kYXRhO3QuaXNEZWZhdWx0UHJldmVudGVkKCl8fCh0LnByZXZlbnREZWZhdWx0KCksZSh0LnRhcmdldCkuY2xvc2VzdChcImZvcm1cIikuYWpheFN1Ym1pdChyKSl9ZnVuY3Rpb24gcih0KXt2YXIgcj10LnRhcmdldCxhPWUocik7aWYoIWEuaXMoXCJbdHlwZT1zdWJtaXRdLFt0eXBlPWltYWdlXVwiKSl7dmFyIG49YS5jbG9zZXN0KFwiW3R5cGU9c3VibWl0XVwiKTtpZigwPT09bi5sZW5ndGgpcmV0dXJuO3I9blswXX12YXIgaT1yLmZvcm07aWYoaS5jbGs9cixcImltYWdlXCI9PT1yLnR5cGUpaWYodm9pZCAwIT09dC5vZmZzZXRYKWkuY2xrX3g9dC5vZmZzZXRYLGkuY2xrX3k9dC5vZmZzZXRZO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5mbi5vZmZzZXQpe3ZhciBvPWEub2Zmc2V0KCk7aS5jbGtfeD10LnBhZ2VYLW8ubGVmdCxpLmNsa195PXQucGFnZVktby50b3B9ZWxzZSBpLmNsa194PXQucGFnZVgtci5vZmZzZXRMZWZ0LGkuY2xrX3k9dC5wYWdlWS1yLm9mZnNldFRvcDtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aS5jbGs9aS5jbGtfeD1pLmNsa195PW51bGx9LDEwMCl9ZnVuY3Rpb24gYSgpe2lmKGUuZm4uYWpheFN1Ym1pdC5kZWJ1Zyl7dmFyIHQ9XCJbanF1ZXJ5LmZvcm1dIFwiK0FycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoYXJndW1lbnRzLFwiXCIpO3dpbmRvdy5jb25zb2xlJiZ3aW5kb3cuY29uc29sZS5sb2c/d2luZG93LmNvbnNvbGUubG9nKHQpOndpbmRvdy5vcGVyYSYmd2luZG93Lm9wZXJhLnBvc3RFcnJvciYmd2luZG93Lm9wZXJhLnBvc3RFcnJvcih0KX19dmFyIG49L1xccj9cXG4vZyxpPXt9O2kuZmlsZWFwaT12b2lkIDAhPT1lKCc8aW5wdXQgdHlwZT1cImZpbGVcIj4nKS5nZXQoMCkuZmlsZXMsaS5mb3JtZGF0YT12b2lkIDAhPT13aW5kb3cuRm9ybURhdGE7dmFyIG89ISFlLmZuLnByb3A7ZS5mbi5hdHRyMj1mdW5jdGlvbigpe2lmKCFvKXJldHVybiB0aGlzLmF0dHIuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBlPXRoaXMucHJvcC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIGUmJmUuanF1ZXJ5fHxcInN0cmluZ1wiPT10eXBlb2YgZT9lOnRoaXMuYXR0ci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGUuZm4uYWpheFN1Ym1pdD1mdW5jdGlvbih0LHIsbixzKXtmdW5jdGlvbiB1KHIpe3ZhciBhLG4saT1lLnBhcmFtKHIsdC50cmFkaXRpb25hbCkuc3BsaXQoXCImXCIpLG89aS5sZW5ndGgscz1bXTtmb3IoYT0wO2E8bzthKyspaVthXT1pW2FdLnJlcGxhY2UoL1xcKy9nLFwiIFwiKSxuPWlbYV0uc3BsaXQoXCI9XCIpLHMucHVzaChbZGVjb2RlVVJJQ29tcG9uZW50KG5bMF0pLGRlY29kZVVSSUNvbXBvbmVudChuWzFdKV0pO3JldHVybiBzfWZ1bmN0aW9uIGMocil7ZnVuY3Rpb24gbihlKXt2YXIgdD1udWxsO3RyeXtlLmNvbnRlbnRXaW5kb3cmJih0PWUuY29udGVudFdpbmRvdy5kb2N1bWVudCl9Y2F0Y2goZSl7YShcImNhbm5vdCBnZXQgaWZyYW1lLmNvbnRlbnRXaW5kb3cgZG9jdW1lbnQ6IFwiK2UpfWlmKHQpcmV0dXJuIHQ7dHJ5e3Q9ZS5jb250ZW50RG9jdW1lbnQ/ZS5jb250ZW50RG9jdW1lbnQ6ZS5kb2N1bWVudH1jYXRjaChyKXthKFwiY2Fubm90IGdldCBpZnJhbWUuY29udGVudERvY3VtZW50OiBcIityKSx0PWUuZG9jdW1lbnR9cmV0dXJuIHR9ZnVuY3Rpb24gaSgpe2Z1bmN0aW9uIHQoKXt0cnl7dmFyIGU9bih2KS5yZWFkeVN0YXRlO2EoXCJzdGF0ZSA9IFwiK2UpLGUmJlwidW5pbml0aWFsaXplZFwiPT09ZS50b0xvd2VyQ2FzZSgpJiZzZXRUaW1lb3V0KHQsNTApfWNhdGNoKGUpe2EoXCJTZXJ2ZXIgYWJvcnQ6IFwiLGUsXCIgKFwiLGUubmFtZSxcIilcIikscyhMKSxqJiZjbGVhclRpbWVvdXQoaiksaj12b2lkIDB9fXZhciByPXAuYXR0cjIoXCJ0YXJnZXRcIiksaT1wLmF0dHIyKFwiYWN0aW9uXCIpLG89cC5hdHRyKFwiZW5jdHlwZVwiKXx8cC5hdHRyKFwiZW5jb2RpbmdcIil8fFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiO3cuc2V0QXR0cmlidXRlKFwidGFyZ2V0XCIsbSksbCYmIS9wb3N0L2kudGVzdChsKXx8dy5zZXRBdHRyaWJ1dGUoXCJtZXRob2RcIixcIlBPU1RcIiksaSE9PWYudXJsJiZ3LnNldEF0dHJpYnV0ZShcImFjdGlvblwiLGYudXJsKSxmLnNraXBFbmNvZGluZ092ZXJyaWRlfHxsJiYhL3Bvc3QvaS50ZXN0KGwpfHxwLmF0dHIoe2VuY29kaW5nOlwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLGVuY3R5cGU6XCJtdWx0aXBhcnQvZm9ybS1kYXRhXCJ9KSxmLnRpbWVvdXQmJihqPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtUPSEwLHMoQSl9LGYudGltZW91dCkpO3ZhciB1PVtdO3RyeXtpZihmLmV4dHJhRGF0YSlmb3IodmFyIGMgaW4gZi5leHRyYURhdGEpZi5leHRyYURhdGEuaGFzT3duUHJvcGVydHkoYykmJihlLmlzUGxhaW5PYmplY3QoZi5leHRyYURhdGFbY10pJiZmLmV4dHJhRGF0YVtjXS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJmYuZXh0cmFEYXRhW2NdLmhhc093blByb3BlcnR5KFwidmFsdWVcIik/dS5wdXNoKGUoJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cIicrZi5leHRyYURhdGFbY10ubmFtZSsnXCI+JyxrKS52YWwoZi5leHRyYURhdGFbY10udmFsdWUpLmFwcGVuZFRvKHcpWzBdKTp1LnB1c2goZSgnPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwiJytjKydcIj4nLGspLnZhbChmLmV4dHJhRGF0YVtjXSkuYXBwZW5kVG8odylbMF0pKTtmLmlmcmFtZVRhcmdldHx8aC5hcHBlbmRUbyhEKSx2LmF0dGFjaEV2ZW50P3YuYXR0YWNoRXZlbnQoXCJvbmxvYWRcIixzKTp2LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIscywhMSksc2V0VGltZW91dCh0LDE1KTt0cnl7dy5zdWJtaXQoKX1jYXRjaChlKXtkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKS5zdWJtaXQuYXBwbHkodyl9fWZpbmFsbHl7dy5zZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIixpKSx3LnNldEF0dHJpYnV0ZShcImVuY3R5cGVcIixvKSxyP3cuc2V0QXR0cmlidXRlKFwidGFyZ2V0XCIscik6cC5yZW1vdmVBdHRyKFwidGFyZ2V0XCIpLGUodSkucmVtb3ZlKCl9fWZ1bmN0aW9uIHModCl7aWYoIXguYWJvcnRlZCYmIVgpe2lmKChPPW4odikpfHwoYShcImNhbm5vdCBhY2Nlc3MgcmVzcG9uc2UgZG9jdW1lbnRcIiksdD1MKSx0PT09QSYmeClyZXR1cm4geC5hYm9ydChcInRpbWVvdXRcIiksdm9pZCBTLnJlamVjdCh4LFwidGltZW91dFwiKTtpZih0PT09TCYmeClyZXR1cm4geC5hYm9ydChcInNlcnZlciBhYm9ydFwiKSx2b2lkIFMucmVqZWN0KHgsXCJlcnJvclwiLFwic2VydmVyIGFib3J0XCIpO2lmKE8mJk8ubG9jYXRpb24uaHJlZiE9PWYuaWZyYW1lU3JjfHxUKXt2LmRldGFjaEV2ZW50P3YuZGV0YWNoRXZlbnQoXCJvbmxvYWRcIixzKTp2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIscywhMSk7dmFyIHIsaT1cInN1Y2Nlc3NcIjt0cnl7aWYoVCl0aHJvd1widGltZW91dFwiO3ZhciBvPVwieG1sXCI9PT1mLmRhdGFUeXBlfHxPLlhNTERvY3VtZW50fHxlLmlzWE1MRG9jKE8pO2lmKGEoXCJpc1htbD1cIitvKSwhbyYmd2luZG93Lm9wZXJhJiYobnVsbD09PU8uYm9keXx8IU8uYm9keS5pbm5lckhUTUwpJiYtLUMpcmV0dXJuIGEoXCJyZXF1ZWluZyBvbkxvYWQgY2FsbGJhY2ssIERPTSBub3QgYXZhaWxhYmxlXCIpLHZvaWQgc2V0VGltZW91dChzLDI1MCk7dmFyIHU9Ty5ib2R5P08uYm9keTpPLmRvY3VtZW50RWxlbWVudDt4LnJlc3BvbnNlVGV4dD11P3UuaW5uZXJIVE1MOm51bGwseC5yZXNwb25zZVhNTD1PLlhNTERvY3VtZW50P08uWE1MRG9jdW1lbnQ6TyxvJiYoZi5kYXRhVHlwZT1cInhtbFwiKSx4LmdldFJlc3BvbnNlSGVhZGVyPWZ1bmN0aW9uKGUpe3JldHVybntcImNvbnRlbnQtdHlwZVwiOmYuZGF0YVR5cGV9W2UudG9Mb3dlckNhc2UoKV19LHUmJih4LnN0YXR1cz1OdW1iZXIodS5nZXRBdHRyaWJ1dGUoXCJzdGF0dXNcIikpfHx4LnN0YXR1cyx4LnN0YXR1c1RleHQ9dS5nZXRBdHRyaWJ1dGUoXCJzdGF0dXNUZXh0XCIpfHx4LnN0YXR1c1RleHQpO3ZhciBjPShmLmRhdGFUeXBlfHxcIlwiKS50b0xvd2VyQ2FzZSgpLGw9Lyhqc29ufHNjcmlwdHx0ZXh0KS8udGVzdChjKTtpZihsfHxmLnRleHRhcmVhKXt2YXIgcD1PLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGV4dGFyZWFcIilbMF07aWYocCl4LnJlc3BvbnNlVGV4dD1wLnZhbHVlLHguc3RhdHVzPU51bWJlcihwLmdldEF0dHJpYnV0ZShcInN0YXR1c1wiKSl8fHguc3RhdHVzLHguc3RhdHVzVGV4dD1wLmdldEF0dHJpYnV0ZShcInN0YXR1c1RleHRcIil8fHguc3RhdHVzVGV4dDtlbHNlIGlmKGwpe3ZhciBtPU8uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwcmVcIilbMF0sZz1PLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTttP3gucmVzcG9uc2VUZXh0PW0udGV4dENvbnRlbnQ/bS50ZXh0Q29udGVudDptLmlubmVyVGV4dDpnJiYoeC5yZXNwb25zZVRleHQ9Zy50ZXh0Q29udGVudD9nLnRleHRDb250ZW50OmcuaW5uZXJUZXh0KX19ZWxzZVwieG1sXCI9PT1jJiYheC5yZXNwb25zZVhNTCYmeC5yZXNwb25zZVRleHQmJih4LnJlc3BvbnNlWE1MPXEoeC5yZXNwb25zZVRleHQpKTt0cnl7TT1OKHgsYyxmKX1jYXRjaChlKXtpPVwicGFyc2VyZXJyb3JcIix4LmVycm9yPXI9ZXx8aX19Y2F0Y2goZSl7YShcImVycm9yIGNhdWdodDogXCIsZSksaT1cImVycm9yXCIseC5lcnJvcj1yPWV8fGl9eC5hYm9ydGVkJiYoYShcInVwbG9hZCBhYm9ydGVkXCIpLGk9bnVsbCkseC5zdGF0dXMmJihpPXguc3RhdHVzPj0yMDAmJnguc3RhdHVzPDMwMHx8MzA0PT09eC5zdGF0dXM/XCJzdWNjZXNzXCI6XCJlcnJvclwiKSxcInN1Y2Nlc3NcIj09PWk/KGYuc3VjY2VzcyYmZi5zdWNjZXNzLmNhbGwoZi5jb250ZXh0LE0sXCJzdWNjZXNzXCIseCksUy5yZXNvbHZlKHgucmVzcG9uc2VUZXh0LFwic3VjY2Vzc1wiLHgpLGQmJmUuZXZlbnQudHJpZ2dlcihcImFqYXhTdWNjZXNzXCIsW3gsZl0pKTppJiYodm9pZCAwPT09ciYmKHI9eC5zdGF0dXNUZXh0KSxmLmVycm9yJiZmLmVycm9yLmNhbGwoZi5jb250ZXh0LHgsaSxyKSxTLnJlamVjdCh4LFwiZXJyb3JcIixyKSxkJiZlLmV2ZW50LnRyaWdnZXIoXCJhamF4RXJyb3JcIixbeCxmLHJdKSksZCYmZS5ldmVudC50cmlnZ2VyKFwiYWpheENvbXBsZXRlXCIsW3gsZl0pLGQmJiEtLWUuYWN0aXZlJiZlLmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKSxmLmNvbXBsZXRlJiZmLmNvbXBsZXRlLmNhbGwoZi5jb250ZXh0LHgsaSksWD0hMCxmLnRpbWVvdXQmJmNsZWFyVGltZW91dChqKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Zi5pZnJhbWVUYXJnZXQ/aC5hdHRyKFwic3JjXCIsZi5pZnJhbWVTcmMpOmgucmVtb3ZlKCkseC5yZXNwb25zZVhNTD1udWxsfSwxMDApfX19dmFyIHUsYyxmLGQsbSxoLHYseCx5LGIsVCxqLHc9cFswXSxTPWUuRGVmZXJyZWQoKTtpZihTLmFib3J0PWZ1bmN0aW9uKGUpe3guYWJvcnQoZSl9LHIpZm9yKGM9MDtjPGcubGVuZ3RoO2MrKyl1PWUoZ1tjXSksbz91LnByb3AoXCJkaXNhYmxlZFwiLCExKTp1LnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTsoZj1lLmV4dGVuZCghMCx7fSxlLmFqYXhTZXR0aW5ncyx0KSkuY29udGV4dD1mLmNvbnRleHR8fGYsbT1cImpxRm9ybUlPXCIrKG5ldyBEYXRlKS5nZXRUaW1lKCk7dmFyIGs9dy5vd25lckRvY3VtZW50LEQ9cC5jbG9zZXN0KFwiYm9keVwiKTtpZihmLmlmcmFtZVRhcmdldD8oYj0oaD1lKGYuaWZyYW1lVGFyZ2V0LGspKS5hdHRyMihcIm5hbWVcIikpP209YjpoLmF0dHIyKFwibmFtZVwiLG0pOihoPWUoJzxpZnJhbWUgbmFtZT1cIicrbSsnXCIgc3JjPVwiJytmLmlmcmFtZVNyYysnXCIgLz4nLGspKS5jc3Moe3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6XCItMTAwMHB4XCIsbGVmdDpcIi0xMDAwcHhcIn0pLHY9aFswXSx4PXthYm9ydGVkOjAscmVzcG9uc2VUZXh0Om51bGwscmVzcG9uc2VYTUw6bnVsbCxzdGF0dXM6MCxzdGF0dXNUZXh0Olwibi9hXCIsZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOmZ1bmN0aW9uKCl7fSxnZXRSZXNwb25zZUhlYWRlcjpmdW5jdGlvbigpe30sc2V0UmVxdWVzdEhlYWRlcjpmdW5jdGlvbigpe30sYWJvcnQ6ZnVuY3Rpb24odCl7dmFyIHI9XCJ0aW1lb3V0XCI9PT10P1widGltZW91dFwiOlwiYWJvcnRlZFwiO2EoXCJhYm9ydGluZyB1cGxvYWQuLi4gXCIrciksdGhpcy5hYm9ydGVkPTE7dHJ5e3YuY29udGVudFdpbmRvdy5kb2N1bWVudC5leGVjQ29tbWFuZCYmdi5jb250ZW50V2luZG93LmRvY3VtZW50LmV4ZWNDb21tYW5kKFwiU3RvcFwiKX1jYXRjaChlKXt9aC5hdHRyKFwic3JjXCIsZi5pZnJhbWVTcmMpLHguZXJyb3I9cixmLmVycm9yJiZmLmVycm9yLmNhbGwoZi5jb250ZXh0LHgscix0KSxkJiZlLmV2ZW50LnRyaWdnZXIoXCJhamF4RXJyb3JcIixbeCxmLHJdKSxmLmNvbXBsZXRlJiZmLmNvbXBsZXRlLmNhbGwoZi5jb250ZXh0LHgscil9fSwoZD1mLmdsb2JhbCkmJjA9PWUuYWN0aXZlKysmJmUuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKSxkJiZlLmV2ZW50LnRyaWdnZXIoXCJhamF4U2VuZFwiLFt4LGZdKSxmLmJlZm9yZVNlbmQmJiExPT09Zi5iZWZvcmVTZW5kLmNhbGwoZi5jb250ZXh0LHgsZikpcmV0dXJuIGYuZ2xvYmFsJiZlLmFjdGl2ZS0tLFMucmVqZWN0KCksUztpZih4LmFib3J0ZWQpcmV0dXJuIFMucmVqZWN0KCksUzsoeT13LmNsaykmJihiPXkubmFtZSkmJiF5LmRpc2FibGVkJiYoZi5leHRyYURhdGE9Zi5leHRyYURhdGF8fHt9LGYuZXh0cmFEYXRhW2JdPXkudmFsdWUsXCJpbWFnZVwiPT09eS50eXBlJiYoZi5leHRyYURhdGFbYitcIi54XCJdPXcuY2xrX3gsZi5leHRyYURhdGFbYitcIi55XCJdPXcuY2xrX3kpKTt2YXIgQT0xLEw9MixGPWUoXCJtZXRhW25hbWU9Y3NyZi10b2tlbl1cIikuYXR0cihcImNvbnRlbnRcIiksRT1lKFwibWV0YVtuYW1lPWNzcmYtcGFyYW1dXCIpLmF0dHIoXCJjb250ZW50XCIpO0UmJkYmJihmLmV4dHJhRGF0YT1mLmV4dHJhRGF0YXx8e30sZi5leHRyYURhdGFbRV09RiksZi5mb3JjZVN5bmM/aSgpOnNldFRpbWVvdXQoaSwxMCk7dmFyIE0sTyxYLEM9NTAscT1lLnBhcnNlWE1MfHxmdW5jdGlvbihlLHQpe3JldHVybiB3aW5kb3cuQWN0aXZlWE9iamVjdD8oKHQ9bmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpKS5hc3luYz1cImZhbHNlXCIsdC5sb2FkWE1MKGUpKTp0PShuZXcgRE9NUGFyc2VyKS5wYXJzZUZyb21TdHJpbmcoZSxcInRleHQveG1sXCIpLHQmJnQuZG9jdW1lbnRFbGVtZW50JiZcInBhcnNlcmVycm9yXCIhPT10LmRvY3VtZW50RWxlbWVudC5ub2RlTmFtZT90Om51bGx9LF89ZS5wYXJzZUpTT058fGZ1bmN0aW9uKGUpe3JldHVybiB3aW5kb3cuZXZhbChcIihcIitlK1wiKVwiKX0sTj1mdW5jdGlvbih0LHIsYSl7dmFyIG49dC5nZXRSZXNwb25zZUhlYWRlcihcImNvbnRlbnQtdHlwZVwiKXx8XCJcIixpPShcInhtbFwiPT09cnx8IXIpJiZuLmluZGV4T2YoXCJ4bWxcIik+PTAsbz1pP3QucmVzcG9uc2VYTUw6dC5yZXNwb25zZVRleHQ7cmV0dXJuIGkmJlwicGFyc2VyZXJyb3JcIj09PW8uZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lJiZlLmVycm9yJiZlLmVycm9yKFwicGFyc2VyZXJyb3JcIiksYSYmYS5kYXRhRmlsdGVyJiYobz1hLmRhdGFGaWx0ZXIobyxyKSksXCJzdHJpbmdcIj09dHlwZW9mIG8mJigoXCJqc29uXCI9PT1yfHwhcikmJm4uaW5kZXhPZihcImpzb25cIik+PTA/bz1fKG8pOihcInNjcmlwdFwiPT09cnx8IXIpJiZuLmluZGV4T2YoXCJqYXZhc2NyaXB0XCIpPj0wJiZlLmdsb2JhbEV2YWwobykpLG99O3JldHVybiBTfWlmKCF0aGlzLmxlbmd0aClyZXR1cm4gYShcImFqYXhTdWJtaXQ6IHNraXBwaW5nIHN1Ym1pdCBwcm9jZXNzIC0gbm8gZWxlbWVudCBzZWxlY3RlZFwiKSx0aGlzO3ZhciBsLGYsZCxwPXRoaXM7XCJmdW5jdGlvblwiPT10eXBlb2YgdD90PXtzdWNjZXNzOnR9Olwic3RyaW5nXCI9PXR5cGVvZiB0fHwhMT09PXQmJmFyZ3VtZW50cy5sZW5ndGg+MD8odD17dXJsOnQsZGF0YTpyLGRhdGFUeXBlOm59LFwiZnVuY3Rpb25cIj09dHlwZW9mIHMmJih0LnN1Y2Nlc3M9cykpOnZvaWQgMD09PXQmJih0PXt9KSxsPXQubWV0aG9kfHx0LnR5cGV8fHRoaXMuYXR0cjIoXCJtZXRob2RcIiksKGQ9KGQ9XCJzdHJpbmdcIj09dHlwZW9mKGY9dC51cmx8fHRoaXMuYXR0cjIoXCJhY3Rpb25cIikpP2UudHJpbShmKTpcIlwiKXx8d2luZG93LmxvY2F0aW9uLmhyZWZ8fFwiXCIpJiYoZD0oZC5tYXRjaCgvXihbXiNdKykvKXx8W10pWzFdKSx0PWUuZXh0ZW5kKCEwLHt1cmw6ZCxzdWNjZXNzOmUuYWpheFNldHRpbmdzLnN1Y2Nlc3MsdHlwZTpsfHxlLmFqYXhTZXR0aW5ncy50eXBlLGlmcmFtZVNyYzovXmh0dHBzL2kudGVzdCh3aW5kb3cubG9jYXRpb24uaHJlZnx8XCJcIik/XCJqYXZhc2NyaXB0OmZhbHNlXCI6XCJhYm91dDpibGFua1wifSx0KTt2YXIgbT17fTtpZih0aGlzLnRyaWdnZXIoXCJmb3JtLXByZS1zZXJpYWxpemVcIixbdGhpcyx0LG1dKSxtLnZldG8pcmV0dXJuIGEoXCJhamF4U3VibWl0OiBzdWJtaXQgdmV0b2VkIHZpYSBmb3JtLXByZS1zZXJpYWxpemUgdHJpZ2dlclwiKSx0aGlzO2lmKHQuYmVmb3JlU2VyaWFsaXplJiYhMT09PXQuYmVmb3JlU2VyaWFsaXplKHRoaXMsdCkpcmV0dXJuIGEoXCJhamF4U3VibWl0OiBzdWJtaXQgYWJvcnRlZCB2aWEgYmVmb3JlU2VyaWFsaXplIGNhbGxiYWNrXCIpLHRoaXM7dmFyIGg9dC50cmFkaXRpb25hbDt2b2lkIDA9PT1oJiYoaD1lLmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbCk7dmFyIHYsZz1bXSx4PXRoaXMuZm9ybVRvQXJyYXkodC5zZW1hbnRpYyxnLHQuZmlsdGVyaW5nKTtpZih0LmRhdGEpe3ZhciB5PWUuaXNGdW5jdGlvbih0LmRhdGEpP3QuZGF0YSh4KTp0LmRhdGE7dC5leHRyYURhdGE9eSx2PWUucGFyYW0oeSxoKX1pZih0LmJlZm9yZVN1Ym1pdCYmITE9PT10LmJlZm9yZVN1Ym1pdCh4LHRoaXMsdCkpcmV0dXJuIGEoXCJhamF4U3VibWl0OiBzdWJtaXQgYWJvcnRlZCB2aWEgYmVmb3JlU3VibWl0IGNhbGxiYWNrXCIpLHRoaXM7aWYodGhpcy50cmlnZ2VyKFwiZm9ybS1zdWJtaXQtdmFsaWRhdGVcIixbeCx0aGlzLHQsbV0pLG0udmV0bylyZXR1cm4gYShcImFqYXhTdWJtaXQ6IHN1Ym1pdCB2ZXRvZWQgdmlhIGZvcm0tc3VibWl0LXZhbGlkYXRlIHRyaWdnZXJcIiksdGhpczt2YXIgYj1lLnBhcmFtKHgsaCk7diYmKGI9Yj9iK1wiJlwiK3Y6diksXCJHRVRcIj09PXQudHlwZS50b1VwcGVyQ2FzZSgpPyh0LnVybCs9KHQudXJsLmluZGV4T2YoXCI/XCIpPj0wP1wiJlwiOlwiP1wiKStiLHQuZGF0YT1udWxsKTp0LmRhdGE9Yjt2YXIgVD1bXTtpZih0LnJlc2V0Rm9ybSYmVC5wdXNoKGZ1bmN0aW9uKCl7cC5yZXNldEZvcm0oKX0pLHQuY2xlYXJGb3JtJiZULnB1c2goZnVuY3Rpb24oKXtwLmNsZWFyRm9ybSh0LmluY2x1ZGVIaWRkZW4pfSksIXQuZGF0YVR5cGUmJnQudGFyZ2V0KXt2YXIgaj10LnN1Y2Nlc3N8fGZ1bmN0aW9uKCl7fTtULnB1c2goZnVuY3Rpb24ocixhLG4pe3ZhciBpPWFyZ3VtZW50cyxvPXQucmVwbGFjZVRhcmdldD9cInJlcGxhY2VXaXRoXCI6XCJodG1sXCI7ZSh0LnRhcmdldClbb10ocikuZWFjaChmdW5jdGlvbigpe2ouYXBwbHkodGhpcyxpKX0pfSl9ZWxzZSB0LnN1Y2Nlc3MmJihlLmlzQXJyYXkodC5zdWNjZXNzKT9lLm1lcmdlKFQsdC5zdWNjZXNzKTpULnB1c2godC5zdWNjZXNzKSk7aWYodC5zdWNjZXNzPWZ1bmN0aW9uKGUscixhKXtmb3IodmFyIG49dC5jb250ZXh0fHx0aGlzLGk9MCxvPVQubGVuZ3RoO2k8bztpKyspVFtpXS5hcHBseShuLFtlLHIsYXx8cCxwXSl9LHQuZXJyb3Ipe3ZhciB3PXQuZXJyb3I7dC5lcnJvcj1mdW5jdGlvbihlLHIsYSl7dmFyIG49dC5jb250ZXh0fHx0aGlzO3cuYXBwbHkobixbZSxyLGEscF0pfX1pZih0LmNvbXBsZXRlKXt2YXIgUz10LmNvbXBsZXRlO3QuY29tcGxldGU9ZnVuY3Rpb24oZSxyKXt2YXIgYT10LmNvbnRleHR8fHRoaXM7Uy5hcHBseShhLFtlLHIscF0pfX12YXIgaz1lKFwiaW5wdXRbdHlwZT1maWxlXTplbmFibGVkXCIsdGhpcykuZmlsdGVyKGZ1bmN0aW9uKCl7cmV0dXJuXCJcIiE9PWUodGhpcykudmFsKCl9KS5sZW5ndGg+MCxEPVwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLEE9cC5hdHRyKFwiZW5jdHlwZVwiKT09PUR8fHAuYXR0cihcImVuY29kaW5nXCIpPT09RCxMPWkuZmlsZWFwaSYmaS5mb3JtZGF0YTthKFwiZmlsZUFQSSA6XCIrTCk7dmFyIEYsRT0oa3x8QSkmJiFMOyExIT09dC5pZnJhbWUmJih0LmlmcmFtZXx8RSk/dC5jbG9zZUtlZXBBbGl2ZT9lLmdldCh0LmNsb3NlS2VlcEFsaXZlLGZ1bmN0aW9uKCl7Rj1jKHgpfSk6Rj1jKHgpOkY9KGt8fEEpJiZMP2Z1bmN0aW9uKHIpe2Zvcih2YXIgYT1uZXcgRm9ybURhdGEsbj0wO248ci5sZW5ndGg7bisrKWEuYXBwZW5kKHJbbl0ubmFtZSxyW25dLnZhbHVlKTtpZih0LmV4dHJhRGF0YSl7dmFyIGk9dSh0LmV4dHJhRGF0YSk7Zm9yKG49MDtuPGkubGVuZ3RoO24rKylpW25dJiZhLmFwcGVuZChpW25dWzBdLGlbbl1bMV0pfXQuZGF0YT1udWxsO3ZhciBvPWUuZXh0ZW5kKCEwLHt9LGUuYWpheFNldHRpbmdzLHQse2NvbnRlbnRUeXBlOiExLHByb2Nlc3NEYXRhOiExLGNhY2hlOiExLHR5cGU6bHx8XCJQT1NUXCJ9KTt0LnVwbG9hZFByb2dyZXNzJiYoby54aHI9ZnVuY3Rpb24oKXt2YXIgcj1lLmFqYXhTZXR0aW5ncy54aHIoKTtyZXR1cm4gci51cGxvYWQmJnIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLGZ1bmN0aW9uKGUpe3ZhciByPTAsYT1lLmxvYWRlZHx8ZS5wb3NpdGlvbixuPWUudG90YWw7ZS5sZW5ndGhDb21wdXRhYmxlJiYocj1NYXRoLmNlaWwoYS9uKjEwMCkpLHQudXBsb2FkUHJvZ3Jlc3MoZSxhLG4scil9LCExKSxyfSksby5kYXRhPW51bGw7dmFyIHM9by5iZWZvcmVTZW5kO3JldHVybiBvLmJlZm9yZVNlbmQ9ZnVuY3Rpb24oZSxyKXt0LmZvcm1EYXRhP3IuZGF0YT10LmZvcm1EYXRhOnIuZGF0YT1hLHMmJnMuY2FsbCh0aGlzLGUscil9LGUuYWpheChvKX0oeCk6ZS5hamF4KHQpLHAucmVtb3ZlRGF0YShcImpxeGhyXCIpLmRhdGEoXCJqcXhoclwiLEYpO2Zvcih2YXIgTT0wO008Zy5sZW5ndGg7TSsrKWdbTV09bnVsbDtyZXR1cm4gdGhpcy50cmlnZ2VyKFwiZm9ybS1zdWJtaXQtbm90aWZ5XCIsW3RoaXMsdF0pLHRoaXN9LGUuZm4uYWpheEZvcm09ZnVuY3Rpb24obixpLG8scyl7aWYoKFwic3RyaW5nXCI9PXR5cGVvZiBufHwhMT09PW4mJmFyZ3VtZW50cy5sZW5ndGg+MCkmJihuPXt1cmw6bixkYXRhOmksZGF0YVR5cGU6b30sXCJmdW5jdGlvblwiPT10eXBlb2YgcyYmKG4uc3VjY2Vzcz1zKSksbj1ufHx7fSxuLmRlbGVnYXRpb249bi5kZWxlZ2F0aW9uJiZlLmlzRnVuY3Rpb24oZS5mbi5vbiksIW4uZGVsZWdhdGlvbiYmMD09PXRoaXMubGVuZ3RoKXt2YXIgdT17czp0aGlzLnNlbGVjdG9yLGM6dGhpcy5jb250ZXh0fTtyZXR1cm4hZS5pc1JlYWR5JiZ1LnM/KGEoXCJET00gbm90IHJlYWR5LCBxdWV1aW5nIGFqYXhGb3JtXCIpLGUoZnVuY3Rpb24oKXtlKHUucyx1LmMpLmFqYXhGb3JtKG4pfSksdGhpcyk6KGEoXCJ0ZXJtaW5hdGluZzsgemVybyBlbGVtZW50cyBmb3VuZCBieSBzZWxlY3RvclwiKyhlLmlzUmVhZHk/XCJcIjpcIiAoRE9NIG5vdCByZWFkeSlcIikpLHRoaXMpfXJldHVybiBuLmRlbGVnYXRpb24/KGUoZG9jdW1lbnQpLm9mZihcInN1Ym1pdC5mb3JtLXBsdWdpblwiLHRoaXMuc2VsZWN0b3IsdCkub2ZmKFwiY2xpY2suZm9ybS1wbHVnaW5cIix0aGlzLnNlbGVjdG9yLHIpLm9uKFwic3VibWl0LmZvcm0tcGx1Z2luXCIsdGhpcy5zZWxlY3RvcixuLHQpLm9uKFwiY2xpY2suZm9ybS1wbHVnaW5cIix0aGlzLnNlbGVjdG9yLG4sciksdGhpcyk6dGhpcy5hamF4Rm9ybVVuYmluZCgpLm9uKFwic3VibWl0LmZvcm0tcGx1Z2luXCIsbix0KS5vbihcImNsaWNrLmZvcm0tcGx1Z2luXCIsbixyKX0sZS5mbi5hamF4Rm9ybVVuYmluZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm9mZihcInN1Ym1pdC5mb3JtLXBsdWdpbiBjbGljay5mb3JtLXBsdWdpblwiKX0sZS5mbi5mb3JtVG9BcnJheT1mdW5jdGlvbih0LHIsYSl7dmFyIG49W107aWYoMD09PXRoaXMubGVuZ3RoKXJldHVybiBuO3ZhciBvLHM9dGhpc1swXSx1PXRoaXMuYXR0cihcImlkXCIpLGM9dHx8dm9pZCAwPT09cy5lbGVtZW50cz9zLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKTpzLmVsZW1lbnRzO2lmKGMmJihjPWUubWFrZUFycmF5KGMpKSx1JiYodHx8LyhFZGdlfFRyaWRlbnQpXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSYmKG89ZSgnOmlucHV0W2Zvcm09XCInK3UrJ1wiXScpLmdldCgpKS5sZW5ndGgmJihjPShjfHxbXSkuY29uY2F0KG8pKSwhY3x8IWMubGVuZ3RoKXJldHVybiBuO2UuaXNGdW5jdGlvbihhKSYmKGM9ZS5tYXAoYyxhKSk7dmFyIGwsZixkLHAsbSxoLHY7Zm9yKGw9MCxoPWMubGVuZ3RoO2w8aDtsKyspaWYobT1jW2xdLChkPW0ubmFtZSkmJiFtLmRpc2FibGVkKWlmKHQmJnMuY2xrJiZcImltYWdlXCI9PT1tLnR5cGUpcy5jbGs9PT1tJiYobi5wdXNoKHtuYW1lOmQsdmFsdWU6ZShtKS52YWwoKSx0eXBlOm0udHlwZX0pLG4ucHVzaCh7bmFtZTpkK1wiLnhcIix2YWx1ZTpzLmNsa194fSx7bmFtZTpkK1wiLnlcIix2YWx1ZTpzLmNsa195fSkpO2Vsc2UgaWYoKHA9ZS5maWVsZFZhbHVlKG0sITApKSYmcC5jb25zdHJ1Y3Rvcj09PUFycmF5KWZvcihyJiZyLnB1c2gobSksZj0wLHY9cC5sZW5ndGg7Zjx2O2YrKyluLnB1c2goe25hbWU6ZCx2YWx1ZTpwW2ZdfSk7ZWxzZSBpZihpLmZpbGVhcGkmJlwiZmlsZVwiPT09bS50eXBlKXtyJiZyLnB1c2gobSk7dmFyIGc9bS5maWxlcztpZihnLmxlbmd0aClmb3IoZj0wO2Y8Zy5sZW5ndGg7ZisrKW4ucHVzaCh7bmFtZTpkLHZhbHVlOmdbZl0sdHlwZTptLnR5cGV9KTtlbHNlIG4ucHVzaCh7bmFtZTpkLHZhbHVlOlwiXCIsdHlwZTptLnR5cGV9KX1lbHNlIG51bGwhPT1wJiZ2b2lkIDAhPT1wJiYociYmci5wdXNoKG0pLG4ucHVzaCh7bmFtZTpkLHZhbHVlOnAsdHlwZTptLnR5cGUscmVxdWlyZWQ6bS5yZXF1aXJlZH0pKTtpZighdCYmcy5jbGspe3ZhciB4PWUocy5jbGspLHk9eFswXTsoZD15Lm5hbWUpJiYheS5kaXNhYmxlZCYmXCJpbWFnZVwiPT09eS50eXBlJiYobi5wdXNoKHtuYW1lOmQsdmFsdWU6eC52YWwoKX0pLG4ucHVzaCh7bmFtZTpkK1wiLnhcIix2YWx1ZTpzLmNsa194fSx7bmFtZTpkK1wiLnlcIix2YWx1ZTpzLmNsa195fSkpfXJldHVybiBufSxlLmZuLmZvcm1TZXJpYWxpemU9ZnVuY3Rpb24odCl7cmV0dXJuIGUucGFyYW0odGhpcy5mb3JtVG9BcnJheSh0KSl9LGUuZm4uZmllbGRTZXJpYWxpemU9ZnVuY3Rpb24odCl7dmFyIHI9W107cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBhPXRoaXMubmFtZTtpZihhKXt2YXIgbj1lLmZpZWxkVmFsdWUodGhpcyx0KTtpZihuJiZuLmNvbnN0cnVjdG9yPT09QXJyYXkpZm9yKHZhciBpPTAsbz1uLmxlbmd0aDtpPG87aSsrKXIucHVzaCh7bmFtZTphLHZhbHVlOm5baV19KTtlbHNlIG51bGwhPT1uJiZ2b2lkIDAhPT1uJiZyLnB1c2goe25hbWU6dGhpcy5uYW1lLHZhbHVlOm59KX19KSxlLnBhcmFtKHIpfSxlLmZuLmZpZWxkVmFsdWU9ZnVuY3Rpb24odCl7Zm9yKHZhciByPVtdLGE9MCxuPXRoaXMubGVuZ3RoO2E8bjthKyspe3ZhciBpPXRoaXNbYV0sbz1lLmZpZWxkVmFsdWUoaSx0KTtudWxsPT09b3x8dm9pZCAwPT09b3x8by5jb25zdHJ1Y3Rvcj09PUFycmF5JiYhby5sZW5ndGh8fChvLmNvbnN0cnVjdG9yPT09QXJyYXk/ZS5tZXJnZShyLG8pOnIucHVzaChvKSl9cmV0dXJuIHJ9LGUuZmllbGRWYWx1ZT1mdW5jdGlvbih0LHIpe3ZhciBhPXQubmFtZSxpPXQudHlwZSxvPXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO2lmKHZvaWQgMD09PXImJihyPSEwKSxyJiYoIWF8fHQuZGlzYWJsZWR8fFwicmVzZXRcIj09PWl8fFwiYnV0dG9uXCI9PT1pfHwoXCJjaGVja2JveFwiPT09aXx8XCJyYWRpb1wiPT09aSkmJiF0LmNoZWNrZWR8fChcInN1Ym1pdFwiPT09aXx8XCJpbWFnZVwiPT09aSkmJnQuZm9ybSYmdC5mb3JtLmNsayE9PXR8fFwic2VsZWN0XCI9PT1vJiYtMT09PXQuc2VsZWN0ZWRJbmRleCkpcmV0dXJuIG51bGw7aWYoXCJzZWxlY3RcIj09PW8pe3ZhciBzPXQuc2VsZWN0ZWRJbmRleDtpZihzPDApcmV0dXJuIG51bGw7Zm9yKHZhciB1PVtdLGM9dC5vcHRpb25zLGw9XCJzZWxlY3Qtb25lXCI9PT1pLGY9bD9zKzE6Yy5sZW5ndGgsZD1sP3M6MDtkPGY7ZCsrKXt2YXIgcD1jW2RdO2lmKHAuc2VsZWN0ZWQmJiFwLmRpc2FibGVkKXt2YXIgbT1wLnZhbHVlO2lmKG18fChtPXAuYXR0cmlidXRlcyYmcC5hdHRyaWJ1dGVzLnZhbHVlJiYhcC5hdHRyaWJ1dGVzLnZhbHVlLnNwZWNpZmllZD9wLnRleHQ6cC52YWx1ZSksbClyZXR1cm4gbTt1LnB1c2gobSl9fXJldHVybiB1fXJldHVybiBlKHQpLnZhbCgpLnJlcGxhY2UobixcIlxcclxcblwiKX0sZS5mbi5jbGVhckZvcm09ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe2UoXCJpbnB1dCxzZWxlY3QsdGV4dGFyZWFcIix0aGlzKS5jbGVhckZpZWxkcyh0KX0pfSxlLmZuLmNsZWFyRmllbGRzPWUuZm4uY2xlYXJJbnB1dHM9ZnVuY3Rpb24odCl7dmFyIHI9L14oPzpjb2xvcnxkYXRlfGRhdGV0aW1lfGVtYWlsfG1vbnRofG51bWJlcnxwYXNzd29yZHxyYW5nZXxzZWFyY2h8dGVsfHRleHR8dGltZXx1cmx8d2VlaykkL2k7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBhPXRoaXMudHlwZSxuPXRoaXMudGFnTmFtZS50b0xvd2VyQ2FzZSgpO3IudGVzdChhKXx8XCJ0ZXh0YXJlYVwiPT09bj90aGlzLnZhbHVlPVwiXCI6XCJjaGVja2JveFwiPT09YXx8XCJyYWRpb1wiPT09YT90aGlzLmNoZWNrZWQ9ITE6XCJzZWxlY3RcIj09PW4/dGhpcy5zZWxlY3RlZEluZGV4PS0xOlwiZmlsZVwiPT09YT8vTVNJRS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KT9lKHRoaXMpLnJlcGxhY2VXaXRoKGUodGhpcykuY2xvbmUoITApKTplKHRoaXMpLnZhbChcIlwiKTp0JiYoITA9PT10JiYvaGlkZGVuLy50ZXN0KGEpfHxcInN0cmluZ1wiPT10eXBlb2YgdCYmZSh0aGlzKS5pcyh0KSkmJih0aGlzLnZhbHVlPVwiXCIpfSl9LGUuZm4ucmVzZXRGb3JtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciB0PWUodGhpcykscj10aGlzLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtzd2l0Y2gocil7Y2FzZVwiaW5wdXRcIjp0aGlzLmNoZWNrZWQ9dGhpcy5kZWZhdWx0Q2hlY2tlZDtjYXNlXCJ0ZXh0YXJlYVwiOnJldHVybiB0aGlzLnZhbHVlPXRoaXMuZGVmYXVsdFZhbHVlLCEwO2Nhc2VcIm9wdGlvblwiOmNhc2VcIm9wdGdyb3VwXCI6dmFyIGE9dC5wYXJlbnRzKFwic2VsZWN0XCIpO3JldHVybiBhLmxlbmd0aCYmYVswXS5tdWx0aXBsZT9cIm9wdGlvblwiPT09cj90aGlzLnNlbGVjdGVkPXRoaXMuZGVmYXVsdFNlbGVjdGVkOnQuZmluZChcIm9wdGlvblwiKS5yZXNldEZvcm0oKTphLnJlc2V0Rm9ybSgpLCEwO2Nhc2VcInNlbGVjdFwiOnJldHVybiB0LmZpbmQoXCJvcHRpb25cIikuZWFjaChmdW5jdGlvbihlKXtpZih0aGlzLnNlbGVjdGVkPXRoaXMuZGVmYXVsdFNlbGVjdGVkLHRoaXMuZGVmYXVsdFNlbGVjdGVkJiYhdFswXS5tdWx0aXBsZSlyZXR1cm4gdFswXS5zZWxlY3RlZEluZGV4PWUsITF9KSwhMDtjYXNlXCJsYWJlbFwiOnZhciBuPWUodC5hdHRyKFwiZm9yXCIpKSxpPXQuZmluZChcImlucHV0LHNlbGVjdCx0ZXh0YXJlYVwiKTtyZXR1cm4gblswXSYmaS51bnNoaWZ0KG5bMF0pLGkucmVzZXRGb3JtKCksITA7Y2FzZVwiZm9ybVwiOnJldHVybihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLnJlc2V0fHxcIm9iamVjdFwiPT10eXBlb2YgdGhpcy5yZXNldCYmIXRoaXMucmVzZXQubm9kZVR5cGUpJiZ0aGlzLnJlc2V0KCksITA7ZGVmYXVsdDpyZXR1cm4gdC5maW5kKFwiZm9ybSxpbnB1dCxsYWJlbCxzZWxlY3QsdGV4dGFyZWFcIikucmVzZXRGb3JtKCksITB9fSl9LGUuZm4uZW5hYmxlPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMCksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dGhpcy5kaXNhYmxlZD0hZX0pfSxlLmZuLnNlbGVjdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0hMCksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHI9dGhpcy50eXBlO2lmKFwiY2hlY2tib3hcIj09PXJ8fFwicmFkaW9cIj09PXIpdGhpcy5jaGVja2VkPXQ7ZWxzZSBpZihcIm9wdGlvblwiPT09dGhpcy50YWdOYW1lLnRvTG93ZXJDYXNlKCkpe3ZhciBhPWUodGhpcykucGFyZW50KFwic2VsZWN0XCIpO3QmJmFbMF0mJlwic2VsZWN0LW9uZVwiPT09YVswXS50eXBlJiZhLmZpbmQoXCJvcHRpb25cIikuc2VsZWN0ZWQoITEpLHRoaXMuc2VsZWN0ZWQ9dH19KX0sZS5mbi5hamF4U3VibWl0LmRlYnVnPSExfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qcXVlcnkuZm9ybS5taW4uanMubWFwXG4iLCIvKipcbioganF1ZXJ5LW1hdGNoLWhlaWdodCAwLjcuMiBieSBAbGlhYnJ1XG4qIGh0dHA6Ly9icm0uaW8vanF1ZXJ5LW1hdGNoLWhlaWdodC9cbiogTGljZW5zZTogTUlUXG4qL1xuXG47KGZ1bmN0aW9uKGZhY3RvcnkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRyYS1zZW1pXG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1EXG4gICAgICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIC8vIENvbW1vbkpTXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHbG9iYWxcbiAgICAgICAgZmFjdG9yeShqUXVlcnkpO1xuICAgIH1cbn0pKGZ1bmN0aW9uKCQpIHtcbiAgICAvKlxuICAgICogIGludGVybmFsXG4gICAgKi9cblxuICAgIHZhciBfcHJldmlvdXNSZXNpemVXaWR0aCA9IC0xLFxuICAgICAgICBfdXBkYXRlVGltZW91dCA9IC0xO1xuXG4gICAgLypcbiAgICAqICBfcGFyc2VcbiAgICAqICB2YWx1ZSBwYXJzZSB1dGlsaXR5IGZ1bmN0aW9uXG4gICAgKi9cblxuICAgIHZhciBfcGFyc2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBwYXJzZSB2YWx1ZSBhbmQgY29udmVydCBOYU4gdG8gMFxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcbiAgICB9O1xuXG4gICAgLypcbiAgICAqICBfcm93c1xuICAgICogIHV0aWxpdHkgZnVuY3Rpb24gcmV0dXJucyBhcnJheSBvZiBqUXVlcnkgc2VsZWN0aW9ucyByZXByZXNlbnRpbmcgZWFjaCByb3dcbiAgICAqICAoYXMgZGlzcGxheWVkIGFmdGVyIGZsb2F0IHdyYXBwaW5nIGFwcGxpZWQgYnkgYnJvd3NlcilcbiAgICAqL1xuXG4gICAgdmFyIF9yb3dzID0gZnVuY3Rpb24oZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHRvbGVyYW5jZSA9IDEsXG4gICAgICAgICAgICAkZWxlbWVudHMgPSAkKGVsZW1lbnRzKSxcbiAgICAgICAgICAgIGxhc3RUb3AgPSBudWxsLFxuICAgICAgICAgICAgcm93cyA9IFtdO1xuXG4gICAgICAgIC8vIGdyb3VwIGVsZW1lbnRzIGJ5IHRoZWlyIHRvcCBwb3NpdGlvblxuICAgICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyICR0aGF0ID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgICB0b3AgPSAkdGhhdC5vZmZzZXQoKS50b3AgLSBfcGFyc2UoJHRoYXQuY3NzKCdtYXJnaW4tdG9wJykpLFxuICAgICAgICAgICAgICAgIGxhc3RSb3cgPSByb3dzLmxlbmd0aCA+IDAgPyByb3dzW3Jvd3MubGVuZ3RoIC0gMV0gOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAobGFzdFJvdyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGZpcnN0IGl0ZW0gb24gdGhlIHJvdywgc28ganVzdCBwdXNoIGl0XG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKCR0aGF0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHJvdyB0b3AgaXMgdGhlIHNhbWUsIGFkZCB0byB0aGUgcm93IGdyb3VwXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IoTWF0aC5hYnMobGFzdFRvcCAtIHRvcCkpIDw9IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICByb3dzW3Jvd3MubGVuZ3RoIC0gMV0gPSBsYXN0Um93LmFkZCgkdGhhdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHN0YXJ0IGEgbmV3IHJvdyBncm91cFxuICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2goJHRoYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgbGFzdCByb3cgdG9wXG4gICAgICAgICAgICBsYXN0VG9wID0gdG9wO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcm93cztcbiAgICB9O1xuXG4gICAgLypcbiAgICAqICBfcGFyc2VPcHRpb25zXG4gICAgKiAgaGFuZGxlIHBsdWdpbiBvcHRpb25zXG4gICAgKi9cblxuICAgIHZhciBfcGFyc2VPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIGJ5Um93OiB0cnVlLFxuICAgICAgICAgICAgcHJvcGVydHk6ICdoZWlnaHQnLFxuICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICAgICAgcmVtb3ZlOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiAkLmV4dGVuZChvcHRzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBvcHRzLmJ5Um93ID0gb3B0aW9ucztcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgb3B0cy5yZW1vdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKiAgbWF0Y2hIZWlnaHRcbiAgICAqICBwbHVnaW4gZGVmaW5pdGlvblxuICAgICovXG5cbiAgICB2YXIgbWF0Y2hIZWlnaHQgPSAkLmZuLm1hdGNoSGVpZ2h0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0cyA9IF9wYXJzZU9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gaGFuZGxlIHJlbW92ZVxuICAgICAgICBpZiAob3B0cy5yZW1vdmUpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGZpeGVkIGhlaWdodCBmcm9tIGFsbCBzZWxlY3RlZCBlbGVtZW50c1xuICAgICAgICAgICAgdGhpcy5jc3Mob3B0cy5wcm9wZXJ0eSwgJycpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgc2VsZWN0ZWQgZWxlbWVudHMgZnJvbSBhbGwgZ3JvdXBzXG4gICAgICAgICAgICAkLmVhY2gobWF0Y2hIZWlnaHQuX2dyb3VwcywgZnVuY3Rpb24oa2V5LCBncm91cCkge1xuICAgICAgICAgICAgICAgIGdyb3VwLmVsZW1lbnRzID0gZ3JvdXAuZWxlbWVudHMubm90KHRoYXQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IGNsZWFudXAgZW1wdHkgZ3JvdXBzXG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDw9IDEgJiYgIW9wdHMudGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhpcyBncm91cCBzbyB3ZSBjYW4gcmUtYXBwbHkgbGF0ZXIgb24gbG9hZCBhbmQgcmVzaXplIGV2ZW50c1xuICAgICAgICBtYXRjaEhlaWdodC5fZ3JvdXBzLnB1c2goe1xuICAgICAgICAgICAgZWxlbWVudHM6IHRoaXMsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG1hdGNoIGVhY2ggZWxlbWVudCdzIGhlaWdodCB0byB0aGUgdGFsbGVzdCBlbGVtZW50IGluIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgbWF0Y2hIZWlnaHQuX2FwcGx5KHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKlxuICAgICogIHBsdWdpbiBnbG9iYWwgb3B0aW9uc1xuICAgICovXG5cbiAgICBtYXRjaEhlaWdodC52ZXJzaW9uID0gJzAuNy4yJztcbiAgICBtYXRjaEhlaWdodC5fZ3JvdXBzID0gW107XG4gICAgbWF0Y2hIZWlnaHQuX3Rocm90dGxlID0gODA7XG4gICAgbWF0Y2hIZWlnaHQuX21haW50YWluU2Nyb2xsID0gZmFsc2U7XG4gICAgbWF0Y2hIZWlnaHQuX2JlZm9yZVVwZGF0ZSA9IG51bGw7XG4gICAgbWF0Y2hIZWlnaHQuX2FmdGVyVXBkYXRlID0gbnVsbDtcbiAgICBtYXRjaEhlaWdodC5fcm93cyA9IF9yb3dzO1xuICAgIG1hdGNoSGVpZ2h0Ll9wYXJzZSA9IF9wYXJzZTtcbiAgICBtYXRjaEhlaWdodC5fcGFyc2VPcHRpb25zID0gX3BhcnNlT3B0aW9ucztcblxuICAgIC8qXG4gICAgKiAgbWF0Y2hIZWlnaHQuX2FwcGx5XG4gICAgKiAgYXBwbHkgbWF0Y2hIZWlnaHQgdG8gZ2l2ZW4gZWxlbWVudHNcbiAgICAqL1xuXG4gICAgbWF0Y2hIZWlnaHQuX2FwcGx5ID0gZnVuY3Rpb24oZWxlbWVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdHMgPSBfcGFyc2VPcHRpb25zKG9wdGlvbnMpLFxuICAgICAgICAgICAgJGVsZW1lbnRzID0gJChlbGVtZW50cyksXG4gICAgICAgICAgICByb3dzID0gWyRlbGVtZW50c107XG5cbiAgICAgICAgLy8gdGFrZSBub3RlIG9mIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpLFxuICAgICAgICAgICAgaHRtbEhlaWdodCA9ICQoJ2h0bWwnKS5vdXRlckhlaWdodCh0cnVlKTtcblxuICAgICAgICAvLyBnZXQgaGlkZGVuIHBhcmVudHNcbiAgICAgICAgdmFyICRoaWRkZW5QYXJlbnRzID0gJGVsZW1lbnRzLnBhcmVudHMoKS5maWx0ZXIoJzpoaWRkZW4nKTtcblxuICAgICAgICAvLyBjYWNoZSB0aGUgb3JpZ2luYWwgaW5saW5lIHN0eWxlXG4gICAgICAgICRoaWRkZW5QYXJlbnRzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgJHRoYXQgPSAkKHRoaXMpO1xuICAgICAgICAgICAgJHRoYXQuZGF0YSgnc3R5bGUtY2FjaGUnLCAkdGhhdC5hdHRyKCdzdHlsZScpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGVtcG9yYXJpbHkgbXVzdCBmb3JjZSBoaWRkZW4gcGFyZW50cyB2aXNpYmxlXG4gICAgICAgICRoaWRkZW5QYXJlbnRzLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuXG4gICAgICAgIC8vIGdldCByb3dzIGlmIHVzaW5nIGJ5Um93LCBvdGhlcndpc2UgYXNzdW1lIG9uZSByb3dcbiAgICAgICAgaWYgKG9wdHMuYnlSb3cgJiYgIW9wdHMudGFyZ2V0KSB7XG5cbiAgICAgICAgICAgIC8vIG11c3QgZmlyc3QgZm9yY2UgYW4gYXJiaXRyYXJ5IGVxdWFsIGhlaWdodCBzbyBmbG9hdGluZyBlbGVtZW50cyBicmVhayBldmVubHlcbiAgICAgICAgICAgICRlbGVtZW50cy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciAkdGhhdCA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkgPSAkdGhhdC5jc3MoJ2Rpc3BsYXknKTtcblxuICAgICAgICAgICAgICAgIC8vIHRlbXBvcmFyaWx5IGZvcmNlIGEgdXNhYmxlIGRpc3BsYXkgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGxheSAhPT0gJ2lubGluZS1ibG9jaycgJiYgZGlzcGxheSAhPT0gJ2ZsZXgnICYmIGRpc3BsYXkgIT09ICdpbmxpbmUtZmxleCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2FjaGUgdGhlIG9yaWdpbmFsIGlubGluZSBzdHlsZVxuICAgICAgICAgICAgICAgICR0aGF0LmRhdGEoJ3N0eWxlLWNhY2hlJywgJHRoYXQuYXR0cignc3R5bGUnKSk7XG5cbiAgICAgICAgICAgICAgICAkdGhhdC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAnZGlzcGxheSc6IGRpc3BsYXksXG4gICAgICAgICAgICAgICAgICAgICdwYWRkaW5nLXRvcCc6ICcwJyxcbiAgICAgICAgICAgICAgICAgICAgJ3BhZGRpbmctYm90dG9tJzogJzAnLFxuICAgICAgICAgICAgICAgICAgICAnbWFyZ2luLXRvcCc6ICcwJyxcbiAgICAgICAgICAgICAgICAgICAgJ21hcmdpbi1ib3R0b20nOiAnMCcsXG4gICAgICAgICAgICAgICAgICAgICdib3JkZXItdG9wLXdpZHRoJzogJzAnLFxuICAgICAgICAgICAgICAgICAgICAnYm9yZGVyLWJvdHRvbS13aWR0aCc6ICcwJyxcbiAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6ICcxMDBweCcsXG4gICAgICAgICAgICAgICAgICAgICdvdmVyZmxvdyc6ICdoaWRkZW4nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBhcnJheSBvZiByb3dzIChiYXNlZCBvbiBlbGVtZW50IHRvcCBwb3NpdGlvbilcbiAgICAgICAgICAgIHJvd3MgPSBfcm93cygkZWxlbWVudHMpO1xuXG4gICAgICAgICAgICAvLyByZXZlcnQgb3JpZ2luYWwgaW5saW5lIHN0eWxlc1xuICAgICAgICAgICAgJGVsZW1lbnRzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyICR0aGF0ID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICAkdGhhdC5hdHRyKCdzdHlsZScsICR0aGF0LmRhdGEoJ3N0eWxlLWNhY2hlJykgfHwgJycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAkLmVhY2gocm93cywgZnVuY3Rpb24oa2V5LCByb3cpIHtcbiAgICAgICAgICAgIHZhciAkcm93ID0gJChyb3cpLFxuICAgICAgICAgICAgICAgIHRhcmdldEhlaWdodCA9IDA7XG5cbiAgICAgICAgICAgIGlmICghb3B0cy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIGFwcGx5IHRvIHJvd3Mgd2l0aCBvbmx5IG9uZSBpdGVtXG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuYnlSb3cgJiYgJHJvdy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAkcm93LmNzcyhvcHRzLnByb3BlcnR5LCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpdGVyYXRlIHRoZSByb3cgYW5kIGZpbmQgdGhlIG1heCBoZWlnaHRcbiAgICAgICAgICAgICAgICAkcm93LmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0aGF0ID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0gJHRoYXQuYXR0cignc3R5bGUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkgPSAkdGhhdC5jc3MoJ2Rpc3BsYXknKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB0ZW1wb3JhcmlseSBmb3JjZSBhIHVzYWJsZSBkaXNwbGF5IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5ICE9PSAnaW5saW5lLWJsb2NrJyAmJiBkaXNwbGF5ICE9PSAnZmxleCcgJiYgZGlzcGxheSAhPT0gJ2lubGluZS1mbGV4Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgd2UgZ2V0IHRoZSBjb3JyZWN0IGFjdHVhbCBoZWlnaHQgKGFuZCBub3QgYSBwcmV2aW91c2x5IHNldCBoZWlnaHQgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhciBjc3MgPSB7ICdkaXNwbGF5JzogZGlzcGxheSB9O1xuICAgICAgICAgICAgICAgICAgICBjc3Nbb3B0cy5wcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgJHRoYXQuY3NzKGNzcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgbWF4IGhlaWdodCAoaW5jbHVkaW5nIHBhZGRpbmcsIGJ1dCBub3QgbWFyZ2luKVxuICAgICAgICAgICAgICAgICAgICBpZiAoJHRoYXQub3V0ZXJIZWlnaHQoZmFsc2UpID4gdGFyZ2V0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRIZWlnaHQgPSAkdGhhdC5vdXRlckhlaWdodChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyByZXZlcnQgc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRoYXQuYXR0cignc3R5bGUnLCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhhdC5jc3MoJ2Rpc3BsYXknLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGFyZ2V0IHNldCwgdXNlIHRoZSBoZWlnaHQgb2YgdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0ID0gb3B0cy50YXJnZXQub3V0ZXJIZWlnaHQoZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpdGVyYXRlIHRoZSByb3cgYW5kIGFwcGx5IHRoZSBoZWlnaHQgdG8gYWxsIGVsZW1lbnRzXG4gICAgICAgICAgICAkcm93LmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB2YXIgJHRoYXQgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbFBhZGRpbmcgPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgYXBwbHkgdG8gYSB0YXJnZXRcbiAgICAgICAgICAgICAgICBpZiAob3B0cy50YXJnZXQgJiYgJHRoYXQuaXMob3B0cy50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgcGFkZGluZyBhbmQgYm9yZGVyIGNvcnJlY3RseSAocmVxdWlyZWQgd2hlbiBub3QgdXNpbmcgYm9yZGVyLWJveClcbiAgICAgICAgICAgICAgICBpZiAoJHRoYXQuY3NzKCdib3gtc2l6aW5nJykgIT09ICdib3JkZXItYm94Jykge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbFBhZGRpbmcgKz0gX3BhcnNlKCR0aGF0LmNzcygnYm9yZGVyLXRvcC13aWR0aCcpKSArIF9wYXJzZSgkdGhhdC5jc3MoJ2JvcmRlci1ib3R0b20td2lkdGgnKSk7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsUGFkZGluZyArPSBfcGFyc2UoJHRoYXQuY3NzKCdwYWRkaW5nLXRvcCcpKSArIF9wYXJzZSgkdGhhdC5jc3MoJ3BhZGRpbmctYm90dG9tJykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgaGVpZ2h0IChhY2NvdW50aW5nIGZvciBwYWRkaW5nIGFuZCBib3JkZXIpXG4gICAgICAgICAgICAgICAgJHRoYXQuY3NzKG9wdHMucHJvcGVydHksICh0YXJnZXRIZWlnaHQgLSB2ZXJ0aWNhbFBhZGRpbmcpICsgJ3B4Jyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmV2ZXJ0IGhpZGRlbiBwYXJlbnRzXG4gICAgICAgICRoaWRkZW5QYXJlbnRzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgJHRoYXQgPSAkKHRoaXMpO1xuICAgICAgICAgICAgJHRoYXQuYXR0cignc3R5bGUnLCAkdGhhdC5kYXRhKCdzdHlsZS1jYWNoZScpIHx8IG51bGwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZXN0b3JlIHNjcm9sbCBwb3NpdGlvbiBpZiBlbmFibGVkXG4gICAgICAgIGlmIChtYXRjaEhlaWdodC5fbWFpbnRhaW5TY3JvbGwpIHtcbiAgICAgICAgICAgICQod2luZG93KS5zY3JvbGxUb3AoKHNjcm9sbFRvcCAvIGh0bWxIZWlnaHQpICogJCgnaHRtbCcpLm91dGVySGVpZ2h0KHRydWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKlxuICAgICogIG1hdGNoSGVpZ2h0Ll9hcHBseURhdGFBcGlcbiAgICAqICBhcHBsaWVzIG1hdGNoSGVpZ2h0IHRvIGFsbCBlbGVtZW50cyB3aXRoIGEgZGF0YS1tYXRjaC1oZWlnaHQgYXR0cmlidXRlXG4gICAgKi9cblxuICAgIG1hdGNoSGVpZ2h0Ll9hcHBseURhdGFBcGkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IHt9O1xuXG4gICAgICAgIC8vIGdlbmVyYXRlIGdyb3VwcyBieSB0aGVpciBncm91cElkIHNldCBieSBlbGVtZW50cyB1c2luZyBkYXRhLW1hdGNoLWhlaWdodFxuICAgICAgICAkKCdbZGF0YS1tYXRjaC1oZWlnaHRdLCBbZGF0YS1taF0nKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgICBncm91cElkID0gJHRoaXMuYXR0cignZGF0YS1taCcpIHx8ICR0aGlzLmF0dHIoJ2RhdGEtbWF0Y2gtaGVpZ2h0Jyk7XG5cbiAgICAgICAgICAgIGlmIChncm91cElkIGluIGdyb3Vwcykge1xuICAgICAgICAgICAgICAgIGdyb3Vwc1tncm91cElkXSA9IGdyb3Vwc1tncm91cElkXS5hZGQoJHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncm91cHNbZ3JvdXBJZF0gPSAkdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYXBwbHkgbWF0Y2hIZWlnaHQgdG8gZWFjaCBncm91cFxuICAgICAgICAkLmVhY2goZ3JvdXBzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hIZWlnaHQodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKlxuICAgICogIG1hdGNoSGVpZ2h0Ll91cGRhdGVcbiAgICAqICB1cGRhdGVzIG1hdGNoSGVpZ2h0IG9uIGFsbCBjdXJyZW50IGdyb3VwcyB3aXRoIHRoZWlyIGNvcnJlY3Qgb3B0aW9uc1xuICAgICovXG5cbiAgICB2YXIgX3VwZGF0ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChtYXRjaEhlaWdodC5fYmVmb3JlVXBkYXRlKSB7XG4gICAgICAgICAgICBtYXRjaEhlaWdodC5fYmVmb3JlVXBkYXRlKGV2ZW50LCBtYXRjaEhlaWdodC5fZ3JvdXBzKTtcbiAgICAgICAgfVxuXG4gICAgICAgICQuZWFjaChtYXRjaEhlaWdodC5fZ3JvdXBzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1hdGNoSGVpZ2h0Ll9hcHBseSh0aGlzLmVsZW1lbnRzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hIZWlnaHQuX2FmdGVyVXBkYXRlKSB7XG4gICAgICAgICAgICBtYXRjaEhlaWdodC5fYWZ0ZXJVcGRhdGUoZXZlbnQsIG1hdGNoSGVpZ2h0Ll9ncm91cHMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1hdGNoSGVpZ2h0Ll91cGRhdGUgPSBmdW5jdGlvbih0aHJvdHRsZSwgZXZlbnQpIHtcbiAgICAgICAgLy8gcHJldmVudCB1cGRhdGUgaWYgZmlyZWQgZnJvbSBhIHJlc2l6ZSBldmVudFxuICAgICAgICAvLyB3aGVyZSB0aGUgdmlld3BvcnQgd2lkdGggaGFzbid0IGFjdHVhbGx5IGNoYW5nZWRcbiAgICAgICAgLy8gZml4ZXMgYW4gZXZlbnQgbG9vcGluZyBidWcgaW4gSUU4XG4gICAgICAgIGlmIChldmVudCAmJiBldmVudC50eXBlID09PSAncmVzaXplJykge1xuICAgICAgICAgICAgdmFyIHdpbmRvd1dpZHRoID0gJCh3aW5kb3cpLndpZHRoKCk7XG4gICAgICAgICAgICBpZiAod2luZG93V2lkdGggPT09IF9wcmV2aW91c1Jlc2l6ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3ByZXZpb3VzUmVzaXplV2lkdGggPSB3aW5kb3dXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRocm90dGxlIHVwZGF0ZXNcbiAgICAgICAgaWYgKCF0aHJvdHRsZSkge1xuICAgICAgICAgICAgX3VwZGF0ZShldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3VwZGF0ZVRpbWVvdXQgPT09IC0xKSB7XG4gICAgICAgICAgICBfdXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZShldmVudCk7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgICAgIH0sIG1hdGNoSGVpZ2h0Ll90aHJvdHRsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICAqICBiaW5kIGV2ZW50c1xuICAgICovXG5cbiAgICAvLyBhcHBseSBvbiBET00gcmVhZHkgZXZlbnRcbiAgICAkKG1hdGNoSGVpZ2h0Ll9hcHBseURhdGFBcGkpO1xuXG4gICAgLy8gdXNlIG9uIG9yIGJpbmQgd2hlcmUgc3VwcG9ydGVkXG4gICAgdmFyIG9uID0gJC5mbi5vbiA/ICdvbicgOiAnYmluZCc7XG5cbiAgICAvLyB1cGRhdGUgaGVpZ2h0cyBvbiBsb2FkIGFuZCByZXNpemUgZXZlbnRzXG4gICAgJCh3aW5kb3cpW29uXSgnbG9hZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIG1hdGNoSGVpZ2h0Ll91cGRhdGUoZmFsc2UsIGV2ZW50KTtcbiAgICB9KTtcblxuICAgIC8vIHRocm90dGxlZCB1cGRhdGUgaGVpZ2h0cyBvbiByZXNpemUgZXZlbnRzXG4gICAgJCh3aW5kb3cpW29uXSgncmVzaXplIG9yaWVudGF0aW9uY2hhbmdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgbWF0Y2hIZWlnaHQuX3VwZGF0ZSh0cnVlLCBldmVudCk7XG4gICAgfSk7XG5cbn0pO1xuIiwiKGZ1bmN0aW9uIChyb290KSB7LypnbG9iYWwgZXhwb3J0cywgSW50bCovXG4vKipcbiAqIFRoaXMgc2NyaXB0IGdpdmVzIHlvdSB0aGUgem9uZSBpbmZvIGtleSByZXByZXNlbnRpbmcgeW91ciBkZXZpY2UncyB0aW1lIHpvbmUgc2V0dGluZy5cbiAqXG4gKiBAbmFtZSBqc1RpbWV6b25lRGV0ZWN0XG4gKiBAdmVyc2lvbiAxLjAuNlxuICogQGF1dGhvciBKb24gTnlsYW5kZXJcbiAqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIC0gaHR0cHM6Ly9iaXRidWNrZXQub3JnL3BlbGxlcGltL2pzdGltZXpvbmVkZXRlY3Qvc3JjL2RlZmF1bHQvTElDRU5DRS50eHRcbiAqXG4gKiBGb3IgdXNhZ2UgYW5kIGV4YW1wbGVzLCB2aXNpdDpcbiAqIGh0dHA6Ly9wZWxsZXBpbS5iaXRidWNrZXQub3JnL2pzdHovXG4gKlxuICogQ29weXJpZ2h0IChjKSBKb24gTnlsYW5kZXJcbiAqL1xuXG5cbi8qKlxuICogTmFtZXNwYWNlIHRvIGhvbGQgYWxsIHRoZSBjb2RlIGZvciB0aW1lem9uZSBkZXRlY3Rpb24uXG4gKi9cbnZhciBqc3R6ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIEhFTUlTUEhFUkVfU09VVEggPSAncycsXG5cbiAgICAgICAgY29uc3RzID0ge1xuICAgICAgICAgICAgREFZOiA4NjQwMDAwMCxcbiAgICAgICAgICAgIEhPVVI6IDM2MDAwMDAsXG4gICAgICAgICAgICBNSU5VVEU6IDYwMDAwLFxuICAgICAgICAgICAgU0VDT05EOiAxMDAwLFxuICAgICAgICAgICAgQkFTRUxJTkVfWUVBUjogMjAxNCxcbiAgICAgICAgICAgIE1BWF9TQ09SRTogODY0MDAwMDAwLCAvLyAxMCBkYXlzXG4gICAgICAgICAgICBBTUJJR1VJVElFUzoge1xuICAgICAgICAgICAgICAgICdBbWVyaWNhL0RlbnZlcic6ICAgICAgIFsnQW1lcmljYS9NYXphdGxhbiddLFxuICAgICAgICAgICAgICAgICdFdXJvcGUvTG9uZG9uJzogICAgICAgIFsnQWZyaWNhL0Nhc2FibGFuY2EnXSxcbiAgICAgICAgICAgICAgICAnQW1lcmljYS9DaGljYWdvJzogICAgICBbJ0FtZXJpY2EvTWV4aWNvX0NpdHknXSxcbiAgICAgICAgICAgICAgICAnQW1lcmljYS9Bc3VuY2lvbic6ICAgICBbJ0FtZXJpY2EvQ2FtcG9fR3JhbmRlJywgJ0FtZXJpY2EvU2FudGlhZ28nXSxcbiAgICAgICAgICAgICAgICAnQW1lcmljYS9Nb250ZXZpZGVvJzogICBbJ0FtZXJpY2EvU2FvX1BhdWxvJywgJ0FtZXJpY2EvU2FudGlhZ28nXSxcbiAgICAgICAgICAgICAgICAvLyBFdXJvcGUvTWluc2sgc2hvdWxkIG5vdCBiZSBpbiB0aGlzIGxpc3QuLi4gYnV0IFdpbmRvd3MuXG4gICAgICAgICAgICAgICAgJ0FzaWEvQmVpcnV0JzogICAgICAgICAgWydBc2lhL0FtbWFuJywgJ0FzaWEvSmVydXNhbGVtJywgJ0V1cm9wZS9IZWxzaW5raScsICdBc2lhL0RhbWFzY3VzJywgJ0FmcmljYS9DYWlybycsICdBc2lhL0dhemEnLCAnRXVyb3BlL01pbnNrJ10sXG4gICAgICAgICAgICAgICAgJ1BhY2lmaWMvQXVja2xhbmQnOiAgICAgWydQYWNpZmljL0ZpamknXSxcbiAgICAgICAgICAgICAgICAnQW1lcmljYS9Mb3NfQW5nZWxlcyc6ICBbJ0FtZXJpY2EvU2FudGFfSXNhYmVsJ10sXG4gICAgICAgICAgICAgICAgJ0FtZXJpY2EvTmV3X1lvcmsnOiAgICAgWydBbWVyaWNhL0hhdmFuYSddLFxuICAgICAgICAgICAgICAgICdBbWVyaWNhL0hhbGlmYXgnOiAgICAgIFsnQW1lcmljYS9Hb29zZV9CYXknXSxcbiAgICAgICAgICAgICAgICAnQW1lcmljYS9Hb2R0aGFiJzogICAgICBbJ0FtZXJpY2EvTWlxdWVsb24nXSxcbiAgICAgICAgICAgICAgICAnQXNpYS9EdWJhaSc6ICAgICAgICAgICBbJ0FzaWEvWWVyZXZhbiddLFxuICAgICAgICAgICAgICAgICdBc2lhL0pha2FydGEnOiAgICAgICAgIFsnQXNpYS9LcmFzbm95YXJzayddLFxuICAgICAgICAgICAgICAgICdBc2lhL1NoYW5naGFpJzogICAgICAgIFsnQXNpYS9Jcmt1dHNrJywgJ0F1c3RyYWxpYS9QZXJ0aCddLFxuICAgICAgICAgICAgICAgICdBdXN0cmFsaWEvU3lkbmV5JzogICAgIFsnQXVzdHJhbGlhL0xvcmRfSG93ZSddLFxuICAgICAgICAgICAgICAgICdBc2lhL1Rva3lvJzogICAgICAgICAgIFsnQXNpYS9ZYWt1dHNrJ10sXG4gICAgICAgICAgICAgICAgJ0FzaWEvRGhha2EnOiAgICAgICAgICAgWydBc2lhL09tc2snXSxcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgcmVhbCB3b3JsZCBZZXJldmFuIGlzIG5vdCBhbWJpZ291cyBmb3IgQmFrdS4uLiBidXQgV2luZG93cy5cbiAgICAgICAgICAgICAgICAnQXNpYS9CYWt1JzogICAgICAgICAgICBbJ0FzaWEvWWVyZXZhbiddLFxuICAgICAgICAgICAgICAgICdBdXN0cmFsaWEvQnJpc2JhbmUnOiAgIFsnQXNpYS9WbGFkaXZvc3RvayddLFxuICAgICAgICAgICAgICAgICdQYWNpZmljL05vdW1lYSc6ICAgICAgIFsnQXNpYS9WbGFkaXZvc3RvayddLFxuICAgICAgICAgICAgICAgICdQYWNpZmljL01hanVybyc6ICAgICAgIFsnQXNpYS9LYW1jaGF0a2EnLCAnUGFjaWZpYy9GaWppJ10sXG4gICAgICAgICAgICAgICAgJ1BhY2lmaWMvVG9uZ2F0YXB1JzogICAgWydQYWNpZmljL0FwaWEnXSxcbiAgICAgICAgICAgICAgICAnQXNpYS9CYWdoZGFkJzogICAgICAgICBbJ0V1cm9wZS9NaW5zaycsICdFdXJvcGUvTW9zY293J10sXG4gICAgICAgICAgICAgICAgJ0FzaWEvS2FyYWNoaSc6ICAgICAgICAgWydBc2lhL1lla2F0ZXJpbmJ1cmcnXSxcbiAgICAgICAgICAgICAgICAnQWZyaWNhL0pvaGFubmVzYnVyZyc6ICBbJ0FzaWEvR2F6YScsICdBZnJpY2EvQ2Fpcm8nXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBvZmZzZXQgaW4gbWludXRlcyBmcm9tIFVUQyBmb3IgYSBjZXJ0YWluIGRhdGUuXG4gICAgICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZVxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0X2RhdGVfb2Zmc2V0ID0gZnVuY3Rpb24gZ2V0X2RhdGVfb2Zmc2V0KGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAtZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICAgICAgcmV0dXJuIChvZmZzZXQgIT09IG51bGwgPyBvZmZzZXQgOiAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBkb2VzIHNvbWUgYmFzaWMgY2FsY3VsYXRpb25zIHRvIGNyZWF0ZSBpbmZvcm1hdGlvbiBhYm91dFxuICAgICAgICAgKiB0aGUgdXNlcidzIHRpbWV6b25lLiBJdCB1c2VzIFJFRkVSRU5DRV9ZRUFSIGFzIGEgc29saWQgeWVhciBmb3Igd2hpY2hcbiAgICAgICAgICogdGhlIHNjcmlwdCBoYXMgYmVlbiB0ZXN0ZWQgcmF0aGVyIHRoYW4gZGVwZW5kIG9uIHRoZSB5ZWFyIHNldCBieSB0aGVcbiAgICAgICAgICogY2xpZW50IGRldmljZS5cbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJucyBhIGtleSB0aGF0IGNhbiBiZSB1c2VkIHRvIGRvIGxvb2t1cHMgaW4ganN0ei5vbHNvbi50aW1lem9uZXMuXG4gICAgICAgICAqIGVnOiBcIjcyMCwxLDJcIi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGxvb2t1cF9rZXkgPSBmdW5jdGlvbiBsb29rdXBfa2V5KCkge1xuICAgICAgICAgICAgdmFyIGphbnVhcnlfb2Zmc2V0ID0gZ2V0X2RhdGVfb2Zmc2V0KG5ldyBEYXRlKGNvbnN0cy5CQVNFTElORV9ZRUFSLCAwLCAyKSksXG4gICAgICAgICAgICAgICAganVuZV9vZmZzZXQgPSBnZXRfZGF0ZV9vZmZzZXQobmV3IERhdGUoY29uc3RzLkJBU0VMSU5FX1lFQVIsIDUsIDIpKSxcbiAgICAgICAgICAgICAgICBkaWZmID0gamFudWFyeV9vZmZzZXQgLSBqdW5lX29mZnNldDtcblxuICAgICAgICAgICAgaWYgKGRpZmYgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGphbnVhcnlfb2Zmc2V0ICsgXCIsMVwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqdW5lX29mZnNldCArIFwiLDEsXCIgKyBIRU1JU1BIRVJFX1NPVVRIO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gamFudWFyeV9vZmZzZXQgKyBcIiwwXCI7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZXMgdG8gZ2V0IHRoZSB0aW1lIHpvbmUga2V5IGRpcmVjdGx5IGZyb20gdGhlIG9wZXJhdGluZyBzeXN0ZW0gZm9yIHRob3NlXG4gICAgICAgICAqIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgdGhlIEVDTUFTY3JpcHQgSW50ZXJuYXRpb25hbGl6YXRpb24gQVBJLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0X2Zyb21faW50ZXJuYXRpb25hbGl6YXRpb25fYXBpID0gZnVuY3Rpb24gZ2V0X2Zyb21faW50ZXJuYXRpb25hbGl6YXRpb25fYXBpKCkge1xuICAgICAgICAgICAgdmFyIGZvcm1hdCwgdGltZXpvbmU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEludGwgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIEludGwuRGF0ZVRpbWVGb3JtYXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IEludGwuRGF0ZVRpbWVGb3JtYXQoKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGZvcm1hdC5yZXNvbHZlZE9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpbWV6b25lID0gZm9ybWF0LnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xuXG4gICAgICAgICAgICBpZiAodGltZXpvbmUgJiYgKHRpbWV6b25lLmluZGV4T2YoXCIvXCIpID4gLTEgfHwgdGltZXpvbmUgPT09ICdVVEMnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aW1lem9uZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydGluZyBwb2ludCBmb3IgZ2V0dGluZyBhbGwgdGhlIERTVCBydWxlcyBmb3IgYSBzcGVjaWZpYyB5ZWFyXG4gICAgICAgICAqIGZvciB0aGUgY3VycmVudCB0aW1lem9uZSAoYXMgZGVzY3JpYmVkIGJ5IHRoZSBjbGllbnQgc3lzdGVtKS5cbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBzdGFydCBhbmQgZW5kIGF0dHJpYnV0ZXMsIG9yIGZhbHNlIGlmIG5vXG4gICAgICAgICAqIERTVCBydWxlcyB3ZXJlIGZvdW5kIGZvciB0aGUgeWVhci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHllYXJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gfHwge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBkc3RfZGF0ZXMgPSBmdW5jdGlvbiBkc3RfZGF0ZXMoeWVhcikge1xuICAgICAgICAgICAgdmFyIHllYXJzdGFydCA9IG5ldyBEYXRlKHllYXIsIDAsIDEsIDAsIDAsIDEsIDApLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHZhciB5ZWFyZW5kID0gbmV3IERhdGUoeWVhciwgMTIsIDMxLCAyMywgNTksIDU5KS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHllYXJzdGFydDtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAobmV3IERhdGUoY3VycmVudCkpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgZHN0X3N0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBkc3RfZW5kID0gbnVsbDtcblxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgPCB5ZWFyZW5kIC0gODY0MDAwMDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZVRvQ2hlY2sgPSBuZXcgRGF0ZShjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZVRvQ2hlY2tPZmZzZXQgPSBkYXRlVG9DaGVjay5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGVUb0NoZWNrT2Zmc2V0ICE9PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGVUb0NoZWNrT2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkc3Rfc3RhcnQgPSBkYXRlVG9DaGVjaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZVRvQ2hlY2tPZmZzZXQgPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdF9lbmQgPSBkYXRlVG9DaGVjaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBkYXRlVG9DaGVja09mZnNldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDg2NDAwMDAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZHN0X3N0YXJ0ICYmIGRzdF9lbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzOiBmaW5kX2RzdF9mb2xkKGRzdF9zdGFydCkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgICAgICAgICBlOiBmaW5kX2RzdF9mb2xkKGRzdF9lbmQpLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvYmFibHkgY29tcGxldGVseSB1bm5lY2Vzc2FyeSBmdW5jdGlvbiB0aGF0IHJlY3Vyc2l2ZWx5IGZpbmRzIHRoZVxuICAgICAgICAgKiBleGFjdCAodG8gdGhlIHNlY29uZCkgdGltZSB3aGVuIGEgRFNUIHJ1bGUgd2FzIGNoYW5nZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBhX2RhdGUgLSBUaGUgY2FuZGlkYXRlIERhdGUuXG4gICAgICAgICAqIEBwYXJhbSBwYWRkaW5nIC0gaW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBwYWRkaW5nIHRvIGFsbG93IGFyb3VuZCB0aGUgY2FuZGlkYXRlXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgZGF0ZSBmb3IgZmluZGluZyB0aGUgZm9sZC5cbiAgICAgICAgICogQHBhcmFtIGl0ZXJhdG9yIC0gaW50ZWdlciBzcGVjaWZ5aW5nIGhvdyBtYW55IG1pbGxpc2Vjb25kcyB0byBpdGVyYXRlIHdoaWxlXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgIHNlYXJjaGluZyBmb3IgdGhlIGZvbGQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtEYXRlfVxuICAgICAgICAgKi9cbiAgICAgICAgZmluZF9kc3RfZm9sZCA9IGZ1bmN0aW9uIGZpbmRfZHN0X2ZvbGQoYV9kYXRlLCBwYWRkaW5nLCBpdGVyYXRvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBjb25zdHMuREFZO1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gY29uc3RzLkhPVVI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRlX3N0YXJ0ID0gbmV3IERhdGUoYV9kYXRlLmdldFRpbWUoKSAtIHBhZGRpbmcpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHZhciBkYXRlX2VuZCA9IGFfZGF0ZS5nZXRUaW1lKCkgKyBwYWRkaW5nO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IG5ldyBEYXRlKGRhdGVfc3RhcnQpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gZGF0ZV9zdGFydDtcblxuICAgICAgICAgICAgdmFyIGRzdF9jaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgPCBkYXRlX2VuZCAtIGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGVUb0NoZWNrID0gbmV3IERhdGUoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGVUb0NoZWNrT2Zmc2V0ID0gZGF0ZVRvQ2hlY2suZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChkYXRlVG9DaGVja09mZnNldCAhPT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRzdF9jaGFuZ2UgPSBkYXRlVG9DaGVjaztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gaXRlcmF0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYWRkaW5nID09PSBjb25zdHMuREFZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRfZHN0X2ZvbGQoZHN0X2NoYW5nZSwgY29uc3RzLkhPVVIsIGNvbnN0cy5NSU5VVEUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFkZGluZyA9PT0gY29uc3RzLkhPVVIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluZF9kc3RfZm9sZChkc3RfY2hhbmdlLCBjb25zdHMuTUlOVVRFLCBjb25zdHMuU0VDT05EKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRzdF9jaGFuZ2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2luZG93czdfYWRhcHRhdGlvbnMgPSBmdW5jdGlvbiB3aW5kb3dzN19hZGFwdGlvbnMocnVsZV9saXN0LCBwcmVsaW1pbmFyeV90aW1lem9uZSwgc2NvcmUsIHNhbXBsZSkge1xuICAgICAgICAgICAgaWYgKHNjb3JlICE9PSAnTi9BJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmVsaW1pbmFyeV90aW1lem9uZSA9PT0gJ0FzaWEvQmVpcnV0Jykge1xuICAgICAgICAgICAgICAgIGlmIChzYW1wbGUubmFtZSA9PT0gJ0FmcmljYS9DYWlybycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVfbGlzdFs2XS5zID09PSAxMzk4Mzc2ODAwMDAwICYmIHJ1bGVfbGlzdFs2XS5lID09PSAxNDExNjc4ODAwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2FtcGxlLm5hbWUgPT09ICdBc2lhL0plcnVzYWxlbScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVfbGlzdFs2XS5zID09PSAxMzk1OTY0ODAwMDAwICYmIHJ1bGVfbGlzdFs2XS5lID09PSAxNDExODU4ODAwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZWxpbWluYXJ5X3RpbWV6b25lID09PSAnQW1lcmljYS9TYW50aWFnbycpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FtcGxlLm5hbWUgPT09ICdBbWVyaWNhL0FzdW5jaW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZV9saXN0WzZdLnMgPT09IDE0MTI0ODE2MDAwMDAgJiYgcnVsZV9saXN0WzZdLmUgPT09IDEzOTczNTgwMDAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzYW1wbGUubmFtZSA9PT0gJ0FtZXJpY2EvQ2FtcG9fR3JhbmRlJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZV9saXN0WzZdLnMgPT09IDE0MTM2OTEyMDAwMDAgJiYgcnVsZV9saXN0WzZdLmUgPT09IDEzOTI1MTk2MDAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVsaW1pbmFyeV90aW1lem9uZSA9PT0gJ0FtZXJpY2EvTW9udGV2aWRlbycpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FtcGxlLm5hbWUgPT09ICdBbWVyaWNhL1Nhb19QYXVsbycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVfbGlzdFs2XS5zID09PSAxNDEzNjg3NjAwMDAwICYmIHJ1bGVfbGlzdFs2XS5lID09PSAxMzkyNTE2MDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJlbGltaW5hcnlfdGltZXpvbmUgPT09ICdQYWNpZmljL0F1Y2tsYW5kJykge1xuICAgICAgICAgICAgICAgIGlmIChzYW1wbGUubmFtZSA9PT0gJ1BhY2lmaWMvRmlqaScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVfbGlzdFs2XS5zID09PSAxNDE0MjQ1NjAwMDAwICYmIHJ1bGVfbGlzdFs2XS5lID09PSAxMzk2MTAxNjAwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNjb3JlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyB0aGUgRFNUIHJ1bGVzIGZvciB0aGUgY3VycmVudCB0aW1lem9uZSwgYW5kIHByb2NlZWRzIHRvIGZpbmQgbWF0Y2hlc1xuICAgICAgICAgKiBpbiB0aGUganN0ei5vbHNvbi5kc3RfcnVsZXMuem9uZXMgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIENvbXBhcmVzIHNhbXBsZXMgdG8gdGhlIGN1cnJlbnQgdGltZXpvbmUgb24gYSBzY29yaW5nIGJhc2lzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDYW5kaWRhdGVzIGFyZSBydWxlZCBpbW1lZGlhdGVseSBpZiBlaXRoZXIgdGhlIGNhbmRpZGF0ZSBvciB0aGUgY3VycmVudCB6b25lXG4gICAgICAgICAqIGhhcyBhIERTVCBydWxlIHdoZXJlIHRoZSBvdGhlciBkb2VzIG5vdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2FuZGlkYXRlcyBhcmUgcnVsZWQgb3V0IGltbWVkaWF0ZWx5IGlmIHRoZSBjdXJyZW50IHpvbmUgaGFzIGEgcnVsZSB0aGF0IGlzXG4gICAgICAgICAqIG91dHNpZGUgdGhlIERTVCBzY29wZSBvZiB0aGUgY2FuZGlkYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDYW5kaWRhdGVzIGFyZSBpbmNsdWRlZCBmb3Igc2NvcmluZyBpZiB0aGUgY3VycmVudCB6b25lcyBydWxlcyBmYWxsIHdpdGhpbiB0aGVcbiAgICAgICAgICogc3BhbiBvZiB0aGUgc2FtcGxlcyBydWxlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogTG93IHNjb3JlIGlzIGJlc3QsIHRoZSBzY29yZSBpcyBjYWxjdWxhdGVkIGJ5IHN1bW1pbmcgdXAgdGhlIGRpZmZlcmVuY2VzIGluIERTVFxuICAgICAgICAgKiBydWxlcyBhbmQgaWYgdGhlIGNvbnN0cy5NQVhfU0NPUkUgaXMgb3ZlcnJlYWNoZWQgdGhlIGNhbmRpZGF0ZSBpcyBydWxlZCBvdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFlhaCBmb2xsb3c/IDopXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBydWxlX2xpc3RcbiAgICAgICAgICogQHBhcmFtIHByZWxpbWluYXJ5X3RpbWV6b25lXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgYmVzdF9kc3RfbWF0Y2ggPSBmdW5jdGlvbiBiZXN0X2RzdF9tYXRjaChydWxlX2xpc3QsIHByZWxpbWluYXJ5X3RpbWV6b25lKSB7XG4gICAgICAgICAgICB2YXIgc2NvcmVfc2FtcGxlID0gZnVuY3Rpb24gc2NvcmVfc2FtcGxlKHNhbXBsZSkge1xuICAgICAgICAgICAgICAgIHZhciBzY29yZSA9IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJ1bGVfbGlzdC5sZW5ndGg7IGorKykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJvdGggc2FtcGxlIGFuZCBjdXJyZW50IHRpbWUgem9uZSByZXBvcnQgRFNUIGR1cmluZyB0aGUgeWVhci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEhc2FtcGxlLnJ1bGVzW2pdICYmICEhcnVsZV9saXN0W2pdKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHRpbWUgem9uZSdzIERTVCBydWxlcyBhcmUgaW5zaWRlIHRoZSBzYW1wbGUncy4gSW5jbHVkZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlX2xpc3Rbal0ucyA+PSBzYW1wbGUucnVsZXNbal0ucyAmJiBydWxlX2xpc3Rbal0uZSA8PSBzYW1wbGUucnVsZXNbal0uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZSArPSBNYXRoLmFicyhydWxlX2xpc3Rbal0ucyAtIHNhbXBsZS5ydWxlc1tqXS5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZSArPSBNYXRoLmFicyhzYW1wbGUucnVsZXNbal0uZSAtIHJ1bGVfbGlzdFtqXS5lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgdGltZSB6b25lJ3MgRFNUIHJ1bGVzIGFyZSBvdXRzaWRlIHRoZSBzYW1wbGUncy4gRGlzY2FyZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmUgPSAnTi9BJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1heCBzY29yZSBoYXMgYmVlbiByZWFjaGVkLiBEaXNjYXJkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3JlID4gY29uc3RzLk1BWF9TQ09SRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlID0gJ04vQSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzY29yZSA9IHdpbmRvd3M3X2FkYXB0YXRpb25zKHJ1bGVfbGlzdCwgcHJlbGltaW5hcnlfdGltZXpvbmUsIHNjb3JlLCBzYW1wbGUpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3JlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzY29yZWJvYXJkID0ge307XG4gICAgICAgICAgICB2YXIgZHN0X3pvbmVzID0ganN0ei5vbHNvbi5kc3RfcnVsZXMuem9uZXM7XG4gICAgICAgICAgICB2YXIgZHN0X3pvbmVzX2xlbmd0aCA9IGRzdF96b25lcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYW1iaWd1aXRpZXMgPSBjb25zdHMuQU1CSUdVSVRJRVNbcHJlbGltaW5hcnlfdGltZXpvbmVdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRzdF96b25lc19sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzYW1wbGUgPSBkc3Rfem9uZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHNjb3JlID0gc2NvcmVfc2FtcGxlKGRzdF96b25lc1tpXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2NvcmUgIT09ICdOL0EnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlYm9hcmRbc2FtcGxlLm5hbWVdID0gc2NvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciB0eiBpbiBzY29yZWJvYXJkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjb3JlYm9hcmQuaGFzT3duUHJvcGVydHkodHopKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYW1iaWd1aXRpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbWJpZ3VpdGllc1tqXSA9PT0gdHopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcmVsaW1pbmFyeV90aW1lem9uZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgdGhlIHByZWxpbWluYXJ5X3RpbWV6b25lIGFzIGRldGVjdGVkIGJ5IGxvb2t1cF9rZXkoKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQnVpbGRzIHVwIHRoZSBjdXJyZW50IHRpbWV6b25lcyBEU1QgcnVsZXMgZm9yIHRoZSB5ZWFycyBkZWZpbmVkXG4gICAgICAgICAqIGluIHRoZSBqc3R6Lm9sc29uLmRzdF9ydWxlcy55ZWFycyBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlcmUgYXJlIG5vIERTVCBvY2N1cmVuY2VzIGZvciB0aG9zZSB5ZWFycywgaW1tZWRpYXRlbHkgcmV0dXJuc1xuICAgICAgICAgKiB0aGUgcHJlbGltaW5hcnkgdGltZXpvbmUuIE90aGVyd2lzZSBwcm9jZWVkcyBhbmQgdHJpZXMgdG8gc29sdmVcbiAgICAgICAgICogYW1iaWd1aXRpZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwcmVsaW1pbmFyeV90aW1lem9uZVxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aW1lem9uZV9uYW1lXG4gICAgICAgICAqL1xuICAgICAgICBnZXRfYnlfZHN0ID0gZnVuY3Rpb24gZ2V0X2J5X2RzdChwcmVsaW1pbmFyeV90aW1lem9uZSkge1xuICAgICAgICAgICAgdmFyIGdldF9ydWxlcyA9IGZ1bmN0aW9uIGdldF9ydWxlcygpIHtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZV9saXN0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc3R6Lm9sc29uLmRzdF9ydWxlcy55ZWFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeWVhcl9ydWxlcyA9IGRzdF9kYXRlcyhqc3R6Lm9sc29uLmRzdF9ydWxlcy55ZWFyc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVfbGlzdC5wdXNoKHllYXJfcnVsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcnVsZV9saXN0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjaGVja19oYXNfZHN0ID0gZnVuY3Rpb24gY2hlY2tfaGFzX2RzdChydWxlcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVzW2ldICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBydWxlcyA9IGdldF9ydWxlcygpO1xuICAgICAgICAgICAgdmFyIGhhc19kc3QgPSBjaGVja19oYXNfZHN0KHJ1bGVzKTtcblxuICAgICAgICAgICAgaWYgKGhhc19kc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdF9kc3RfbWF0Y2gocnVsZXMsIHByZWxpbWluYXJ5X3RpbWV6b25lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByZWxpbWluYXJ5X3RpbWV6b25lO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VzIGdldF90aW1lem9uZV9pbmZvKCkgdG8gZm9ybXVsYXRlIGEga2V5IHRvIHVzZSBpbiB0aGUgb2xzb24udGltZXpvbmVzIGRpY3Rpb25hcnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggb25lIGZ1bmN0aW9uIFwiLm5hbWUoKVwiXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgZGV0ZXJtaW5lID0gZnVuY3Rpb24gZGV0ZXJtaW5lKCkge1xuICAgICAgICAgICAgdmFyIHByZWxpbWluYXJ5X3R6ID0gZ2V0X2Zyb21faW50ZXJuYXRpb25hbGl6YXRpb25fYXBpKCk7XG5cbiAgICAgICAgICAgIGlmICghcHJlbGltaW5hcnlfdHopIHtcbiAgICAgICAgICAgICAgICBwcmVsaW1pbmFyeV90eiA9IGpzdHoub2xzb24udGltZXpvbmVzW2xvb2t1cF9rZXkoKV07XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnN0cy5BTUJJR1VJVElFU1twcmVsaW1pbmFyeV90el0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWxpbWluYXJ5X3R6ID0gZ2V0X2J5X2RzdChwcmVsaW1pbmFyeV90eik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWxpbWluYXJ5X3R6O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkZXRlcm1pbmU6IGRldGVybWluZVxuICAgIH07XG59KCkpO1xuXG5cbmpzdHoub2xzb24gPSBqc3R6Lm9sc29uIHx8IHt9O1xuXG4vKipcbiAqIFRoZSBrZXlzIGluIHRoaXMgZGljdGlvbmFyeSBhcmUgY29tbWEgc2VwYXJhdGVkIGFzIHN1Y2g6XG4gKlxuICogRmlyc3QgdGhlIG9mZnNldCBjb21wYXJlZCB0byBVVEMgdGltZSBpbiBtaW51dGVzLlxuICpcbiAqIFRoZW4gYSBmbGFnIHdoaWNoIGlzIDAgaWYgdGhlIHRpbWV6b25lIGRvZXMgbm90IHRha2UgZGF5bGlnaHQgc2F2aW5ncyBpbnRvIGFjY291bnQgYW5kIDEgaWYgaXRcbiAqIGRvZXMuXG4gKlxuICogVGhpcmRseSBhbiBvcHRpb25hbCAncycgc2lnbmlmaWVzIHRoYXQgdGhlIHRpbWV6b25lIGlzIGluIHRoZSBzb3V0aGVybiBoZW1pc3BoZXJlLFxuICogb25seSBpbnRlcmVzdGluZyBmb3IgdGltZXpvbmVzIHdpdGggRFNULlxuICpcbiAqIFRoZSBtYXBwZWQgYXJyYXlzIGlzIHVzZWQgZm9yIGNvbnN0cnVjdGluZyB0aGUganN0ei5UaW1lWm9uZSBvYmplY3QgZnJvbSB3aXRoaW5cbiAqIGpzdHouZGV0ZXJtaW5lKCk7XG4gKi9cbmpzdHoub2xzb24udGltZXpvbmVzID0ge1xuICAgICctNzIwLDAnOiAnRXRjL0dNVCsxMicsXG4gICAgJy02NjAsMCc6ICdQYWNpZmljL1BhZ29fUGFnbycsXG4gICAgJy02NjAsMSxzJzogJ1BhY2lmaWMvQXBpYScsIC8vIFdoeT8gQmVjYXVzZSB3aW5kb3dzLi4uIGNyeSFcbiAgICAnLTYwMCwxJzogJ0FtZXJpY2EvQWRhaycsXG4gICAgJy02MDAsMCc6ICdQYWNpZmljL0hvbm9sdWx1JyxcbiAgICAnLTU3MCwwJzogJ1BhY2lmaWMvTWFycXVlc2FzJyxcbiAgICAnLTU0MCwwJzogJ1BhY2lmaWMvR2FtYmllcicsXG4gICAgJy01NDAsMSc6ICdBbWVyaWNhL0FuY2hvcmFnZScsXG4gICAgJy00ODAsMSc6ICdBbWVyaWNhL0xvc19BbmdlbGVzJyxcbiAgICAnLTQ4MCwwJzogJ1BhY2lmaWMvUGl0Y2Fpcm4nLFxuICAgICctNDIwLDAnOiAnQW1lcmljYS9QaG9lbml4JyxcbiAgICAnLTQyMCwxJzogJ0FtZXJpY2EvRGVudmVyJyxcbiAgICAnLTM2MCwwJzogJ0FtZXJpY2EvR3VhdGVtYWxhJyxcbiAgICAnLTM2MCwxJzogJ0FtZXJpY2EvQ2hpY2FnbycsXG4gICAgJy0zNjAsMSxzJzogJ1BhY2lmaWMvRWFzdGVyJyxcbiAgICAnLTMwMCwwJzogJ0FtZXJpY2EvQm9nb3RhJyxcbiAgICAnLTMwMCwxJzogJ0FtZXJpY2EvTmV3X1lvcmsnLFxuICAgICctMjcwLDAnOiAnQW1lcmljYS9DYXJhY2FzJyxcbiAgICAnLTI0MCwxJzogJ0FtZXJpY2EvSGFsaWZheCcsXG4gICAgJy0yNDAsMCc6ICdBbWVyaWNhL1NhbnRvX0RvbWluZ28nLFxuICAgICctMjQwLDEscyc6ICdBbWVyaWNhL0FzdW5jaW9uJyxcbiAgICAnLTIxMCwxJzogJ0FtZXJpY2EvU3RfSm9obnMnLFxuICAgICctMTgwLDEnOiAnQW1lcmljYS9Hb2R0aGFiJyxcbiAgICAnLTE4MCwwJzogJ0FtZXJpY2EvQXJnZW50aW5hL0J1ZW5vc19BaXJlcycsXG4gICAgJy0xODAsMSxzJzogJ0FtZXJpY2EvTW9udGV2aWRlbycsXG4gICAgJy0xMjAsMCc6ICdBbWVyaWNhL05vcm9uaGEnLFxuICAgICctMTIwLDEnOiAnQW1lcmljYS9Ob3JvbmhhJyxcbiAgICAnLTYwLDEnOiAnQXRsYW50aWMvQXpvcmVzJyxcbiAgICAnLTYwLDAnOiAnQXRsYW50aWMvQ2FwZV9WZXJkZScsXG4gICAgJzAsMCc6ICdVVEMnLFxuICAgICcwLDEnOiAnRXVyb3BlL0xvbmRvbicsXG4gICAgJzYwLDEnOiAnRXVyb3BlL0JlcmxpbicsXG4gICAgJzYwLDAnOiAnQWZyaWNhL0xhZ29zJyxcbiAgICAnNjAsMSxzJzogJ0FmcmljYS9XaW5kaG9laycsXG4gICAgJzEyMCwxJzogJ0FzaWEvQmVpcnV0JyxcbiAgICAnMTIwLDAnOiAnQWZyaWNhL0pvaGFubmVzYnVyZycsXG4gICAgJzE4MCwwJzogJ0FzaWEvQmFnaGRhZCcsXG4gICAgJzE4MCwxJzogJ0V1cm9wZS9Nb3Njb3cnLFxuICAgICcyMTAsMSc6ICdBc2lhL1RlaHJhbicsXG4gICAgJzI0MCwwJzogJ0FzaWEvRHViYWknLFxuICAgICcyNDAsMSc6ICdBc2lhL0Jha3UnLFxuICAgICcyNzAsMCc6ICdBc2lhL0thYnVsJyxcbiAgICAnMzAwLDEnOiAnQXNpYS9ZZWthdGVyaW5idXJnJyxcbiAgICAnMzAwLDAnOiAnQXNpYS9LYXJhY2hpJyxcbiAgICAnMzMwLDAnOiAnQXNpYS9Lb2xrYXRhJyxcbiAgICAnMzQ1LDAnOiAnQXNpYS9LYXRobWFuZHUnLFxuICAgICczNjAsMCc6ICdBc2lhL0RoYWthJyxcbiAgICAnMzYwLDEnOiAnQXNpYS9PbXNrJyxcbiAgICAnMzkwLDAnOiAnQXNpYS9SYW5nb29uJyxcbiAgICAnNDIwLDEnOiAnQXNpYS9LcmFzbm95YXJzaycsXG4gICAgJzQyMCwwJzogJ0FzaWEvSmFrYXJ0YScsXG4gICAgJzQ4MCwwJzogJ0FzaWEvU2hhbmdoYWknLFxuICAgICc0ODAsMSc6ICdBc2lhL0lya3V0c2snLFxuICAgICc1MjUsMCc6ICdBdXN0cmFsaWEvRXVjbGEnLFxuICAgICc1MjUsMSxzJzogJ0F1c3RyYWxpYS9FdWNsYScsXG4gICAgJzU0MCwxJzogJ0FzaWEvWWFrdXRzaycsXG4gICAgJzU0MCwwJzogJ0FzaWEvVG9reW8nLFxuICAgICc1NzAsMCc6ICdBdXN0cmFsaWEvRGFyd2luJyxcbiAgICAnNTcwLDEscyc6ICdBdXN0cmFsaWEvQWRlbGFpZGUnLFxuICAgICc2MDAsMCc6ICdBdXN0cmFsaWEvQnJpc2JhbmUnLFxuICAgICc2MDAsMSc6ICdBc2lhL1ZsYWRpdm9zdG9rJyxcbiAgICAnNjAwLDEscyc6ICdBdXN0cmFsaWEvU3lkbmV5JyxcbiAgICAnNjMwLDEscyc6ICdBdXN0cmFsaWEvTG9yZF9Ib3dlJyxcbiAgICAnNjYwLDEnOiAnQXNpYS9LYW1jaGF0a2EnLFxuICAgICc2NjAsMCc6ICdQYWNpZmljL05vdW1lYScsXG4gICAgJzY5MCwwJzogJ1BhY2lmaWMvTm9yZm9saycsXG4gICAgJzcyMCwxLHMnOiAnUGFjaWZpYy9BdWNrbGFuZCcsXG4gICAgJzcyMCwwJzogJ1BhY2lmaWMvTWFqdXJvJyxcbiAgICAnNzY1LDEscyc6ICdQYWNpZmljL0NoYXRoYW0nLFxuICAgICc3ODAsMCc6ICdQYWNpZmljL1RvbmdhdGFwdScsXG4gICAgJzc4MCwxLHMnOiAnUGFjaWZpYy9BcGlhJyxcbiAgICAnODQwLDAnOiAnUGFjaWZpYy9LaXJpdGltYXRpJ1xufTtcblxuLyogQnVpbGQgdGltZTogMjAxNS0xMS0wMiAxMzowMTowMFogQnVpbGQgYnkgaW52b2tpbmcgcHl0aG9uIHV0aWxpdGllcy9kc3QucHkgZ2VuZXJhdGUgKi9cbmpzdHoub2xzb24uZHN0X3J1bGVzID0ge1xuICAgIFwieWVhcnNcIjogW1xuICAgICAgICAyMDA4LFxuICAgICAgICAyMDA5LFxuICAgICAgICAyMDEwLFxuICAgICAgICAyMDExLFxuICAgICAgICAyMDEyLFxuICAgICAgICAyMDEzLFxuICAgICAgICAyMDE0XG4gICAgXSxcbiAgICBcInpvbmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQWZyaWNhL0NhaXJvXCIsXG4gICAgICAgICAgICBcInJ1bGVzXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjE5OTU3MjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIwOTA3NDQwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI1MDgwMjAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyNDA1MjQwMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyODU4ODA0MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjg0MDY5NjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxNDExNjc4ODAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTQwNjg0NDAwMDAwMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQWZyaWNhL0Nhc2FibGFuY2FcIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMjAyMjM2MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjEyMjc4NDAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjUwODA5MjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTI0MzgxNDQwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI4MTIyMjAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyNzI3NTg0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzMTIwNjY4MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzAxNzg4ODAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzQ4OTcwNDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTM0NTQyODAwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTM4MjgzOTIwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzNzYxMDAwMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDE0MTQyODg4MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxNDA2OTQ0ODAwMDAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJBbWVyaWNhL0FzdW5jaW9uXCIsXG4gICAgICAgICAgICBcInJ1bGVzXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjA1MDMxNjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIyNDM4ODgwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTIzNjQ4MTIwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyNTU4Mzg0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyNzA5NTQ4MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjg2MDc4NDAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzAyNDA0NDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTMxNzUyODAwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTMzMzg1NDAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzNDk1ODI0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzNjQwOTQwMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzgxMDMyMDAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzk1NTQzNjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTQxMjQ4MTYwMDAwMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQW1lcmljYS9DYW1wb19HcmFuZGVcIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMDMyMTcyMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjI0Mzg4ODAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjM0NjY2ODAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTI1NTgzODQwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI2NjcyMTIwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyODcyODgwMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyOTgxNzA4MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzE4NzM3NjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzMwMjI1MjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTM1MDc5MjAwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTM2MTA3MDAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzODIyNDE2MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzOTI1MTk2MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxNDEzNjkxMjAwMDAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJBbWVyaWNhL0dvb3NlX0JheVwiLFxuICAgICAgICAgICAgXCJydWxlc1wiOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTIyNTU5NDg2MDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyMDUwMzUyNjAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyNTcwNDQ0NjAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjM2NDg0ODYwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjg5MDk4ODYwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTI2ODUzOTI2MDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTMyMDU1NTYwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyOTk5ODg4NjAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzNTIwMDUyMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzMxNDQ1NjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzgzNDU0ODAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTM2Mjg5NTIwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTQxNDkwNDQwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzOTQzNDQ4MDAwMDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkFtZXJpY2EvSGF2YW5hXCIsXG4gICAgICAgICAgICBcInJ1bGVzXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjI0OTk3MjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIwNTY0MzYwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI1NjQ0NjgwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyMzY0ODg0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyODg1MDEyMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjY4NTQyODAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzIxMTYwNDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTMwMDU5NzIwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTM1MjAwNTIwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzMzMyNTY0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzODM0NTQ4MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzYyODkxNjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxNDE0OTA0NDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTM5NDM0MTIwMDAwMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQW1lcmljYS9NYXphdGxhblwiLFxuICAgICAgICAgICAgXCJydWxlc1wiOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTIyNTAwODAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyMDc0NzI0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyNTY0NTc2MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjM4OTIyMDAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjg4NTEyMDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTI3MDM3MTYwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTMxOTk2MTYwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzMDE4MjEyMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzNTE0MTEyMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzMzMjcwODAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzgyODYwODAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTM2NTMyNTIwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTQxNDMxMDQwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzOTY3NzQ4MDAwMDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkFtZXJpY2EvTWV4aWNvX0NpdHlcIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMjUwMDQ0MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjA3NDY4ODAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjU2NDU0MDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIzODkxODQwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI4ODUwODQwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyNzAzNjgwMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzMTk5NTgwMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzAxODE3NjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzUxNDA3NjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTMzMzI2NzIwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTM4Mjg1NzIwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzNjUzMjE2MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDE0MTQzMDY4MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzk2NzcxMjAwMDAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJBbWVyaWNhL01pcXVlbG9uXCIsXG4gICAgICAgICAgICBcInJ1bGVzXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjI1NTk4NDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIwNTAzODgwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI1NzA0ODAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyMzY0ODg0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyODkxMDI0MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjY4NTQyODAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzIwNTUyMDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTI5OTk5MjQwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTM1MjAwMTYwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzMzE0NDIwMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzODM0NTEyMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzYyODkxNjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxNDE0OTAwODAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTM5NDM0MTIwMDAwMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQW1lcmljYS9TYW50YV9Jc2FiZWxcIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMjUwMTE2MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjA3NDc2MDAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjU2NDYxMjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIzODkyNTYwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI4ODUxNTYwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyNzAzNzUyMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzMTk5NjUyMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzAxODI0ODAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzUxNDE0ODAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTMzMzI3NDQwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTM4Mjg2NDQwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzNjUzMjg4MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDE0MTQzMTQwMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzk2Nzc4NDAwMDAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJBbWVyaWNhL1NhbnRpYWdvXCIsXG4gICAgICAgICAgICBcInJ1bGVzXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjA2ODQ2MDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIyMzc4NDAwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTIzNzA4NjAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyNTUyMzM2MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyNzAzNTAwMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjg2NjgzMjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzA0ODIzNjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTMxMzg5OTIwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTMzNTY2ODQwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzNDY1NTg0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzNjcxMTgwMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzc4NjEyODAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzk4NTY3NjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTQxMDA2MjQwMDAwMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQW1lcmljYS9TYW9fUGF1bG9cIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMDMyMTM2MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjI0Mzg1MjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjM0NjYzMjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTI1NTgzNDgwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI2NjcxNzYwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyODcyODQ0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyOTgxNjcyMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzE4NzM0MDAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzMwMjIxNjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTM1MDc4ODQwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTM2MTA2NjQwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzODIyMzgwMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzOTI1MTYwMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxNDEzNjg3NjAwMDAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJBc2lhL0FtbWFuXCIsXG4gICAgICAgICAgICBcInJ1bGVzXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjI1NDA0MDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIwNjY1NTIwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI1Njg1MzYwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyMzgxMDQ4MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyODgzMDMyMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjY5NTU0NDAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzE5NzUyODAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTMwMTYwODgwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTQxNDcwNjQwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzOTU5NTc2MDAwMDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkFzaWEvRGFtYXNjdXNcIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMjU0ODY4MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjA3MjYwMDAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjU2ODUwMDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIzODEwNDgwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI4ODI5OTYwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyNzAxNTkyMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzMTk3NDkyMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzAxNjA4ODAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzUxMTk4ODAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTMzMzA1ODQwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTM4MjY0ODQwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzNjQ1MDgwMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDE0MTQ3MDI4MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzk1OTU3NjAwMDAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJBc2lhL0R1YmFpXCIsXG4gICAgICAgICAgICBcInJ1bGVzXCI6IFtcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJBc2lhL0dhemFcIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMTk5NTcyMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjA2NjU1MjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjUyMDE1MjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIzODEwNDgwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI4MTQ3NDAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyNjk2NDA4NjAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzMTIxNDYwMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzAxNjA4ODYwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzQ4MTc4NDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTMzMzA1ODQwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTM4MDIyOTIwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzNjQ1MDgwMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDE0MTQwOTgwMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzk1OTU3NjAwMDAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJBc2lhL0lya3V0c2tcIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMjQ5NTc2MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjA2ODEzNjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjU2NDA3MjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIzODI2MzIwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI4ODQ2MTYwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyNjk3MTI4MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkFzaWEvSmVydXNhbGVtXCIsXG4gICAgICAgICAgICBcInJ1bGVzXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjIzMTYxMjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIwNjY2MjQwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI1NDAwNjAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyMzgxMTIwMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyODQyNDYwMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjY5NTYxNjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzE3NTEwMDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTMwMTYxNjAwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTM0ODM1NDgwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzMzMwNjU2MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzODI4Mjg0MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzY0NTE1MjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxNDE0Mjc4MDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTM5NTk2NDgwMDAwMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQXNpYS9LYW1jaGF0a2FcIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMjQ5NDMyMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjA2Nzk5MjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjU2MzkyODAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIzODI0ODgwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI4ODQ1MDgwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyNjk2OTg0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkFzaWEvS3Jhc25veWFyc2tcIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMjQ5NjEyMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjA2ODE3MjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjU2NDEwODAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIzODI2NjgwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI4ODQ2NTIwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyNjk3MTY0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkFzaWEvT21za1wiLFxuICAgICAgICAgICAgXCJydWxlc1wiOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTIyNDk2NDgwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyMDY4MjA4MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyNTY0MTQ0MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjM4MjcwNDAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjg4NDY4ODAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTI2OTcyMDAwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQXNpYS9WbGFkaXZvc3Rva1wiLFxuICAgICAgICAgICAgXCJydWxlc1wiOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTIyNDk1MDQwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyMDY4MDY0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyNTY0MDAwMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjM4MjU2MDAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjg4NDU0NDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTI2OTcwNTYwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQXNpYS9ZYWt1dHNrXCIsXG4gICAgICAgICAgICBcInJ1bGVzXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjI0OTU0MDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIwNjgxMDAwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI1NjQwMzYwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyMzgyNTk2MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyODg0NTgwMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjY5NzA5MjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJBc2lhL1lla2F0ZXJpbmJ1cmdcIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMjQ5Njg0MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjA2ODI0NDAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjU2NDE4MDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIzODI3NDAwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI4ODQ3MjQwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyNjk3MjM2MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkFzaWEvWWVyZXZhblwiLFxuICAgICAgICAgICAgXCJydWxlc1wiOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTIyNDk3MjAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyMDY4MjgwMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyNTY0MjE2MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjM4Mjc3NjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjg4NDc2MDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTI2OTcyNzIwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTMxOTkyNTYwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzMDExNzY4MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkF1c3RyYWxpYS9Mb3JkX0hvd2VcIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMDc0MDc2MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjIzMTM0MjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjM4ODU3MjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTI1NDU4MzgwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI3MDMwNjgwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyODYwMzM0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzMDE3NTY0MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzE3NDgzMDAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzMzMjA2MDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTM0OTUzNzQwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTM2NTI2MDQwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzODA5ODcwMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzOTY3MTAwMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxNDEyNDM2NjAwMDAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJBdXN0cmFsaWEvUGVydGhcIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMDY4MTM2MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjI0OTU3NjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJFdXJvcGUvSGVsc2lua2lcIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMjQ5ODI4MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjA2ODM4ODAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjU2NDMyNDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIzODI4ODQwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI4ODQ4NjgwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyNjk3MzgwMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzMTk5MzY0MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzAxMTg3NjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzUxMzg2MDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTMzMjYzNzIwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTM4MjgzNTYwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzNjQ2OTE2MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDE0MTQyODUyMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzk2MTQxMjAwMDAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJFdXJvcGUvTWluc2tcIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMjQ5NzkyMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjA2ODM1MjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjU2NDI4ODAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIzODI4NDgwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI4ODQ4MzIwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyNjk3MzQ0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkV1cm9wZS9Nb3Njb3dcIixcbiAgICAgICAgICAgIFwicnVsZXNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyMjQ5NzU2MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjA2ODMxNjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjU2NDI1MjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIzODI4MTIwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI4ODQ3OTYwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyNjk3MzA4MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlBhY2lmaWMvQXBpYVwiLFxuICAgICAgICAgICAgXCJydWxlc1wiOiBbXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTMwMTc1MjgwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzMTY4NzI4MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzMzMyMDI0MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzQ4OTI3MjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzY1MjU2ODAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTM4MDM3NjgwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTM5NjcwNjQwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDE0MTE4MjY0MDAwMDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlBhY2lmaWMvRmlqaVwiLFxuICAgICAgICAgICAgXCJydWxlc1wiOiBbXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI2OTY5ODQwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyODc4NDI0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzMjcxNTQ0MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzE5MjkyMDAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzU4NjA0MDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTM1MDc0MTYwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTM5MDA1MDAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzODI3OTYwMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDE0MjE1MDMyMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxNDE0ODUwNDAwMDAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJFdXJvcGUvTG9uZG9uXCIsXG4gICAgICAgICAgICBcInJ1bGVzXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMjI0OTgyODAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTIwNjgzODgwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTI1NjQzMjQwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEyMzgyODg0MDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEyODg0ODY4MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMjY5NzM4MDAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxMzE5OTM2NDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTMwMTE4NzYwMDAwMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImVcIjogMTM1MTM4NjAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzXCI6IDEzMzI2MzcyMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJlXCI6IDEzODI4MzU2MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIFwic1wiOiAxMzY0NjkxNjAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZVwiOiAxNDE0Mjg1MjAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInNcIjogMTM5NjE0MTIwMDAwMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIF1cbn07XG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganN0ejtcbn0gZWxzZSBpZiAoKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZSAhPT0gbnVsbCkgJiYgKGRlZmluZS5hbWQgIT0gbnVsbCkpIHtcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ganN0ejtcbiAgICB9KTtcbn0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiByb290ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW5kb3cuanN0eiA9IGpzdHo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5qc3R6ID0ganN0ejtcbiAgICB9XG59XG59KCkpO1xuIiwiLyohIGxpZ2h0c2xpZGVyIC0gdjEuMS42IC0gMjAxNi0xMC0yNVxuKiBodHRwczovL2dpdGh1Yi5jb20vc2FjaGluY2hvb2x1ci9saWdodHNsaWRlclxuKiBDb3B5cmlnaHQgKGMpIDIwMTYgU2FjaGluIE47IExpY2Vuc2VkIE1JVCAqL1xuIWZ1bmN0aW9uKGEsYil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGM9e2l0ZW06MyxhdXRvV2lkdGg6ITEsc2xpZGVNb3ZlOjEsc2xpZGVNYXJnaW46MTAsYWRkQ2xhc3M6XCJcIixtb2RlOlwic2xpZGVcIix1c2VDU1M6ITAsY3NzRWFzaW5nOlwiZWFzZVwiLGVhc2luZzpcImxpbmVhclwiLHNwZWVkOjQwMCxhdXRvOiExLHBhdXNlT25Ib3ZlcjohMSxsb29wOiExLHNsaWRlRW5kQW5pbWF0aW9uOiEwLHBhdXNlOjJlMyxrZXlQcmVzczohMSxjb250cm9sczohMCxwcmV2SHRtbDpcIlwiLG5leHRIdG1sOlwiXCIscnRsOiExLGFkYXB0aXZlSGVpZ2h0OiExLHZlcnRpY2FsOiExLHZlcnRpY2FsSGVpZ2h0OjUwMCx2VGh1bWJXaWR0aDoxMDAsdGh1bWJJdGVtOjEwLHBhZ2VyOiEwLGdhbGxlcnk6ITEsZ2FsbGVyeU1hcmdpbjo1LHRodW1iTWFyZ2luOjUsY3VycmVudFBhZ2VyUG9zaXRpb246XCJtaWRkbGVcIixlbmFibGVUb3VjaDohMCxlbmFibGVEcmFnOiEwLGZyZWVNb3ZlOiEwLHN3aXBlVGhyZXNob2xkOjQwLHJlc3BvbnNpdmU6W10sb25CZWZvcmVTdGFydDpmdW5jdGlvbihhKXt9LG9uU2xpZGVyTG9hZDpmdW5jdGlvbihhKXt9LG9uQmVmb3JlU2xpZGU6ZnVuY3Rpb24oYSxiKXt9LG9uQWZ0ZXJTbGlkZTpmdW5jdGlvbihhLGIpe30sb25CZWZvcmVOZXh0U2xpZGU6ZnVuY3Rpb24oYSxiKXt9LG9uQmVmb3JlUHJldlNsaWRlOmZ1bmN0aW9uKGEsYil7fX07YS5mbi5saWdodFNsaWRlcj1mdW5jdGlvbihiKXtpZigwPT09dGhpcy5sZW5ndGgpcmV0dXJuIHRoaXM7aWYodGhpcy5sZW5ndGg+MSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5saWdodFNsaWRlcihiKX0pLHRoaXM7dmFyIGQ9e30sZT1hLmV4dGVuZCghMCx7fSxjLGIpLGY9e30sZz10aGlzO2QuJGVsPXRoaXMsXCJmYWRlXCI9PT1lLm1vZGUmJihlLnZlcnRpY2FsPSExKTt2YXIgaD1nLmNoaWxkcmVuKCksaT1hKHdpbmRvdykud2lkdGgoKSxqPW51bGwsaz1udWxsLGw9MCxtPTAsbj0hMSxvPTAscD1cIlwiLHE9MCxyPWUudmVydGljYWw9PT0hMD9cImhlaWdodFwiOlwid2lkdGhcIixzPWUudmVydGljYWw9PT0hMD9cIm1hcmdpbi1ib3R0b21cIjpcIm1hcmdpbi1yaWdodFwiLHQ9MCx1PTAsdj0wLHc9MCx4PW51bGwseT1cIm9udG91Y2hzdGFydFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHo9e307cmV0dXJuIHouY2hicmVha3BvaW50PWZ1bmN0aW9uKCl7aWYoaT1hKHdpbmRvdykud2lkdGgoKSxlLnJlc3BvbnNpdmUubGVuZ3RoKXt2YXIgYjtpZihlLmF1dG9XaWR0aD09PSExJiYoYj1lLml0ZW0pLGk8ZS5yZXNwb25zaXZlWzBdLmJyZWFrcG9pbnQpZm9yKHZhciBjPTA7YzxlLnJlc3BvbnNpdmUubGVuZ3RoO2MrKylpPGUucmVzcG9uc2l2ZVtjXS5icmVha3BvaW50JiYoaj1lLnJlc3BvbnNpdmVbY10uYnJlYWtwb2ludCxrPWUucmVzcG9uc2l2ZVtjXSk7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGsmJm51bGwhPT1rKWZvcih2YXIgZCBpbiBrLnNldHRpbmdzKWsuc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoZCkmJigoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGZbZF18fG51bGw9PT1mW2RdKSYmKGZbZF09ZVtkXSksZVtkXT1rLnNldHRpbmdzW2RdKTtpZighYS5pc0VtcHR5T2JqZWN0KGYpJiZpPmUucmVzcG9uc2l2ZVswXS5icmVha3BvaW50KWZvcih2YXIgZyBpbiBmKWYuaGFzT3duUHJvcGVydHkoZykmJihlW2ddPWZbZ10pO2UuYXV0b1dpZHRoPT09ITEmJnQ+MCYmdj4wJiZiIT09ZS5pdGVtJiYocT1NYXRoLnJvdW5kKHQvKCh2K2Uuc2xpZGVNYXJnaW4pKmUuc2xpZGVNb3ZlKSkpfX0sei5jYWxTVz1mdW5jdGlvbigpe2UuYXV0b1dpZHRoPT09ITEmJih2PShvLShlLml0ZW0qZS5zbGlkZU1hcmdpbi1lLnNsaWRlTWFyZ2luKSkvZS5pdGVtKX0sei5jYWxXaWR0aD1mdW5jdGlvbihhKXt2YXIgYj1hPT09ITA/cC5maW5kKFwiLmxzbGlkZVwiKS5sZW5ndGg6aC5sZW5ndGg7aWYoZS5hdXRvV2lkdGg9PT0hMSltPWIqKHYrZS5zbGlkZU1hcmdpbik7ZWxzZXttPTA7Zm9yKHZhciBjPTA7Yj5jO2MrKyltKz1wYXJzZUludChoLmVxKGMpLndpZHRoKCkpK2Uuc2xpZGVNYXJnaW59cmV0dXJuIG19LGQ9e2RvQ3NzOmZ1bmN0aW9uKCl7dmFyIGE9ZnVuY3Rpb24oKXtmb3IodmFyIGE9W1widHJhbnNpdGlvblwiLFwiTW96VHJhbnNpdGlvblwiLFwiV2Via2l0VHJhbnNpdGlvblwiLFwiT1RyYW5zaXRpb25cIixcIm1zVHJhbnNpdGlvblwiLFwiS2h0bWxUcmFuc2l0aW9uXCJdLGI9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGM9MDtjPGEubGVuZ3RoO2MrKylpZihhW2NdaW4gYi5zdHlsZSlyZXR1cm4hMH07cmV0dXJuIGUudXNlQ1NTJiZhKCk/ITA6ITF9LGtleVByZXNzOmZ1bmN0aW9uKCl7ZS5rZXlQcmVzcyYmYShkb2N1bWVudCkub24oXCJrZXl1cC5saWdodHNsaWRlclwiLGZ1bmN0aW9uKGIpe2EoXCI6Zm9jdXNcIikuaXMoXCJpbnB1dCwgdGV4dGFyZWFcIil8fChiLnByZXZlbnREZWZhdWx0P2IucHJldmVudERlZmF1bHQoKTpiLnJldHVyblZhbHVlPSExLDM3PT09Yi5rZXlDb2RlP2cuZ29Ub1ByZXZTbGlkZSgpOjM5PT09Yi5rZXlDb2RlJiZnLmdvVG9OZXh0U2xpZGUoKSl9KX0sY29udHJvbHM6ZnVuY3Rpb24oKXtlLmNvbnRyb2xzJiYoZy5hZnRlcignPGRpdiBjbGFzcz1cImxTQWN0aW9uXCI+PGEgY2xhc3M9XCJsU1ByZXZcIj4nK2UucHJldkh0bWwrJzwvYT48YSBjbGFzcz1cImxTTmV4dFwiPicrZS5uZXh0SHRtbCtcIjwvYT48L2Rpdj5cIiksZS5hdXRvV2lkdGg/ei5jYWxXaWR0aCghMSk8byYmcC5maW5kKFwiLmxTQWN0aW9uXCIpLmhpZGUoKTpsPD1lLml0ZW0mJnAuZmluZChcIi5sU0FjdGlvblwiKS5oaWRlKCkscC5maW5kKFwiLmxTQWN0aW9uIGFcIikub24oXCJjbGlja1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnByZXZlbnREZWZhdWx0P2IucHJldmVudERlZmF1bHQoKTpiLnJldHVyblZhbHVlPSExLFwibFNQcmV2XCI9PT1hKHRoaXMpLmF0dHIoXCJjbGFzc1wiKT9nLmdvVG9QcmV2U2xpZGUoKTpnLmdvVG9OZXh0U2xpZGUoKSwhMX0pKX0saW5pdGlhbFN0eWxlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcztcImZhZGVcIj09PWUubW9kZSYmKGUuYXV0b1dpZHRoPSExLGUuc2xpZGVFbmRBbmltYXRpb249ITEpLGUuYXV0byYmKGUuc2xpZGVFbmRBbmltYXRpb249ITEpLGUuYXV0b1dpZHRoJiYoZS5zbGlkZU1vdmU9MSxlLml0ZW09MSksZS5sb29wJiYoZS5zbGlkZU1vdmU9MSxlLmZyZWVNb3ZlPSExKSxlLm9uQmVmb3JlU3RhcnQuY2FsbCh0aGlzLGcpLHouY2hicmVha3BvaW50KCksZy5hZGRDbGFzcyhcImxpZ2h0U2xpZGVyXCIpLndyYXAoJzxkaXYgY2xhc3M9XCJsU1NsaWRlT3V0ZXIgJytlLmFkZENsYXNzKydcIj48ZGl2IGNsYXNzPVwibFNTbGlkZVdyYXBwZXJcIj48L2Rpdj48L2Rpdj4nKSxwPWcucGFyZW50KFwiLmxTU2xpZGVXcmFwcGVyXCIpLGUucnRsPT09ITAmJnAucGFyZW50KCkuYWRkQ2xhc3MoXCJsU3J0bFwiKSxlLnZlcnRpY2FsPyhwLnBhcmVudCgpLmFkZENsYXNzKFwidmVydGljYWxcIiksbz1lLnZlcnRpY2FsSGVpZ2h0LHAuY3NzKFwiaGVpZ2h0XCIsbytcInB4XCIpKTpvPWcub3V0ZXJXaWR0aCgpLGguYWRkQ2xhc3MoXCJsc2xpZGVcIiksZS5sb29wPT09ITAmJlwic2xpZGVcIj09PWUubW9kZSYmKHouY2FsU1coKSx6LmNsb25lPWZ1bmN0aW9uKCl7aWYoei5jYWxXaWR0aCghMCk+byl7Zm9yKHZhciBiPTAsYz0wLGQ9MDtkPGgubGVuZ3RoJiYoYis9cGFyc2VJbnQoZy5maW5kKFwiLmxzbGlkZVwiKS5lcShkKS53aWR0aCgpKStlLnNsaWRlTWFyZ2luLGMrKywhKGI+PW8rZS5zbGlkZU1hcmdpbikpO2QrKyk7dmFyIGY9ZS5hdXRvV2lkdGg9PT0hMD9jOmUuaXRlbTtpZihmPGcuZmluZChcIi5jbG9uZS5sZWZ0XCIpLmxlbmd0aClmb3IodmFyIGk9MDtpPGcuZmluZChcIi5jbG9uZS5sZWZ0XCIpLmxlbmd0aC1mO2krKyloLmVxKGkpLnJlbW92ZSgpO2lmKGY8Zy5maW5kKFwiLmNsb25lLnJpZ2h0XCIpLmxlbmd0aClmb3IodmFyIGo9aC5sZW5ndGgtMTtqPmgubGVuZ3RoLTEtZy5maW5kKFwiLmNsb25lLnJpZ2h0XCIpLmxlbmd0aDtqLS0pcS0tLGguZXEoaikucmVtb3ZlKCk7Zm9yKHZhciBrPWcuZmluZChcIi5jbG9uZS5yaWdodFwiKS5sZW5ndGg7Zj5rO2srKylnLmZpbmQoXCIubHNsaWRlXCIpLmVxKGspLmNsb25lKCkucmVtb3ZlQ2xhc3MoXCJsc2xpZGVcIikuYWRkQ2xhc3MoXCJjbG9uZSByaWdodFwiKS5hcHBlbmRUbyhnKSxxKys7Zm9yKHZhciBsPWcuZmluZChcIi5sc2xpZGVcIikubGVuZ3RoLWcuZmluZChcIi5jbG9uZS5sZWZ0XCIpLmxlbmd0aDtsPmcuZmluZChcIi5sc2xpZGVcIikubGVuZ3RoLWY7bC0tKWcuZmluZChcIi5sc2xpZGVcIikuZXEobC0xKS5jbG9uZSgpLnJlbW92ZUNsYXNzKFwibHNsaWRlXCIpLmFkZENsYXNzKFwiY2xvbmUgbGVmdFwiKS5wcmVwZW5kVG8oZyk7aD1nLmNoaWxkcmVuKCl9ZWxzZSBoLmhhc0NsYXNzKFwiY2xvbmVcIikmJihnLmZpbmQoXCIuY2xvbmVcIikucmVtb3ZlKCksYS5tb3ZlKGcsMCkpfSx6LmNsb25lKCkpLHouc1NXPWZ1bmN0aW9uKCl7bD1oLmxlbmd0aCxlLnJ0bD09PSEwJiZlLnZlcnRpY2FsPT09ITEmJihzPVwibWFyZ2luLWxlZnRcIiksZS5hdXRvV2lkdGg9PT0hMSYmaC5jc3Mocix2K1wicHhcIiksaC5jc3MocyxlLnNsaWRlTWFyZ2luK1wicHhcIiksbT16LmNhbFdpZHRoKCExKSxnLmNzcyhyLG0rXCJweFwiKSxlLmxvb3A9PT0hMCYmXCJzbGlkZVwiPT09ZS5tb2RlJiZuPT09ITEmJihxPWcuZmluZChcIi5jbG9uZS5sZWZ0XCIpLmxlbmd0aCl9LHouY2FsTD1mdW5jdGlvbigpe2g9Zy5jaGlsZHJlbigpLGw9aC5sZW5ndGh9LHRoaXMuZG9Dc3MoKSYmcC5hZGRDbGFzcyhcInVzaW5nQ3NzXCIpLHouY2FsTCgpLFwic2xpZGVcIj09PWUubW9kZT8oei5jYWxTVygpLHouc1NXKCksZS5sb29wPT09ITAmJih0PWEuc2xpZGVWYWx1ZSgpLHRoaXMubW92ZShnLHQpKSxlLnZlcnRpY2FsPT09ITEmJnRoaXMuc2V0SGVpZ2h0KGcsITEpKToodGhpcy5zZXRIZWlnaHQoZywhMCksZy5hZGRDbGFzcyhcImxTRmFkZVwiKSx0aGlzLmRvQ3NzKCl8fChoLmZhZGVPdXQoMCksaC5lcShxKS5mYWRlSW4oMCkpKSxlLmxvb3A9PT0hMCYmXCJzbGlkZVwiPT09ZS5tb2RlP2guZXEocSkuYWRkQ2xhc3MoXCJhY3RpdmVcIik6aC5maXJzdCgpLmFkZENsYXNzKFwiYWN0aXZlXCIpfSxwYWdlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXM7aWYoei5jcmVhdGVQYWdlcj1mdW5jdGlvbigpe3c9KG8tKGUudGh1bWJJdGVtKmUudGh1bWJNYXJnaW4tZS50aHVtYk1hcmdpbikpL2UudGh1bWJJdGVtO3ZhciBiPXAuZmluZChcIi5sc2xpZGVcIiksYz1wLmZpbmQoXCIubHNsaWRlXCIpLmxlbmd0aCxkPTAsZj1cIlwiLGg9MDtmb3IoZD0wO2M+ZDtkKyspe1wic2xpZGVcIj09PWUubW9kZSYmKGUuYXV0b1dpZHRoP2grPShwYXJzZUludChiLmVxKGQpLndpZHRoKCkpK2Uuc2xpZGVNYXJnaW4pKmUuc2xpZGVNb3ZlOmg9ZCooditlLnNsaWRlTWFyZ2luKSplLnNsaWRlTW92ZSk7dmFyIGk9Yi5lcShkKmUuc2xpZGVNb3ZlKS5hdHRyKFwiZGF0YS10aHVtYlwiKTtpZihmKz1lLmdhbGxlcnk9PT0hMD8nPGxpIHN0eWxlPVwid2lkdGg6MTAwJTsnK3IrXCI6XCIrdytcInB4O1wiK3MrXCI6XCIrZS50aHVtYk1hcmdpbisncHhcIj48YSBocmVmPVwiI1wiPjxpbWcgc3JjPVwiJytpKydcIiAvPjwvYT48L2xpPic6JzxsaT48YSBocmVmPVwiI1wiPicrKGQrMSkrXCI8L2E+PC9saT5cIixcInNsaWRlXCI9PT1lLm1vZGUmJmg+PW0tby1lLnNsaWRlTWFyZ2luKXtkKz0xO3ZhciBqPTI7ZS5hdXRvV2lkdGgmJihmKz0nPGxpPjxhIGhyZWY9XCIjXCI+JysoZCsxKStcIjwvYT48L2xpPlwiLGo9MSksaj5kPyhmPW51bGwscC5wYXJlbnQoKS5hZGRDbGFzcyhcIm5vUGFnZXJcIikpOnAucGFyZW50KCkucmVtb3ZlQ2xhc3MoXCJub1BhZ2VyXCIpO2JyZWFrfX12YXIgaz1wLnBhcmVudCgpO2suZmluZChcIi5sU1BhZ2VyXCIpLmh0bWwoZiksZS5nYWxsZXJ5PT09ITAmJihlLnZlcnRpY2FsPT09ITAmJmsuZmluZChcIi5sU1BhZ2VyXCIpLmNzcyhcIndpZHRoXCIsZS52VGh1bWJXaWR0aCtcInB4XCIpLHU9ZCooZS50aHVtYk1hcmdpbit3KSsuNSxrLmZpbmQoXCIubFNQYWdlclwiKS5jc3Moe3Byb3BlcnR5OnUrXCJweFwiLFwidHJhbnNpdGlvbi1kdXJhdGlvblwiOmUuc3BlZWQrXCJtc1wifSksZS52ZXJ0aWNhbD09PSEwJiZwLnBhcmVudCgpLmNzcyhcInBhZGRpbmctcmlnaHRcIixlLnZUaHVtYldpZHRoK2UuZ2FsbGVyeU1hcmdpbitcInB4XCIpLGsuZmluZChcIi5sU1BhZ2VyXCIpLmNzcyhyLHUrXCJweFwiKSk7dmFyIGw9ay5maW5kKFwiLmxTUGFnZXJcIikuZmluZChcImxpXCIpO2wuZmlyc3QoKS5hZGRDbGFzcyhcImFjdGl2ZVwiKSxsLm9uKFwiY2xpY2tcIixmdW5jdGlvbigpe3JldHVybiBlLmxvb3A9PT0hMCYmXCJzbGlkZVwiPT09ZS5tb2RlP3ErPWwuaW5kZXgodGhpcyktay5maW5kKFwiLmxTUGFnZXJcIikuZmluZChcImxpLmFjdGl2ZVwiKS5pbmRleCgpOnE9bC5pbmRleCh0aGlzKSxnLm1vZGUoITEpLGUuZ2FsbGVyeT09PSEwJiZhLnNsaWRlVGh1bWIoKSwhMX0pfSxlLnBhZ2VyKXt2YXIgYj1cImxTcGdcIjtlLmdhbGxlcnkmJihiPVwibFNHYWxsZXJ5XCIpLHAuYWZ0ZXIoJzx1bCBjbGFzcz1cImxTUGFnZXIgJytiKydcIj48L3VsPicpO3ZhciBjPWUudmVydGljYWw/XCJtYXJnaW4tbGVmdFwiOlwibWFyZ2luLXRvcFwiO3AucGFyZW50KCkuZmluZChcIi5sU1BhZ2VyXCIpLmNzcyhjLGUuZ2FsbGVyeU1hcmdpbitcInB4XCIpLHouY3JlYXRlUGFnZXIoKX1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ei5pbml0KCl9LDApfSxzZXRIZWlnaHQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz1udWxsLGQ9dGhpcztjPWUubG9vcD9hLmNoaWxkcmVuKFwiLmxzbGlkZSBcIikuZmlyc3QoKTphLmNoaWxkcmVuKCkuZmlyc3QoKTt2YXIgZj1mdW5jdGlvbigpe3ZhciBkPWMub3V0ZXJIZWlnaHQoKSxlPTAsZj1kO2ImJihkPTAsZT0xMDAqZi9vKSxhLmNzcyh7aGVpZ2h0OmQrXCJweFwiLFwicGFkZGluZy1ib3R0b21cIjplK1wiJVwifSl9O2YoKSxjLmZpbmQoXCJpbWdcIikubGVuZ3RoP2MuZmluZChcImltZ1wiKVswXS5jb21wbGV0ZT8oZigpLHh8fGQuYXV0bygpKTpjLmZpbmQoXCJpbWdcIikub24oXCJsb2FkXCIsZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZigpLHh8fGQuYXV0bygpfSwxMDApfSk6eHx8ZC5hdXRvKCl9LGFjdGl2ZTpmdW5jdGlvbihhLGIpe3RoaXMuZG9Dc3MoKSYmXCJmYWRlXCI9PT1lLm1vZGUmJnAuYWRkQ2xhc3MoXCJvblwiKTt2YXIgYz0wO2lmKHEqZS5zbGlkZU1vdmU8bCl7YS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKSx0aGlzLmRvQ3NzKCl8fFwiZmFkZVwiIT09ZS5tb2RlfHxiIT09ITF8fGEuZmFkZU91dChlLnNwZWVkKSxjPWI9PT0hMD9xOnEqZS5zbGlkZU1vdmU7dmFyIGQsZjtiPT09ITAmJihkPWEubGVuZ3RoLGY9ZC0xLGMrMT49ZCYmKGM9ZikpLGUubG9vcD09PSEwJiZcInNsaWRlXCI9PT1lLm1vZGUmJihjPWI9PT0hMD9xLWcuZmluZChcIi5jbG9uZS5sZWZ0XCIpLmxlbmd0aDpxKmUuc2xpZGVNb3ZlLGI9PT0hMCYmKGQ9YS5sZW5ndGgsZj1kLTEsYysxPT09ZD9jPWY6YysxPmQmJihjPTApKSksdGhpcy5kb0NzcygpfHxcImZhZGVcIiE9PWUubW9kZXx8YiE9PSExfHxhLmVxKGMpLmZhZGVJbihlLnNwZWVkKSxhLmVxKGMpLmFkZENsYXNzKFwiYWN0aXZlXCIpfWVsc2UgYS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKSxhLmVxKGEubGVuZ3RoLTEpLmFkZENsYXNzKFwiYWN0aXZlXCIpLHRoaXMuZG9Dc3MoKXx8XCJmYWRlXCIhPT1lLm1vZGV8fGIhPT0hMXx8KGEuZmFkZU91dChlLnNwZWVkKSxhLmVxKGMpLmZhZGVJbihlLnNwZWVkKSl9LG1vdmU6ZnVuY3Rpb24oYSxiKXtlLnJ0bD09PSEwJiYoYj0tYiksdGhpcy5kb0NzcygpP2EuY3NzKGUudmVydGljYWw9PT0hMD97dHJhbnNmb3JtOlwidHJhbnNsYXRlM2QoMHB4LCBcIistYitcInB4LCAwcHgpXCIsXCItd2Via2l0LXRyYW5zZm9ybVwiOlwidHJhbnNsYXRlM2QoMHB4LCBcIistYitcInB4LCAwcHgpXCJ9Ont0cmFuc2Zvcm06XCJ0cmFuc2xhdGUzZChcIistYitcInB4LCAwcHgsIDBweClcIixcIi13ZWJraXQtdHJhbnNmb3JtXCI6XCJ0cmFuc2xhdGUzZChcIistYitcInB4LCAwcHgsIDBweClcIn0pOmUudmVydGljYWw9PT0hMD9hLmNzcyhcInBvc2l0aW9uXCIsXCJyZWxhdGl2ZVwiKS5hbmltYXRlKHt0b3A6LWIrXCJweFwifSxlLnNwZWVkLGUuZWFzaW5nKTphLmNzcyhcInBvc2l0aW9uXCIsXCJyZWxhdGl2ZVwiKS5hbmltYXRlKHtsZWZ0Oi1iK1wicHhcIn0sZS5zcGVlZCxlLmVhc2luZyk7dmFyIGM9cC5wYXJlbnQoKS5maW5kKFwiLmxTUGFnZXJcIikuZmluZChcImxpXCIpO3RoaXMuYWN0aXZlKGMsITApfSxmYWRlOmZ1bmN0aW9uKCl7dGhpcy5hY3RpdmUoaCwhMSk7dmFyIGE9cC5wYXJlbnQoKS5maW5kKFwiLmxTUGFnZXJcIikuZmluZChcImxpXCIpO3RoaXMuYWN0aXZlKGEsITApfSxzbGlkZTpmdW5jdGlvbigpe3ZhciBhPXRoaXM7ei5jYWxTbGlkZT1mdW5jdGlvbigpe20+byYmKHQ9YS5zbGlkZVZhbHVlKCksYS5hY3RpdmUoaCwhMSksdD5tLW8tZS5zbGlkZU1hcmdpbj90PW0tby1lLnNsaWRlTWFyZ2luOjA+dCYmKHQ9MCksYS5tb3ZlKGcsdCksZS5sb29wPT09ITAmJlwic2xpZGVcIj09PWUubW9kZSYmKHE+PWwtZy5maW5kKFwiLmNsb25lLmxlZnRcIikubGVuZ3RoL2Uuc2xpZGVNb3ZlJiZhLnJlc2V0U2xpZGUoZy5maW5kKFwiLmNsb25lLmxlZnRcIikubGVuZ3RoKSwwPT09cSYmYS5yZXNldFNsaWRlKHAuZmluZChcIi5sc2xpZGVcIikubGVuZ3RoKSkpfSx6LmNhbFNsaWRlKCl9LHJlc2V0U2xpZGU6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztwLmZpbmQoXCIubFNBY3Rpb24gYVwiKS5hZGRDbGFzcyhcImRpc2FibGVkXCIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtxPWEscC5jc3MoXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsXCIwbXNcIiksdD1iLnNsaWRlVmFsdWUoKSxiLmFjdGl2ZShoLCExKSxkLm1vdmUoZyx0KSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cC5jc3MoXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsZS5zcGVlZCtcIm1zXCIpLHAuZmluZChcIi5sU0FjdGlvbiBhXCIpLnJlbW92ZUNsYXNzKFwiZGlzYWJsZWRcIil9LDUwKX0sZS5zcGVlZCsxMDApfSxzbGlkZVZhbHVlOmZ1bmN0aW9uKCl7dmFyIGE9MDtpZihlLmF1dG9XaWR0aD09PSExKWE9cSooditlLnNsaWRlTWFyZ2luKSplLnNsaWRlTW92ZTtlbHNle2E9MDtmb3IodmFyIGI9MDtxPmI7YisrKWErPXBhcnNlSW50KGguZXEoYikud2lkdGgoKSkrZS5zbGlkZU1hcmdpbn1yZXR1cm4gYX0sc2xpZGVUaHVtYjpmdW5jdGlvbigpe3ZhciBhO3N3aXRjaChlLmN1cnJlbnRQYWdlclBvc2l0aW9uKXtjYXNlXCJsZWZ0XCI6YT0wO2JyZWFrO2Nhc2VcIm1pZGRsZVwiOmE9by8yLXcvMjticmVhaztjYXNlXCJyaWdodFwiOmE9by13fXZhciBiPXEtZy5maW5kKFwiLmNsb25lLmxlZnRcIikubGVuZ3RoLGM9cC5wYXJlbnQoKS5maW5kKFwiLmxTUGFnZXJcIik7XCJzbGlkZVwiPT09ZS5tb2RlJiZlLmxvb3A9PT0hMCYmKGI+PWMuY2hpbGRyZW4oKS5sZW5ndGg/Yj0wOjA+YiYmKGI9Yy5jaGlsZHJlbigpLmxlbmd0aCkpO3ZhciBkPWIqKHcrZS50aHVtYk1hcmdpbiktYTtkK28+dSYmKGQ9dS1vLWUudGh1bWJNYXJnaW4pLDA+ZCYmKGQ9MCksdGhpcy5tb3ZlKGMsZCl9LGF1dG86ZnVuY3Rpb24oKXtlLmF1dG8mJihjbGVhckludGVydmFsKHgpLHg9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtnLmdvVG9OZXh0U2xpZGUoKX0sZS5wYXVzZSkpfSxwYXVzZU9uSG92ZXI6ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2UuYXV0byYmZS5wYXVzZU9uSG92ZXImJihwLm9uKFwibW91c2VlbnRlclwiLGZ1bmN0aW9uKCl7YSh0aGlzKS5hZGRDbGFzcyhcImxzLWhvdmVyXCIpLGcucGF1c2UoKSxlLmF1dG89ITB9KSxwLm9uKFwibW91c2VsZWF2ZVwiLGZ1bmN0aW9uKCl7YSh0aGlzKS5yZW1vdmVDbGFzcyhcImxzLWhvdmVyXCIpLHAuZmluZChcIi5saWdodFNsaWRlclwiKS5oYXNDbGFzcyhcImxzR3JhYmJpbmdcIil8fGIuYXV0bygpfSkpfSx0b3VjaE1vdmU6ZnVuY3Rpb24oYSxiKXtpZihwLmNzcyhcInRyYW5zaXRpb24tZHVyYXRpb25cIixcIjBtc1wiKSxcInNsaWRlXCI9PT1lLm1vZGUpe3ZhciBjPWEtYixkPXQtYztpZihkPj1tLW8tZS5zbGlkZU1hcmdpbilpZihlLmZyZWVNb3ZlPT09ITEpZD1tLW8tZS5zbGlkZU1hcmdpbjtlbHNle3ZhciBmPW0tby1lLnNsaWRlTWFyZ2luO2Q9ZisoZC1mKS81fWVsc2UgMD5kJiYoZS5mcmVlTW92ZT09PSExP2Q9MDpkLz01KTt0aGlzLm1vdmUoZyxkKX19LHRvdWNoRW5kOmZ1bmN0aW9uKGEpe2lmKHAuY3NzKFwidHJhbnNpdGlvbi1kdXJhdGlvblwiLGUuc3BlZWQrXCJtc1wiKSxcInNsaWRlXCI9PT1lLm1vZGUpe3ZhciBiPSExLGM9ITA7dC09YSx0Pm0tby1lLnNsaWRlTWFyZ2luPyh0PW0tby1lLnNsaWRlTWFyZ2luLGUuYXV0b1dpZHRoPT09ITEmJihiPSEwKSk6MD50JiYodD0wKTt2YXIgZD1mdW5jdGlvbihhKXt2YXIgYz0wO2lmKGJ8fGEmJihjPTEpLGUuYXV0b1dpZHRoKWZvcih2YXIgZD0wLGY9MDtmPGgubGVuZ3RoJiYoZCs9cGFyc2VJbnQoaC5lcShmKS53aWR0aCgpKStlLnNsaWRlTWFyZ2luLHE9ZitjLCEoZD49dCkpO2YrKyk7ZWxzZXt2YXIgZz10LygoditlLnNsaWRlTWFyZ2luKSplLnNsaWRlTW92ZSk7cT1wYXJzZUludChnKStjLHQ+PW0tby1lLnNsaWRlTWFyZ2luJiZnJTEhPT0wJiZxKyt9fTthPj1lLnN3aXBlVGhyZXNob2xkPyhkKCExKSxjPSExKTphPD0tZS5zd2lwZVRocmVzaG9sZCYmKGQoITApLGM9ITEpLGcubW9kZShjKSx0aGlzLnNsaWRlVGh1bWIoKX1lbHNlIGE+PWUuc3dpcGVUaHJlc2hvbGQ/Zy5nb1RvUHJldlNsaWRlKCk6YTw9LWUuc3dpcGVUaHJlc2hvbGQmJmcuZ29Ub05leHRTbGlkZSgpfSxlbmFibGVEcmFnOmZ1bmN0aW9uKCl7dmFyIGI9dGhpcztpZigheSl7dmFyIGM9MCxkPTAsZj0hMTtwLmZpbmQoXCIubGlnaHRTbGlkZXJcIikuYWRkQ2xhc3MoXCJsc0dyYWJcIikscC5vbihcIm1vdXNlZG93blwiLGZ1bmN0aW9uKGIpe3JldHVybiBvPm0mJjAhPT1tPyExOnZvaWQoXCJsU1ByZXZcIiE9PWEoYi50YXJnZXQpLmF0dHIoXCJjbGFzc1wiKSYmXCJsU05leHRcIiE9PWEoYi50YXJnZXQpLmF0dHIoXCJjbGFzc1wiKSYmKGM9ZS52ZXJ0aWNhbD09PSEwP2IucGFnZVk6Yi5wYWdlWCxmPSEwLGIucHJldmVudERlZmF1bHQ/Yi5wcmV2ZW50RGVmYXVsdCgpOmIucmV0dXJuVmFsdWU9ITEscC5zY3JvbGxMZWZ0Kz0xLHAuc2Nyb2xsTGVmdC09MSxwLmZpbmQoXCIubGlnaHRTbGlkZXJcIikucmVtb3ZlQ2xhc3MoXCJsc0dyYWJcIikuYWRkQ2xhc3MoXCJsc0dyYWJiaW5nXCIpLGNsZWFySW50ZXJ2YWwoeCkpKX0pLGEod2luZG93KS5vbihcIm1vdXNlbW92ZVwiLGZ1bmN0aW9uKGEpe2YmJihkPWUudmVydGljYWw9PT0hMD9hLnBhZ2VZOmEucGFnZVgsYi50b3VjaE1vdmUoZCxjKSl9KSxhKHdpbmRvdykub24oXCJtb3VzZXVwXCIsZnVuY3Rpb24oZyl7aWYoZil7cC5maW5kKFwiLmxpZ2h0U2xpZGVyXCIpLnJlbW92ZUNsYXNzKFwibHNHcmFiYmluZ1wiKS5hZGRDbGFzcyhcImxzR3JhYlwiKSxmPSExLGQ9ZS52ZXJ0aWNhbD09PSEwP2cucGFnZVk6Zy5wYWdlWDt2YXIgaD1kLWM7TWF0aC5hYnMoaCk+PWUuc3dpcGVUaHJlc2hvbGQmJmEod2luZG93KS5vbihcImNsaWNrLmxzXCIsZnVuY3Rpb24oYil7Yi5wcmV2ZW50RGVmYXVsdD9iLnByZXZlbnREZWZhdWx0KCk6Yi5yZXR1cm5WYWx1ZT0hMSxiLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLGIuc3RvcFByb3BhZ2F0aW9uKCksYSh3aW5kb3cpLm9mZihcImNsaWNrLmxzXCIpfSksYi50b3VjaEVuZChoKX19KX19LGVuYWJsZVRvdWNoOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcztpZih5KXt2YXIgYj17fSxjPXt9O3Aub24oXCJ0b3VjaHN0YXJ0XCIsZnVuY3Rpb24oYSl7Yz1hLm9yaWdpbmFsRXZlbnQudGFyZ2V0VG91Y2hlc1swXSxiLnBhZ2VYPWEub3JpZ2luYWxFdmVudC50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYLGIucGFnZVk9YS5vcmlnaW5hbEV2ZW50LnRhcmdldFRvdWNoZXNbMF0ucGFnZVksY2xlYXJJbnRlcnZhbCh4KX0pLHAub24oXCJ0b3VjaG1vdmVcIixmdW5jdGlvbihkKXtpZihvPm0mJjAhPT1tKXJldHVybiExO3ZhciBmPWQub3JpZ2luYWxFdmVudDtjPWYudGFyZ2V0VG91Y2hlc1swXTt2YXIgZz1NYXRoLmFicyhjLnBhZ2VYLWIucGFnZVgpLGg9TWF0aC5hYnMoYy5wYWdlWS1iLnBhZ2VZKTtlLnZlcnRpY2FsPT09ITA/KDMqaD5nJiZkLnByZXZlbnREZWZhdWx0KCksYS50b3VjaE1vdmUoYy5wYWdlWSxiLnBhZ2VZKSk6KDMqZz5oJiZkLnByZXZlbnREZWZhdWx0KCksYS50b3VjaE1vdmUoYy5wYWdlWCxiLnBhZ2VYKSl9KSxwLm9uKFwidG91Y2hlbmRcIixmdW5jdGlvbigpe2lmKG8+bSYmMCE9PW0pcmV0dXJuITE7dmFyIGQ7ZD1lLnZlcnRpY2FsPT09ITA/Yy5wYWdlWS1iLnBhZ2VZOmMucGFnZVgtYi5wYWdlWCxhLnRvdWNoRW5kKGQpfSl9fSxidWlsZDpmdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi5pbml0aWFsU3R5bGUoKSx0aGlzLmRvQ3NzKCkmJihlLmVuYWJsZVRvdWNoPT09ITAmJmIuZW5hYmxlVG91Y2goKSxlLmVuYWJsZURyYWc9PT0hMCYmYi5lbmFibGVEcmFnKCkpLGEod2luZG93KS5vbihcImZvY3VzXCIsZnVuY3Rpb24oKXtiLmF1dG8oKX0pLGEod2luZG93KS5vbihcImJsdXJcIixmdW5jdGlvbigpe2NsZWFySW50ZXJ2YWwoeCl9KSxiLnBhZ2VyKCksYi5wYXVzZU9uSG92ZXIoKSxiLmNvbnRyb2xzKCksYi5rZXlQcmVzcygpfX0sZC5idWlsZCgpLHouaW5pdD1mdW5jdGlvbigpe3ouY2hicmVha3BvaW50KCksZS52ZXJ0aWNhbD09PSEwPyhvPWUuaXRlbT4xP2UudmVydGljYWxIZWlnaHQ6aC5vdXRlckhlaWdodCgpLHAuY3NzKFwiaGVpZ2h0XCIsbytcInB4XCIpKTpvPXAub3V0ZXJXaWR0aCgpLGUubG9vcD09PSEwJiZcInNsaWRlXCI9PT1lLm1vZGUmJnouY2xvbmUoKSx6LmNhbEwoKSxcInNsaWRlXCI9PT1lLm1vZGUmJmcucmVtb3ZlQ2xhc3MoXCJsU1NsaWRlXCIpLFwic2xpZGVcIj09PWUubW9kZSYmKHouY2FsU1coKSx6LnNTVygpKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XCJzbGlkZVwiPT09ZS5tb2RlJiZnLmFkZENsYXNzKFwibFNTbGlkZVwiKX0sMWUzKSxlLnBhZ2VyJiZ6LmNyZWF0ZVBhZ2VyKCksZS5hZGFwdGl2ZUhlaWdodD09PSEwJiZlLnZlcnRpY2FsPT09ITEmJmcuY3NzKFwiaGVpZ2h0XCIsaC5lcShxKS5vdXRlckhlaWdodCghMCkpLGUuYWRhcHRpdmVIZWlnaHQ9PT0hMSYmKFwic2xpZGVcIj09PWUubW9kZT9lLnZlcnRpY2FsPT09ITE/ZC5zZXRIZWlnaHQoZywhMSk6ZC5hdXRvKCk6ZC5zZXRIZWlnaHQoZywhMCkpLGUuZ2FsbGVyeT09PSEwJiZkLnNsaWRlVGh1bWIoKSxcInNsaWRlXCI9PT1lLm1vZGUmJmQuc2xpZGUoKSxlLmF1dG9XaWR0aD09PSExP2gubGVuZ3RoPD1lLml0ZW0/cC5maW5kKFwiLmxTQWN0aW9uXCIpLmhpZGUoKTpwLmZpbmQoXCIubFNBY3Rpb25cIikuc2hvdygpOnouY2FsV2lkdGgoITEpPG8mJjAhPT1tP3AuZmluZChcIi5sU0FjdGlvblwiKS5oaWRlKCk6cC5maW5kKFwiLmxTQWN0aW9uXCIpLnNob3coKX0sZy5nb1RvUHJldlNsaWRlPWZ1bmN0aW9uKCl7aWYocT4wKWUub25CZWZvcmVQcmV2U2xpZGUuY2FsbCh0aGlzLGcscSkscS0tLGcubW9kZSghMSksZS5nYWxsZXJ5PT09ITAmJmQuc2xpZGVUaHVtYigpO2Vsc2UgaWYoZS5sb29wPT09ITApe2lmKGUub25CZWZvcmVQcmV2U2xpZGUuY2FsbCh0aGlzLGcscSksXCJmYWRlXCI9PT1lLm1vZGUpe3ZhciBhPWwtMTtxPXBhcnNlSW50KGEvZS5zbGlkZU1vdmUpfWcubW9kZSghMSksZS5nYWxsZXJ5PT09ITAmJmQuc2xpZGVUaHVtYigpfWVsc2UgZS5zbGlkZUVuZEFuaW1hdGlvbj09PSEwJiYoZy5hZGRDbGFzcyhcImxlZnRFbmRcIiksc2V0VGltZW91dChmdW5jdGlvbigpe2cucmVtb3ZlQ2xhc3MoXCJsZWZ0RW5kXCIpfSw0MDApKX0sZy5nb1RvTmV4dFNsaWRlPWZ1bmN0aW9uKCl7dmFyIGE9ITA7aWYoXCJzbGlkZVwiPT09ZS5tb2RlKXt2YXIgYj1kLnNsaWRlVmFsdWUoKTthPWI8bS1vLWUuc2xpZGVNYXJnaW59cSplLnNsaWRlTW92ZTxsLWUuc2xpZGVNb3ZlJiZhPyhlLm9uQmVmb3JlTmV4dFNsaWRlLmNhbGwodGhpcyxnLHEpLHErKyxnLm1vZGUoITEpLGUuZ2FsbGVyeT09PSEwJiZkLnNsaWRlVGh1bWIoKSk6ZS5sb29wPT09ITA/KGUub25CZWZvcmVOZXh0U2xpZGUuY2FsbCh0aGlzLGcscSkscT0wLGcubW9kZSghMSksZS5nYWxsZXJ5PT09ITAmJmQuc2xpZGVUaHVtYigpKTplLnNsaWRlRW5kQW5pbWF0aW9uPT09ITAmJihnLmFkZENsYXNzKFwicmlnaHRFbmRcIiksc2V0VGltZW91dChmdW5jdGlvbigpe2cucmVtb3ZlQ2xhc3MoXCJyaWdodEVuZFwiKX0sNDAwKSl9LGcubW9kZT1mdW5jdGlvbihhKXtlLmFkYXB0aXZlSGVpZ2h0PT09ITAmJmUudmVydGljYWw9PT0hMSYmZy5jc3MoXCJoZWlnaHRcIixoLmVxKHEpLm91dGVySGVpZ2h0KCEwKSksbj09PSExJiYoXCJzbGlkZVwiPT09ZS5tb2RlP2QuZG9Dc3MoKSYmKGcuYWRkQ2xhc3MoXCJsU1NsaWRlXCIpLFwiXCIhPT1lLnNwZWVkJiZwLmNzcyhcInRyYW5zaXRpb24tZHVyYXRpb25cIixlLnNwZWVkK1wibXNcIiksXCJcIiE9PWUuY3NzRWFzaW5nJiZwLmNzcyhcInRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uXCIsZS5jc3NFYXNpbmcpKTpkLmRvQ3NzKCkmJihcIlwiIT09ZS5zcGVlZCYmZy5jc3MoXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsZS5zcGVlZCtcIm1zXCIpLFwiXCIhPT1lLmNzc0Vhc2luZyYmZy5jc3MoXCJ0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblwiLGUuY3NzRWFzaW5nKSkpLGF8fGUub25CZWZvcmVTbGlkZS5jYWxsKHRoaXMsZyxxKSxcInNsaWRlXCI9PT1lLm1vZGU/ZC5zbGlkZSgpOmQuZmFkZSgpLHAuaGFzQ2xhc3MoXCJscy1ob3ZlclwiKXx8ZC5hdXRvKCksc2V0VGltZW91dChmdW5jdGlvbigpe2F8fGUub25BZnRlclNsaWRlLmNhbGwodGhpcyxnLHEpfSxlLnNwZWVkKSxuPSEwfSxnLnBsYXk9ZnVuY3Rpb24oKXtnLmdvVG9OZXh0U2xpZGUoKSxlLmF1dG89ITAsZC5hdXRvKCl9LGcucGF1c2U9ZnVuY3Rpb24oKXtlLmF1dG89ITEsY2xlYXJJbnRlcnZhbCh4KX0sZy5yZWZyZXNoPWZ1bmN0aW9uKCl7ei5pbml0KCl9LGcuZ2V0Q3VycmVudFNsaWRlQ291bnQ9ZnVuY3Rpb24oKXt2YXIgYT1xO2lmKGUubG9vcCl7dmFyIGI9cC5maW5kKFwiLmxzbGlkZVwiKS5sZW5ndGgsYz1nLmZpbmQoXCIuY2xvbmUubGVmdFwiKS5sZW5ndGg7YT1jLTE+PXE/YisocS1jKTpxPj1iK2M/cS1iLWM6cS1jfXJldHVybiBhKzF9LGcuZ2V0VG90YWxTbGlkZUNvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIHAuZmluZChcIi5sc2xpZGVcIikubGVuZ3RofSxnLmdvVG9TbGlkZT1mdW5jdGlvbihhKXtxPWUubG9vcD9hK2cuZmluZChcIi5jbG9uZS5sZWZ0XCIpLmxlbmd0aC0xOmEsZy5tb2RlKCExKSxlLmdhbGxlcnk9PT0hMCYmZC5zbGlkZVRodW1iKCl9LGcuZGVzdHJveT1mdW5jdGlvbigpe2cubGlnaHRTbGlkZXImJihnLmdvVG9QcmV2U2xpZGU9ZnVuY3Rpb24oKXt9LGcuZ29Ub05leHRTbGlkZT1mdW5jdGlvbigpe30sZy5tb2RlPWZ1bmN0aW9uKCl7fSxnLnBsYXk9ZnVuY3Rpb24oKXt9LGcucGF1c2U9ZnVuY3Rpb24oKXt9LGcucmVmcmVzaD1mdW5jdGlvbigpe30sZy5nZXRDdXJyZW50U2xpZGVDb3VudD1mdW5jdGlvbigpe30sZy5nZXRUb3RhbFNsaWRlQ291bnQ9ZnVuY3Rpb24oKXt9LGcuZ29Ub1NsaWRlPWZ1bmN0aW9uKCl7fSxnLmxpZ2h0U2xpZGVyPW51bGwsej17aW5pdDpmdW5jdGlvbigpe319LGcucGFyZW50KCkucGFyZW50KCkuZmluZChcIi5sU0FjdGlvbiwgLmxTUGFnZXJcIikucmVtb3ZlKCksZy5yZW1vdmVDbGFzcyhcImxpZ2h0U2xpZGVyIGxTRmFkZSBsU1NsaWRlIGxzR3JhYiBsc0dyYWJiaW5nIGxlZnRFbmQgcmlnaHRcIikucmVtb3ZlQXR0cihcInN0eWxlXCIpLnVud3JhcCgpLnVud3JhcCgpLGcuY2hpbGRyZW4oKS5yZW1vdmVBdHRyKFwic3R5bGVcIiksaC5yZW1vdmVDbGFzcyhcImxzbGlkZSBhY3RpdmVcIiksZy5maW5kKFwiLmNsb25lXCIpLnJlbW92ZSgpLGg9bnVsbCx4PW51bGwsbj0hMSxxPTApfSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5vblNsaWRlckxvYWQuY2FsbCh0aGlzLGcpfSwxMCksYSh3aW5kb3cpLm9uKFwicmVzaXplIG9yaWVudGF0aW9uY2hhbmdlXCIsZnVuY3Rpb24oYSl7c2V0VGltZW91dChmdW5jdGlvbigpe2EucHJldmVudERlZmF1bHQ/YS5wcmV2ZW50RGVmYXVsdCgpOmEucmV0dXJuVmFsdWU9ITEsei5pbml0KCl9LDIwMCl9KSx0aGlzfX0oalF1ZXJ5KTsiLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbnZhciByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG52YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmXFxcXHVmZTIwLVxcXFx1ZmUyMycsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGYwJyxcbiAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UgKyAnXScsXG4gICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByc0xvd2VyTWlzYyA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc1VwcGVyTWlzYyA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc09wdExvd2VyQ29udHIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICByc09wdFVwcGVyQ29udHIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcSxcbiAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYXBvc3Ryb3BoZXMuICovXG52YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICovXG52YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi9cbnZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdExvd2VyQ29udHIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNVcHBlck1pc2MgKyAnKycgKyByc09wdFVwcGVyQ29udHIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyICsgcnNMb3dlck1pc2MsICckJ10uam9pbignfCcpICsgJyknLFxuICByc1VwcGVyICsgJz8nICsgcnNMb3dlck1pc2MgKyAnKycgKyByc09wdExvd2VyQ29udHIsXG4gIHJzVXBwZXIgKyAnKycgKyByc09wdFVwcGVyQ29udHIsXG4gIHJzRGlnaXRzLFxuICByc0Vtb2ppXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xudmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyLH1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbi8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbnZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAnXFx4ZGYnOiAnc3MnLFxuICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAnc3MnXG59O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG59XG5cbi8qKlxuICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBMYXRpbi0xIFN1cHBsZW1lbnQgYW5kIExhdGluIEV4dGVuZGVkLUFcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICovXG52YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbn1cblxuLyoqXG4gKiBTcGxpdHMgYSBVbmljb2RlIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gKi9cbmZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgIHZhciBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICA6IHN0cmluZy5jaGFyQXQoMCk7XG5cbiAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXG4gICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgOiBzdHJpbmcuc2xpY2UoMSk7XG5cbiAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICogLy8gPT4gJ2Zvb0JhcidcbiAqXG4gKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyLS0nKTtcbiAqIC8vID0+ICdmb29CYXInXG4gKlxuICogXy5jYW1lbENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gKiAvLyA9PiAnZm9vQmFyJ1xuICovXG52YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyBjYXBpdGFsaXplKHdvcmQpIDogd29yZCk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAqIHRvIGxvd2VyIGNhc2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqL1xuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuLyoqXG4gKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAqIC8vID0+ICdkZWphIHZ1J1xuICovXG5mdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAqIC8vID0+ICdGcmVkJ1xuICpcbiAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICogLy8gPT4gJ0ZSRUQnXG4gKi9cbnZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG4vKipcbiAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICovXG5mdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbENhc2U7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gaXNLZXkocGF0aCwgb2JqZWN0KSA/IFtwYXRoXSA6IGNhc3RQYXRoKHBhdGgpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gKGlzRnVuY3Rpb24odmFsdWUpIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBzdHJpbmdUb1BhdGgodmFsdWUpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemUoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAocmVMZWFkaW5nRG90LnRlc3Qoc3RyaW5nKSkge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEFzc2lnbiBjYWNoZSB0byBgXy5tZW1vaXplYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbnZhciByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG52YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmXFxcXHVmZTIwLVxcXFx1ZmUyMycsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGYwJyxcbiAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgIHJzQnJlYWsgPSAnWycgKyByc0JyZWFrUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9NYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSArICddJyxcbiAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxuICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXG4gICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJzTG93ZXJNaXNjID0gJyg/OicgKyByc0xvd2VyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgIHJzVXBwZXJNaXNjID0gJyg/OicgKyByc1VwcGVyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgIHJzT3B0TG93ZXJDb250ciA9ICcoPzonICsgcnNBcG9zICsgJyg/OmR8bGx8bXxyZXxzfHR8dmUpKT8nLFxuICAgIHJzT3B0VXBwZXJDb250ciA9ICcoPzonICsgcnNBcG9zICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxuICAgIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzRW1vamkgPSAnKD86JyArIFtyc0RpbmdiYXQsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzU2VxO1xuXG4vKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cbnZhciByZUFwb3MgPSBSZWdFeHAocnNBcG9zLCAnZycpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gKi9cbnZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xudmFyIHJlVW5pY29kZVdvcmQgPSBSZWdFeHAoW1xuICByc1VwcGVyICsgJz8nICsgcnNMb3dlciArICcrJyArIHJzT3B0TG93ZXJDb250ciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICByc1VwcGVyTWlzYyArICcrJyArIHJzT3B0VXBwZXJDb250ciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc0xvd2VyTWlzYywgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyTWlzYyArICcrJyArIHJzT3B0TG93ZXJDb250cixcbiAgcnNVcHBlciArICcrJyArIHJzT3B0VXBwZXJDb250cixcbiAgcnNEaWdpdHMsXG4gIHJzRW1vamlcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG52YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezIsfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuLyoqIFVzZWQgdG8gbWFwIExhdGluIFVuaWNvZGUgbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLiAqL1xudmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgLy8gTGF0aW4tMSBTdXBwbGVtZW50IGJsb2NrLlxuICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAnXFx4Y2MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAnXFx4ZWMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICdcXHhkZic6ICdzcycsXG4gIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXG4gICdcXHUwMTAwJzogJ0EnLCAgJ1xcdTAxMDInOiAnQScsICdcXHUwMTA0JzogJ0EnLFxuICAnXFx1MDEwMSc6ICdhJywgICdcXHUwMTAzJzogJ2EnLCAnXFx1MDEwNSc6ICdhJyxcbiAgJ1xcdTAxMDYnOiAnQycsICAnXFx1MDEwOCc6ICdDJywgJ1xcdTAxMGEnOiAnQycsICdcXHUwMTBjJzogJ0MnLFxuICAnXFx1MDEwNyc6ICdjJywgICdcXHUwMTA5JzogJ2MnLCAnXFx1MDEwYic6ICdjJywgJ1xcdTAxMGQnOiAnYycsXG4gICdcXHUwMTBlJzogJ0QnLCAgJ1xcdTAxMTAnOiAnRCcsICdcXHUwMTBmJzogJ2QnLCAnXFx1MDExMSc6ICdkJyxcbiAgJ1xcdTAxMTInOiAnRScsICAnXFx1MDExNCc6ICdFJywgJ1xcdTAxMTYnOiAnRScsICdcXHUwMTE4JzogJ0UnLCAnXFx1MDExYSc6ICdFJyxcbiAgJ1xcdTAxMTMnOiAnZScsICAnXFx1MDExNSc6ICdlJywgJ1xcdTAxMTcnOiAnZScsICdcXHUwMTE5JzogJ2UnLCAnXFx1MDExYic6ICdlJyxcbiAgJ1xcdTAxMWMnOiAnRycsICAnXFx1MDExZSc6ICdHJywgJ1xcdTAxMjAnOiAnRycsICdcXHUwMTIyJzogJ0cnLFxuICAnXFx1MDExZCc6ICdnJywgICdcXHUwMTFmJzogJ2cnLCAnXFx1MDEyMSc6ICdnJywgJ1xcdTAxMjMnOiAnZycsXG4gICdcXHUwMTI0JzogJ0gnLCAgJ1xcdTAxMjYnOiAnSCcsICdcXHUwMTI1JzogJ2gnLCAnXFx1MDEyNyc6ICdoJyxcbiAgJ1xcdTAxMjgnOiAnSScsICAnXFx1MDEyYSc6ICdJJywgJ1xcdTAxMmMnOiAnSScsICdcXHUwMTJlJzogJ0knLCAnXFx1MDEzMCc6ICdJJyxcbiAgJ1xcdTAxMjknOiAnaScsICAnXFx1MDEyYic6ICdpJywgJ1xcdTAxMmQnOiAnaScsICdcXHUwMTJmJzogJ2knLCAnXFx1MDEzMSc6ICdpJyxcbiAgJ1xcdTAxMzQnOiAnSicsICAnXFx1MDEzNSc6ICdqJyxcbiAgJ1xcdTAxMzYnOiAnSycsICAnXFx1MDEzNyc6ICdrJywgJ1xcdTAxMzgnOiAnaycsXG4gICdcXHUwMTM5JzogJ0wnLCAgJ1xcdTAxM2InOiAnTCcsICdcXHUwMTNkJzogJ0wnLCAnXFx1MDEzZic6ICdMJywgJ1xcdTAxNDEnOiAnTCcsXG4gICdcXHUwMTNhJzogJ2wnLCAgJ1xcdTAxM2MnOiAnbCcsICdcXHUwMTNlJzogJ2wnLCAnXFx1MDE0MCc6ICdsJywgJ1xcdTAxNDInOiAnbCcsXG4gICdcXHUwMTQzJzogJ04nLCAgJ1xcdTAxNDUnOiAnTicsICdcXHUwMTQ3JzogJ04nLCAnXFx1MDE0YSc6ICdOJyxcbiAgJ1xcdTAxNDQnOiAnbicsICAnXFx1MDE0Nic6ICduJywgJ1xcdTAxNDgnOiAnbicsICdcXHUwMTRiJzogJ24nLFxuICAnXFx1MDE0Yyc6ICdPJywgICdcXHUwMTRlJzogJ08nLCAnXFx1MDE1MCc6ICdPJyxcbiAgJ1xcdTAxNGQnOiAnbycsICAnXFx1MDE0Zic6ICdvJywgJ1xcdTAxNTEnOiAnbycsXG4gICdcXHUwMTU0JzogJ1InLCAgJ1xcdTAxNTYnOiAnUicsICdcXHUwMTU4JzogJ1InLFxuICAnXFx1MDE1NSc6ICdyJywgICdcXHUwMTU3JzogJ3InLCAnXFx1MDE1OSc6ICdyJyxcbiAgJ1xcdTAxNWEnOiAnUycsICAnXFx1MDE1Yyc6ICdTJywgJ1xcdTAxNWUnOiAnUycsICdcXHUwMTYwJzogJ1MnLFxuICAnXFx1MDE1Yic6ICdzJywgICdcXHUwMTVkJzogJ3MnLCAnXFx1MDE1Zic6ICdzJywgJ1xcdTAxNjEnOiAncycsXG4gICdcXHUwMTYyJzogJ1QnLCAgJ1xcdTAxNjQnOiAnVCcsICdcXHUwMTY2JzogJ1QnLFxuICAnXFx1MDE2Myc6ICd0JywgICdcXHUwMTY1JzogJ3QnLCAnXFx1MDE2Nyc6ICd0JyxcbiAgJ1xcdTAxNjgnOiAnVScsICAnXFx1MDE2YSc6ICdVJywgJ1xcdTAxNmMnOiAnVScsICdcXHUwMTZlJzogJ1UnLCAnXFx1MDE3MCc6ICdVJywgJ1xcdTAxNzInOiAnVScsXG4gICdcXHUwMTY5JzogJ3UnLCAgJ1xcdTAxNmInOiAndScsICdcXHUwMTZkJzogJ3UnLCAnXFx1MDE2Zic6ICd1JywgJ1xcdTAxNzEnOiAndScsICdcXHUwMTczJzogJ3UnLFxuICAnXFx1MDE3NCc6ICdXJywgICdcXHUwMTc1JzogJ3cnLFxuICAnXFx1MDE3Nic6ICdZJywgICdcXHUwMTc3JzogJ3knLCAnXFx1MDE3OCc6ICdZJyxcbiAgJ1xcdTAxNzknOiAnWicsICAnXFx1MDE3Yic6ICdaJywgJ1xcdTAxN2QnOiAnWicsXG4gICdcXHUwMTdhJzogJ3onLCAgJ1xcdTAxN2MnOiAneicsICdcXHUwMTdlJzogJ3onLFxuICAnXFx1MDEzMic6ICdJSicsICdcXHUwMTMzJzogJ2lqJyxcbiAgJ1xcdTAxNTInOiAnT2UnLCAnXFx1MDE1Myc6ICdvZScsXG4gICdcXHUwMTQ5JzogXCInblwiLCAnXFx1MDE3Zic6ICdzcydcbn07XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxuLyoqXG4gKiBTcGxpdHMgYW4gQVNDSUkgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBhc2NpaVdvcmRzKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gKi9cbnZhciBkZWJ1cnJMZXR0ZXIgPSBiYXNlUHJvcGVydHlPZihkZWJ1cnJlZExldHRlcnMpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBhIHdvcmQgY29tcG9zZWQgb2YgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHdvcmQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSB7XG4gIHJldHVybiByZUhhc1VuaWNvZGVXb3JkLnRlc3Qoc3RyaW5nKTtcbn1cblxuLyoqXG4gKiBTcGxpdHMgYSBVbmljb2RlIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmNhbWVsQ2FzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZ1xuICogW0xhdGluLTEgU3VwcGxlbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gKiBhbmQgW0xhdGluIEV4dGVuZGVkLUFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX0V4dGVuZGVkLUEpXG4gKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nXG4gKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICogLy8gPT4gJ2RlamEgdnUnXG4gKi9cbmZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICogW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBrZWJhYiBjYXNlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ua2ViYWJDYXNlKCdGb28gQmFyJyk7XG4gKiAvLyA9PiAnZm9vLWJhcidcbiAqXG4gKiBfLmtlYmFiQ2FzZSgnZm9vQmFyJyk7XG4gKiAvLyA9PiAnZm9vLWJhcidcbiAqXG4gKiBfLmtlYmFiQ2FzZSgnX19GT09fQkFSX18nKTtcbiAqIC8vID0+ICdmb28tYmFyJ1xuICovXG52YXIga2ViYWJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnLScgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG59KTtcblxuLyoqXG4gKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICpcbiAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAqL1xuZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xuXG4gIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICB9XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2ViYWJDYXNlO1xuIiwiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanMuZm91bmRhdGlvbi8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBrZXkgPT0gJ19fcHJvdG9fXydcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogb2JqZWN0W2tleV07XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQsXG4gICAgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksXG4gICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IChzcmNJbmRleCAmJiBpc0Z1bmN0aW9uKG9ialZhbHVlKSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAqICAgfVxuICogfVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAqXG4gKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAqL1xudmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlV2l0aDtcbiIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICBpZiAodmFsdWUgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA/IHZhbHVlcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIC8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcbiAgICA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZylcbiAgICA6IFtdO1xuXG4gIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZGlmZmVyZW5jZWAgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgZXhjbHVkaW5nIG11bHRpcGxlIGFycmF5cyBvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICB2YWx1ZXNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoaXRlcmF0ZWUpIHtcbiAgICB2YWx1ZXMgPSBhcnJheU1hcCh2YWx1ZXMsIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICB9XG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICB9XG4gIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpbmNsdWRlcyh2YWx1ZXMsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwcm9wcykge1xuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJldHVybiBrZXkgaW4gb2JqZWN0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gcGljayBmcm9tLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5KSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gYXJyYXk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2wgcHJvcGVydGllcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9IG5hdGl2ZUdldFN5bWJvbHMgPyBvdmVyQXJnKG5hdGl2ZUdldFN5bWJvbHMsIE9iamVjdCkgOiBzdHViQXJyYXk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2wgcHJvcGVydGllc1xuICogb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICghcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIHx8IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0IGFyZVxuICogbm90IG9taXR0ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwcm9wc10gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIG9taXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLm9taXQob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2InOiAnMicgfVxuICovXG52YXIgb21pdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcHJvcHMpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHByb3BzID0gYXJyYXlNYXAoYmFzZUZsYXR0ZW4ocHJvcHMsIDEpLCB0b0tleSk7XG4gIHJldHVybiBiYXNlUGljayhvYmplY3QsIGJhc2VEaWZmZXJlbmNlKGdldEFsbEtleXNJbihvYmplY3QpLCBwcm9wcykpO1xufSk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb21pdDtcbiIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgIHJlTGVhZGluZ0RvdCA9IC9eXFwuLyxcbiAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyBkYXRhW2tleV0gIT09IHVuZGVmaW5lZCA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIGdldE1hcERhdGEodGhpcywga2V5KS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgcGF0aCA9IGlzS2V5KHBhdGgsIG9iamVjdCkgPyBbcGF0aF0gOiBjYXN0UGF0aChwYXRoKTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IHN0cmluZ1RvUGF0aCh2YWx1ZSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZShmdW5jdGlvbihzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChyZUxlYWRpbmdEb3QudGVzdChzdHJpbmcpKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gQXNzaWduIGNhY2hlIHRvIGBfLm1lbW9pemVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcbiAqIGBwYXRoYCBjcmVhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gKiAvLyA9PiA0XG4gKlxuICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG4gKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICogLy8gPT4gNVxuICovXG5mdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldDtcbiIsIi8vISBtb21lbnQuanNcblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gaG9va3MgKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAgICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxuICAgICAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIHJmYzI4MjIgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICAgICAgdmFyIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaXNOb3dWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaXNOb3dWYWxpZCA9IGlzTm93VmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXG4gICAgICAgICAgICAgICAgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQgICA6ICdoOm1tIEEnLFxuICAgICAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgICAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnO1xuICAgIHZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIHNzIDogJyVkIHNlY29uZHMnLFxuICAgICAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoICA6ICdhbiBob3VyJyxcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICBkICA6ICdhIGRheScsXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICBNICA6ICdhIG1vbnRoJyxcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeSAgOiAnYSB5ZWFyJyxcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgICAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgICAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG4gICAgdmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxuICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbiAgICB2YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG4gICAgdmFyIG1hdGNoM3RvNCAgICAgID0gL1xcZFxcZFxcZFxcZD8vOyAgICAgLy8gICAgIDk5OSAtIDk5OTlcbiAgICB2YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICB2YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG4gICAgdmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbiAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2k7XG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwO1xuICAgIHZhciBNT05USCA9IDE7XG4gICAgdmFyIERBVEUgPSAyO1xuICAgIHZhciBIT1VSID0gMztcbiAgICB2YXIgTUlOVVRFID0gNDtcbiAgICB2YXIgU0VDT05EID0gNTtcbiAgICB2YXIgTUlMTElTRUNPTkQgPSA2O1xuICAgIHZhciBXRUVLID0gNztcbiAgICB2YXIgV0VFS0RBWSA9IDg7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQgKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJiBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmIG1vbS5tb250aCgpID09PSAxICYmIG1vbS5kYXRlKCkgPT09IDI5KSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlLCBtb20ubW9udGgoKSwgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc3RyaW5nR2V0ICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJpb3JpdGl6ZWRbaV0udW5pdF0odW5pdHNbcHJpb3JpdGl6ZWRbaV0udW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxID8gKGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KSA6ICgzMSAtIG1vZE1vbnRoICUgNyAlIDIpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LztcbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRocyA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0IDpcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAgICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuXG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cbiAgICAgICAgLy8gdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgICAgICBmd2QgPSA3ICsgZG93IC0gZG95LFxuICAgICAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgeWVhcjogcmVzWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrJywgNSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXMgOlxuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV0gOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20uZGF5KCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgICAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c01pbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkJyAmJiB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuXG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gd2Vla2RheSA6IHdlZWtkYXkgLSA3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgIHNob3J0cCA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdrJywgWydraycsIDJdLCAwLCBrRm9ybWF0KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciB0aGV5IHdhbnQuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlXG4gICAgfTtcblxuICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgIHZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xuICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKCFsb2NhbGVzW25hbWVdICYmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIHZhciBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMb2NhbGUgJyArIGtleSArICAnIG5vdCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gbG9hZCBpdD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHRtcExvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIC8vIE1FUkdFXG4gICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgZXhwZWN0ZWRXZWVrZGF5LCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQyA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKSA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB2YXIgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG4gICAgdmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuXG4gICAgdmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbiAgICB2YXIgaXNvRGF0ZXMgPSBbXG4gICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAgICAgLy8gWVlZWU1NIGlzIE5PVCBhbGxvd2VkIGJ5IHRoZSBzdGFuZGFyZFxuICAgICAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L11cbiAgICBdO1xuXG4gICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgIHZhciBpc29UaW1lcyA9IFtcbiAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIJywgL1xcZFxcZC9dXG4gICAgXTtcblxuICAgIHZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgdmFyIHJmYzI4MjIgPSAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KFsrLV1cXGR7NH0pKSQvO1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyh5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgdW50cnVuY2F0ZVllYXIoeWVhclN0ciksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXG4gICAgICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGhvdXJTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKHNlY29uZFN0cikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc2Vjb25kU3RyLCAxMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSB7XG4gICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoeWVhclN0ciwgMTApO1xuICAgICAgICBpZiAoeWVhciA8PSA0OSkge1xuICAgICAgICAgICAgcmV0dXJuIDIwMDAgKyB5ZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKHllYXIgPD0gOTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gMTkwMCArIHllYXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHllYXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAgICAgICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXChbXildKlxcKXxbXFxuXFx0XS9nLCAnICcpLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrV2Vla2RheSh3ZWVrZGF5U3RyLCBwYXJzZWRJbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbnRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXG4gICAgICAgICAgICB2YXIgd2Vla2RheVByb3ZpZGVkID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSxcbiAgICAgICAgICAgICAgICB3ZWVrZGF5QWN0dWFsID0gbmV3IERhdGUocGFyc2VkSW5wdXRbMF0sIHBhcnNlZElucHV0WzFdLCBwYXJzZWRJbnB1dFsyXSkuZ2V0RGF5KCk7XG4gICAgICAgICAgICBpZiAod2Vla2RheVByb3ZpZGVkICE9PSB3ZWVrZGF5QWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG9ic09mZnNldHMgPSB7XG4gICAgICAgIFVUOiAwLFxuICAgICAgICBHTVQ6IDAsXG4gICAgICAgIEVEVDogLTQgKiA2MCxcbiAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICBDRFQ6IC01ICogNjAsXG4gICAgICAgIENTVDogLTYgKiA2MCxcbiAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICBNU1Q6IC03ICogNjAsXG4gICAgICAgIFBEVDogLTcgKiA2MCxcbiAgICAgICAgUFNUOiAtOCAqIDYwXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChvYnNPZmZzZXQsIG1pbGl0YXJ5T2Zmc2V0LCBudW1PZmZzZXQpIHtcbiAgICAgICAgaWYgKG9ic09mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgICAgICAgfSBlbHNlIGlmIChtaWxpdGFyeU9mZnNldCkge1xuICAgICAgICAgICAgLy8gdGhlIG9ubHkgYWxsb3dlZCBtaWxpdGFyeSB0eiBpcyBaXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBobSA9IHBhcnNlSW50KG51bU9mZnNldCwgMTApO1xuICAgICAgICAgICAgdmFyIG0gPSBobSAlIDEwMCwgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkQXJyYXkgPSBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKG1hdGNoWzRdLCBtYXRjaFszXSwgbWF0Y2hbMl0sIG1hdGNoWzVdLCBtYXRjaFs2XSwgbWF0Y2hbN10pO1xuICAgICAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcbiAgICAgICAgICAgIGNvbmZpZy5fdHptID0gY2FsY3VsYXRlT2Zmc2V0KG1hdGNoWzhdLCBtYXRjaFs5XSwgbWF0Y2hbMTBdKTtcblxuICAgICAgICAgICAgY29uZmlnLl9kID0gY3JlYXRlVVRDRGF0ZS5hcHBseShudWxsLCBjb25maWcuX2EpO1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucmZjMjgyMiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICB9XG5cbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAgICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIG1ham9yIHJlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgJ2h0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICBob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cbiAgICBob29rcy5SRkNfMjgyMiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmIChsb2NhbGUgPT09IHRydWUgfHwgbG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdmFyIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXggKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICsobmV3IERhdGUoKSk7XG4gICAgfTtcblxuICAgIHZhciBvcmRlcmluZyA9IFsneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCddO1xuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG0pIHtcbiAgICAgICAgICAgIGlmICghKGluZGV4T2YuY2FsbChvcmRlcmluZywga2V5KSAhPT0gLTEgJiYgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5pdEhhc0RlY2ltYWwgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRvIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKTtcblxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgP1xuICAgICAgICAgIDAgOlxuICAgICAgICAgIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gaW5wdXQudmFsdWVPZigpIDogY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIGhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXihcXC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcblxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgIC8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbiAgICB2YXIgaXNvUmVnZXggPSAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5ICA6IDAsXG4gICAgICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zIDogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IChtYXRjaFsxXSA9PT0gJysnKSA/IDEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSwgY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pKTtcblxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuICAgIGNyZWF0ZUR1cmF0aW9uLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkJDE7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xuICAgICAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgICAgICByZXR1cm4gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciQxICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBmb3JtYXQgPSBob29rcy5jYWxlbmRhckZvcm1hdCh0aGlzLCBzb2QpIHx8ICdzYW1lRWxzZSc7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdykgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihmcm9tLCB1bml0cykgOiAhdGhpcy5pc0JlZm9yZShmcm9tLCB1bml0cykpICYmXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJyA/IHRoaXMuaXNCZWZvcmUodG8sIHVuaXRzKSA6ICF0aGlzLmlzQWZ0ZXIodG8sIHVuaXRzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCx1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgICAgIHZhciB0aGF0LFxuICAgICAgICAgICAgem9uZURlbHRhLFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMTI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDM7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDFlMzsgYnJlYWs7IC8vIDEwMDBcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7IGJyZWFrOyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMzZlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICBjYXNlICdkYXknOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gODY0ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBkZWZhdWx0OiBvdXRwdXQgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyKSArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgICAgIGFuY2hvcjIsIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxuXG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nKGtlZXBPZmZzZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHV0YyA9IGtlZXBPZmZzZXQgIT09IHRydWU7XG4gICAgICAgIHZhciBtID0gdXRjID8gdGhpcy5jbG9uZSgpLnV0YygpIDogdGhpcztcbiAgICAgICAgaWYgKG0ueWVhcigpIDwgMCB8fCBtLnllYXIoKSA+IDk5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkgKyB0aGlzLnV0Y09mZnNldCgpICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLnJlcGxhY2UoJ1onLCBmb3JtYXRNb21lbnQobSwgJ1onKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCB1dGMgPyAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICAgICAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbW9tZW50LmludmFsaWQoLyogJyArIHRoaXMuX2kgKyAnICovKSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmMgPSAnbW9tZW50JztcbiAgICAgICAgdmFyIHpvbmUgPSAnJztcbiAgICAgICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xuICAgICAgICAgICAgZnVuYyA9IHRoaXMudXRjT2Zmc2V0KCkgPT09IDAgPyAnbW9tZW50LnV0YycgOiAnbW9tZW50LnBhcnNlWm9uZSc7XG4gICAgICAgICAgICB6b25lID0gJ1onO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xuICAgICAgICB2YXIgeWVhciA9ICgwIDw9IHRoaXMueWVhcigpICYmIHRoaXMueWVhcigpIDw9IDk5OTkpID8gJ1lZWVknIDogJ1lZWVlZWSc7XG4gICAgICAgIHZhciBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgICAgICB2YXIgc3VmZml4ID0gem9uZSArICdbXCIpXSc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHByZWZpeCArIHllYXIgKyBkYXRldGltZSArIHN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgICAgICBpZiAoIWlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKSA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiBob29rcy5kZWZhdWx0Rm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb20gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXG4gICAgICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRoaXMubWludXRlcygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kcygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRzKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Vla3MgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtkYXkoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXRzID09PSAnaXNvV2VlaycpIHtcbiAgICAgICAgICAgIHRoaXMuaXNvV2Vla2RheSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHF1YXJ0ZXJzIGFyZSBhbHNvIHNwZWNpYWxcbiAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgIHRoaXMubW9udGgoTWF0aC5mbG9vcih0aGlzLm1vbnRoKCkgLyAzKSAqIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAnZGF0ZScgaXMgYW4gYWxpYXMgZm9yICdkYXknLCBzbyBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBzdWNoLlxuICAgICAgICBpZiAodW5pdHMgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgdW5pdHMgPSAnZGF5JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCAodW5pdHMgPT09ICdpc29XZWVrJyA/ICd3ZWVrJyA6IHVuaXRzKSkuc3VidHJhY3QoMSwgJ21zJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXggKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFttLnllYXIoKSwgbS5tb250aCgpLCBtLmRhdGUoKSwgbS5ob3VyKCksIG0ubWludXRlKCksIG0uc2Vjb25kKCksIG0ubWlsbGlzZWNvbmQoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcbiAgICAgICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxuICAgICAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgICAgICAvLyBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsXG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMudG9JU09TdHJpbmcoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0aW9uRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9mLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgICAgICBzdHJpY3Q6IHRoaXMuX3N0cmljdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICAgICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID9cbiAgICAgICAgICAobG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlKSA6XG4gICAgICAgICAgbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbnV0ZScsIDE0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ20nLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW47XG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgIH1cblxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgfVxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZDtcbiAgICBwcm90by5jYWxlbmRhciAgICAgICAgICA9IGNhbGVuZGFyJDE7XG4gICAgcHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbiAgICBwcm90by5kaWZmICAgICAgICAgICAgICA9IGRpZmY7XG4gICAgcHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbiAgICBwcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbiAgICBwcm90by5mcm9tICAgICAgICAgICAgICA9IGZyb207XG4gICAgcHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xuICAgIHByb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG4gICAgcHJvdG8udG9Ob3cgICAgICAgICAgICAgPSB0b05vdztcbiAgICBwcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcbiAgICBwcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbiAgICBwcm90by5pc0FmdGVyICAgICAgICAgICA9IGlzQWZ0ZXI7XG4gICAgcHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbiAgICBwcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbiAgICBwcm90by5pc1NhbWUgICAgICAgICAgICA9IGlzU2FtZTtcbiAgICBwcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgcHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBwcm90by5pc1ZhbGlkICAgICAgICAgICA9IGlzVmFsaWQkMjtcbiAgICBwcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG4gICAgcHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG4gICAgcHJvdG8ubG9jYWxlRGF0YSAgICAgICAgPSBsb2NhbGVEYXRhO1xuICAgIHByb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xuICAgIHByb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xuICAgIHByb3RvLnBhcnNpbmdGbGFncyAgICAgID0gcGFyc2luZ0ZsYWdzO1xuICAgIHByb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xuICAgIHByb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbiAgICBwcm90by5zdWJ0cmFjdCAgICAgICAgICA9IHN1YnRyYWN0O1xuICAgIHByb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbiAgICBwcm90by50b09iamVjdCAgICAgICAgICA9IHRvT2JqZWN0O1xuICAgIHByb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xuICAgIHByb3RvLnRvSVNPU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmc7XG4gICAgcHJvdG8uaW5zcGVjdCAgICAgICAgICAgPSBpbnNwZWN0O1xuICAgIHByb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xuICAgIHByb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG4gICAgcHJvdG8udW5peCAgICAgICAgICAgICAgPSB1bml4O1xuICAgIHByb3RvLnZhbHVlT2YgICAgICAgICAgID0gdmFsdWVPZjtcbiAgICBwcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcbiAgICBwcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbiAgICBwcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcbiAgICBwcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG4gICAgcHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcbiAgICBwcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xuICAgIHByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG4gICAgcHJvdG8ud2VlayAgICAgICAgICAgPSBwcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xuICAgIHByb3RvLmlzb1dlZWsgICAgICAgID0gcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbiAgICBwcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG4gICAgcHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG4gICAgcHJvdG8uZGF5ICAgICAgICA9IHByb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgcHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBwcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIHByb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG4gICAgcHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcbiAgICBwcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuICAgIHByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG4gICAgcHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBwcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbiAgICBwcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xuICAgIHByb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICBwcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIHByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgcHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBwcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgcHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbiAgICBwcm90by5pc1V0YyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuICAgIHByb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBwcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuICAgIHByb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbiAgICBwcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbiAgICBwcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbiAgICBwcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJywgZ2V0U2V0Wm9uZSk7XG4gICAgcHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKCdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJywgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluWm9uZSAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMS5jYWxlbmRhciAgICAgICAgPSBjYWxlbmRhcjtcbiAgICBwcm90byQxLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvJDEuaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG8kMS5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgIHByb3RvJDEucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvJDEucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbiAgICBwcm90byQxLnNldCAgICAgICAgICAgICA9IHNldDtcblxuICAgIHByb3RvJDEubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgIHByb3RvJDEubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG8kMS5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90byQxLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90byQxLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90byQxLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICBwcm90byQxLndlZWtkYXlzUmVnZXggICAgICAgPSAgICAgICAgd2Vla2RheXNSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCAgPSAgICAgICAgd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgcHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBnZXQkMSAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG4gICAgICAgIHZhciB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzSW1wbCAoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgLy8gKClcbiAgICAvLyAoNSlcbiAgICAvLyAoZm10LCA1KVxuICAgIC8vIChmbXQpXG4gICAgLy8gKHRydWUpXG4gICAgLy8gKHRydWUsIDUpXG4gICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAvLyAodHJ1ZSwgZm10KVxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXMgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0IChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG4gICAgfVxuXG4gICAgZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICBob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGdldFNldEdsb2JhbExvY2FsZSk7XG4gICAgaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBnZXRMb2NhbGUpO1xuXG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCQxIChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBhZGQkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXlzO1xuICAgICAgICB2YXIgbW9udGhzO1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzICAgPSB0aGlzLl9kYXlzICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHJldHVybiB1bml0cyA9PT0gJ21vbnRoJyA/IG1vbnRocyA6IG1vbnRocyAvIDEyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbiAgICBmdW5jdGlvbiB2YWx1ZU9mJDEgKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyk7XG4gICAgdmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG4gICAgdmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XG4gICAgdmFyIGFzSG91cnMgICAgICAgID0gbWFrZUFzKCdoJyk7XG4gICAgdmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG4gICAgdmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XG4gICAgdmFyIGFzTW9udGhzICAgICAgID0gbWFrZUFzKCdNJyk7XG4gICAgdmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbiAgICBmdW5jdGlvbiBjbG9uZSQxICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldCQyICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpc1t1bml0cyArICdzJ10oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xuICAgIHZhciBzZWNvbmRzICAgICAgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyk7XG4gICAgdmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbiAgICB2YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbiAgICB2YXIgZGF5cyAgICAgICAgID0gbWFrZUdldHRlcignZGF5cycpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbiAgICB2YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzICgpIHtcbiAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICB2YXIgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgc3M6IDQ0LCAgICAgICAgIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgICAgICBzIDogNDUsICAgICAgICAgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICAgICAgbSA6IDQ1LCAgICAgICAgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICBoIDogMjIsICAgICAgICAgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgIGQgOiAyNiwgICAgICAgICAvLyBkYXlzIHRvIG1vbnRoXG4gICAgICAgIE0gOiAxMSAgICAgICAgICAvLyBtb250aHMgdG8geWVhclxuICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICAgICAgdmFyIHNlY29uZHMgID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSk7XG4gICAgICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgICAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICAgICAgdmFyIGRheXMgICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSk7XG4gICAgICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgICAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgICAgICB2YXIgYSA9IHNlY29uZHMgPD0gdGhyZXNob2xkcy5zcyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcbiAgICAgICAgICAgICAgICBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICAgJiYgWydzcycsIHNlY29uZHNdIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gICAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDw9IDEgICAgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAgICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2QnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICAgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gICAmJiBbJ01NJywgbW9udGhzXSAgfHxcbiAgICAgICAgICAgICAgICB5ZWFycyAgIDw9IDEgICAgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIChyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKHJvdW5kaW5nRnVuY3Rpb24pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIHZhciBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWJzJDEgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIHNpZ24oeCkge1xuICAgICAgICByZXR1cm4gKCh4ID4gMCkgLSAoeCA8IDApKSB8fCAreDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyQxKCkge1xuICAgICAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgICAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAgICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgICAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAgICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gYWJzJDEodGhpcy5fZGF5cyk7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSBhYnMkMSh0aGlzLl9tb250aHMpO1xuICAgICAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgdmFyIFkgPSB5ZWFycztcbiAgICAgICAgdmFyIE0gPSBtb250aHM7XG4gICAgICAgIHZhciBEID0gZGF5cztcbiAgICAgICAgdmFyIGggPSBob3VycztcbiAgICAgICAgdmFyIG0gPSBtaW51dGVzO1xuICAgICAgICB2YXIgcyA9IHNlY29uZHMgPyBzZWNvbmRzLnRvRml4ZWQoMykucmVwbGFjZSgvXFwuPzArJC8sICcnKSA6ICcnO1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3RhbFNpZ24gPSB0b3RhbCA8IDAgPyAnLScgOiAnJztcbiAgICAgICAgdmFyIHltU2lnbiA9IHNpZ24odGhpcy5fbW9udGhzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgdmFyIGRheXNTaWduID0gc2lnbih0aGlzLl9kYXlzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgdmFyIGhtc1NpZ24gPSBzaWduKHRoaXMuX21pbGxpc2Vjb25kcykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG5cbiAgICAgICAgcmV0dXJuIHRvdGFsU2lnbiArICdQJyArXG4gICAgICAgICAgICAoWSA/IHltU2lnbiArIFkgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgKE0gPyB5bVNpZ24gKyBNICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChEID8gZGF5c1NpZ24gKyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChoID8gaG1zU2lnbiArIGggKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgKG0gPyBobXNTaWduICsgbSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAocyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpO1xuICAgIH1cblxuICAgIHZhciBwcm90byQyID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMi5pc1ZhbGlkICAgICAgICA9IGlzVmFsaWQkMTtcbiAgICBwcm90byQyLmFicyAgICAgICAgICAgID0gYWJzO1xuICAgIHByb3RvJDIuYWRkICAgICAgICAgICAgPSBhZGQkMTtcbiAgICBwcm90byQyLnN1YnRyYWN0ICAgICAgID0gc3VidHJhY3QkMTtcbiAgICBwcm90byQyLmFzICAgICAgICAgICAgID0gYXM7XG4gICAgcHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG4gICAgcHJvdG8kMi5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbiAgICBwcm90byQyLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbiAgICBwcm90byQyLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xuICAgIHByb3RvJDIuYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xuICAgIHByb3RvJDIuYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbiAgICBwcm90byQyLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbiAgICBwcm90byQyLnZhbHVlT2YgICAgICAgID0gdmFsdWVPZiQxO1xuICAgIHByb3RvJDIuX2J1YmJsZSAgICAgICAgPSBidWJibGU7XG4gICAgcHJvdG8kMi5jbG9uZSAgICAgICAgICA9IGNsb25lJDE7XG4gICAgcHJvdG8kMi5nZXQgICAgICAgICAgICA9IGdldCQyO1xuICAgIHByb3RvJDIubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XG4gICAgcHJvdG8kMi5taW51dGVzICAgICAgICA9IG1pbnV0ZXM7XG4gICAgcHJvdG8kMi5ob3VycyAgICAgICAgICA9IGhvdXJzO1xuICAgIHByb3RvJDIuZGF5cyAgICAgICAgICAgPSBkYXlzO1xuICAgIHByb3RvJDIud2Vla3MgICAgICAgICAgPSB3ZWVrcztcbiAgICBwcm90byQyLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xuICAgIHByb3RvJDIueWVhcnMgICAgICAgICAgPSB5ZWFycztcbiAgICBwcm90byQyLmh1bWFuaXplICAgICAgID0gaHVtYW5pemU7XG4gICAgcHJvdG8kMi50b0lTT1N0cmluZyAgICA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b0pTT04gICAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcbiAgICBwcm90byQyLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcblxuICAgIHByb3RvJDIudG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJywgdG9JU09TdHJpbmckMSk7XG4gICAgcHJvdG8kMi5sYW5nID0gbGFuZztcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cblxuICAgIGhvb2tzLnZlcnNpb24gPSAnMi4yMi4yJztcblxuICAgIHNldEhvb2tDYWxsYmFjayhjcmVhdGVMb2NhbCk7XG5cbiAgICBob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBwcm90bztcbiAgICBob29rcy5taW4gICAgICAgICAgICAgICAgICAgPSBtaW47XG4gICAgaG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuICAgIGhvb2tzLm5vdyAgICAgICAgICAgICAgICAgICA9IG5vdztcbiAgICBob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVVEM7XG4gICAgaG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gY3JlYXRlVW5peDtcbiAgICBob29rcy5tb250aHMgICAgICAgICAgICAgICAgPSBsaXN0TW9udGhzO1xuICAgIGhvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbiAgICBob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBnZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgaG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gY3JlYXRlSW52YWxpZDtcbiAgICBob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVEdXJhdGlvbjtcbiAgICBob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbiAgICBob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0V2Vla2RheXM7XG4gICAgaG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gY3JlYXRlSW5ab25lO1xuICAgIGhvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGdldExvY2FsZTtcbiAgICBob29rcy5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xuICAgIGhvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RNb250aHNTaG9ydDtcbiAgICBob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0V2Vla2RheXNNaW47XG4gICAgaG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xuICAgIGhvb2tzLnVwZGF0ZUxvY2FsZSAgICAgICAgICA9IHVwZGF0ZUxvY2FsZTtcbiAgICBob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsaXN0TG9jYWxlcztcbiAgICBob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0V2Vla2RheXNTaG9ydDtcbiAgICBob29rcy5ub3JtYWxpemVVbml0cyAgICAgICAgPSBub3JtYWxpemVVbml0cztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyAgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG4gICAgaG9va3MuY2FsZW5kYXJGb3JtYXQgICAgICAgID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG4gICAgaG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gcHJvdG87XG5cbiAgICAvLyBjdXJyZW50bHkgSFRNTDUgaW5wdXQgdHlwZSBvbmx5IHN1cHBvcnRzIDI0LWhvdXIgZm9ybWF0c1xuICAgIGhvb2tzLkhUTUw1X0ZNVCA9IHtcbiAgICAgICAgREFURVRJTUVfTE9DQUw6ICdZWVlZLU1NLUREVEhIOm1tJywgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX1NFQ09ORFM6ICdZWVlZLU1NLUREVEhIOm1tOnNzJywgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX01TOiAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1MnLCAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBEQVRFOiAnWVlZWS1NTS1ERCcsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxuICAgICAgICBUSU1FOiAnSEg6bW0nLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiAvPlxuICAgICAgICBUSU1FX1NFQ09ORFM6ICdISDptbTpzcycsICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIFRJTUVfTVM6ICdISDptbTpzcy5TU1MnLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIFdFRUs6ICdZWVlZLVtXXVdXJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwid2Vla1wiIC8+XG4gICAgICAgIE1PTlRIOiAnWVlZWS1NTScgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwibW9udGhcIiAvPlxuICAgIH07XG5cbiAgICByZXR1cm4gaG9va3M7XG5cbn0pKSk7XG4iLCIvLyAgICAgKGMpIDIwMTItMjAxNiBBaXJibmIsIEluYy5cbi8vXG4vLyAgICAgcG9seWdsb3QuanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEJTRFxuLy8gICAgIGxpY2Vuc2UuIEZvciBhbGwgbGljZW5zaW5nIGluZm9ybWF0aW9uLCBkZXRhaWxzLCBhbmQgZG9jdW1lbnRpb246XG4vLyAgICAgaHR0cDovL2FpcmJuYi5naXRodWIuY29tL3BvbHlnbG90LmpzXG4vL1xuLy9cbi8vIFBvbHlnbG90LmpzIGlzIGFuIEkxOG4gaGVscGVyIGxpYnJhcnkgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LCBtYWRlIHRvXG4vLyB3b3JrIGJvdGggaW4gdGhlIGJyb3dzZXIgYW5kIGluIE5vZGUuIEl0IHByb3ZpZGVzIGEgc2ltcGxlIHNvbHV0aW9uIGZvclxuLy8gaW50ZXJwb2xhdGlvbiBhbmQgcGx1cmFsaXphdGlvbiwgYmFzZWQgb2ZmIG9mIEFpcmJuYidzXG4vLyBleHBlcmllbmNlIGFkZGluZyBJMThuIGZ1bmN0aW9uYWxpdHkgdG8gaXRzIEJhY2tib25lLmpzIGFuZCBOb2RlIGFwcHMuXG4vL1xuLy8gUG9seWxnbG90IGlzIGFnbm9zdGljIHRvIHlvdXIgdHJhbnNsYXRpb24gYmFja2VuZC4gSXQgZG9lc24ndCBwZXJmb3JtIGFueVxuLy8gdHJhbnNsYXRpb247IGl0IHNpbXBseSBnaXZlcyB5b3UgYSB3YXkgdG8gbWFuYWdlIHRyYW5zbGF0ZWQgcGhyYXNlcyBmcm9tXG4vLyB5b3VyIGNsaWVudC0gb3Igc2VydmVyLXNpZGUgSmF2YVNjcmlwdCBhcHBsaWNhdGlvbi5cbi8vXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3ItZWFjaCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgdHJpbSA9IHJlcXVpcmUoJ3N0cmluZy5wcm90b3R5cGUudHJpbScpO1xuXG52YXIgd2FybiA9IGZ1bmN0aW9uIHdhcm4obWVzc2FnZSkge1xuICB3YXJuaW5nKGZhbHNlLCBtZXNzYWdlKTtcbn07XG5cbnZhciByZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xudmFyIHNwbGl0ID0gU3RyaW5nLnByb3RvdHlwZS5zcGxpdDtcblxuLy8gIyMjIyBQbHVyYWxpemF0aW9uIG1ldGhvZHNcbi8vIFRoZSBzdHJpbmcgdGhhdCBzZXBhcmF0ZXMgdGhlIGRpZmZlcmVudCBwaHJhc2UgcG9zc2liaWxpdGllcy5cbnZhciBkZWxpbWV0ZXIgPSAnfHx8fCc7XG5cbi8vIE1hcHBpbmcgZnJvbSBwbHVyYWxpemF0aW9uIGdyb3VwIHBsdXJhbCBsb2dpYy5cbnZhciBwbHVyYWxUeXBlcyA9IHtcbiAgYXJhYmljOiBmdW5jdGlvbiAobikge1xuICAgIC8vIGh0dHA6Ly93d3cuYXJhYmV5ZXMub3JnL1BsdXJhbF9Gb3Jtc1xuICAgIGlmIChuIDwgMykgeyByZXR1cm4gbjsgfVxuICAgIGlmIChuICUgMTAwID49IDMgJiYgbiAlIDEwMCA8PSAxMCkgcmV0dXJuIDM7XG4gICAgcmV0dXJuIG4gJSAxMDAgPj0gMTEgPyA0IDogNTtcbiAgfSxcbiAgY2hpbmVzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfSxcbiAgZ2VybWFuOiBmdW5jdGlvbiAobikgeyByZXR1cm4gbiAhPT0gMSA/IDEgOiAwOyB9LFxuICBmcmVuY2g6IGZ1bmN0aW9uIChuKSB7IHJldHVybiBuID4gMSA/IDEgOiAwOyB9LFxuICBydXNzaWFuOiBmdW5jdGlvbiAobikge1xuICAgIGlmIChuICUgMTAgPT09IDEgJiYgbiAlIDEwMCAhPT0gMTEpIHsgcmV0dXJuIDA7IH1cbiAgICByZXR1cm4gbiAlIDEwID49IDIgJiYgbiAlIDEwIDw9IDQgJiYgKG4gJSAxMDAgPCAxMCB8fCBuICUgMTAwID49IDIwKSA/IDEgOiAyO1xuICB9LFxuICBjemVjaDogZnVuY3Rpb24gKG4pIHtcbiAgICBpZiAobiA9PT0gMSkgeyByZXR1cm4gMDsgfVxuICAgIHJldHVybiAobiA+PSAyICYmIG4gPD0gNCkgPyAxIDogMjtcbiAgfSxcbiAgcG9saXNoOiBmdW5jdGlvbiAobikge1xuICAgIGlmIChuID09PSAxKSB7IHJldHVybiAwOyB9XG4gICAgcmV0dXJuIG4gJSAxMCA+PSAyICYmIG4gJSAxMCA8PSA0ICYmIChuICUgMTAwIDwgMTAgfHwgbiAlIDEwMCA+PSAyMCkgPyAxIDogMjtcbiAgfSxcbiAgaWNlbGFuZGljOiBmdW5jdGlvbiAobikgeyByZXR1cm4gKG4gJSAxMCAhPT0gMSB8fCBuICUgMTAwID09PSAxMSkgPyAxIDogMDsgfVxufTtcblxuLy8gTWFwcGluZyBmcm9tIHBsdXJhbGl6YXRpb24gZ3JvdXAgdG8gaW5kaXZpZHVhbCBsb2NhbGVzLlxudmFyIHBsdXJhbFR5cGVUb0xhbmd1YWdlcyA9IHtcbiAgYXJhYmljOiBbJ2FyJ10sXG4gIGNoaW5lc2U6IFsnZmEnLCAnaWQnLCAnamEnLCAna28nLCAnbG8nLCAnbXMnLCAndGgnLCAndHInLCAnemgnXSxcbiAgZ2VybWFuOiBbJ2RhJywgJ2RlJywgJ2VuJywgJ2VzJywgJ2ZpJywgJ2VsJywgJ2hlJywgJ2h1JywgJ2l0JywgJ25sJywgJ25vJywgJ3B0JywgJ3N2J10sXG4gIGZyZW5jaDogWydmcicsICd0bCcsICdwdC1iciddLFxuICBydXNzaWFuOiBbJ2hyJywgJ3J1JywgJ2x0J10sXG4gIGN6ZWNoOiBbJ2NzJywgJ3NrJ10sXG4gIHBvbGlzaDogWydwbCddLFxuICBpY2VsYW5kaWM6IFsnaXMnXVxufTtcblxuZnVuY3Rpb24gbGFuZ1RvVHlwZU1hcChtYXBwaW5nKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgZm9yRWFjaChtYXBwaW5nLCBmdW5jdGlvbiAobGFuZ3MsIHR5cGUpIHtcbiAgICBmb3JFYWNoKGxhbmdzLCBmdW5jdGlvbiAobGFuZykge1xuICAgICAgcmV0W2xhbmddID0gdHlwZTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHBsdXJhbFR5cGVOYW1lKGxvY2FsZSkge1xuICB2YXIgbGFuZ1RvUGx1cmFsVHlwZSA9IGxhbmdUb1R5cGVNYXAocGx1cmFsVHlwZVRvTGFuZ3VhZ2VzKTtcbiAgcmV0dXJuIGxhbmdUb1BsdXJhbFR5cGVbbG9jYWxlXVxuICAgIHx8IGxhbmdUb1BsdXJhbFR5cGVbc3BsaXQuY2FsbChsb2NhbGUsIC8tLywgMSlbMF1dXG4gICAgfHwgbGFuZ1RvUGx1cmFsVHlwZS5lbjtcbn1cblxuZnVuY3Rpb24gcGx1cmFsVHlwZUluZGV4KGxvY2FsZSwgY291bnQpIHtcbiAgcmV0dXJuIHBsdXJhbFR5cGVzW3BsdXJhbFR5cGVOYW1lKGxvY2FsZSldKGNvdW50KTtcbn1cblxudmFyIGRvbGxhclJlZ2V4ID0gL1xcJC9nO1xudmFyIGRvbGxhckJpbGxzWWFsbCA9ICckJCc7XG52YXIgdG9rZW5SZWdleCA9IC8lXFx7KC4qPylcXH0vZztcblxuLy8gIyMjIHRyYW5zZm9ybVBocmFzZShwaHJhc2UsIHN1YnN0aXR1dGlvbnMsIGxvY2FsZSlcbi8vXG4vLyBUYWtlcyBhIHBocmFzZSBzdHJpbmcgYW5kIHRyYW5zZm9ybXMgaXQgYnkgY2hvb3NpbmcgdGhlIGNvcnJlY3Rcbi8vIHBsdXJhbCBmb3JtIGFuZCBpbnRlcnBvbGF0aW5nIGl0LlxuLy9cbi8vICAgICB0cmFuc2Zvcm1QaHJhc2UoJ0hlbGxvLCAle25hbWV9IScsIHtuYW1lOiAnU3Bpa2UnfSk7XG4vLyAgICAgLy8gXCJIZWxsbywgU3Bpa2UhXCJcbi8vXG4vLyBUaGUgY29ycmVjdCBwbHVyYWwgZm9ybSBpcyBzZWxlY3RlZCBpZiBzdWJzdGl0dXRpb25zLnNtYXJ0X2NvdW50XG4vLyBpcyBzZXQuIFlvdSBjYW4gcGFzcyBpbiBhIG51bWJlciBpbnN0ZWFkIG9mIGFuIE9iamVjdCBhcyBgc3Vic3RpdHV0aW9uc2Bcbi8vIGFzIGEgc2hvcnRjdXQgZm9yIGBzbWFydF9jb3VudGAuXG4vL1xuLy8gICAgIHRyYW5zZm9ybVBocmFzZSgnJXtzbWFydF9jb3VudH0gbmV3IG1lc3NhZ2VzIHx8fHwgMSBuZXcgbWVzc2FnZScsIHtzbWFydF9jb3VudDogMX0sICdlbicpO1xuLy8gICAgIC8vIFwiMSBuZXcgbWVzc2FnZVwiXG4vL1xuLy8gICAgIHRyYW5zZm9ybVBocmFzZSgnJXtzbWFydF9jb3VudH0gbmV3IG1lc3NhZ2VzIHx8fHwgMSBuZXcgbWVzc2FnZScsIHtzbWFydF9jb3VudDogMn0sICdlbicpO1xuLy8gICAgIC8vIFwiMiBuZXcgbWVzc2FnZXNcIlxuLy9cbi8vICAgICB0cmFuc2Zvcm1QaHJhc2UoJyV7c21hcnRfY291bnR9IG5ldyBtZXNzYWdlcyB8fHx8IDEgbmV3IG1lc3NhZ2UnLCA1LCAnZW4nKTtcbi8vICAgICAvLyBcIjUgbmV3IG1lc3NhZ2VzXCJcbi8vXG4vLyBZb3Ugc2hvdWxkIHBhc3MgaW4gYSB0aGlyZCBhcmd1bWVudCwgdGhlIGxvY2FsZSwgdG8gc3BlY2lmeSB0aGUgY29ycmVjdCBwbHVyYWwgdHlwZS5cbi8vIEl0IGRlZmF1bHRzIHRvIGAnZW4nYCB3aXRoIDIgcGx1cmFsIGZvcm1zLlxuZnVuY3Rpb24gdHJhbnNmb3JtUGhyYXNlKHBocmFzZSwgc3Vic3RpdHV0aW9ucywgbG9jYWxlKSB7XG4gIGlmICh0eXBlb2YgcGhyYXNlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BvbHlnbG90LnRyYW5zZm9ybVBocmFzZSBleHBlY3RzIGFyZ3VtZW50ICMxIHRvIGJlIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKHN1YnN0aXR1dGlvbnMgPT0gbnVsbCkge1xuICAgIHJldHVybiBwaHJhc2U7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gcGhyYXNlO1xuXG4gIC8vIGFsbG93IG51bWJlciBhcyBhIHBsdXJhbGl6YXRpb24gc2hvcnRjdXRcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc3Vic3RpdHV0aW9ucyA9PT0gJ251bWJlcicgPyB7IHNtYXJ0X2NvdW50OiBzdWJzdGl0dXRpb25zIH0gOiBzdWJzdGl0dXRpb25zO1xuXG4gIC8vIFNlbGVjdCBwbHVyYWwgZm9ybTogYmFzZWQgb24gYSBwaHJhc2UgdGV4dCB0aGF0IGNvbnRhaW5zIGBuYFxuICAvLyBwbHVyYWwgZm9ybXMgc2VwYXJhdGVkIGJ5IGBkZWxpbWV0ZXJgLCBhIGBsb2NhbGVgLCBhbmQgYSBgc3Vic3RpdHV0aW9ucy5zbWFydF9jb3VudGAsXG4gIC8vIGNob29zZSB0aGUgY29ycmVjdCBwbHVyYWwgZm9ybS4gVGhpcyBpcyBvbmx5IGRvbmUgaWYgYGNvdW50YCBpcyBzZXQuXG4gIGlmIChvcHRpb25zLnNtYXJ0X2NvdW50ICE9IG51bGwgJiYgcmVzdWx0KSB7XG4gICAgdmFyIHRleHRzID0gc3BsaXQuY2FsbChyZXN1bHQsIGRlbGltZXRlcik7XG4gICAgcmVzdWx0ID0gdHJpbSh0ZXh0c1twbHVyYWxUeXBlSW5kZXgobG9jYWxlIHx8ICdlbicsIG9wdGlvbnMuc21hcnRfY291bnQpXSB8fCB0ZXh0c1swXSk7XG4gIH1cblxuICAvLyBJbnRlcnBvbGF0ZTogQ3JlYXRlcyBhIGBSZWdFeHBgIG9iamVjdCBmb3IgZWFjaCBpbnRlcnBvbGF0aW9uIHBsYWNlaG9sZGVyLlxuICByZXN1bHQgPSByZXBsYWNlLmNhbGwocmVzdWx0LCB0b2tlblJlZ2V4LCBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgYXJndW1lbnQpIHtcbiAgICBpZiAoIWhhcyhvcHRpb25zLCBhcmd1bWVudCkgfHwgb3B0aW9uc1thcmd1bWVudF0gPT0gbnVsbCkgeyByZXR1cm4gZXhwcmVzc2lvbjsgfVxuICAgIC8vIEVuc3VyZSByZXBsYWNlbWVudCB2YWx1ZSBpcyBlc2NhcGVkIHRvIHByZXZlbnQgc3BlY2lhbCAkLXByZWZpeGVkIHJlZ2V4IHJlcGxhY2UgdG9rZW5zLlxuICAgIHJldHVybiByZXBsYWNlLmNhbGwob3B0aW9uc1thcmd1bWVudF0sIGRvbGxhclJlZ2V4LCBkb2xsYXJCaWxsc1lhbGwpO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyAjIyMgUG9seWdsb3QgY2xhc3MgY29uc3RydWN0b3JcbmZ1bmN0aW9uIFBvbHlnbG90KG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnBocmFzZXMgPSB7fTtcbiAgdGhpcy5leHRlbmQob3B0cy5waHJhc2VzIHx8IHt9KTtcbiAgdGhpcy5jdXJyZW50TG9jYWxlID0gb3B0cy5sb2NhbGUgfHwgJ2VuJztcbiAgdmFyIGFsbG93TWlzc2luZyA9IG9wdHMuYWxsb3dNaXNzaW5nID8gdHJhbnNmb3JtUGhyYXNlIDogbnVsbDtcbiAgdGhpcy5vbk1pc3NpbmdLZXkgPSB0eXBlb2Ygb3B0cy5vbk1pc3NpbmdLZXkgPT09ICdmdW5jdGlvbicgPyBvcHRzLm9uTWlzc2luZ0tleSA6IGFsbG93TWlzc2luZztcbiAgdGhpcy53YXJuID0gb3B0cy53YXJuIHx8IHdhcm47XG59XG5cbi8vICMjIyBwb2x5Z2xvdC5sb2NhbGUoW2xvY2FsZV0pXG4vL1xuLy8gR2V0IG9yIHNldCBsb2NhbGUuIEludGVybmFsbHksIFBvbHlnbG90IG9ubHkgdXNlcyBsb2NhbGUgZm9yIHBsdXJhbGl6YXRpb24uXG5Qb2x5Z2xvdC5wcm90b3R5cGUubG9jYWxlID0gZnVuY3Rpb24gKG5ld0xvY2FsZSkge1xuICBpZiAobmV3TG9jYWxlKSB0aGlzLmN1cnJlbnRMb2NhbGUgPSBuZXdMb2NhbGU7XG4gIHJldHVybiB0aGlzLmN1cnJlbnRMb2NhbGU7XG59O1xuXG4vLyAjIyMgcG9seWdsb3QuZXh0ZW5kKHBocmFzZXMpXG4vL1xuLy8gVXNlIGBleHRlbmRgIHRvIHRlbGwgUG9seWdsb3QgaG93IHRvIHRyYW5zbGF0ZSBhIGdpdmVuIGtleS5cbi8vXG4vLyAgICAgcG9seWdsb3QuZXh0ZW5kKHtcbi8vICAgICAgIFwiaGVsbG9cIjogXCJIZWxsb1wiLFxuLy8gICAgICAgXCJoZWxsb19uYW1lXCI6IFwiSGVsbG8sICV7bmFtZX1cIlxuLy8gICAgIH0pO1xuLy9cbi8vIFRoZSBrZXkgY2FuIGJlIGFueSBzdHJpbmcuICBGZWVsIGZyZWUgdG8gY2FsbCBgZXh0ZW5kYCBtdWx0aXBsZSB0aW1lcztcbi8vIGl0IHdpbGwgb3ZlcnJpZGUgYW55IHBocmFzZXMgd2l0aCB0aGUgc2FtZSBrZXksIGJ1dCBsZWF2ZSBleGlzdGluZyBwaHJhc2VzXG4vLyB1bnRvdWNoZWQuXG4vL1xuLy8gSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBwYXNzIG5lc3RlZCBwaHJhc2Ugb2JqZWN0cywgd2hpY2ggZ2V0IGZsYXR0ZW5lZFxuLy8gaW50byBhbiBvYmplY3Qgd2l0aCB0aGUgbmVzdGVkIGtleXMgY29uY2F0ZW5hdGVkIHVzaW5nIGRvdCBub3RhdGlvbi5cbi8vXG4vLyAgICAgcG9seWdsb3QuZXh0ZW5kKHtcbi8vICAgICAgIFwibmF2XCI6IHtcbi8vICAgICAgICAgXCJoZWxsb1wiOiBcIkhlbGxvXCIsXG4vLyAgICAgICAgIFwiaGVsbG9fbmFtZVwiOiBcIkhlbGxvLCAle25hbWV9XCIsXG4vLyAgICAgICAgIFwic2lkZWJhclwiOiB7XG4vLyAgICAgICAgICAgXCJ3ZWxjb21lXCI6IFwiV2VsY29tZVwiXG4vLyAgICAgICAgIH1cbi8vICAgICAgIH1cbi8vICAgICB9KTtcbi8vXG4vLyAgICAgY29uc29sZS5sb2cocG9seWdsb3QucGhyYXNlcyk7XG4vLyAgICAgLy8ge1xuLy8gICAgIC8vICAgJ25hdi5oZWxsbyc6ICdIZWxsbycsXG4vLyAgICAgLy8gICAnbmF2LmhlbGxvX25hbWUnOiAnSGVsbG8sICV7bmFtZX0nLFxuLy8gICAgIC8vICAgJ25hdi5zaWRlYmFyLndlbGNvbWUnOiAnV2VsY29tZSdcbi8vICAgICAvLyB9XG4vL1xuLy8gYGV4dGVuZGAgYWNjZXB0cyBhbiBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQsIGBwcmVmaXhgLCB3aGljaCBjYW4gYmUgdXNlZFxuLy8gdG8gcHJlZml4IGV2ZXJ5IGtleSBpbiB0aGUgcGhyYXNlcyBvYmplY3Qgd2l0aCBzb21lIHN0cmluZywgdXNpbmcgZG90XG4vLyBub3RhdGlvbi5cbi8vXG4vLyAgICAgcG9seWdsb3QuZXh0ZW5kKHtcbi8vICAgICAgIFwiaGVsbG9cIjogXCJIZWxsb1wiLFxuLy8gICAgICAgXCJoZWxsb19uYW1lXCI6IFwiSGVsbG8sICV7bmFtZX1cIlxuLy8gICAgIH0sIFwibmF2XCIpO1xuLy9cbi8vICAgICBjb25zb2xlLmxvZyhwb2x5Z2xvdC5waHJhc2VzKTtcbi8vICAgICAvLyB7XG4vLyAgICAgLy8gICAnbmF2LmhlbGxvJzogJ0hlbGxvJyxcbi8vICAgICAvLyAgICduYXYuaGVsbG9fbmFtZSc6ICdIZWxsbywgJXtuYW1lfSdcbi8vICAgICAvLyB9XG4vL1xuLy8gVGhpcyBmZWF0dXJlIGlzIHVzZWQgaW50ZXJuYWxseSB0byBzdXBwb3J0IG5lc3RlZCBwaHJhc2Ugb2JqZWN0cy5cblBvbHlnbG90LnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAobW9yZVBocmFzZXMsIHByZWZpeCkge1xuICBmb3JFYWNoKG1vcmVQaHJhc2VzLCBmdW5jdGlvbiAocGhyYXNlLCBrZXkpIHtcbiAgICB2YXIgcHJlZml4ZWRLZXkgPSBwcmVmaXggPyBwcmVmaXggKyAnLicgKyBrZXkgOiBrZXk7XG4gICAgaWYgKHR5cGVvZiBwaHJhc2UgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLmV4dGVuZChwaHJhc2UsIHByZWZpeGVkS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5waHJhc2VzW3ByZWZpeGVkS2V5XSA9IHBocmFzZTtcbiAgICB9XG4gIH0sIHRoaXMpO1xufTtcblxuLy8gIyMjIHBvbHlnbG90LnVuc2V0KHBocmFzZXMpXG4vLyBVc2UgYHVuc2V0YCB0byBzZWxlY3RpdmVseSByZW1vdmUga2V5cyBmcm9tIGEgcG9seWdsb3QgaW5zdGFuY2UuXG4vL1xuLy8gICAgIHBvbHlnbG90LnVuc2V0KFwic29tZV9rZXlcIik7XG4vLyAgICAgcG9seWdsb3QudW5zZXQoe1xuLy8gICAgICAgXCJoZWxsb1wiOiBcIkhlbGxvXCIsXG4vLyAgICAgICBcImhlbGxvX25hbWVcIjogXCJIZWxsbywgJXtuYW1lfVwiXG4vLyAgICAgfSk7XG4vL1xuLy8gVGhlIHVuc2V0IG1ldGhvZCBjYW4gdGFrZSBlaXRoZXIgYSBzdHJpbmcgKGZvciB0aGUga2V5KSwgb3IgYW4gb2JqZWN0IGhhc2ggd2l0aFxuLy8gdGhlIGtleXMgdGhhdCB5b3Ugd291bGQgbGlrZSB0byB1bnNldC5cblBvbHlnbG90LnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uIChtb3JlUGhyYXNlcywgcHJlZml4KSB7XG4gIGlmICh0eXBlb2YgbW9yZVBocmFzZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgZGVsZXRlIHRoaXMucGhyYXNlc1ttb3JlUGhyYXNlc107XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaChtb3JlUGhyYXNlcywgZnVuY3Rpb24gKHBocmFzZSwga2V5KSB7XG4gICAgICB2YXIgcHJlZml4ZWRLZXkgPSBwcmVmaXggPyBwcmVmaXggKyAnLicgKyBrZXkgOiBrZXk7XG4gICAgICBpZiAodHlwZW9mIHBocmFzZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy51bnNldChwaHJhc2UsIHByZWZpeGVkS2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBocmFzZXNbcHJlZml4ZWRLZXldO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9XG59O1xuXG4vLyAjIyMgcG9seWdsb3QuY2xlYXIoKVxuLy9cbi8vIENsZWFycyBhbGwgcGhyYXNlcy4gVXNlZnVsIGZvciBzcGVjaWFsIGNhc2VzLCBzdWNoIGFzIGZyZWVpbmdcbi8vIHVwIG1lbW9yeSBpZiB5b3UgaGF2ZSBsb3RzIG9mIHBocmFzZXMgYnV0IG5vIGxvbmdlciBuZWVkIHRvXG4vLyBwZXJmb3JtIGFueSB0cmFuc2xhdGlvbi4gQWxzbyB1c2VkIGludGVybmFsbHkgYnkgYHJlcGxhY2VgLlxuUG9seWdsb3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBocmFzZXMgPSB7fTtcbn07XG5cbi8vICMjIyBwb2x5Z2xvdC5yZXBsYWNlKHBocmFzZXMpXG4vL1xuLy8gQ29tcGxldGVseSByZXBsYWNlIHRoZSBleGlzdGluZyBwaHJhc2VzIHdpdGggYSBuZXcgc2V0IG9mIHBocmFzZXMuXG4vLyBOb3JtYWxseSwganVzdCB1c2UgYGV4dGVuZGAgdG8gYWRkIG1vcmUgcGhyYXNlcywgYnV0IHVuZGVyIGNlcnRhaW5cbi8vIGNpcmN1bXN0YW5jZXMsIHlvdSBtYXkgd2FudCB0byBtYWtlIHN1cmUgbm8gb2xkIHBocmFzZXMgYXJlIGx5aW5nIGFyb3VuZC5cblBvbHlnbG90LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKG5ld1BocmFzZXMpIHtcbiAgdGhpcy5jbGVhcigpO1xuICB0aGlzLmV4dGVuZChuZXdQaHJhc2VzKTtcbn07XG5cblxuLy8gIyMjIHBvbHlnbG90LnQoa2V5LCBvcHRpb25zKVxuLy9cbi8vIFRoZSBtb3N0LXVzZWQgbWV0aG9kLiBQcm92aWRlIGEga2V5LCBhbmQgYHRgIHdpbGwgcmV0dXJuIHRoZVxuLy8gcGhyYXNlLlxuLy9cbi8vICAgICBwb2x5Z2xvdC50KFwiaGVsbG9cIik7XG4vLyAgICAgPT4gXCJIZWxsb1wiXG4vL1xuLy8gVGhlIHBocmFzZSB2YWx1ZSBpcyBwcm92aWRlZCBmaXJzdCBieSBhIGNhbGwgdG8gYHBvbHlnbG90LmV4dGVuZCgpYCBvclxuLy8gYHBvbHlnbG90LnJlcGxhY2UoKWAuXG4vL1xuLy8gUGFzcyBpbiBhbiBvYmplY3QgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBwZXJmb3JtIGludGVycG9sYXRpb24uXG4vL1xuLy8gICAgIHBvbHlnbG90LnQoXCJoZWxsb19uYW1lXCIsIHtuYW1lOiBcIlNwaWtlXCJ9KTtcbi8vICAgICA9PiBcIkhlbGxvLCBTcGlrZVwiXG4vL1xuLy8gSWYgeW91IGxpa2UsIHlvdSBjYW4gcHJvdmlkZSBhIGRlZmF1bHQgdmFsdWUgaW4gY2FzZSB0aGUgcGhyYXNlIGlzIG1pc3NpbmcuXG4vLyBVc2UgdGhlIHNwZWNpYWwgb3B0aW9uIGtleSBcIl9cIiB0byBzcGVjaWZ5IGEgZGVmYXVsdC5cbi8vXG4vLyAgICAgcG9seWdsb3QudChcImlfbGlrZV90b193cml0ZV9pbl9sYW5ndWFnZVwiLCB7XG4vLyAgICAgICBfOiBcIkkgbGlrZSB0byB3cml0ZSBpbiAle2xhbmd1YWdlfS5cIixcbi8vICAgICAgIGxhbmd1YWdlOiBcIkphdmFTY3JpcHRcIlxuLy8gICAgIH0pO1xuLy8gICAgID0+IFwiSSBsaWtlIHRvIHdyaXRlIGluIEphdmFTY3JpcHQuXCJcbi8vXG5Qb2x5Z2xvdC5wcm90b3R5cGUudCA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMpIHtcbiAgdmFyIHBocmFzZSwgcmVzdWx0O1xuICB2YXIgb3B0cyA9IG9wdGlvbnMgPT0gbnVsbCA/IHt9IDogb3B0aW9ucztcbiAgaWYgKHR5cGVvZiB0aGlzLnBocmFzZXNba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICBwaHJhc2UgPSB0aGlzLnBocmFzZXNba2V5XTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5fID09PSAnc3RyaW5nJykge1xuICAgIHBocmFzZSA9IG9wdHMuXztcbiAgfSBlbHNlIGlmICh0aGlzLm9uTWlzc2luZ0tleSkge1xuICAgIHZhciBvbk1pc3NpbmdLZXkgPSB0aGlzLm9uTWlzc2luZ0tleTtcbiAgICByZXN1bHQgPSBvbk1pc3NpbmdLZXkoa2V5LCBvcHRzLCB0aGlzLmN1cnJlbnRMb2NhbGUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2FybignTWlzc2luZyB0cmFuc2xhdGlvbiBmb3Iga2V5OiBcIicgKyBrZXkgKyAnXCInKTtcbiAgICByZXN1bHQgPSBrZXk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwaHJhc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gdHJhbnNmb3JtUGhyYXNlKHBocmFzZSwgb3B0cywgdGhpcy5jdXJyZW50TG9jYWxlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLyAjIyMgcG9seWdsb3QuaGFzKGtleSlcbi8vXG4vLyBDaGVjayBpZiBwb2x5Z2xvdCBoYXMgYSB0cmFuc2xhdGlvbiBmb3IgZ2l2ZW4ga2V5XG5Qb2x5Z2xvdC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gaGFzKHRoaXMucGhyYXNlcywga2V5KTtcbn07XG5cbi8vIGV4cG9ydCB0cmFuc2Zvcm1QaHJhc2VcblBvbHlnbG90LnRyYW5zZm9ybVBocmFzZSA9IHRyYW5zZm9ybVBocmFzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z2xvdDtcbiIsIi8qIVxuICogUGlrYWRheVxuICpcbiAqIENvcHlyaWdodCDCqSAyMDE0IERhdmlkIEJ1c2hlbGwgfCBCU0QgJiBNSVQgbGljZW5zZSB8IGh0dHBzOi8vZ2l0aHViLmNvbS9kYnVzaGVsbC9QaWthZGF5XG4gKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KVxue1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBtb21lbnQ7XG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBDb21tb25KUyBtb2R1bGVcbiAgICAgICAgLy8gTG9hZCBtb21lbnQuanMgYXMgYW4gb3B0aW9uYWwgZGVwZW5kZW5jeVxuICAgICAgICB0cnkgeyBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTsgfSBjYXRjaCAoZSkge31cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KG1vbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoZnVuY3Rpb24gKHJlcSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gTG9hZCBtb21lbnQuanMgYXMgYW4gb3B0aW9uYWwgZGVwZW5kZW5jeVxuICAgICAgICAgICAgdmFyIGlkID0gJ21vbWVudCc7XG4gICAgICAgICAgICB0cnkgeyBtb21lbnQgPSByZXEoaWQpOyB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkobW9tZW50KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5QaWthZGF5ID0gZmFjdG9yeShyb290Lm1vbWVudCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KVxue1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIGZlYXR1cmUgZGV0ZWN0aW9uIGFuZCBoZWxwZXIgZnVuY3Rpb25zXG4gICAgICovXG4gICAgdmFyIGhhc01vbWVudCA9IHR5cGVvZiBtb21lbnQgPT09ICdmdW5jdGlvbicsXG5cbiAgICBoYXNFdmVudExpc3RlbmVycyA9ICEhd2luZG93LmFkZEV2ZW50TGlzdGVuZXIsXG5cbiAgICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcblxuICAgIHN0byA9IHdpbmRvdy5zZXRUaW1lb3V0LFxuXG4gICAgYWRkRXZlbnQgPSBmdW5jdGlvbihlbCwgZSwgY2FsbGJhY2ssIGNhcHR1cmUpXG4gICAge1xuICAgICAgICBpZiAoaGFzRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZSwgY2FsbGJhY2ssICEhY2FwdHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oZWwsIGUsIGNhbGxiYWNrLCBjYXB0dXJlKVxuICAgIHtcbiAgICAgICAgaWYgKGhhc0V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGUsIGNhbGxiYWNrLCAhIWNhcHR1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0cmltID0gZnVuY3Rpb24oc3RyKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCcnKTtcbiAgICB9LFxuXG4gICAgaGFzQ2xhc3MgPSBmdW5jdGlvbihlbCwgY24pXG4gICAge1xuICAgICAgICByZXR1cm4gKCcgJyArIGVsLmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignICcgKyBjbiArICcgJykgIT09IC0xO1xuICAgIH0sXG5cbiAgICBhZGRDbGFzcyA9IGZ1bmN0aW9uKGVsLCBjbilcbiAgICB7XG4gICAgICAgIGlmICghaGFzQ2xhc3MoZWwsIGNuKSkge1xuICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gKGVsLmNsYXNzTmFtZSA9PT0gJycpID8gY24gOiBlbC5jbGFzc05hbWUgKyAnICcgKyBjbjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKGVsLCBjbilcbiAgICB7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IHRyaW0oKCcgJyArIGVsLmNsYXNzTmFtZSArICcgJykucmVwbGFjZSgnICcgKyBjbiArICcgJywgJyAnKSk7XG4gICAgfSxcblxuICAgIGlzQXJyYXkgPSBmdW5jdGlvbihvYmopXG4gICAge1xuICAgICAgICByZXR1cm4gKC9BcnJheS8pLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpO1xuICAgIH0sXG5cbiAgICBpc0RhdGUgPSBmdW5jdGlvbihvYmopXG4gICAge1xuICAgICAgICByZXR1cm4gKC9EYXRlLykudGVzdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgJiYgIWlzTmFOKG9iai5nZXRUaW1lKCkpO1xuICAgIH0sXG5cbiAgICBpc1dlZWtlbmQgPSBmdW5jdGlvbihkYXRlKVxuICAgIHtcbiAgICAgICAgdmFyIGRheSA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgIHJldHVybiBkYXkgPT09IDAgfHwgZGF5ID09PSA2O1xuICAgIH0sXG5cbiAgICBpc0xlYXBZZWFyID0gZnVuY3Rpb24oeWVhcilcbiAgICB7XG4gICAgICAgIC8vIHNvbHV0aW9uIGJ5IE1hdHRpIFZpcmtrdW5lbjogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDg4MTk1MVxuICAgICAgICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH0sXG5cbiAgICBnZXREYXlzSW5Nb250aCA9IGZ1bmN0aW9uKHllYXIsIG1vbnRoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIFszMSwgaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVttb250aF07XG4gICAgfSxcblxuICAgIHNldFRvU3RhcnRPZkRheSA9IGZ1bmN0aW9uKGRhdGUpXG4gICAge1xuICAgICAgICBpZiAoaXNEYXRlKGRhdGUpKSBkYXRlLnNldEhvdXJzKDAsMCwwLDApO1xuICAgIH0sXG5cbiAgICBjb21wYXJlRGF0ZXMgPSBmdW5jdGlvbihhLGIpXG4gICAge1xuICAgICAgICAvLyB3ZWFrIGRhdGUgY29tcGFyaXNvbiAodXNlIHNldFRvU3RhcnRPZkRheShkYXRlKSB0byBlbnN1cmUgY29ycmVjdCByZXN1bHQpXG4gICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCk7XG4gICAgfSxcblxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKHRvLCBmcm9tLCBvdmVyd3JpdGUpXG4gICAge1xuICAgICAgICB2YXIgcHJvcCwgaGFzUHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGZyb20pIHtcbiAgICAgICAgICAgIGhhc1Byb3AgPSB0b1twcm9wXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGhhc1Byb3AgJiYgdHlwZW9mIGZyb21bcHJvcF0gPT09ICdvYmplY3QnICYmIGZyb21bcHJvcF0gIT09IG51bGwgJiYgZnJvbVtwcm9wXS5ub2RlTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGF0ZShmcm9tW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IG5ldyBEYXRlKGZyb21bcHJvcF0uZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5KGZyb21bcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gZnJvbVtwcm9wXS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gZXh0ZW5kKHt9LCBmcm9tW3Byb3BdLCBvdmVyd3JpdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3ZlcndyaXRlIHx8ICFoYXNQcm9wKSB7XG4gICAgICAgICAgICAgICAgdG9bcHJvcF0gPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9LFxuXG4gICAgZmlyZUV2ZW50ID0gZnVuY3Rpb24oZWwsIGV2ZW50TmFtZSwgZGF0YSlcbiAgICB7XG4gICAgICAgIHZhciBldjtcblxuICAgICAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgICAgICAgICAgIGV2LmluaXRFdmVudChldmVudE5hbWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGV2ID0gZXh0ZW5kKGV2LCBkYXRhKTtcbiAgICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQoZXYpO1xuICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KSB7XG4gICAgICAgICAgICBldiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7XG4gICAgICAgICAgICBldiA9IGV4dGVuZChldiwgZGF0YSk7XG4gICAgICAgICAgICBlbC5maXJlRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgZXYpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkanVzdENhbGVuZGFyID0gZnVuY3Rpb24oY2FsZW5kYXIpIHtcbiAgICAgICAgaWYgKGNhbGVuZGFyLm1vbnRoIDwgMCkge1xuICAgICAgICAgICAgY2FsZW5kYXIueWVhciAtPSBNYXRoLmNlaWwoTWF0aC5hYnMoY2FsZW5kYXIubW9udGgpLzEyKTtcbiAgICAgICAgICAgIGNhbGVuZGFyLm1vbnRoICs9IDEyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxlbmRhci5tb250aCA+IDExKSB7XG4gICAgICAgICAgICBjYWxlbmRhci55ZWFyICs9IE1hdGguZmxvb3IoTWF0aC5hYnMoY2FsZW5kYXIubW9udGgpLzEyKTtcbiAgICAgICAgICAgIGNhbGVuZGFyLm1vbnRoIC09IDEyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxlbmRhcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGVmYXVsdHMgYW5kIGxvY2FsaXNhdGlvblxuICAgICAqL1xuICAgIGRlZmF1bHRzID0ge1xuXG4gICAgICAgIC8vIGJpbmQgdGhlIHBpY2tlciB0byBhIGZvcm0gZmllbGRcbiAgICAgICAgZmllbGQ6IG51bGwsXG5cbiAgICAgICAgLy8gYXV0b21hdGljYWxseSBzaG93L2hpZGUgdGhlIHBpY2tlciBvbiBgZmllbGRgIGZvY3VzIChkZWZhdWx0IGB0cnVlYCBpZiBgZmllbGRgIGlzIHNldClcbiAgICAgICAgYm91bmQ6IHVuZGVmaW5lZCxcblxuICAgICAgICAvLyBwb3NpdGlvbiBvZiB0aGUgZGF0ZXBpY2tlciwgcmVsYXRpdmUgdG8gdGhlIGZpZWxkIChkZWZhdWx0IHRvIGJvdHRvbSAmIGxlZnQpXG4gICAgICAgIC8vICgnYm90dG9tJyAmICdsZWZ0JyBrZXl3b3JkcyBhcmUgbm90IHVzZWQsICd0b3AnICYgJ3JpZ2h0JyBhcmUgbW9kaWZpZXIgb24gdGhlIGJvdHRvbS9sZWZ0IHBvc2l0aW9uKVxuICAgICAgICBwb3NpdGlvbjogJ2JvdHRvbSBsZWZ0JyxcblxuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGZpdCBpbiB0aGUgdmlld3BvcnQgZXZlbiBpZiBpdCBtZWFucyByZXBvc2l0aW9uaW5nIGZyb20gdGhlIHBvc2l0aW9uIG9wdGlvblxuICAgICAgICByZXBvc2l0aW9uOiB0cnVlLFxuXG4gICAgICAgIC8vIHRoZSBkZWZhdWx0IG91dHB1dCBmb3JtYXQgZm9yIGAudG9TdHJpbmcoKWAgYW5kIGBmaWVsZGAgdmFsdWVcbiAgICAgICAgZm9ybWF0OiAnWVlZWS1NTS1ERCcsXG5cbiAgICAgICAgLy8gdGhlIHRvU3RyaW5nIGZ1bmN0aW9uIHdoaWNoIGdldHMgcGFzc2VkIGEgY3VycmVudCBkYXRlIG9iamVjdCBhbmQgZm9ybWF0XG4gICAgICAgIC8vIGFuZCByZXR1cm5zIGEgc3RyaW5nXG4gICAgICAgIHRvU3RyaW5nOiBudWxsLFxuXG4gICAgICAgIC8vIHVzZWQgdG8gY3JlYXRlIGRhdGUgb2JqZWN0IGZyb20gY3VycmVudCBpbnB1dCBzdHJpbmdcbiAgICAgICAgcGFyc2U6IG51bGwsXG5cbiAgICAgICAgLy8gdGhlIGluaXRpYWwgZGF0ZSB0byB2aWV3IHdoZW4gZmlyc3Qgb3BlbmVkXG4gICAgICAgIGRlZmF1bHREYXRlOiBudWxsLFxuXG4gICAgICAgIC8vIG1ha2UgdGhlIGBkZWZhdWx0RGF0ZWAgdGhlIGluaXRpYWwgc2VsZWN0ZWQgdmFsdWVcbiAgICAgICAgc2V0RGVmYXVsdERhdGU6IGZhbHNlLFxuXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB3ZWVrICgwOiBTdW5kYXksIDE6IE1vbmRheSBldGMpXG4gICAgICAgIGZpcnN0RGF5OiAwLFxuXG4gICAgICAgIC8vIHRoZSBkZWZhdWx0IGZsYWcgZm9yIG1vbWVudCdzIHN0cmljdCBkYXRlIHBhcnNpbmdcbiAgICAgICAgZm9ybWF0U3RyaWN0OiBmYWxzZSxcblxuICAgICAgICAvLyB0aGUgbWluaW11bS9lYXJsaWVzdCBkYXRlIHRoYXQgY2FuIGJlIHNlbGVjdGVkXG4gICAgICAgIG1pbkRhdGU6IG51bGwsXG4gICAgICAgIC8vIHRoZSBtYXhpbXVtL2xhdGVzdCBkYXRlIHRoYXQgY2FuIGJlIHNlbGVjdGVkXG4gICAgICAgIG1heERhdGU6IG51bGwsXG5cbiAgICAgICAgLy8gbnVtYmVyIG9mIHllYXJzIGVpdGhlciBzaWRlLCBvciBhcnJheSBvZiB1cHBlci9sb3dlciByYW5nZVxuICAgICAgICB5ZWFyUmFuZ2U6IDEwLFxuXG4gICAgICAgIC8vIHNob3cgd2VlayBudW1iZXJzIGF0IGhlYWQgb2Ygcm93XG4gICAgICAgIHNob3dXZWVrTnVtYmVyOiBmYWxzZSxcblxuICAgICAgICAvLyBXZWVrIHBpY2tlciBtb2RlXG4gICAgICAgIHBpY2tXaG9sZVdlZWs6IGZhbHNlLFxuXG4gICAgICAgIC8vIHVzZWQgaW50ZXJuYWxseSAoZG9uJ3QgY29uZmlnIG91dHNpZGUpXG4gICAgICAgIG1pblllYXI6IDAsXG4gICAgICAgIG1heFllYXI6IDk5OTksXG4gICAgICAgIG1pbk1vbnRoOiB1bmRlZmluZWQsXG4gICAgICAgIG1heE1vbnRoOiB1bmRlZmluZWQsXG5cbiAgICAgICAgc3RhcnRSYW5nZTogbnVsbCxcbiAgICAgICAgZW5kUmFuZ2U6IG51bGwsXG5cbiAgICAgICAgaXNSVEw6IGZhbHNlLFxuXG4gICAgICAgIC8vIEFkZGl0aW9uYWwgdGV4dCB0byBhcHBlbmQgdG8gdGhlIHllYXIgaW4gdGhlIGNhbGVuZGFyIHRpdGxlXG4gICAgICAgIHllYXJTdWZmaXg6ICcnLFxuXG4gICAgICAgIC8vIFJlbmRlciB0aGUgbW9udGggYWZ0ZXIgeWVhciBpbiB0aGUgY2FsZW5kYXIgdGl0bGVcbiAgICAgICAgc2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblxuICAgICAgICAvLyBSZW5kZXIgZGF5cyBvZiB0aGUgY2FsZW5kYXIgZ3JpZCB0aGF0IGZhbGwgaW4gdGhlIG5leHQgb3IgcHJldmlvdXMgbW9udGhcbiAgICAgICAgc2hvd0RheXNJbk5leHRBbmRQcmV2aW91c01vbnRoczogZmFsc2UsXG5cbiAgICAgICAgLy8gQWxsb3dzIHVzZXIgdG8gc2VsZWN0IGRheXMgdGhhdCBmYWxsIGluIHRoZSBuZXh0IG9yIHByZXZpb3VzIG1vbnRoXG4gICAgICAgIGVuYWJsZVNlbGVjdGlvbkRheXNJbk5leHRBbmRQcmV2aW91c01vbnRoczogZmFsc2UsXG5cbiAgICAgICAgLy8gaG93IG1hbnkgbW9udGhzIGFyZSB2aXNpYmxlXG4gICAgICAgIG51bWJlck9mTW9udGhzOiAxLFxuXG4gICAgICAgIC8vIHdoZW4gbnVtYmVyT2ZNb250aHMgaXMgdXNlZCwgdGhpcyB3aWxsIGhlbHAgeW91IHRvIGNob29zZSB3aGVyZSB0aGUgbWFpbiBjYWxlbmRhciB3aWxsIGJlIChkZWZhdWx0IGBsZWZ0YCwgY2FuIGJlIHNldCB0byBgcmlnaHRgKVxuICAgICAgICAvLyBvbmx5IHVzZWQgZm9yIHRoZSBmaXJzdCBkaXNwbGF5IG9yIHdoZW4gYSBzZWxlY3RlZCBkYXRlIGlzIG5vdCB2aXNpYmxlXG4gICAgICAgIG1haW5DYWxlbmRhcjogJ2xlZnQnLFxuXG4gICAgICAgIC8vIFNwZWNpZnkgYSBET00gZWxlbWVudCB0byByZW5kZXIgdGhlIGNhbGVuZGFyIGluXG4gICAgICAgIGNvbnRhaW5lcjogdW5kZWZpbmVkLFxuXG4gICAgICAgIC8vIEJsdXIgZmllbGQgd2hlbiBkYXRlIGlzIHNlbGVjdGVkXG4gICAgICAgIGJsdXJGaWVsZE9uU2VsZWN0IDogdHJ1ZSxcblxuICAgICAgICAvLyBpbnRlcm5hdGlvbmFsaXphdGlvblxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBwcmV2aW91c01vbnRoIDogJ1ByZXZpb3VzIE1vbnRoJyxcbiAgICAgICAgICAgIG5leHRNb250aCAgICAgOiAnTmV4dCBNb250aCcsXG4gICAgICAgICAgICBtb250aHMgICAgICAgIDogWydKYW51YXJ5JywnRmVicnVhcnknLCdNYXJjaCcsJ0FwcmlsJywnTWF5JywnSnVuZScsJ0p1bHknLCdBdWd1c3QnLCdTZXB0ZW1iZXInLCdPY3RvYmVyJywnTm92ZW1iZXInLCdEZWNlbWJlciddLFxuICAgICAgICAgICAgd2Vla2RheXMgICAgICA6IFsnU3VuZGF5JywnTW9uZGF5JywnVHVlc2RheScsJ1dlZG5lc2RheScsJ1RodXJzZGF5JywnRnJpZGF5JywnU2F0dXJkYXknXSxcbiAgICAgICAgICAgIHdlZWtkYXlzU2hvcnQgOiBbJ1N1bicsJ01vbicsJ1R1ZScsJ1dlZCcsJ1RodScsJ0ZyaScsJ1NhdCddXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVGhlbWUgQ2xhc3NuYW1lXG4gICAgICAgIHRoZW1lOiBudWxsLFxuXG4gICAgICAgIC8vIGV2ZW50cyBhcnJheVxuICAgICAgICBldmVudHM6IFtdLFxuXG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIG9uU2VsZWN0OiBudWxsLFxuICAgICAgICBvbk9wZW46IG51bGwsXG4gICAgICAgIG9uQ2xvc2U6IG51bGwsXG4gICAgICAgIG9uRHJhdzogbnVsbCxcblxuICAgICAgICAvLyBFbmFibGUga2V5Ym9hcmQgaW5wdXRcbiAgICAgICAga2V5Ym9hcmRJbnB1dDogdHJ1ZVxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIHRlbXBsYXRpbmcgZnVuY3Rpb25zIHRvIGFic3RyYWN0IEhUTUwgcmVuZGVyaW5nXG4gICAgICovXG4gICAgcmVuZGVyRGF5TmFtZSA9IGZ1bmN0aW9uKG9wdHMsIGRheSwgYWJicilcbiAgICB7XG4gICAgICAgIGRheSArPSBvcHRzLmZpcnN0RGF5O1xuICAgICAgICB3aGlsZSAoZGF5ID49IDcpIHtcbiAgICAgICAgICAgIGRheSAtPSA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhYmJyID8gb3B0cy5pMThuLndlZWtkYXlzU2hvcnRbZGF5XSA6IG9wdHMuaTE4bi53ZWVrZGF5c1tkYXldO1xuICAgIH0sXG5cbiAgICByZW5kZXJEYXkgPSBmdW5jdGlvbihvcHRzKVxuICAgIHtcbiAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICB2YXIgYXJpYVNlbGVjdGVkID0gJ2ZhbHNlJztcbiAgICAgICAgaWYgKG9wdHMuaXNFbXB0eSkge1xuICAgICAgICAgICAgaWYgKG9wdHMuc2hvd0RheXNJbk5leHRBbmRQcmV2aW91c01vbnRocykge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKCdpcy1vdXRzaWRlLWN1cnJlbnQtbW9udGgnKTtcblxuICAgICAgICAgICAgICAgIGlmKCFvcHRzLmVuYWJsZVNlbGVjdGlvbkRheXNJbk5leHRBbmRQcmV2aW91c01vbnRocykge1xuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCgnaXMtc2VsZWN0aW9uLWRpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiaXMtZW1wdHlcIj48L3RkPic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgYXJyLnB1c2goJ2lzLWRpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaXNUb2RheSkge1xuICAgICAgICAgICAgYXJyLnB1c2goJ2lzLXRvZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgYXJyLnB1c2goJ2lzLXNlbGVjdGVkJyk7XG4gICAgICAgICAgICBhcmlhU2VsZWN0ZWQgPSAndHJ1ZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaGFzRXZlbnQpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKCdoYXMtZXZlbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5pc0luUmFuZ2UpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKCdpcy1pbnJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaXNTdGFydFJhbmdlKSB7XG4gICAgICAgICAgICBhcnIucHVzaCgnaXMtc3RhcnRyYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmlzRW5kUmFuZ2UpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKCdpcy1lbmRyYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnPHRkIGRhdGEtZGF5PVwiJyArIG9wdHMuZGF5ICsgJ1wiIGNsYXNzPVwiJyArIGFyci5qb2luKCcgJykgKyAnXCIgYXJpYS1zZWxlY3RlZD1cIicgKyBhcmlhU2VsZWN0ZWQgKyAnXCI+JyArXG4gICAgICAgICAgICAgICAgICc8YnV0dG9uIGNsYXNzPVwicGlrYS1idXR0b24gcGlrYS1kYXlcIiB0eXBlPVwiYnV0dG9uXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICdkYXRhLXBpa2EteWVhcj1cIicgKyBvcHRzLnllYXIgKyAnXCIgZGF0YS1waWthLW1vbnRoPVwiJyArIG9wdHMubW9udGggKyAnXCIgZGF0YS1waWthLWRheT1cIicgKyBvcHRzLmRheSArICdcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuZGF5ICtcbiAgICAgICAgICAgICAgICAgJzwvYnV0dG9uPicgK1xuICAgICAgICAgICAgICAgJzwvdGQ+JztcbiAgICB9LFxuXG4gICAgcmVuZGVyV2VlayA9IGZ1bmN0aW9uIChkLCBtLCB5KSB7XG4gICAgICAgIC8vIExpZnRlZCBmcm9tIGh0dHA6Ly9qYXZhc2NyaXB0LmFib3V0LmNvbS9saWJyYXJ5L2Jsd2Vla3llYXIuaHRtLCBsaWdodGx5IG1vZGlmaWVkLlxuICAgICAgICB2YXIgb25lamFuID0gbmV3IERhdGUoeSwgMCwgMSksXG4gICAgICAgICAgICB3ZWVrTnVtID0gTWF0aC5jZWlsKCgoKG5ldyBEYXRlKHksIG0sIGQpIC0gb25lamFuKSAvIDg2NDAwMDAwKSArIG9uZWphbi5nZXREYXkoKSsxKS83KTtcbiAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJwaWthLXdlZWtcIj4nICsgd2Vla051bSArICc8L3RkPic7XG4gICAgfSxcblxuICAgIHJlbmRlclJvdyA9IGZ1bmN0aW9uKGRheXMsIGlzUlRMLCBwaWNrV2hvbGVXZWVrLCBpc1Jvd1NlbGVjdGVkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICc8dHIgY2xhc3M9XCJwaWthLXJvdycgKyAocGlja1dob2xlV2VlayA/ICcgcGljay13aG9sZS13ZWVrJyA6ICcnKSArIChpc1Jvd1NlbGVjdGVkID8gJyBpcy1zZWxlY3RlZCcgOiAnJykgKyAnXCI+JyArIChpc1JUTCA/IGRheXMucmV2ZXJzZSgpIDogZGF5cykuam9pbignJykgKyAnPC90cj4nO1xuICAgIH0sXG5cbiAgICByZW5kZXJCb2R5ID0gZnVuY3Rpb24ocm93cylcbiAgICB7XG4gICAgICAgIHJldHVybiAnPHRib2R5PicgKyByb3dzLmpvaW4oJycpICsgJzwvdGJvZHk+JztcbiAgICB9LFxuXG4gICAgcmVuZGVySGVhZCA9IGZ1bmN0aW9uKG9wdHMpXG4gICAge1xuICAgICAgICB2YXIgaSwgYXJyID0gW107XG4gICAgICAgIGlmIChvcHRzLnNob3dXZWVrTnVtYmVyKSB7XG4gICAgICAgICAgICBhcnIucHVzaCgnPHRoPjwvdGg+Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgYXJyLnB1c2goJzx0aCBzY29wZT1cImNvbFwiPjxhYmJyIHRpdGxlPVwiJyArIHJlbmRlckRheU5hbWUob3B0cywgaSkgKyAnXCI+JyArIHJlbmRlckRheU5hbWUob3B0cywgaSwgdHJ1ZSkgKyAnPC9hYmJyPjwvdGg+Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICc8dGhlYWQ+PHRyPicgKyAob3B0cy5pc1JUTCA/IGFyci5yZXZlcnNlKCkgOiBhcnIpLmpvaW4oJycpICsgJzwvdHI+PC90aGVhZD4nO1xuICAgIH0sXG5cbiAgICByZW5kZXJUaXRsZSA9IGZ1bmN0aW9uKGluc3RhbmNlLCBjLCB5ZWFyLCBtb250aCwgcmVmWWVhciwgcmFuZElkKVxuICAgIHtcbiAgICAgICAgdmFyIGksIGosIGFycixcbiAgICAgICAgICAgIG9wdHMgPSBpbnN0YW5jZS5fbyxcbiAgICAgICAgICAgIGlzTWluWWVhciA9IHllYXIgPT09IG9wdHMubWluWWVhcixcbiAgICAgICAgICAgIGlzTWF4WWVhciA9IHllYXIgPT09IG9wdHMubWF4WWVhcixcbiAgICAgICAgICAgIGh0bWwgPSAnPGRpdiBpZD1cIicgKyByYW5kSWQgKyAnXCIgY2xhc3M9XCJwaWthLXRpdGxlXCIgcm9sZT1cImhlYWRpbmdcIiBhcmlhLWxpdmU9XCJhc3NlcnRpdmVcIj4nLFxuICAgICAgICAgICAgbW9udGhIdG1sLFxuICAgICAgICAgICAgeWVhckh0bWwsXG4gICAgICAgICAgICBwcmV2ID0gdHJ1ZSxcbiAgICAgICAgICAgIG5leHQgPSB0cnVlO1xuXG4gICAgICAgIGZvciAoYXJyID0gW10sIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgYXJyLnB1c2goJzxvcHRpb24gdmFsdWU9XCInICsgKHllYXIgPT09IHJlZlllYXIgPyBpIC0gYyA6IDEyICsgaSAtIGMpICsgJ1wiJyArXG4gICAgICAgICAgICAgICAgKGkgPT09IG1vbnRoID8gJyBzZWxlY3RlZD1cInNlbGVjdGVkXCInOiAnJykgK1xuICAgICAgICAgICAgICAgICgoaXNNaW5ZZWFyICYmIGkgPCBvcHRzLm1pbk1vbnRoKSB8fCAoaXNNYXhZZWFyICYmIGkgPiBvcHRzLm1heE1vbnRoKSA/ICdkaXNhYmxlZD1cImRpc2FibGVkXCInIDogJycpICsgJz4nICtcbiAgICAgICAgICAgICAgICBvcHRzLmkxOG4ubW9udGhzW2ldICsgJzwvb3B0aW9uPicpO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9udGhIdG1sID0gJzxkaXYgY2xhc3M9XCJwaWthLWxhYmVsXCI+JyArIG9wdHMuaTE4bi5tb250aHNbbW9udGhdICsgJzxzZWxlY3QgY2xhc3M9XCJwaWthLXNlbGVjdCBwaWthLXNlbGVjdC1tb250aFwiIHRhYmluZGV4PVwiLTFcIj4nICsgYXJyLmpvaW4oJycpICsgJzwvc2VsZWN0PjwvZGl2Pic7XG5cbiAgICAgICAgaWYgKGlzQXJyYXkob3B0cy55ZWFyUmFuZ2UpKSB7XG4gICAgICAgICAgICBpID0gb3B0cy55ZWFyUmFuZ2VbMF07XG4gICAgICAgICAgICBqID0gb3B0cy55ZWFyUmFuZ2VbMV0gKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSA9IHllYXIgLSBvcHRzLnllYXJSYW5nZTtcbiAgICAgICAgICAgIGogPSAxICsgeWVhciArIG9wdHMueWVhclJhbmdlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChhcnIgPSBbXTsgaSA8IGogJiYgaSA8PSBvcHRzLm1heFllYXI7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPj0gb3B0cy5taW5ZZWFyKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goJzxvcHRpb24gdmFsdWU9XCInICsgaSArICdcIicgKyAoaSA9PT0geWVhciA/ICcgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJzogJycpICsgJz4nICsgKGkpICsgJzwvb3B0aW9uPicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHllYXJIdG1sID0gJzxkaXYgY2xhc3M9XCJwaWthLWxhYmVsXCI+JyArIHllYXIgKyBvcHRzLnllYXJTdWZmaXggKyAnPHNlbGVjdCBjbGFzcz1cInBpa2Etc2VsZWN0IHBpa2Etc2VsZWN0LXllYXJcIiB0YWJpbmRleD1cIi0xXCI+JyArIGFyci5qb2luKCcnKSArICc8L3NlbGVjdD48L2Rpdj4nO1xuXG4gICAgICAgIGlmIChvcHRzLnNob3dNb250aEFmdGVyWWVhcikge1xuICAgICAgICAgICAgaHRtbCArPSB5ZWFySHRtbCArIG1vbnRoSHRtbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0bWwgKz0gbW9udGhIdG1sICsgeWVhckh0bWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNaW5ZZWFyICYmIChtb250aCA9PT0gMCB8fCBvcHRzLm1pbk1vbnRoID49IG1vbnRoKSkge1xuICAgICAgICAgICAgcHJldiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTWF4WWVhciAmJiAobW9udGggPT09IDExIHx8IG9wdHMubWF4TW9udGggPD0gbW9udGgpKSB7XG4gICAgICAgICAgICBuZXh0ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gMCkge1xuICAgICAgICAgICAgaHRtbCArPSAnPGJ1dHRvbiBjbGFzcz1cInBpa2EtcHJldicgKyAocHJldiA/ICcnIDogJyBpcy1kaXNhYmxlZCcpICsgJ1wiIHR5cGU9XCJidXR0b25cIj4nICsgb3B0cy5pMThuLnByZXZpb3VzTW9udGggKyAnPC9idXR0b24+JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gKGluc3RhbmNlLl9vLm51bWJlck9mTW9udGhzIC0gMSkgKSB7XG4gICAgICAgICAgICBodG1sICs9ICc8YnV0dG9uIGNsYXNzPVwicGlrYS1uZXh0JyArIChuZXh0ID8gJycgOiAnIGlzLWRpc2FibGVkJykgKyAnXCIgdHlwZT1cImJ1dHRvblwiPicgKyBvcHRzLmkxOG4ubmV4dE1vbnRoICsgJzwvYnV0dG9uPic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHRtbCArPSAnPC9kaXY+JztcbiAgICB9LFxuXG4gICAgcmVuZGVyVGFibGUgPSBmdW5jdGlvbihvcHRzLCBkYXRhLCByYW5kSWQpXG4gICAge1xuICAgICAgICByZXR1cm4gJzx0YWJsZSBjZWxscGFkZGluZz1cIjBcIiBjZWxsc3BhY2luZz1cIjBcIiBjbGFzcz1cInBpa2EtdGFibGVcIiByb2xlPVwiZ3JpZFwiIGFyaWEtbGFiZWxsZWRieT1cIicgKyByYW5kSWQgKyAnXCI+JyArIHJlbmRlckhlYWQob3B0cykgKyByZW5kZXJCb2R5KGRhdGEpICsgJzwvdGFibGU+JztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBQaWthZGF5IGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgUGlrYWRheSA9IGZ1bmN0aW9uKG9wdGlvbnMpXG4gICAge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBvcHRzID0gc2VsZi5jb25maWcob3B0aW9ucyk7XG5cbiAgICAgICAgc2VsZi5fb25Nb3VzZURvd24gPSBmdW5jdGlvbihlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXNlbGYuX3YpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaGFzQ2xhc3ModGFyZ2V0LCAnaXMtZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNDbGFzcyh0YXJnZXQsICdwaWthLWJ1dHRvbicpICYmICFoYXNDbGFzcyh0YXJnZXQsICdpcy1lbXB0eScpICYmICFoYXNDbGFzcyh0YXJnZXQucGFyZW50Tm9kZSwgJ2lzLWRpc2FibGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXREYXRlKG5ldyBEYXRlKHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGlrYS15ZWFyJyksIHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGlrYS1tb250aCcpLCB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXBpa2EtZGF5JykpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuYm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0byhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5ibHVyRmllbGRPblNlbGVjdCAmJiBvcHRzLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuZmllbGQuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzQ2xhc3ModGFyZ2V0LCAncGlrYS1wcmV2JykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcmV2TW9udGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzQ2xhc3ModGFyZ2V0LCAncGlrYS1uZXh0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5uZXh0TW9udGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhc0NsYXNzKHRhcmdldCwgJ3Bpa2Etc2VsZWN0JykpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIHRvdWNoIGV2ZW50IHByZXZlbnQgbW91c2UgZXZlbnRzIGVtdWxhdGlvblxuICAgICAgICAgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuX2MgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuX29uQ2hhbmdlID0gZnVuY3Rpb24oZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0NsYXNzKHRhcmdldCwgJ3Bpa2Etc2VsZWN0LW1vbnRoJykpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmdvdG9Nb250aCh0YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQ2xhc3ModGFyZ2V0LCAncGlrYS1zZWxlY3QteWVhcicpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5nb3RvWWVhcih0YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuX29uS2V5Q2hhbmdlID0gZnVuY3Rpb24oZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5pc1Zpc2libGUoKSkge1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoKGUua2V5Q29kZSl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5maWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuZmllbGQuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkanVzdERhdGUoJ3N1YnRyYWN0JywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRqdXN0RGF0ZSgnc3VidHJhY3QnLCA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGp1c3REYXRlKCdhZGQnLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGp1c3REYXRlKCdhZGQnLCA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLl9vbklucHV0Q2hhbmdlID0gZnVuY3Rpb24oZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRhdGU7XG5cbiAgICAgICAgICAgIGlmIChlLmZpcmVkQnkgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5wYXJzZSkge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBvcHRzLnBhcnNlKG9wdHMuZmllbGQudmFsdWUsIG9wdHMuZm9ybWF0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzTW9tZW50KSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG1vbWVudChvcHRzLmZpZWxkLnZhbHVlLCBvcHRzLmZvcm1hdCwgb3B0cy5mb3JtYXRTdHJpY3QpO1xuICAgICAgICAgICAgICAgIGRhdGUgPSAoZGF0ZSAmJiBkYXRlLmlzVmFsaWQoKSkgPyBkYXRlLnRvRGF0ZSgpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKG9wdHMuZmllbGQudmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RhdGUoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXREYXRlKGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLl92KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5fb25JbnB1dEZvY3VzID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBzZWxmLnNob3coKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLl9vbklucHV0Q2xpY2sgPSBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNlbGYuc2hvdygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuX29uSW5wdXRCbHVyID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBJRSBhbGxvd3MgcGlrYSBkaXYgdG8gZ2FpbiBmb2N1czsgY2F0Y2ggYmx1ciB0aGUgaW5wdXQgZmllbGRcbiAgICAgICAgICAgIHZhciBwRWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChoYXNDbGFzcyhwRWwsICdwaWthLXNpbmdsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoKHBFbCA9IHBFbC5wYXJlbnROb2RlKSk7XG5cbiAgICAgICAgICAgIGlmICghc2VsZi5fYykge1xuICAgICAgICAgICAgICAgIHNlbGYuX2IgPSBzdG8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuX2MgPSBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLl9vbkNsaWNrID0gZnVuY3Rpb24oZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcbiAgICAgICAgICAgICAgICBwRWwgPSB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzRXZlbnRMaXN0ZW5lcnMgJiYgaGFzQ2xhc3ModGFyZ2V0LCAncGlrYS1zZWxlY3QnKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0Lm9uY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ29uY2hhbmdlJywgJ3JldHVybjsnKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkRXZlbnQodGFyZ2V0LCAnY2hhbmdlJywgc2VsZi5fb25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3MocEVsLCAncGlrYS1zaW5nbGUnKSB8fCBwRWwgPT09IG9wdHMudHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKChwRWwgPSBwRWwucGFyZW50Tm9kZSkpO1xuICAgICAgICAgICAgaWYgKHNlbGYuX3YgJiYgdGFyZ2V0ICE9PSBvcHRzLnRyaWdnZXIgJiYgcEVsICE9PSBvcHRzLnRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHNlbGYuZWwuY2xhc3NOYW1lID0gJ3Bpa2Etc2luZ2xlJyArIChvcHRzLmlzUlRMID8gJyBpcy1ydGwnIDogJycpICsgKG9wdHMudGhlbWUgPyAnICcgKyBvcHRzLnRoZW1lIDogJycpO1xuXG4gICAgICAgIGFkZEV2ZW50KHNlbGYuZWwsICdtb3VzZWRvd24nLCBzZWxmLl9vbk1vdXNlRG93biwgdHJ1ZSk7XG4gICAgICAgIGFkZEV2ZW50KHNlbGYuZWwsICd0b3VjaGVuZCcsIHNlbGYuX29uTW91c2VEb3duLCB0cnVlKTtcbiAgICAgICAgYWRkRXZlbnQoc2VsZi5lbCwgJ2NoYW5nZScsIHNlbGYuX29uQ2hhbmdlKTtcblxuICAgICAgICBpZiAob3B0cy5rZXlib2FyZElucHV0KSB7XG4gICAgICAgICAgICBhZGRFdmVudChkb2N1bWVudCwgJ2tleWRvd24nLCBzZWxmLl9vbktleUNoYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5maWVsZCkge1xuICAgICAgICAgICAgaWYgKG9wdHMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5jb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5lbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuYm91bmQpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNlbGYuZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRzLmZpZWxkLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNlbGYuZWwsIG9wdHMuZmllbGQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkRXZlbnQob3B0cy5maWVsZCwgJ2NoYW5nZScsIHNlbGYuX29uSW5wdXRDaGFuZ2UpO1xuXG4gICAgICAgICAgICBpZiAoIW9wdHMuZGVmYXVsdERhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzTW9tZW50ICYmIG9wdHMuZmllbGQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5kZWZhdWx0RGF0ZSA9IG1vbWVudChvcHRzLmZpZWxkLnZhbHVlLCBvcHRzLmZvcm1hdCkudG9EYXRlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5kZWZhdWx0RGF0ZSA9IG5ldyBEYXRlKERhdGUucGFyc2Uob3B0cy5maWVsZC52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLnNldERlZmF1bHREYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZEYXRlID0gb3B0cy5kZWZhdWx0RGF0ZTtcblxuICAgICAgICBpZiAoaXNEYXRlKGRlZkRhdGUpKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5zZXREZWZhdWx0RGF0ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0RGF0ZShkZWZEYXRlLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5nb3RvRGF0ZShkZWZEYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZ290b0RhdGUobmV3IERhdGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5ib3VuZCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICBzZWxmLmVsLmNsYXNzTmFtZSArPSAnIGlzLWJvdW5kJztcbiAgICAgICAgICAgIGFkZEV2ZW50KG9wdHMudHJpZ2dlciwgJ2NsaWNrJywgc2VsZi5fb25JbnB1dENsaWNrKTtcbiAgICAgICAgICAgIGFkZEV2ZW50KG9wdHMudHJpZ2dlciwgJ2ZvY3VzJywgc2VsZi5fb25JbnB1dEZvY3VzKTtcbiAgICAgICAgICAgIGFkZEV2ZW50KG9wdHMudHJpZ2dlciwgJ2JsdXInLCBzZWxmLl9vbklucHV0Qmx1cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIHB1YmxpYyBQaWthZGF5IEFQSVxuICAgICAqL1xuICAgIFBpa2FkYXkucHJvdG90eXBlID0ge1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbmZpZ3VyZSBmdW5jdGlvbmFsaXR5XG4gICAgICAgICAqL1xuICAgICAgICBjb25maWc6IGZ1bmN0aW9uKG9wdGlvbnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbykge1xuICAgICAgICAgICAgICAgIHRoaXMuX28gPSBleHRlbmQoe30sIGRlZmF1bHRzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9wdHMgPSBleHRlbmQodGhpcy5fbywgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIG9wdHMuaXNSVEwgPSAhIW9wdHMuaXNSVEw7XG5cbiAgICAgICAgICAgIG9wdHMuZmllbGQgPSAob3B0cy5maWVsZCAmJiBvcHRzLmZpZWxkLm5vZGVOYW1lKSA/IG9wdHMuZmllbGQgOiBudWxsO1xuXG4gICAgICAgICAgICBvcHRzLnRoZW1lID0gKHR5cGVvZiBvcHRzLnRoZW1lKSA9PT0gJ3N0cmluZycgJiYgb3B0cy50aGVtZSA/IG9wdHMudGhlbWUgOiBudWxsO1xuXG4gICAgICAgICAgICBvcHRzLmJvdW5kID0gISEob3B0cy5ib3VuZCAhPT0gdW5kZWZpbmVkID8gb3B0cy5maWVsZCAmJiBvcHRzLmJvdW5kIDogb3B0cy5maWVsZCk7XG5cbiAgICAgICAgICAgIG9wdHMudHJpZ2dlciA9IChvcHRzLnRyaWdnZXIgJiYgb3B0cy50cmlnZ2VyLm5vZGVOYW1lKSA/IG9wdHMudHJpZ2dlciA6IG9wdHMuZmllbGQ7XG5cbiAgICAgICAgICAgIG9wdHMuZGlzYWJsZVdlZWtlbmRzID0gISFvcHRzLmRpc2FibGVXZWVrZW5kcztcblxuICAgICAgICAgICAgb3B0cy5kaXNhYmxlRGF5Rm4gPSAodHlwZW9mIG9wdHMuZGlzYWJsZURheUZuKSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZGlzYWJsZURheUZuIDogbnVsbDtcblxuICAgICAgICAgICAgdmFyIG5vbSA9IHBhcnNlSW50KG9wdHMubnVtYmVyT2ZNb250aHMsIDEwKSB8fCAxO1xuICAgICAgICAgICAgb3B0cy5udW1iZXJPZk1vbnRocyA9IG5vbSA+IDQgPyA0IDogbm9tO1xuXG4gICAgICAgICAgICBpZiAoIWlzRGF0ZShvcHRzLm1pbkRhdGUpKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5taW5EYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzRGF0ZShvcHRzLm1heERhdGUpKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5tYXhEYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG9wdHMubWluRGF0ZSAmJiBvcHRzLm1heERhdGUpICYmIG9wdHMubWF4RGF0ZSA8IG9wdHMubWluRGF0ZSkge1xuICAgICAgICAgICAgICAgIG9wdHMubWF4RGF0ZSA9IG9wdHMubWluRGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMubWluRGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWluRGF0ZShvcHRzLm1pbkRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMubWF4RGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWF4RGF0ZShvcHRzLm1heERhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNBcnJheShvcHRzLnllYXJSYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmFsbGJhY2sgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgLSAxMDtcbiAgICAgICAgICAgICAgICBvcHRzLnllYXJSYW5nZVswXSA9IHBhcnNlSW50KG9wdHMueWVhclJhbmdlWzBdLCAxMCkgfHwgZmFsbGJhY2s7XG4gICAgICAgICAgICAgICAgb3B0cy55ZWFyUmFuZ2VbMV0gPSBwYXJzZUludChvcHRzLnllYXJSYW5nZVsxXSwgMTApIHx8IGZhbGxiYWNrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRzLnllYXJSYW5nZSA9IE1hdGguYWJzKHBhcnNlSW50KG9wdHMueWVhclJhbmdlLCAxMCkpIHx8IGRlZmF1bHRzLnllYXJSYW5nZTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy55ZWFyUmFuZ2UgPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy55ZWFyUmFuZ2UgPSAxMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0cztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJuIGEgZm9ybWF0dGVkIHN0cmluZyBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gKHVzaW5nIE1vbWVudC5qcyBpZiBhdmFpbGFibGUpXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24oZm9ybWF0KVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgdGhpcy5fby5mb3JtYXQ7XG4gICAgICAgICAgICBpZiAoIWlzRGF0ZSh0aGlzLl9kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vLnRvU3RyaW5nKHRoaXMuX2QsIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzTW9tZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBtb21lbnQodGhpcy5fZCkuZm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZC50b0RhdGVTdHJpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJuIGEgTW9tZW50LmpzIG9iamVjdCBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gKGlmIGF2YWlsYWJsZSlcbiAgICAgICAgICovXG4gICAgICAgIGdldE1vbWVudDogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gaGFzTW9tZW50ID8gbW9tZW50KHRoaXMuX2QpIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHRoZSBjdXJyZW50IHNlbGVjdGlvbiBmcm9tIGEgTW9tZW50LmpzIG9iamVjdCAoaWYgYXZhaWxhYmxlKVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TW9tZW50OiBmdW5jdGlvbihkYXRlLCBwcmV2ZW50T25TZWxlY3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChoYXNNb21lbnQgJiYgbW9tZW50LmlzTW9tZW50KGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREYXRlKGRhdGUudG9EYXRlKCksIHByZXZlbnRPblNlbGVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybiBhIERhdGUgb2JqZWN0IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RGF0ZTogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gaXNEYXRlKHRoaXMuX2QpID8gbmV3IERhdGUodGhpcy5fZC5nZXRUaW1lKCkpIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RGF0ZTogZnVuY3Rpb24oZGF0ZSwgcHJldmVudE9uU2VsZWN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX28uZmllbGQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZmlyZUV2ZW50KHRoaXMuX28uZmllbGQsICdjaGFuZ2UnLCB7IGZpcmVkQnk6IHRoaXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKGRhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNEYXRlKGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWluID0gdGhpcy5fby5taW5EYXRlLFxuICAgICAgICAgICAgICAgIG1heCA9IHRoaXMuX28ubWF4RGF0ZTtcblxuICAgICAgICAgICAgaWYgKGlzRGF0ZShtaW4pICYmIGRhdGUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbWluO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUobWF4KSAmJiBkYXRlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG1heDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIHNldFRvU3RhcnRPZkRheSh0aGlzLl9kKTtcbiAgICAgICAgICAgIHRoaXMuZ290b0RhdGUodGhpcy5fZCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5maWVsZC52YWx1ZSA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBmaXJlRXZlbnQodGhpcy5fby5maWVsZCwgJ2NoYW5nZScsIHsgZmlyZWRCeTogdGhpcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJldmVudE9uU2VsZWN0ICYmIHR5cGVvZiB0aGlzLl9vLm9uU2VsZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5vblNlbGVjdC5jYWxsKHRoaXMsIHRoaXMuZ2V0RGF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hhbmdlIHZpZXcgdG8gYSBzcGVjaWZpYyBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBnb3RvRGF0ZTogZnVuY3Rpb24oZGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5ld0NhbGVuZGFyID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCFpc0RhdGUoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGVuZGFycykge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFZpc2libGVEYXRlID0gbmV3IERhdGUodGhpcy5jYWxlbmRhcnNbMF0ueWVhciwgdGhpcy5jYWxlbmRhcnNbMF0ubW9udGgsIDEpLFxuICAgICAgICAgICAgICAgICAgICBsYXN0VmlzaWJsZURhdGUgPSBuZXcgRGF0ZSh0aGlzLmNhbGVuZGFyc1t0aGlzLmNhbGVuZGFycy5sZW5ndGgtMV0ueWVhciwgdGhpcy5jYWxlbmRhcnNbdGhpcy5jYWxlbmRhcnMubGVuZ3RoLTFdLm1vbnRoLCAxKSxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZURhdGUgPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGVuZCBvZiB0aGUgbW9udGhcbiAgICAgICAgICAgICAgICBsYXN0VmlzaWJsZURhdGUuc2V0TW9udGgobGFzdFZpc2libGVEYXRlLmdldE1vbnRoKCkrMSk7XG4gICAgICAgICAgICAgICAgbGFzdFZpc2libGVEYXRlLnNldERhdGUobGFzdFZpc2libGVEYXRlLmdldERhdGUoKS0xKTtcbiAgICAgICAgICAgICAgICBuZXdDYWxlbmRhciA9ICh2aXNpYmxlRGF0ZSA8IGZpcnN0VmlzaWJsZURhdGUuZ2V0VGltZSgpIHx8IGxhc3RWaXNpYmxlRGF0ZS5nZXRUaW1lKCkgPCB2aXNpYmxlRGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXdDYWxlbmRhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgbW9udGg6IGRhdGUuZ2V0TW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgeWVhcjogZGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX28ubWFpbkNhbGVuZGFyID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJzWzBdLm1vbnRoICs9IDEgLSB0aGlzLl9vLm51bWJlck9mTW9udGhzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hZGp1c3RDYWxlbmRhcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGp1c3REYXRlOiBmdW5jdGlvbihzaWduLCBkYXlzKSB7XG5cbiAgICAgICAgICAgIHZhciBkYXkgPSB0aGlzLmdldERhdGUoKSB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSBwYXJzZUludChkYXlzKSoyNCo2MCo2MCoxMDAwO1xuXG4gICAgICAgICAgICB2YXIgbmV3RGF5O1xuXG4gICAgICAgICAgICBpZiAoc2lnbiA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgICAgICBuZXdEYXkgPSBuZXcgRGF0ZShkYXkudmFsdWVPZigpICsgZGlmZmVyZW5jZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNpZ24gPT09ICdzdWJ0cmFjdCcpIHtcbiAgICAgICAgICAgICAgICBuZXdEYXkgPSBuZXcgRGF0ZShkYXkudmFsdWVPZigpIC0gZGlmZmVyZW5jZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0RGF0ZShuZXdEYXkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkanVzdENhbGVuZGFyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyc1swXSA9IGFkanVzdENhbGVuZGFyKHRoaXMuY2FsZW5kYXJzWzBdKTtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAxOyBjIDwgdGhpcy5fby5udW1iZXJPZk1vbnRoczsgYysrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhcnNbY10gPSBhZGp1c3RDYWxlbmRhcih7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoOiB0aGlzLmNhbGVuZGFyc1swXS5tb250aCArIGMsXG4gICAgICAgICAgICAgICAgICAgIHllYXI6IHRoaXMuY2FsZW5kYXJzWzBdLnllYXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdvdG9Ub2RheTogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdvdG9EYXRlKG5ldyBEYXRlKCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFuZ2UgdmlldyB0byBhIHNwZWNpZmljIG1vbnRoICh6ZXJvLWluZGV4LCBlLmcuIDA6IEphbnVhcnkpXG4gICAgICAgICAqL1xuICAgICAgICBnb3RvTW9udGg6IGZ1bmN0aW9uKG1vbnRoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJzWzBdLm1vbnRoID0gcGFyc2VJbnQobW9udGgsIDEwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkanVzdENhbGVuZGFycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG5leHRNb250aDogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyc1swXS5tb250aCsrO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RDYWxlbmRhcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcmV2TW9udGg6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhcnNbMF0ubW9udGgtLTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2FsZW5kYXJzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYW5nZSB2aWV3IHRvIGEgc3BlY2lmaWMgZnVsbCB5ZWFyIChlLmcuIFwiMjAxMlwiKVxuICAgICAgICAgKi9cbiAgICAgICAgZ290b1llYXI6IGZ1bmN0aW9uKHllYXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghaXNOYU4oeWVhcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGVuZGFyc1swXS55ZWFyID0gcGFyc2VJbnQoeWVhciwgMTApO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2FsZW5kYXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYW5nZSB0aGUgbWluRGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TWluRGF0ZTogZnVuY3Rpb24odmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHNldFRvU3RhcnRPZkRheSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5taW5EYXRlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5taW5ZZWFyICA9IHZhbHVlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5taW5Nb250aCA9IHZhbHVlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX28ubWluRGF0ZSA9IGRlZmF1bHRzLm1pbkRhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5taW5ZZWFyICA9IGRlZmF1bHRzLm1pblllYXI7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5taW5Nb250aCA9IGRlZmF1bHRzLm1pbk1vbnRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX28uc3RhcnRSYW5nZSA9IGRlZmF1bHRzLnN0YXJ0UmFuZ2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFuZ2UgdGhlIG1heERhdGVcbiAgICAgICAgICovXG4gICAgICAgIHNldE1heERhdGU6IGZ1bmN0aW9uKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZih2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICBzZXRUb1N0YXJ0T2ZEYXkodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX28ubWF4RGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX28ubWF4WWVhciA9IHZhbHVlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5tYXhNb250aCA9IHZhbHVlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX28ubWF4RGF0ZSA9IGRlZmF1bHRzLm1heERhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5tYXhZZWFyID0gZGVmYXVsdHMubWF4WWVhcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9vLm1heE1vbnRoID0gZGVmYXVsdHMubWF4TW9udGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5lbmRSYW5nZSA9IGRlZmF1bHRzLmVuZFJhbmdlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRTdGFydFJhbmdlOiBmdW5jdGlvbih2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fby5zdGFydFJhbmdlID0gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0RW5kUmFuZ2U6IGZ1bmN0aW9uKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vLmVuZFJhbmdlID0gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlZnJlc2ggdGhlIEhUTUxcbiAgICAgICAgICovXG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uKGZvcmNlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3YgJiYgIWZvcmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLl9vLFxuICAgICAgICAgICAgICAgIG1pblllYXIgPSBvcHRzLm1pblllYXIsXG4gICAgICAgICAgICAgICAgbWF4WWVhciA9IG9wdHMubWF4WWVhcixcbiAgICAgICAgICAgICAgICBtaW5Nb250aCA9IG9wdHMubWluTW9udGgsXG4gICAgICAgICAgICAgICAgbWF4TW9udGggPSBvcHRzLm1heE1vbnRoLFxuICAgICAgICAgICAgICAgIGh0bWwgPSAnJyxcbiAgICAgICAgICAgICAgICByYW5kSWQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl95IDw9IG1pblllYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gbWluWWVhcjtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKG1pbk1vbnRoKSAmJiB0aGlzLl9tIDwgbWluTW9udGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbSA9IG1pbk1vbnRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl95ID49IG1heFllYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gbWF4WWVhcjtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKG1heE1vbnRoKSAmJiB0aGlzLl9tID4gbWF4TW9udGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbSA9IG1heE1vbnRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmFuZElkID0gJ3Bpa2EtdGl0bGUtJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnJlcGxhY2UoL1teYS16XSsvZywgJycpLnN1YnN0cigwLCAyKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvcHRzLm51bWJlck9mTW9udGhzOyBjKyspIHtcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwicGlrYS1sZW5kYXJcIj4nICsgcmVuZGVyVGl0bGUodGhpcywgYywgdGhpcy5jYWxlbmRhcnNbY10ueWVhciwgdGhpcy5jYWxlbmRhcnNbY10ubW9udGgsIHRoaXMuY2FsZW5kYXJzWzBdLnllYXIsIHJhbmRJZCkgKyB0aGlzLnJlbmRlcih0aGlzLmNhbGVuZGFyc1tjXS55ZWFyLCB0aGlzLmNhbGVuZGFyc1tjXS5tb250aCwgcmFuZElkKSArICc8L2Rpdj4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmVsLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAgICAgICAgIGlmIChvcHRzLmJvdW5kKSB7XG4gICAgICAgICAgICAgICAgaWYob3B0cy5maWVsZC50eXBlICE9PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgICAgICAgICBzdG8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnRyaWdnZXIuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX28ub25EcmF3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5vbkRyYXcodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRzLmJvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gbGV0IHRoZSBzY3JlZW4gcmVhZGVyIHVzZXIga25vdyB0byB1c2UgYXJyb3cga2V5c1xuICAgICAgICAgICAgICAgIG9wdHMuZmllbGQuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJ1VzZSB0aGUgYXJyb3cga2V5cyB0byBwaWNrIGEgZGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkanVzdFBvc2l0aW9uOiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCwgcEVsLCB3aWR0aCwgaGVpZ2h0LCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCwgc2Nyb2xsVG9wLCBsZWZ0LCB0b3AsIGNsaWVudFJlY3Q7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vLmNvbnRhaW5lcikgcmV0dXJuO1xuXG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgICAgICAgICAgZmllbGQgPSB0aGlzLl9vLnRyaWdnZXI7XG4gICAgICAgICAgICBwRWwgPSBmaWVsZDtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5lbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgdmlld3BvcnRXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHZpZXdwb3J0SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjbGllbnRSZWN0ID0gZmllbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGNsaWVudFJlY3QubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgICAgICAgICAgICB0b3AgPSBjbGllbnRSZWN0LmJvdHRvbSArIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHBFbC5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgIHRvcCAgPSBwRWwub2Zmc2V0VG9wICsgcEVsLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICB3aGlsZSgocEVsID0gcEVsLm9mZnNldFBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCArPSBwRWwub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdG9wICArPSBwRWwub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGVmYXVsdCBwb3NpdGlvbiBpcyBib3R0b20gJiBsZWZ0XG4gICAgICAgICAgICBpZiAoKHRoaXMuX28ucmVwb3NpdGlvbiAmJiBsZWZ0ICsgd2lkdGggPiB2aWV3cG9ydFdpZHRoKSB8fFxuICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fby5wb3NpdGlvbi5pbmRleE9mKCdyaWdodCcpID4gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtIHdpZHRoICsgZmllbGQub2Zmc2V0V2lkdGggPiAwXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQgLSB3aWR0aCArIGZpZWxkLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLl9vLnJlcG9zaXRpb24gJiYgdG9wICsgaGVpZ2h0ID4gdmlld3BvcnRIZWlnaHQgKyBzY3JvbGxUb3ApIHx8XG4gICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vLnBvc2l0aW9uLmluZGV4T2YoJ3RvcCcpID4gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgdG9wIC0gaGVpZ2h0IC0gZmllbGQub2Zmc2V0SGVpZ2h0ID4gMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRvcCA9IHRvcCAtIGhlaWdodCAtIGZpZWxkLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlbmRlciBIVE1MIGZvciBhIHBhcnRpY3VsYXIgbW9udGhcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24oeWVhciwgbW9udGgsIHJhbmRJZClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG9wdHMgICA9IHRoaXMuX28sXG4gICAgICAgICAgICAgICAgbm93ICAgID0gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBkYXlzICAgPSBnZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCksXG4gICAgICAgICAgICAgICAgYmVmb3JlID0gbmV3IERhdGUoeWVhciwgbW9udGgsIDEpLmdldERheSgpLFxuICAgICAgICAgICAgICAgIGRhdGEgICA9IFtdLFxuICAgICAgICAgICAgICAgIHJvdyAgICA9IFtdO1xuICAgICAgICAgICAgc2V0VG9TdGFydE9mRGF5KG5vdyk7XG4gICAgICAgICAgICBpZiAob3B0cy5maXJzdERheSA+IDApIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUgLT0gb3B0cy5maXJzdERheTtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgKz0gNztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNNb250aCA9IG1vbnRoID09PSAwID8gMTEgOiBtb250aCAtIDEsXG4gICAgICAgICAgICAgICAgbmV4dE1vbnRoID0gbW9udGggPT09IDExID8gMCA6IG1vbnRoICsgMSxcbiAgICAgICAgICAgICAgICB5ZWFyT2ZQcmV2aW91c01vbnRoID0gbW9udGggPT09IDAgPyB5ZWFyIC0gMSA6IHllYXIsXG4gICAgICAgICAgICAgICAgeWVhck9mTmV4dE1vbnRoID0gbW9udGggPT09IDExID8geWVhciArIDEgOiB5ZWFyLFxuICAgICAgICAgICAgICAgIGRheXNJblByZXZpb3VzTW9udGggPSBnZXREYXlzSW5Nb250aCh5ZWFyT2ZQcmV2aW91c01vbnRoLCBwcmV2aW91c01vbnRoKTtcbiAgICAgICAgICAgIHZhciBjZWxscyA9IGRheXMgKyBiZWZvcmUsXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBjZWxscztcbiAgICAgICAgICAgIHdoaWxlKGFmdGVyID4gNykge1xuICAgICAgICAgICAgICAgIGFmdGVyIC09IDc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxscyArPSA3IC0gYWZ0ZXI7XG4gICAgICAgICAgICB2YXIgaXNXZWVrU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByID0gMDsgaSA8IGNlbGxzOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGRheSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxICsgKGkgLSBiZWZvcmUpKSxcbiAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3RlZCA9IGlzRGF0ZSh0aGlzLl9kKSA/IGNvbXBhcmVEYXRlcyhkYXksIHRoaXMuX2QpIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGlzVG9kYXkgPSBjb21wYXJlRGF0ZXMoZGF5LCBub3cpLFxuICAgICAgICAgICAgICAgICAgICBoYXNFdmVudCA9IG9wdHMuZXZlbnRzLmluZGV4T2YoZGF5LnRvRGF0ZVN0cmluZygpKSAhPT0gLTEgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGlzRW1wdHkgPSBpIDwgYmVmb3JlIHx8IGkgPj0gKGRheXMgKyBiZWZvcmUpLFxuICAgICAgICAgICAgICAgICAgICBkYXlOdW1iZXIgPSAxICsgKGkgLSBiZWZvcmUpLFxuICAgICAgICAgICAgICAgICAgICBtb250aE51bWJlciA9IG1vbnRoLFxuICAgICAgICAgICAgICAgICAgICB5ZWFyTnVtYmVyID0geWVhcixcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydFJhbmdlID0gb3B0cy5zdGFydFJhbmdlICYmIGNvbXBhcmVEYXRlcyhvcHRzLnN0YXJ0UmFuZ2UsIGRheSksXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kUmFuZ2UgPSBvcHRzLmVuZFJhbmdlICYmIGNvbXBhcmVEYXRlcyhvcHRzLmVuZFJhbmdlLCBkYXkpLFxuICAgICAgICAgICAgICAgICAgICBpc0luUmFuZ2UgPSBvcHRzLnN0YXJ0UmFuZ2UgJiYgb3B0cy5lbmRSYW5nZSAmJiBvcHRzLnN0YXJ0UmFuZ2UgPCBkYXkgJiYgZGF5IDwgb3B0cy5lbmRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhYmxlZCA9IChvcHRzLm1pbkRhdGUgJiYgZGF5IDwgb3B0cy5taW5EYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdHMubWF4RGF0ZSAmJiBkYXkgPiBvcHRzLm1heERhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3B0cy5kaXNhYmxlV2Vla2VuZHMgJiYgaXNXZWVrZW5kKGRheSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3B0cy5kaXNhYmxlRGF5Rm4gJiYgb3B0cy5kaXNhYmxlRGF5Rm4oZGF5KSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF5TnVtYmVyID0gZGF5c0luUHJldmlvdXNNb250aCArIGRheU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoTnVtYmVyID0gcHJldmlvdXNNb250aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHllYXJOdW1iZXIgPSB5ZWFyT2ZQcmV2aW91c01vbnRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF5TnVtYmVyID0gZGF5TnVtYmVyIC0gZGF5cztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoTnVtYmVyID0gbmV4dE1vbnRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWVhck51bWJlciA9IHllYXJPZk5leHRNb250aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkYXlDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXk6IGRheU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoOiBtb250aE51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHllYXI6IHllYXJOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFdmVudDogaGFzRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGVkOiBpc1NlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNUb2RheTogaXNUb2RheSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VtcHR5OiBpc0VtcHR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdGFydFJhbmdlOiBpc1N0YXJ0UmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZFJhbmdlOiBpc0VuZFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJblJhbmdlOiBpc0luUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93RGF5c0luTmV4dEFuZFByZXZpb3VzTW9udGhzOiBvcHRzLnNob3dEYXlzSW5OZXh0QW5kUHJldmlvdXNNb250aHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVTZWxlY3Rpb25EYXlzSW5OZXh0QW5kUHJldmlvdXNNb250aHM6IG9wdHMuZW5hYmxlU2VsZWN0aW9uRGF5c0luTmV4dEFuZFByZXZpb3VzTW9udGhzXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0cy5waWNrV2hvbGVXZWVrICYmIGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNXZWVrU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJvdy5wdXNoKHJlbmRlckRheShkYXlDb25maWcpKTtcblxuICAgICAgICAgICAgICAgIGlmICgrK3IgPT09IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuc2hvd1dlZWtOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy51bnNoaWZ0KHJlbmRlcldlZWsoaSAtIGJlZm9yZSwgbW9udGgsIHllYXIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2gocmVuZGVyUm93KHJvdywgb3B0cy5pc1JUTCwgb3B0cy5waWNrV2hvbGVXZWVrLCBpc1dlZWtTZWxlY3RlZCkpO1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgciA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlzV2Vla1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlclRhYmxlKG9wdHMsIGRhdGEsIHJhbmRJZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNWaXNpYmxlOiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgJ2lzLWhpZGRlbicpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vLmJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEV2ZW50KGRvY3VtZW50LCAnY2xpY2snLCB0aGlzLl9vbkNsaWNrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX28ub25PcGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX28ub25PcGVuLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLl92O1xuICAgICAgICAgICAgaWYgKHYgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX28uYm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnQoZG9jdW1lbnQsICdjbGljaycsIHRoaXMuX29uQ2xpY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gJ3N0YXRpYyc7IC8vIHJlc2V0XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5sZWZ0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKHRoaXMuZWwsICdpcy1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdGhpcy5fby5vbkNsb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX28ub25DbG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR0FNRSBPVkVSXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5fbztcblxuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICByZW1vdmVFdmVudCh0aGlzLmVsLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRydWUpO1xuICAgICAgICAgICAgcmVtb3ZlRXZlbnQodGhpcy5lbCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Nb3VzZURvd24sIHRydWUpO1xuICAgICAgICAgICAgcmVtb3ZlRXZlbnQodGhpcy5lbCwgJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKTtcbiAgICAgICAgICAgIGlmIChvcHRzLmtleWJvYXJkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudChkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleUNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5maWVsZCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50KG9wdHMuZmllbGQsICdjaGFuZ2UnLCB0aGlzLl9vbklucHV0Q2hhbmdlKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5ib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudChvcHRzLnRyaWdnZXIsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljayk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50KG9wdHMudHJpZ2dlciwgJ2ZvY3VzJywgdGhpcy5fb25JbnB1dEZvY3VzKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnQob3B0cy50cmlnZ2VyLCAnYmx1cicsIHRoaXMuX29uSW5wdXRCbHVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgcmV0dXJuIFBpa2FkYXk7XG59KSk7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cbiAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgRVMgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9lczUnKTtcbnZhciByZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG5cbnZhciBsZWZ0V2hpdGVzcGFjZSA9IC9eW1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRl0rLztcbnZhciByaWdodFdoaXRlc3BhY2UgPSAvW1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRl0rJC87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJpbSgpIHtcblx0dmFyIFMgPSBFUy5Ub1N0cmluZyhFUy5DaGVja09iamVjdENvZXJjaWJsZSh0aGlzKSk7XG5cdHJldHVybiByZXBsYWNlKHJlcGxhY2UoUywgbGVmdFdoaXRlc3BhY2UsICcnKSwgcmlnaHRXaGl0ZXNwYWNlLCAnJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJy4vc2hpbScpO1xuXG52YXIgYm91bmRUcmltID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIGdldFBvbHlmaWxsKCkpO1xuXG5kZWZpbmUoYm91bmRUcmltLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBib3VuZFRyaW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxudmFyIHplcm9XaWR0aFNwYWNlID0gJ1xcdTIwMGInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRpZiAoU3RyaW5nLnByb3RvdHlwZS50cmltICYmIHplcm9XaWR0aFNwYWNlLnRyaW0oKSA9PT0gemVyb1dpZHRoU3BhY2UpIHtcblx0XHRyZXR1cm4gU3RyaW5nLnByb3RvdHlwZS50cmltO1xuXHR9XG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1TdHJpbmdUcmltKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgeyB0cmltOiBwb2x5ZmlsbCB9LCB7IHRyaW06IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUudHJpbSAhPT0gcG9seWZpbGw7IH0gfSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgKC9eW3NcXFddKiQvKS50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgK1xuICAgICAgICAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcbiJdfQ==
